/*
|--------------------------------------------|
| Nome in codice       | Versione gamemode   |
|--------------------------------------------|
| Erdbeben 			   |        3.0          |
| Erdbeben  		   |        3.1          |
| Erdbeben  		   |        3.2          |
| Erdbeben  		   |        3.3          |
| Erdbeben  		   |        3.4          |
| Erdbeben  		   |        3.5          |
| Engelwurz            |        4.0          |
| Engelwurz            |        4.1          |
| Engelwurz            |        4.2          |
| Engelwurz            |        4.3          |
| Engelwurz            |        4.5          |
| Engelwurz            |        4.6          |
|
| --                   |        5.0          |
|--------------------------------------------|

19/giu/2012

NameTagsUpdate

finire il nuovo sistema log cw
HDXboWhPG2

size 0 = 1vs1
size 1 = all vs all


testare /tw

http://www.youtube.com/watch?v=AhVNakamXQo

dovrebbero essere fixati:
la fight 1vs1 non finisce correttamente
FINIRE FIGHT MODE
DA TESTARE COSA SUCCEDE QUANDO SI UCCIDE UNO 1VS1 -> SIA QUANDO ï¿½ SOLO QUEL DUEL IN CORSO SIA QUANDO CI SONO PIï¿½ DUELS IN CORSO
DA TESTARE COSA SUCCEDE QUANDO LA FIGHT ï¿½ UN ALL VS ALL

--
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
INSERT INTO `MicheleGdb`.`config` (`roundtime`, `tcp`, `cp`, `tdmkills`, `ready`, `lobbyv`, `lobbyw`, `time`, `weather`, `hb`, `autoafk`, `anticbug`, `notice`, `skinswap`, `lobby`, `usefps`, `fpslimit`, `useping`, `pinglimit`, `usepl`, `pllimit`, `scores`) VALUES ('8', '30', '1', '20', '4', '1', '0', '12', '0', '1', '0', '0', 'Nulla', '1', '882.820739,-31.076736,63.195312,156.022644,0', '0', '20', '0', '180', '0', '10.0', '0,10');
INSERT INTO `MicheleGdb`.`stats` (`bases`, `arene`, `tdms`, `pvp`, `ints`, `gungame`, `massacre`, `runs`, `connect`, `kills`) VALUES ('0', '0', '0', '0', '0', '0', '0', '0', '0', '0');
INSERT INTO `MicheleGdb`.`teams` (`id`, `name`, `skin`, `ingamecolor`, `outcolor`) VALUES ('1', 'Home', '177', '74055594', '2039136426'), ('2', 'Away', '250', '1139023530', '1908105642');
                CREATE TABLE `bases_nocbug` (
                  `id` int(11) NOT NULL,
                  `home` text NOT NULL,
                  `att` text NOT NULL,
                  `def` text NOT NULL,
                  `int` int(11) NOT NULL,
                  `attwin` int(11) NOT NULL,
                  `defwin` int(11) NOT NULL,
                  `played` int(11) NOT NULL,
                  `name` text NOT NULL,
                  PRIMARY KEY (`id`)
                ) ENGINE=MyISAM DEFAULT CHARSET=latin1;

                CREATE TABLE `arene` (
                  `id` int(11) NOT NULL,
                  `att` text NOT NULL,
                  `def` text NOT NULL,
                  `interior` int(11) NOT NULL,
                  `name` text NOT NULL,
                  `Zmax` text NOT NULL,
                  `Zmin` text NOT NULL
                ) ENGINE=MyISAM DEFAULT CHARSET=latin1;

	fps

	21.51

	// [todo]
	[todo] -> Ogni funzione da testare avrï¿½ un commento con questo tag in modo da identificarlo nel codice
	// ^ aggiunto di recente nuvoa funzione [todo] 19/03/2013
	// [fine global] specifica il punto in cui finiscono le dichiarazioni delle variabili globali

	######################
	##      To-Do       ##
	######################

		* Scrivere il comando /bans (che mostra la lista dei utenti bannati)
	    * Fixare la Last Bullet
	    * Restore del damage sempre

	// 5848 you win sir, well played (suono a fine round?)
	// 8259 nobody can stop us (fine round winner)
	//<3 <3

	// angy e.e

	comandi che accetteranno fino a 5 ids:

		/add
		/remove
		/setteam - /setsub (sicuro?) -> eventuale nuova sintassi: (setteam [team] [id] [id]) altrimenti? ( [todo] #FARE EVENTUALI TEST#)
		/kick (?)

	da testare:
	    /add
	[...]
-----------------------------------------------------------------------------
	######################
	##    Changelog     ##
	######################

	5.0:
	    [Fixed] Risolto il bug che bloccava lo /switch quando si scriveva un nome team errato
	    [Removed] Rimossa ogni dipendenza dal SQLite, rimossa la possiblità di compilare la gamemode in SQLite mode.
	    [Fixed] Risolto il bug che mostrava un warning dello sscanf quando si usava /switch
	    [Fixed] Risolto il bug nel /play che non mostrava tutte le opzioni
	    [Improved] Migliorato il messaggio del /lock e /unlock
		[Improved] Cambiata la cam nella skin selection
		[Improved] Il final round textdraw ora comparirà solo ai players che sono nei teams
	    [Improved] Il limite del dm è stato rimosso. Ora puoi andare nello spec anche mentre sei un DM.
	    [Improved] Swap teams disattivato nella modalità no scores
	    [Improved] Textdraws aggiornati
	    [Improved] Anticheat aggiornato
	    [Fixed] Risolti tutti i bug delle query
	    [General] Vari fixbug / modifiche
	    [Improved] Cambiato il colore del dm
	    [Fixed] Risolto il bug che non swappava i nomi dei teams nella skin selection

	4.8:
	    [Fixed] Risolto il bug che bloccava il /sync dopo 24 giorni
	    [New] Nuovo sistema per il calcolo degli FPS
	    [New] Aggiunto /gm alias di /givemenu
	    [Fixed] Risolto il bug che non resettava il nome del server quando l'anticheat veniva disattivato automaticamente
	    [Fixed] Risolto il bug del /sync che costringeva il restart manuale del server ogni 24 giorni
	    [Improved] Migliorato il label che indica il damage dei veicoli
	    [New] Aggiunto il comando /dvehicles per distruggere tutti i veicoli spawnati nel lobby
	    [Improved] Migliorato il messaggio di kick/ban
	    [Fixed] Risolto il bug che non terminava il round a 0:00 preciso.
	    [Fixed] Risolto il bug dei labels dei veicoli dopo /dvehicles
	    [Fixed] Risolto il bug che non cancellava i dati di crash dopo il comando /add
	    [New] Aggiunto il comando /replace che permette di sostituire un player in game con un altro.
	    [Fixed] Risolto il bug che faceva scattare il nuovo minuto a x.01 e non a x.00
	    [Changed] Ridotto il tempo di kick da 1 secondo a 900 ms.
	    [Updated] Aggiornate le basi ESL
	    [Fixed] Risolto il bug che mostrava la top buggata

	4.7:
	    Risolto il bug che assegnava i punti per i kills anche ai players non in game.
	    Risolto il bug che assegnava i punti al player sul checkpoint anche se il round non era stato vinto per checkpoint.
	    Risolto il bug che mostrva la scritta sbagliata nel messaggio di swap ad ogni fine round.
		Ad ogni fine round della fun mode i punti che il players ha accumulato durante tutti i rounds vengono mostrati nel tab "score" e nelle /stats
	    Migliorata la gestione del "freeze-sfreeze"
	    Risolto il bug che mostrava in alcuni casi la map-icon spawn anche ai defenders dopo l'add
	    Risolto il bug che non auto-riaddava un player dopo il timeout in modalitï¿½ ESL
	    Aggiunto /vote [ADD, minplayers] nelle modalitï¿½ ESL per aggiungere un players o cambiare li numero di players minimi richiesti per startare il round esl
	    Risolto il bug che non mostrava un messaggio d'errore se si usava un ID non valido in /vote [X]
	    Migliorate le prestazioni della gamemode
	    Se il server è vuoto l'anticheat verrà disattivato dopo 2 minuti.
		Alla fine di una TCW/CW l'anticheat sarà disattivato automaticamente.

	4.6:
	    Risolto il bug che non resettava il textdraw dopo un resetscores
	    Modificato il "fade" della gamemode
	    Rimosse le armi sopra la testa del player, aggiunto il cuore o l'armatura
	    Rimosso il textdraw "sigmaseven.forumfree.it"
	    Risolto un bug che sovrapponeva vari final round stats unos opra l'altro se il player era afk o in uno stato specifico
	    Migliorato codice dell'update dei labels dei veicoli
		Migliorati /gun e /stats
		Il veicolo dopo essere stato distrutto non viene piï¿½ respawnato
		/spec ora è disponibile nella modalitï¿½ ESL
		Aggiunto /lockteam per chiudere un team
		Risolto il bug che non cambiava aggiornava i team name nel mapname
		Quando si passa alla modalitïà ESL i nomi dei teams saranno impostati A e B
		Quando damage e total damage cambiano per motivi diversi da un hit il td viene aggiornato immediatamente (esempio: durante un resetscores o un restore etc)
		/whois da oggi puï¿½ essere usato su un ID disconnesso, saranno visualizzate le stats dell'ultimo player che ha usato quell'id
		Vari miglioramenti interni
		Da ora è possibile mutare, bannare o kickare un player senza inserire una reason
		Il roundstats ï¿½ visibile in ogni punto della gamemode durante un round
		Allo scopo di migliorare le prestazioni della gamemode, l'anticbug ï¿½ stato disattivato.
		Modifica al sistema di draw dei name tags dei players dello stesso team
		Risolto il bug che faceva buggare la cam dopo un hit
		/vdestroy temporaneamente rimosso
		Risolto il bug che non salvava la modifica alla skin in caso di rimozione
		Risolto un bug critico nella memoria
		Il plugin MySQL ï¿½ stato aggiornato alla versione R23 (dalla R7)
		Aggiunto il "Force Final" nel menu /play
		Migliorato l'auto-pause nella modalitï¿½ ESL
	    Varie modifiche non elencate

	4.5:
	    Risolto il problema del name tag
	    I dati di crash del player vengono cancellati solamente quando viene addato o alla fine di un round
	    /ac rimosso, inserito in /play
	    Risolto il bug che non dava le armi quando un player crashava durante un arena
	    Risolto il bug che se il database laggava i messaggi di connect venivano visualizzati pure se il player si disconnetteva
	    Aggiunta la possibilitï¿½ di cambiare pack basi direttamente dal /play

	4.5 RC11:
	    Risolti tutti i bugs
		Migliorata la stabilità della gamemode
	    Driveby disattivato

	4.5 RC9:
	    Ora ï¿½ possibile usare /pm anche quando non si ï¿½ spawnati
	    /dmq funzionerï¿½ come /lobby
	    Usando /ac ï¿½ possibile attivare l'anticheat
	    Pulizia codice.
	    Rimosso il vote-pause
	    Risolto un bug che non permetteva di usare /spec [id] quando si era ref
	    Fixato /aa
	    Riattivato il pause/unpause tramite Y rimosso per errore.
	    Fixato un bug in /aweaponsets

	4.5 RC7:
	    Rimesso vecchio round stats
	    Web Match code rimosso temporaneamente6
		Fixato il bug che non faceva sentire il tick del quinto secondo durante lo start
		Il weaponmenu comparirï¿½ solamente dopo che i players spawnano

	4.5 RC6:
		Aggiunto il suono per il terzo secondo dell'unpause
		Risolto un problema che settava la vita o armatura a 0 se dopo /healall o /armourall non si scriveva un numero.
		Se /swap viene usato su un player nel team ref viene swappato nel team con meno membri
		Rimosso /tw
		Aggiunto il weaponset Shotgun / Rifle [tutte le versioni della gamemode precedenti alla 4.5 RC6 non saranno piï¿½ compatibili]

	4.5 RC5:
		Il vecchio veicolo spawnato con /v non sarï¿½ piï¿½ rimosso
		Fixbugs nel roundstats
		Risolto il bug che a volte non fixava la cam quando il player scendeva dal veicolo
		/Ban ï¿½ stato diviso in tre comandi diversi: /ban /banserial /bannick (si, la gente non sapeva usare /ban)
		Risolto un bug che causava l'impossibilitï¿½ di syncarsi
		Nella modalitï¿½ TDM le barre indicano il numero di kills fatti dal team

	4.5 RC4:
	    Nella modalitï¿½ lastbullet dopo aver ucciso un player viene dato un colpo di deagle
	    Il colore del messaggio "All the rounds have been played! Wait while final results are being prepared..." varia in base al team che ha vinto la TCW/CW
	    Aggiunto numero players nel textdraw del gungame
	    Nuovo round stats!

	4.5 RC3:
 		Quando si uccide un giocatore nel deathmatch il suo nick nel td kill sarï¿½ rosso
	    Fallout fixbug

	4.5 RC2:
	    Risolto il bug che non mostrava il colore giallo nelle modalitï¿½ no teams quando si faceva /kill o si moriva non per opera di un player
	    Migliorato codice del sync
	    Quando un player viene aggiunto con /add le sue statistiche in game (damage/kills/deaths) non vengono resettate

	4.5 RC1:
		Aggiunta la modalitï¿½ Fallout
		/Spec si puï¿½ usare su tutti i players quando le modalitï¿½ Gungame, Fight e Fallout sono attive
		/start fava per startare una fight all vs all
		Fixati i spawn delle interiors
		Cambiato spawn del dm 19.
		Cambiata scritta e colori del label sui players
		Fixbug nel FPS/Ping/Packetloss kicker

	4.3:
	    Risolto bug nella teamchat
		Le healthbars saranno visibili solo dentro il round o durante lo spec
		Risolto un bug nel register
		Multi hits
		Fixbug nel contatore "Played"
		Fixbug nel td fine round
		Fixbug nel messaggio di inizio round
		Miglioramenti nelle healthbars
		Gamemode portata da INI a MySQL!
		TDM Funzionante!
		Rimossa modalitï¿½ Massacre!
		Fixbug nel label dei players
	    Migliorato codice add
	    Fixed gungame
	    Aggiunto /bestdm
	    Risolti alcuni spawns buggati nei dm
	    /giveweapon [playerid] [weapon] [ammo]
	    Risolto un bug nel readd di un player
	    Risolto il bug che causava una divisione per 0
	    Sistema multi config per i due server
		Aggiunti /unbannick e /unbanserial
		Nuovo round stats
		Nuovo Textdraw fine round
		Aggiunto /showagain
	    Fixbug nel sistema ban
	    Rimosso /setsub usare /setteam [id] [sub-team] per settare un player sub
	    /switch [teamname] ora supporta anche i team sub
	    Aggiunto "Y" Per votare/pausare un round
	    Risolto un problema con /pinfo
	    Beta del nuovo codice dell'Auto-Start
	    Fixati svariati bugs
		Aggiunto nuovo livello admin
	    Aggiunto /reload
	    /admins non sarï¿½ piï¿½ a dialog
	    Risolto il problema che non prendeva gli scores dal db nel passaggio da tcw/cw a fun
	    Aggiunto /roles
	    Risolto un problema che non mostrava correttamente la mappa di gta durante lo start round
	    Aggiunta la possibilitï¿½ di cambiare le armi nella PVP mode
	    Il colore della gangzone del CP ora sarï¿½ del colore del team defender
		Nuovo fixbug in /config
		Nuovo sistema per supportare piï¿½ servers senza la necessitï¿½ di compilarla per ogni server
		Il comando /pass ora funzionerï¿½ come /password
		Risolto un bug nel /bestdm
		Risolto un problema nel sync
	    Risolto un bug nel config
	    Risolto un bug che impostava il limite di Packetloss sbagliato
	    Quando un player ï¿½ mutato tutto ciï¿½ che scrive viene inviato direttamente nella team chat, lo stesso vale se la chat principale ï¿½ disattivata
	    Riattivata la chat admins tramite @
	    Risolto un bug che permetteva ai players di syncronizzarsi mentre erano in spec
	    Modificato /credits
	    Fixbug nel fight
	    Risolto un problema nel mapname quando si cambiava modalitï¿½ di gioco
	    Fixbug nel /delvotes che non cancellava il timer
	    Aggiunta la possibilitï¿½ di impedire un voto specifico usando /lockvote
	    Risolto un bug nel vote quando non si inseriva l'id dopo il tipo di vote
	    Aggiunta la possibilitï¿½ di votare un TDM nel vote
		/armourall ora ï¿½ disattivato anche nelle gungame e fight modes.
		Armourall e Healall ora accettano un parametro secondario che corrisponde alla vita/armatura da dare ai players
	    Miglioramenti nel comando /pm
	    Ora sarï¿½ possibile inviare PMs anche durante lo start del round
	    Aggiunto il comando /allvs
	    Quando un player muove in game si creano dei pezzetti di corpo nel posto dove ï¿½ morto.
		/pl => /packetloss
		Risolto un problema nel colore dello /switch diretto nei team sub
		Il textdraw dei players nei teams ï¿½ visibile solo ai players fuori dal round
	    Modificato /admins
	    Modificato /whois
	    0.3x only: Ora i players dello stesso team non possono danneggiare le auto guidate dai loro compagni di team
	    Aggiunto /tw
	    La password impostata con /lock non puï¿½ superare i 20 caratteri
	    Risolto un problema che non settava il nome corretto alla gm in caso di modalitï¿½ ESL o NoCBUG
		Usando /v (/car) dentro un veicolo puoi cambiare direttamente il veicolo senza uscirci
		Risolto un bug che bloccava il proseguimento del TDM una volta fatti 20 kills
		Risolto un bug che non cambiava spec quando il player si remuoveva o veniva rimosso
		Risolto il bug che permetteva di bilanciare i players anche quando un round era in corso
		Nuovo textdraw Fall protection
		Nuovo textdraw spec
		Modifiche al colore del player quando preme N
		Risolto un bug che non faceva nascondere il textdraw round stats quando si cambiava modalitï¿½ da fun a tcw/cw
		Risolto un bug nel /random che non startava l'arena PVP corretta
		Risolto un bug che startava l'arena PVP quando si usava /start arena (o TDM)
		Risolto un bug che permetteva di settare il team a un player afk (/afk)
		Risolto un bug che conteggiava i players afk durante il controllo dei players nei team prima dello /start
		Riattivato /delacc
		I players loggati nella rcon saranno contati nell'/admins
		Nuovo colore al messaggio di Sync
		Risolto un bug che non fixava la musica nell'EndRound
		Risolto un bug che aggiungeva la mapicon dello spawn a un player aggiunto dopo il crash
		Risolto un bug che permetteva di syncarsi all'infinito usando /s
		Risolto un bug nell'OnPlayerTakeDamage
		DM 3 portato a shotgun/rifle
		Miglioramenti all'OnPlayerText
		Migliorato il codice del final round
		Risolto un bug che non nascondeva il textdraw del final round
		Migliorato il codice durante lo switch della modalitï¿½ da una modalitï¿½ a ESL e viceversa
		Quando si preme Y in modalitï¿½ ESL si setta come ready, N per settarsi come non ready
		Risolti due bugs nello spec
		Modificato textdraw player info
		Creato /swap

	4.1.2:
	    Miglioramenti nella gestione del remote
		Miglioramenti
		Fixbug nello spec
		Aggiunto /snetstats
		Migliorato /netstats
		Risolto il problema con gli score dei refs (se prima erano stati players)
		Risolto un problema con le arene
	    Attivata la possibilitï¿½ di cambiare i limiti
	    Migliorato codice dialogs
	    Migliorato /pinfo
	    Modifica al messaggio del /v
	    Modificato /admins
	    Aggiunta la possibilitï¿½ di cambiare lobby dal /config
	    Aumentato il raggio del messaggio di benvenuto
	    Importante fixbug riguardo il conteggio dei players!
	    Ogni DM ha un proprio world
	    Rimosso /blockpms
	    Rimossi i custom spawn
	    Miglioramenti generali relativi alla memoria
	    Rimosso /afks
	    Risolto il problema che non aggiornava il mapname dopo un gungame
	    Risolto un bug nello spec che non aggiornava la visuale quando il player usciva dal veicolo
	    Risolto il problema che invertiva le scritte "Attackers Win" e "Defenders Win" a fine round
	    Risolto il problema che non cambiava il colore nella scritta del team vincitore
	    Risolto bug riguardante il conteggio dei players fuori dal round
	    Risolto un bug che non assegnava il colore giusto ai players
	    Nuovo codice per l'invisiblitï¿½
	    Risolto il problema che non resettare lo score che indificava vita/damage del player dopo il /(rem)ove
		I msg di damage e di kill scompariranno in caso di fine round
		Random spawn migliorato nel lobby
		Modificato /acmd
		Modificato msg di autologin quando il player si connette
		Nuovo textdraw per gli hits
		Nuovo algoritmo per la top!
		Ora i nicknames dei players nel final round saranno ordinati in base al dmg
	    Nuove arene Deathmatch
	    Nuova arena per il dm Sniper / Shotgun
	    Quando un difensore entra nel checkpoint il countdown sarï¿½ terminato immediatamente
	    Nuovi fixbug
	    Quando il player entra in spec i TD riguardo hits e kill verranno nascosti
	    Add dopo un crash fixato
	    Migliorati gli spawns nei rounds
	    Modificato messaggio in /rem
		Tradotti messaggi nel /vote
		Modificato messaggio quando il player viene kickato/bannato
		Restore del dmg quando il player si connette
		Risolto il problema con /givemenu che non mostrava tutto il nickname oppure niente
		Risolto il bug del checkpoint che azzerava il conto quando un altro attacker entrava nel cp
		Aggiunti /freeze /unfreeze /sfreeze
		Aggiunti /eject /say /ann /giveweapon
		Aggiunti /freezeall /unfreezeall
		Aggiunto /unmuteall /muteall
		Varie modifiche
	    Ora il PlayerInfo sarï¿½ disattivato quando si ï¿½ in modalitï¿½ spec
	    Miglioramenti generali nel codice dello spec
	    Risolto un problema a fine round che modificava i world dei players nei dm
	    Aggiunto /givemenu [id] fino a 5 ids.
	    Aggiunto "N" per chiedere aiuto
	    Miglioramenti nell'/afk
	    Modifica dei messaggi nel /kick, /ban e /mute
	    Modificato /admins
	    Modificato /setlevel
	    Modificato /setlvltemp
	    Miglioramenti nello spawn dei players
		Modificati messaggi di connessione e uscita
		Modificato dialog /dm
		Aggiunto lo skin swap
		Riaggiunti i 3 secondi tra un sync e l'altro
		Aggiunto un messaggio quando si usa /gunmenu (o /wmenu)
		La frase di hint sarï¿½ visibile solo quando si ï¿½ nel lobby e il round non ï¿½ startato
		Lo Skin swap avverrï¿½ ad ogni inizio round (se attivo)

	4.1.1:
	    Ulteriori miglioramenti
	    Migliorata la lettura dei players nei vari teams
		Fixbug nello /switch

	4.1.0:
		Modifiche al gunmenu.
		Fixbug nella colorazione del gunmenu
		Risolto un problema nel sync
		Migliorata lettura del file utente
		Aggiunto campo "HINT" in basso a destra quando il round non è in corso
		Nuovo codice deathmatchs
		Modifiche ad alcuni comandi
		Miglioramenti generali
		Fixato spec
		Migliorate stats
		/setscores [con nome del team] + setteam
		Miglioramenti
		Risolto bug della health quando la modalitï¿½ no-bars ï¿½ attiva
		Migliorato sync

	4.0.2:
	    Migliorato OnPlayerDeath
	    Miglioramenti nell'OnPlayerUpdate
	    Modifiche al timer invisibilitï¿½ e al codice del sync
	    Fixbug nel fall protection
	    Fixbug nel readd
		Migliorato codice vote
		Aggiunto /weather
		Risolto il problema che non faceva uscire l'indicatore della vita dopo il final
		Cambiato colore del team ref
		Aggiunto /demobase
	    Risolto un problema nel ban
	    Fixbug nel spec
		Aggiunto checkpoint nello spec
		Risolto un problema nel salvataggio della configurazione dei weaponsets
		Risolto il problema che non rendeva nessun comando attivabile durante la spec-mode
		Aggiunto /fs
		Aggiunto /ab (/add ball) per aggiungere tutti i giocatori e bilanciare i teams
		Aggiunto /explode
		Risolto un problema con i label dei veicoli
		Aggiunto /switch [team_name] per switchare direttamente in quel team
		Risolto il problema con gli allineamenti nel final

	4.0.1:
		Fixbug nel sistema dei veicoli
		Risolto il problema che toglieva le armi dopo il sync
		Riscritto totalmente codice del gunmenu e creato /aweaponsets per cambiare il limite, togliere un limite o disattivarlo.
		Risolto un bug con l'unpause

 	4.0:
      	Se la password ï¿½ giï¿½ impostata all'avvio del server, /password funzionerï¿½ lo stesso
      	Rimosso sistema team leader
      	Rimosso sistema sostituzioni
      	Nuovo /config
      	Codice migliorato
      	Rimosso codice missioni
      	Usando /getgun [weaponsetid] ï¿½ possibile ottenere le armi del weaponset scelto
      	Imposto un limite per il nome dei teams (1-7 caratteri)
      	Nuovo /switch
      	Fixbugs nel sync
      	Il messaggio "Cannot start the round, not enough players in every team." (dello start-round) non sarï¿½ visualizzato da tutti in caso di start da un player
      	Risolto bug nel sistema lock dm
      	Risolto bug health bars
      	Operazione semplificazione codice: Tutti le modalitï¿½ che usano piï¿½ spawns per giocatore devono adattarsi al nuovo standard: 30 spawns diversi
      	Risolto bug nel /getgun
      	Agginto "Massacre" mode - funzionerï¿½ come all vs all (still in beta)
      	Migliorati i suoni
      	Risolto un bug nel sistema ban
      	Rimosso /music
      	Scrivendo /dm [id] si andrï¿½ direttamente al dm scelto
      	Algoritmo per la top creato
      	Top players finita
      	Aggiunta la reason in /kick, /ban, /hdban e /mute
      	Migliorato sistema di voting - quando un player che ï¿½ in vote kick si logga nella rcon il voting viene cancellato automaticamente
      	Aggiunto /delvotes per cancellare una votazione in corso
      	Cambiato suono nella !
      	Cambiata scritta nella teamchat
      	Rimosso commands.ini, nuovo codice per i comandi admin (ancora in beta)
      	New vote system
      	Aggiunto systema pack basi
		Aggiunte tre modalitï¿½ di gioco: ESL, NoCbug e Slaughterfield
		Migliorie al sistema di spec, e vari fixbug
		Migliorato il sistema di damage che causava lag
		Aggiunto fall protection system fino al primo hit
		Svariati fixbug
		Aggiunto /Acmd
		Aggiornamento dello score nel textdraw immediato
		Risolto il problema che non aggiornata il textdraw roundstats all'hit di un player
		Quando la TCW/CW finisce la death log viene pulita e cambiato tempo e weather
		Risolto un problema che non riportava correttamente al lobby (o alla posizione di spawn impostata) dopo aver fatto /specoff
		Quando un player fa 0 damage non viene visualizzato nella top
		Il label contenente (PL / Ping - FPS) Si colorerï¿½ quando vengono superati i limiti
		Quando si spawna un nuovo veicolo tramite /v il precedente viene rimosso
		Risolto un problema con /ready quando la modalitï¿½ ESL era attiva
		Aggiunta la modalitï¿½ NoCbug e lo script anti cbug
		Rimossa la parola "mode" nel messaggio dell'/afk
		Quando un player muore lo script cerca un altro player dello stesso team da spectare, altrimenti lo rimuove dallo spec
		Quando un player preme su "Players" (nel dialog /stats) viene visualizzata la lista di tutti i players connessi cliccando sarï¿½ possibile visualizzare le loro stats
		Quando un player si logga nella rcon ora il messaggio di login viene visualizzato a tutti i players connessi
		Risolti alcuni bugs relativi al nuovo codice per la ricerca dei files delle basi (etc)
		Aggiunto /gun con la lista di tutte le armi disponibili
		Risolti alcuni bugs nel /getgun

	RC6-2 (03/09/2012):
		Aggiungo /getgun e due nuove opzioni nel /config per attivare/disattivare lo spawn di veicoli/armi nel lobby.
		Aggiornamenti di sicurezza nel sistema accounts
		Fixbug nel salvataggio delle armi

	RC6 (31/08/2012 22-51):
		Aggiunto /fstyle che cambia lo stile di combattimento come /fight
		Aggiunto /blockpms per bloccare i pms da un altro utente
		Fixate arene con rispettivi limiti
		Aggiunto /rem
		Importante fixbug riguardante la divisione per 0 che faceva buggare il server
		Aggiunto /gungame con due arene
		Il label indicante "Ping - Packetloss / FPS" ora non si vedrï¿½ solo in game ma anche fuori
		Fixbugs generali
		Aggiunta la possibilitï¿½ di chiudere un dm (/lockdm) con o senza una password
		Risolto un bug riguardante la gangzone del CP
		Aggiunta admin chat (level 5) con @
		Risolto un bug nel roundstats
		Risolto un problema che faceva terminare la "cw" anche se la modalitï¿½ no scores era attiva
		Gli scores saranno salvati solamente se la modalitï¿½ no scores ï¿½ attiva
		Fixbug al rilevatore fps
		Creato sistema di debug (debug.txt) della gamemode
		Fixati vari bugs riguardanti gli scores tra la Matchmode e No scores mode
		Risolto un problema nel /setscores
		Gli scores della modalitï¿½ "no scores" saranno diversi da quelli della tcw/cw mode
		Prima base per un AC (controllo veicoli)
		Riscritto TOTALMENTE codice del /spec system
		name tags e icone players ora lavorano su due timer diversi
		Quando una votazione ï¿½ in corso e tutti i players hanno votato si la votazione termina immediatamente
		Migliorato ulteriorlmente il codice /spec
		Migliorato il messaggio del /dm
		Aggiunto nuovo sistema di ban
		Aggiunto un messaggio nel DM quando un player uccide un player player (visibile solo dai players in quel dm)
		Migliorata la gestione della fine cw per i player nell'/afk
		Fixbug nel fix del damage
		Rimosso /gungame, aggiunto /start gungame
		/spec senza id porterï¿½ al primo id possibile da spectare
		Piccola modifica nel codice del Damage
		Fixato sistema account, ora funziona correttamente
		Migliorato sistema AC (veicoli) che creava falsi-positivi
		Aggiunto /t

	RC5 (24/08/2012 22-01):
		Modifica ai messaggi del vote
		Se il player fa /afk mentre ï¿½ in un veicolo, al suo ritorno sarï¿½ rimesso nel veicolo
		Importante fixbug riguardante i messaggi di blocco
		Alcuni fixbug al /sync
		Nuovi textdraw ai nickname dei players nelle barre
		Added /lock, /unlock e /password
		Se il round ï¿½ giï¿½ stato startato non ne viene startato uno nuovo.
		Tutte le votazioni per start arena o base vengono cancellate allo start del round
		Quando un player viene aggiunto e il round ï¿½ pausato, viene bloccato
		"restore-to-crash" riportato al precedente codice
		Aggiunta la possibilitï¿½ di aggiungere il nos ogni volta che si preme il tasto sinistro del mouse
		Premendo "Y" ï¿½ possibile mostrare/nascondere il Final round td
		/setlevel ID tmp Per dare all'id scelto i poteri admin temporanei, remtmp per toglierli.
		Fixbugs nel sistema di spec
		Aggiunto Lobby x:x (x = scores dei due teams)
		Rimossa la possibilitï¿½ di attivare/disattivare un comando admin
		Aggiunto /readtype per cambiare il round da startare quando tutti i giocatori sono pronti /ready
		Aggiunta nuova arena all vs all
		Per startare gli ints si dovrï¿½ usare /start ints [id o -1]
		Risolto un bug riguardante le barre (quando un player si disconnetteva)
		Bug importantissimo fixato per la sicurezza del server
		Fixato importantissimo bug riguardanti i comandi admin che ignoravano totalmente i livelli ed erano usabili da chiunque
		Nuovo formato per il salvataggio dei comandi admin nel file commands.ini
		Aggiunti nuovi comandi gamemode (non necessari per l'uso della gamemode) /reloadlimits /changelimit (L'uso di questi comandi puï¿½ danneggiare il sistema random dello start di un round!)

	RC4 (18/08/2012):
		Fixbug barra verde e rossa
		Cambiato suono al sync
		Aggiunto ID prima del testo quando si scrive in chat
		Aggiunti suoni ai comandi
		Leggermente modificato td scores
		Nuovo td final cw
		Nuovo td che indica Ping, packetloss, kills, damage in basso a sinistra
		Nuovo codice per salvare i crashs dei players (SQLite) i players crashati salvati saranno cancelli a fine round
		Aggiunto sistema AFK, quando si ï¿½ AFK nel lobby da piï¿½ di 2 minuti si viene portati nell'/afk, mentre per 30 secondi afk in round si viene rimossi.
		Aggiunto comando /afk, aggiunto /random, aggiunto /remcrash
		Aggiunto suono al gunmenu
		Aggiunto TD "first blood"
		Aggiunto /start base -2 per startare interiors random
		Rimosso codice di Bea.

	RC3:
		Nuovo TD fine round
		Fixato un importante bug riguardante i TDs
		Aggiunti i due td "Player hittato / amount hits (x hits) / arma " anche nel lobby
		Aggiunto comando /radio
		Da oggi ï¿½ possibile attivare e disattivare le missioni, una volta disattivate rimarranno tali finchï¿½ non saranno riattivate con /mission
		Piccolo fixbug nel controllo del danno di un player
		Reset delle variabili quando un player muore
		Nuovo textdraw scores

	RC2:
		Fixato un bug nei limiti dell'arena/pvp/tdm che non resettava il conteggio dei secondi una volta rientrati in arena
		Altri fixbugs
		Fixato il label dei players
		Cambiato il colore dei labels
		Cambiato formato dei labels ( Ping / Packetloss\nFPS: x )

	RC1-1:
		Fixbug "Quando un player veniva riaggiunto al round dopo essere crashato, anche se il round era pausato poteva comunque muoversi.".
		Fixato gunmenu
		Fixbug nel comando /pm
		Nuovo textdraw Round paused

	RC1 (11/08/2012):
		Prima RC!.
		Fixati vari bugs.
		Risolto il problema del timer che causava un enorme lag (anche server crash) durante le basi (arene, tdm, etc).
		Rimossi frammenti di codici riguardanti il vecchio lobby (mongolfiera, beat the record).
		Rimosse le race.
		La mapicon che indicava lo spawn degli attackers non avrï¿½ piï¿½ un checkpoint, ma solo l'icona.
		Cambiata la song durante la skin selection

	I Changelog della versione 3.5 / 3.0 o 0.2 non sono stati riportati in questa gamemode
-----------------------------------------------------------------------------
 debug:: -w 203 -d3
 pawn.cfg::-d0 -r

 debug mode

 Per farla funzionare:

 YSI
 Foreach
 Geo location
 strlib
 zcmd
 sscanf

 UPDATE  `11221_s7gm`.`teams` SET  `ingamecolor` =  '0xe21f1faa',
`outcolor` =  '0xba6060aa' WHERE  `teams`.`id` =1 AND  `teams`.`name` =  'TTMF' AND  `teams`.`skin` =53 AND  `teams`.`ingamecolor` =1139023530 AND  `teams`.`outcolor` =1908105642 AND  `teams`.`gid` =0 LIMIT 1 ;

UPDATE  `11221_s7gm`.`teams` SET  `ingamecolor` =  '0xe21f1faa',
`outcolor` =  '0xba6060aa' WHERE  `teams`.`id` =1 AND  `teams`.`name` =  's7' AND  `teams`.`skin` =53 AND  `teams`.`ingamecolor` =1139023530 AND  `teams`.`outcolor` =1908105642 AND  `teams`.`gid` =1 LIMIT 1 ;
-----------------------------------------------------------------------------
*/
antiDeAMX()
{
   new AntiDeAMX[][] =
   {
       "Unarmed (Fist)",
       "Brass K"
   };
   #pragma unused AntiDeAMX
}

new StartTick;

// rappresenta i colori dei teams dei gametext o textdraws
#define GT_TEAMA            	"r"                     // ATTACKERS
#define GT_TEAMB            	"b"                     // DEFENDERS
// rappresenta i colori dei teams nei messages (embed)
#define SC_TEAMA            	"f22b2b"            	// TEAM A = ATTACKERS ( rossi )
#define SC_TEAMB            	"0469FF"            	// TEAM B = DEFENDERS ( blu )
#define SC_TEAMSA           	"D0D4AC"                // TEAM SUB A = ATTACKERS SUB A ( rossi - sub )
#define SC_TEAMSB           	"B28C8C"                // TEAM SUB B = DEFENDERS SUB B ( blu - sub )
#define SC_TEAMR            	"DCF000"                // TEAM REF = REF ( giallo - ref )
// colori in hex
#define HEX_TEAMA            	0xf22b2bAA
#define HEX_TEAMB            	0x0469FFAA
#define HEX_TEAMSA           	0xD0D4ACAA
#define HEX_TEAMSB           	0xB28C8CAA
#define HEX_TEAMR            	0xDCF000AA
////////////////////////////////////////////////////////////////////////////////
//==============================================================================
////////////////////////////////////////////////////////////////////////////////
//vehicles
#define MIN_VEHI_ID		400
#define MAX_VEHI_ID		611

new const aVehicleNames[212][] = {	// Vehicle Names - Betamaster
	{"Landstalker"},
	{"Bravura"},
	{"Buffalo"},
	{"Linerunner"},
	{"Perrenial"},
	{"Sentinel"},
	{"Dumper"},
	{"Firetruck"},
	{"Trashmaster"},
	{"Stretch"},
	{"Manana"},
	{"Infernus"},
	{"Voodoo"},
	{"Pony"},
	{"Mule"},
	{"Cheetah"},
	{"Ambulance"},
	{"Leviathan"},
	{"Moonbeam"},
	{"Esperanto"},
	{"Taxi"},
	{"Washington"},
	{"Bobcat"},
	{"Mr Whoopee"},
	{"BF Injection"},
	{"Hunter"},
	{"Premier"},
	{"Enforcer"},
	{"Securicar"},
	{"Banshee"},
	{"Predator"},
	{"Bus"},
	{"Rhino"},
	{"Barracks"},
	{"Hotknife"},
	{"Trailer 1"}, //artict1
	{"Previon"},
	{"Coach"},
	{"Cabbie"},
	{"Stallion"},
	{"Rumpo"},
	{"RC Bandit"},
	{"Romero"},
	{"Packer"},
	{"Monster"},
	{"Admiral"},
	{"Squalo"},
	{"Seasparrow"},
	{"Pizzaboy"},
	{"Tram"},
	{"Trailer 2"}, //artict2
	{"Turismo"},
	{"Speeder"},
	{"Reefer"},
	{"Tropic"},
	{"Flatbed"},
	{"Yankee"},
	{"Caddy"},
	{"Solair"},
	{"Berkley's RC Van"},
	{"Skimmer"},
	{"PCJ-600"},
	{"Faggio"},
	{"Freeway"},
	{"RC Baron"},
	{"RC Raider"},
	{"Glendale"},
	{"Oceanic"},
	{"Sanchez"},
	{"Sparrow"},
	{"Patriot"},
	{"Quad"},
	{"Coastguard"},
	{"Dinghy"},
	{"Hermes"},
	{"Sabre"},
	{"Rustler"},
	{"ZR-350"},
	{"Walton"},
	{"Regina"},
	{"Comet"},
	{"BMX"},
	{"Burrito"},
	{"Camper"},
	{"Marquis"},
	{"Baggage"},
	{"Dozer"},
	{"Maverick"},
	{"News Chopper"},
	{"Rancher"},
	{"FBI Rancher"},
	{"Virgo"},
	{"Greenwood"},
	{"Jetmax"},
	{"Hotring"},
	{"Sandking"},
	{"Blista Compact"},
	{"Police Maverick"},
	{"Boxville"},
	{"Benson"},
	{"Mesa"},
	{"RC Goblin"},
	{"Hotring Racer A"}, //hotrina
	{"Hotring Racer B"}, //hotrinb
	{"Bloodring Banger"},
	{"Rancher"},
	{"Super GT"},
	{"Elegant"},
	{"Journey"},
	{"Bike"},
	{"Mountain Bike"},
	{"Beagle"},
	{"Cropdust"},
	{"Stunt"},
	{"Tanker"}, //petro
	{"Roadtrain"},
	{"Nebula"},
	{"Majestic"},
	{"Buccaneer"},
	{"Shamal"},
	{"Hydra"},
	{"FCR-900"},
	{"NRG-500"},
	{"HPV1000"},
	{"Cement Truck"},
	{"Tow Truck"},
	{"Fortune"},
	{"Cadrona"},
	{"FBI Truck"},
	{"Willard"},
	{"Forklift"},
	{"Tractor"},
	{"Combine"},
	{"Feltzer"},
	{"Remington"},
	{"Slamvan"},
	{"Blade"},
	{"Freight"},
	{"Streak"},//train
	{"Vortex"},
	{"Vincent"},
	{"Bullet"},
	{"Clover"},
	{"Sadler"},
	{"Firetruck LA"}, //firela
	{"Hustler"},
	{"Intruder"},
	{"Primo"},
	{"Cargobob"},
	{"Tampa"},
	{"Sunrise"},
	{"Merit"},
	{"Utility"},
	{"Nevada"},
	{"Yosemite"},
	{"Windsor"},
	{"Monster A"}, //monstera
	{"Monster B"}, //monsterb
	{"Uranus"},
	{"Jester"},
	{"Sultan"},
	{"Stratum"},
	{"Elegy"},
	{"Raindance"},
	{"RC Tiger"},
	{"Flash"},
	{"Tahoma"},
	{"Savanna"},
	{"Bandito"},
	{"Freight Flat"}, //freiflat
	{"Streak Carriage"}, //streakc
	{"Kart"},
	{"Mower"},
	{"Duneride"},
	{"Sweeper"},
	{"Broadway"},
	{"Tornado"},
	{"AT-400"},
	{"DFT-30"},
	{"Huntley"},
	{"Stafford"},
	{"BF-400"},
	{"Newsvan"},
	{"Tug"},
	{"Trailer 3"}, //petrotr
	{"Emperor"},
	{"Wayfarer"},
	{"Euros"},
	{"Hotdog"},
	{"Club"},
	{"Freight Carriage"}, //freibox
	{"Trailer 3"}, //artict3
	{"Andromada"},
	{"Dodo"},
	{"RC Cam"},
	{"Launch"},
	{"Police Car (LSPD)"},
	{"Police Car (SFPD)"},
	{"Police Car (LVPD)"},
	{"Police Ranger"},
	{"Picador"},
	{"S.W.A.T. Van"},
	{"Alpha"},
	{"Phoenix"},
	{"Glendale"},
	{"Sadler"},
	{"Luggage Trailer A"}, //bagboxa
	{"Luggage Trailer B"}, //bagboxb
	{"Stair Trailer"}, //tugstair
	{"Boxville"},
	{"Farm Plow"}, //farmtr1
	{"Utility Trailer"} //utiltr1
};

#define COLOR_SET               2
#if COLOR_SET == 1
#define COLOR_SYSTEM 			0xF0E288AA
#define COLOR_SYSTEM_REST   	F0E288
#define COLOR_SYSTEM_FOCUS  	F3EAB2
#elseif COLOR_SET == 2
#define COLOR_SYSTEM 			0x8179fcAA
#define COLOR_SYSTEM_REST   	8179fc
#define COLOR_SYSTEM_FOCUS  	ffffff
#endif

//#define GetHisSubTeam(%1)           ( Player[%1][Team] == TEAM_A ? TEAM_A_SUB : Player[%1][Team] == TEAM_B ? TEAM_B_SUB : 0 )

#define TXT_BASE_ATT 				"* Your team is attacking in this round, reach and capture the CP or kill the whole opponent team."
#define TXT_BASE_DEF 				"* Your team is defending in this round, your job is to defend the checkpoint or kill the whole opponent team."
#define TXT_INT      				"* This is an interior base, kill the opponent team, if time will expire the team with higher health will win."
#define TXT_ARENA    				"* Kill the whole opponent team to win the round."
#define TXT_TDM_P1      			"* Kill"
#define TXT_TDM_P2      			" opponent players before the opponent does it to win."
#define TXT_MASSACRE 				"* This is the Massacre! Kill everyone!"
#define TXT_GUNGAME  				"* This is the GunGame! Reach the maximum level by killing as many players as you can to win."
#define TXT_FIGHT                   "* Kill your opponents!"
#define TXT_FALLOUT                 "* Resist as much as you can!"
#define TXT_LASTBULLET              "* Beta"

//#define CONN_REMOTE         		false   // Non invia le informazioni al server remoto
//#define REMOTE_BASE_URL     		"_" // senza / finale //  - sigmaseven.gel-gaming.co.uk/remote

#define TXT_WELCOME_LABEL 			"{"#COLOR_SYSTEM_FOCUS"}Welcome to {"#COLOR_SYSTEM_REST"}"#GAMEMODE_NAME#"\n{"#COLOR_SYSTEM_FOCUS"}Use {"#COLOR_SYSTEM_REST"}/vote{"#COLOR_SYSTEM_FOCUS"} or {"#COLOR_SYSTEM_REST"}/ready{"#COLOR_SYSTEM_FOCUS"} to play a round.\n{"#COLOR_SYSTEM_REST"}/cmds{"#COLOR_SYSTEM_FOCUS"} for more commands and {"#COLOR_SYSTEM_REST"}/credits{"#COLOR_SYSTEM_FOCUS"} to know who made this gamemode!"
#define DRAWDISTANCE_WELCOMELABEL   60.0

#define BUON_NATALE                 false

#define MAX_RANDOM_SPAWN            10
#define RANDOM_SPAWN_ROUND          5

#define MAX_DMS       				19 // e' veramente buono crearlo cosi?

#include 							<	a_samp				>
#include <YSI\y_dialog>
#include <YSI\y_inline>


//#include                            <   a_http              >

#undef 					  			MAX_PLAYERS
#define 				  			MAX_PLAYERS 	20
#define                             GAMEMODE_ID_ARR MAX_PLAYERS

//#include 							<	YSI\y_zonepulse		>
#include                            <	YSI\y_bintree		>
#include                            <   YSI\y_timers       	>
#include 							<	foreach				>
#include 							<	sscanf2				>
#define ENABLE_DEBUGGING 			true
#include                            <	a_mysql				>// blueg
#include                            <   YSI\y_ini           >
//#include                            <   YSI\y_stringhash    >
//#include                            <   sqlitei         	>
#include                            <   streamer            >

#define mysql_function_query(%0,%1,%2,%3,"%4"%5) mysql_tquery(%0,%1,%3,#%4%5)


//mysqlStatus
/*
#define mysql_function_queryex(%1,%2,%3,%4,%5,%6) \
    MySQLStatus[TotalQuerys] ++;\
	mysql_function_query(%1, %2, %3, %4, %5, %6);

#define mysql_function_query mysql_function_queryex
*/
//#define MAILER_URL                  "s7domina.gel-gaming.co.uk/mailer.php"

//#include                            <	mailer				>
#include 							<	zcmd				>
#include 							<	geolocation			>

#define STRLIB_RETURN_SIZE          256// mysql querys

#include 							<	strlib				>
#define _sampac_PLUGINS  			1
#include 							<	sampac_api			>
#define GANGZONE_COLORAZIONE 		(Gaming == GAMETYPE_BASE ? (TeamRole[TEAM_A] == DEFENDERS ? iTeam[TEAM_A][InGameColor] : iTeam[TEAM_B][InGameColor]) : 0xff000044)
//#define COLOR_GANGZONE_NOCAPTURE    (X11_GREEN) // fade: team che lo nn possiede to team che lo ha
												//(TeamRole[TEAM_A] == DEFENDERS ? iTeam[TEAM_A][InGameColor] : iTeam[TEAM_B][InGameColor])
//#define COLOR_GANGZONE_CAPTURE      (X11_RED)  // (TeamRole[TEAM_A] == ATTACKERS ? iTeam[TEAM_A][InGameColor] : iTeam[TEAM_B][InGameColor])

#define COLOR_GANGZONE_NOCAPTURE    (TeamRole[TEAM_A] == DEFENDERS ? iTeam[TEAM_A][InGameColor] : iTeam[TEAM_B][InGameColor])
#define COLOR_GANGZONE_CAPTURE      (TeamRole[TEAM_A] == ATTACKERS ? iTeam[TEAM_A][InGameColor] : iTeam[TEAM_B][InGameColor])

#define GAMEMODE_SERVER_1           1
#define GAMEMODE_SERVER_2           0

//#define G_ID                        GAMEMODE_MAINSERVER

new G_ID = 0; // g_id indica il server in cui sta girando la gamemode

#define MAX_MULTI_HITS      		5
#define COLLISION_ID 				MAX_PLAYERS + 1

enum ePlayer
{
		    Kills,
		    Deaths,
		    Damage,
		    RKills,
		    RDeaths,
		    RDamage,
		    GKills,
		    GDeaths,
		    Team,
       bool:Spawned,
	   	    InGame,
		    Nickname[MAX_PLAYER_NAME],
		    Nickname_WOTag[MAX_PLAYER_NAME],
		    Weaponset,
		    InDm,
		    Skin,
		    EditorBone,
		    EditorIndex,
		    Password[129],

		    Timer:Timer_ObjArmour,
		    Timer:Timer_ObjHealth,

		    HeadObj_Armour,
		    HeadObj_Health,

			// 0 VERDE
			TD0_ID                  [MAX_MULTI_HITS],                           // INVALID_PLAYER_ID IF NOT ASSIGNED YET <-> COLLISION_ID IF COLLISION
			TD0_WEAP                [MAX_MULTI_HITS],
			TD0_DMG              [MAX_MULTI_HITS],
			TD0_HEALTH              [MAX_MULTI_HITS],
      Timer:TD0_TIMER               [MAX_MULTI_HITS],

			// 1 ROSSO
			TD1_ID                  [MAX_MULTI_HITS],                           // INVALID_PLAYER_ID IF NOT ASSIGNED YET <-> COLLISION_ID IF COLLISION
			TD1_WEAP                [MAX_MULTI_HITS],
			TD1_DMG              [MAX_MULTI_HITS],
			TD1_HEALTH              [MAX_MULTI_HITS],
      Timer:TD1_TIMER               [MAX_MULTI_HITS],

      //Timer:HideTextdraw_1,
      //Timer:HideTextdraw_0,

		    //xcH
   //   Timer:Hide_Textdraw0,
	 // Timer:Hide_Textdraw1,
		    fAmount,
	        LastWritten[ 128 ],
	   bool:Muted,
	        LastFPS,
	   bool:IsAfk,
	        AfkStart,
	  Float:Pos_Afk[4],
	        Afk_Interior,
	        AfkColor,
		    RconFails,
	//	    Head_Object,
    //  Timer:Timer_ObjectHide,
//	        pHealth,
//	        pArmour,
	        LastHP,
	        LastArmour,
//	 	    LowHP_SoundTimer,
//	   bool:MusicClass,
//	   bool:InLastHP,
     Text3D:Label_PlInfo,
       bool:RadioStream,
	        Last_Tick,
	  Text3D:AfkLabel,
        bool:AfkLabelCreated,
	   		 AfkSeat,
		   	 AfkVeh,
		   	 AfkVW,
			 aLevel,
	    bool:Connected,
	  	bool:tmpLevel,
 FINALSTATUS:FinalRound_Status,
//        	 Label_Timer,
 	    bool:AccountExist,
			 Save_Password[129],
		bool:Loggen,
			 GunGameWins,
			 Serial[ 50 ],
			 tmp_serial[ 50 ], //
			 Weapons[ 13 ],
	   Float:MySpawn[ 4 ],
			 MyInt,
	   Float:AngoloFinal,
	    bool:Voted,
		bool:nVoted,
			 lastSpawnedVeh,
		bool:AllowDM[MAX_DMS],
			 LastCMDTime,
			 DDamage,
			 DKills,
			 CurrentView,
		bool:fInWaiting,
		bool:ConnectedNow,
			 PlayerScorer_Score,
		bool:InRestoring,
			 WhoIs_uIp[16],
			 WhoIs_Country [158],
			 WhoIs_Isp[60],//due to bug, name has been changed to something similar
			 WhoIs_City[40],
			 PlayerTotalPoints,
			 pMatchID,// L'id assegnato che riguarda PlayerMatch
	    bool:SkinSelection, // true se il player deve scegliere la skin
	    bool:fake_selection,
}

#define MAX_SAVE_SLOTS                                                  		50 // 50? too big for me, anyway this is a testing feature so i try 50
enum savedPlayer
{
		  	sNickname[24],
		  	sNickname_WOTag[24],
      Float:sHealth,
      Float:sArmour,
		  	sTeam,
		  	sKills,
		  	sDeaths,
		  	sDamage,
		  	sRKills,
			sRDeaths,
			sRDamage,
	  Float:sPos[5],
       		sPlayed,
       bool:sAssigned,
}
new SavedPlayer [MAX_SAVE_SLOTS][savedPlayer];

/*
#define MAX_MATCH_IDS		                      								30
enum pMatch_Data
{
	mKills, //
	mDeaths, //
	mDamage, //

	mRKills, //
	mRDeaths, //
	mRDamage, //

	mNickname [24], //

	mTeam, //

	bool:mConnected,    //           											// Indica se il player che corrisponde a questo id è connesso al srv
	bool:Played,        //                                                     // Indica se il player ha giocato il round che è appena terminato

	Assigned,
}
*/
//new Player[MAX_PLAYERS][ePlayer];
new Player[MAX_PLAYERS + 3][ePlayer];
//new PlayerMatch [MAX_MATCH_IDS][pMatch_Data];

////////////////////////////////////////////////////////////////////////////////
//==============================================================================
////////////////////////////////////////////////////////////////////////////////
//spec vars
new InSpec[MAX_PLAYERS]={-1, ...};
//#include <timerfix>

/*
	MySQL info e data
*/

enum// multi thread - changed
{
	THREAD_VALIDACC,
	THREAD_CREATEACC,
	THREAD_PLAYERLOGIN,
	THREAD_CONNECTING,
	THREAD_ACCOUNTUPDATE,
}

new g_MySQLConnection;


// =================================================================================
enum e_mysql_status//to be improved
{
    TotalQuerys,
}

new MySQLStatus[e_mysql_status];
//MySQLSttus[TotalQuerys] ++;
//===================================================================================
//===================================================================================
//===================================================================================
//===================================================================================
//===================================================================================
enum apObjects
{
		  ao_model,
		  ao_bone,

	Float:ao_x,
	Float:ao_y,
	Float:ao_z,

	Float:ao_rx,
	Float:ao_ry,
	Float:ao_rz,

	Float:ao_sx,
	Float:ao_sy,
	Float:ao_sz
}
new pSkinAttachObject[MAX_PLAYERS][MAX_PLAYER_ATTACHED_OBJECTS][apObjects];

//new pClassid[MAX_PLAYERS];
new Text:Classtd_SpawnTN[9];
new FirstCreated[MAX_PLAYERS];

////////////////////////////////////////////////////////////////////////////////
//==============================================================================
////////////////////////////////////////////////////////////////////////////////

// x.x.x.sin DEVE AGGIORNARE AD OGNI UPLOAD
#define GAMEMODE_NAME        					"SlaughterField v5.0" // non piï¿½ solo game version ma con nome gm + eventuale subname
#define MAX_TEAM_NAME                           15
//#define DELAY_NAMETAGS                          1000
#define DELAY_REFRESHICONS                      3000
#define DELAY_CHECKPLAYERS                      150
#define VOTE_VOTETIME                           60000
#define DEBUG                                   false
#define MAX_VOTAZIONI 							30
#define GAMEMODE_DEBUG                          true
//#define PVP_ARENA                               16

/*// Gamemode special state
#define PROFILER_RUNNING                        1
#define DEBUG_RUNNING                           2
#define NORMAL_STATE                            0
#define GAMEMODE_SPECIAL_STATE                  NORMAL_STATE*/
//#define GAMEMODE_PROFILER_ENABLED               false
////////////////////////////////////////////////////////////////////////////////
//==============================================================================
////////////////////////////////////////////////////////////////////////////////
native IsValidVehicle(vehicleid);
native gpci(playerid,const serial[], maxlen);
native WP_Hash(buffer[], len, const str[]);
#define randex(%1, %2) 							random(%2-%1)+(%1)
// -----------------------------------------------------------------------------
#undef  INVALID_TEXT_DRAW
#define INVALID_TEXT_DRAW 						Text:(0xFFFF)
/*#define SOUND_CEILING_VENT_LAND 				1002
#define SOUND_BONNET_DENT 						1009
#define SOUND_WHEEL_OF_FORTUNE_CLACKER 			1027
#define SOUND_SHUTTER_DOOR_START 				1035
#define SOUND_SHUTTER_DOOR_STOP 				1036
#define SOUND_PARACHUTE_OPEN 					1039
#define SOUND_AMMUNATION_BUY_WEAPON 			1052
#define SOUND_AMMUNATION_BUY_WEAPON_DENIED 		1053
#define SOUND_SHOP_BUY 							1054
#define SOUND_SHOP_BUY_DENIED 					1055
#define SOUND_RACE_321 							1056
#define SOUND_RACE_GO 							1057
#define SOUND_PART_MISSION_COMPLETE 			1058
#define SOUND_GOGO_TRACK_START 					1062 // -music
#define SOUND_GOGO_TRACK_STOP 					1063 //-music
#define SOUND_DUAL_TRACK_START 					1068 // -music
#define SOUND_DUAL_TRACK_STOP 					1069 // -music
#define SOUND_BEE_TRACK_START 					1076 //  -music
#define SOUND_BEE_TRACK_STOP 					1077 // -music
#define SOUND_ROULETTE_ADD_CASH 				1083
#define SOUND_ROULETTE_REMOVE_CASH 				1084
#define SOUND_ROULETTE_NO_CASH 					1085
#define SOUND_AWARD_TRACK_START 				1097 // -music
#define SOUND_AWARD_TRACK_STOP 					1098 // -music
#define SOUND_PUNCH_PED 						1130
#define SOUND_AMMUNATION_GUN_COLLISION 			1131
#define SOUND_CAMERA_SHOT 						1132
#define SOUND_BUY_CAR_MOD 						1133
#define SOUND_BUY_CAR_RESPRAY 					1134
#define SOUND_BASEBALL_BAT_HIT_PED 				1135
#define SOUND_STAMP_PED 						1136
#define SOUND_CHECKPOINT_AMBER 					1137
#define SOUND_CHECKPOINT_GREEN 					1138
#define SOUND_CHECKPOINT_RED 					1139
#define SOUND_CAR_SMASH_CAR 					1140
#define SOUND_CAR_SMASH_GATE 					1141
#define SOUND_OTB_TRACK_START 					1142
#define SOUND_OTB_TRACK_STOP 					1143
#define SOUND_PED_HIT_WATER_SPLASH				1144
#define SOUND_RESTAURANT_TRAY_COLLISION 		1145
#define SOUND_SWEETS_HORN 						1147
#define SOUND_MAGNET_VEHICLE_COLLISION 			1148
#define SOUND_PROPERTY_PURCHASED 				1149
#define SOUND_PICKUP_STANDARD 					1150
#define SOUND_GARAGE_DOOR_START 				1153
#define SOUND_GARAGE_DOOR_STOP 					1154
#define SOUND_PED_COLLAPSE 						1163
#define SOUND_SHUTTER_DOOR_SLOW_START 			1165
#define SOUND_SHUTTER_DOOR_SLOW_STOP 			1166
#define SOUND_RESTAURANT_CJ_PUKE 				1169
#define SOUND_DRIVING_AWARD_TRACK_START 		1183 // -music
#define SOUND_DRIVING_AWARD_TRACK_STOP 			1184
#define SOUND_BIKE_AWARD_TRACK_START 			1185 // -music
#define SOUND_BIKE_AWARD_TRACK_STOP 			1186
#define SOUND_PILOT_AWARD_TRACK_START 			1187 // -music
#define SOUND_PILOT_AWARD_TRACK_STOP 			1188
*/
// sounds
#define SOUND_WRONGCOMMAND                      30803
#define SOUND_SUCCESS                           30800
#define SOUND_WRONG                             SOUND_WRONGCOMMAND

#define FULLY_READY_STEPS                       11
new FullyReady = 0;

////////////////////////////////////////////////////////////////////////////////
//==============================================================================
////////////////////////////////////////////////////////////////////////////////
//key
#define RELEASED(%0) \
	(((newkeys & (%0)) != (%0)) && ((oldkeys & (%0)) == (%0)))

// gamemodes
enum
{
	GAMEMODE_NORMAL,
	GAMEMODE_ESL,
	GAMEMODE_NOCBUG,
}

////////////////////////////////////////////////////////////////////////////////
//==============================================================================
////////////////////////////////////////////////////////////////////////////////
/*//defs varie
new PlayerColors[200] =// ex all vs all
{
	0xFF8C13FF,0xC715FFFF,0x20B2AAFF,0xDC143CFF,0x6495EDFF,0xf0e68cFF,0x778899FF,0xFF1493FF,0xF4A460FF,
	0xEE82EEFF,0xFFD720FF,0x8b4513FF,0x4949A0FF,0x148b8bFF,0x14ff7fFF,0x556b2fFF,0x0FD9FAFF,0x10DC29FF,
	0x534081FF,0x0495CDFF,0xEF6CE8FF,0xBD34DAFF,0x247C1BFF,0x0C8E5DFF,0x635B03FF,0xCB7ED3FF,0x65ADEBFF,
	0x5C1ACCFF,0xF2F853FF,0x11F891FF,0x7B39AAFF,0x53EB10FF,0x54137DFF,0x275222FF,0xF09F5BFF,0x3D0A4FFF,
	0x22F767FF,0xD63034FF,0x9A6980FF,0xDFB935FF,0x3793FAFF,0x90239DFF,0xE9AB2FFF,0xAF2FF3FF,0x057F94FF,
	0xB98519FF,0x388EEAFF,0x028151FF,0xA55043FF,0x0DE018FF,0x93AB1CFF,0x95BAF0FF,0x369976FF,0x18F71FFF,
	0x4B8987FF,0x491B9EFF,0x829DC7FF,0xBCE635FF,0xCEA6DFFF,0x20D4ADFF,0x2D74FDFF,0x3C1C0DFF,0x12D6D4FF,
	0x48C000FF,0x2A51E2FF,0xE3AC12FF,0xFC42A8FF,0x2FC827FF,0x1A30BFFF,0xB740C2FF,0x42ACF5FF,0x2FD9DEFF,
	0xFAFB71FF,0x05D1CDFF,0xC471BDFF,0x94436EFF,0xC1F7ECFF,0xCE79EEFF,0xBD1EF2FF,0x93B7E4FF,0x3214AAFF,
	0x184D3BFF,0xAE4B99FF,0x7E49D7FF,0x4C436EFF,0xFA24CCFF,0xCE76BEFF,0xA04E0AFF,0x9F945CFF,0xDCDE3DFF,
	0x10C9C5FF,0x70524DFF,0x0BE472FF,0x8A2CD7FF,0x6152C2FF,0xCF72A9FF,0xE59338FF,0xEEDC2DFF,0xD8C762FF,
	0xD8C762FF,0xFF8C13FF,0xC715FFFF,0x20B2AAFF,0xDC143CFF,0x6495EDFF,0xf0e68cFF,0x778899FF,0xFF1493FF,
	0xF4A460FF,0xEE82EEFF,0xFFD720FF,0x8b4513FF,0x4949A0FF,0x148b8bFF,0x14ff7fFF,0x556b2fFF,0x0FD9FAFF,
	0x10DC29FF,0x534081FF,0x0495CDFF,0xEF6CE8FF,0xBD34DAFF,0x247C1BFF,0x0C8E5DFF,0x635B03FF,0xCB7ED3FF,
	0x65ADEBFF,0x5C1ACCFF,0xF2F853FF,0x11F891FF,0x7B39AAFF,0x53EB10FF,0x54137DFF,0x275222FF,0xF09F5BFF,
	0x3D0A4FFF,0x22F767FF,0xD63034FF,0x9A6980FF,0xDFB935FF,0x3793FAFF,0x90239DFF,0xE9AB2FFF,0xAF2FF3FF,
	0x057F94FF,0xB98519FF,0x388EEAFF,0x028151FF,0xA55043FF,0x0DE018FF,0x93AB1CFF,0x95BAF0FF,0x369976FF,
	0x18F71FFF,0x4B8987FF,0x491B9EFF,0x829DC7FF,0xBCE635FF,0xCEA6DFFF,0x20D4ADFF,0x2D74FDFF,0x3C1C0DFF,
	0x12D6D4FF,0x48C000FF,0x2A51E2FF,0xE3AC12FF,0xFC42A8FF,0x2FC827FF,0x1A30BFFF,0xB740C2FF,0x42ACF5FF,
	0x2FD9DEFF,0xFAFB71FF,0x05D1CDFF,0xC471BDFF,0x94436EFF,0xC1F7ECFF,0xCE79EEFF,0xBD1EF2FF,0x93B7E4FF,
	0x3214AAFF,0x184D3BFF,0xAE4B99FF,0x7E49D7FF,0x4C436EFF,0xFA24CCFF,0xCE76BEFF,0xA04E0AFF,0x9F945CFF,
	0xDCDE3DFF,0x10C9C5FF,0x70524DFF,0x0BE472FF,0x8A2CD7FF,0x6152C2FF,0xCF72A9FF,0xE59338FF,0xEEDC2DFF,
	0xD8C762FF,0xD8C762FF
};*/
////////////////////////////////////////////////////////////////////////////////
//==============================================================================
////////////////////////////////////////////////////////////////////////////////
//interiors
enum intinfo
{
    int_interior,
    Float:int_x,
    Float:int_y,
    Float:int_z,
    Float:int_a,
    int_name[40]
}

new const Interiors[][intinfo] =
{
	{0,	  0.0,        0.0,        0.0,           0.0,         " "},
	{5,   770.8033,   -0.7033,    1000.7267,     22.8599,     "Ganton Gym"},
	{3,   974.0177,   -9.5937,    1001.1484,     22.6045,     "Brothel"},
	{3,   961.9308,   -51.9071,   1001.1172,     95.5381,     "Brothel2"},
	{3,   830.6016,   5.9404,     1004.1797,     125.8149,    "Inside Track Betting"},
	{3,   1037.8276,  0.397,      1001.2845,     353.933,     "Blastin' Fools Records"},
	{3,   1212.1489,  -28.5388,   1000.9531,     170.5692,    "The Big Spread Ranch"},
	{18,  1290.4106,  1.9512,     1001.0201,     179.9419,    "Warehouse 1"},
	{1,   1412.1472,  -2.2836,    1000.9241,     114.661,     "Warehouse 2"},
	{3,   1527.0468,  -12.0236,   1002.0971,     350.0013,    "B Dup's Apartment"},
	{0,   2547.1853,  2824.2493,  10.8203,       262.7038,    "KACC Miltary Warehouse"},
	{3,   612.2191,   -123.9028,  997.9922,      266.5704,    "Wheel Arch Angels"},
	{3,   512.9291,   -11.6929,   1001.5653,     198.7669,    "OG Loc's House"},
	{3,   418.4666,   -80.4595,   1001.8047,     343.2358,    "Barber Shop"},
	{3,   386.5259,   173.6381,   1008.3828,     63.7399,     "Planning Department"},
	{3,   288.4723,   170.0647,   1007.1794,     22.0477,     "Las Venturas Police Department"},
	{3,   206.4627,   -137.7076,  1003.0938,     10.9347,     "Pro-Laps"},
	{3,   -100.2674,  -22.9376,   1000.7188,     17.285,      "Sex Shop"},
	{3,   -201.2236,  -43.2465,   1002.2734,     45.8613,     "Las Venturas Tattoo parlor"},
	{17,  -202.9381,  -6.7006,    1002.2734,     204.2693,    "Lost San Fierro Tattoo parlor"},
	{17,  -17.9142,   -173.4321,  1003.5469,     45.1436,     "24/7 (version 1)"},
	{5,   454.9853,   -107.2548,  999.4376,      309.0195,    "Diner 1"},
	{5,   372.5565,   -131.3607,  1001.4922,     354.2285,    "Pizza Stack"},
	{17,  378.026,    -190.5155,  1000.6328,     141.0245,    "Rusty Brown's Donuts"},
	{7,   315.244,    -140.8858,  999.6016,      7.4226,      "Ammu-nation"},
	{5,   225.0306,   -9.1838,    1002.218,      85.5322,     "Victim"},
	{2,   611.3536,   -77.5574,   997.9995,      320.9263,    "Loco Low Co"},
	{10,  246.0688,   108.9703,   1003.2188,     0.2922,      "San Fierro Police Department"},
	{10,  6.0856,     -28.8966,   1003.5494,     5.0365,      "24/7 (version 2 - large)"},
	{7,   773.7318,   -74.6957,   1000.6542,     5.2304,      "Below The Belt Gym (Las Venturas)"},
	{1,   621.4528,   -23.7289,   1000.9219,     15.6789,     "Transfenders"},
	{1,  445.6003,   -6.9823,    1000.7344,     172.2105,     "World of Coq"},
	{1,   285.8361,   -39.0166,   1001.5156,     0.7529,      "Ammu-nation (version 2)"},
	{1,   204.1174,   -46.8047,   1001.8047,     357.5777,    "SubUrban"},
	{1,   245.2307,   304.7632,   999.1484,      273.4364,    "Denise's Bedroom"},
	{3,   290.623,    309.0622,   999.1484,      89.9164,     "Helena's Barn"},
	{5,   322.5014,   303.6906,   999.1484,      8.1747,      "Barbara's Love nest"},
	{1,   -2041.2334, 178.3969,   28.8465,       156.2153,    "San Fierro Garage"},
	{1,   -1402.6613, 106.3897,   1032.2734,     105.1356,    "Oval Stadium"},
	{7,   -1403.0116, -250.4526,  1043.5341,     355.8576,    "8-Track Stadium"},
	{2,   1207.5087,  3.6289,     1000.9219,     214.6596,    "The Pig Pen (strip club 2)"},
	{10,  2016.1156,  1017.1541,  996.875,       88.0055,     "Four Dragons"},
	{1,   -741.8495,  493.0036,   1371.9766,     71.7782,     "Liberty City"},
	{2,   2447.8704,  -1704.4509, 1013.5078,     314.5253,    "Ryder's house"},
	{1,   2527.0176,  -1679.2076, 1015.4986,     260.9709,    "Sweet's House"},
	{10,  -1129.8909, 1057.5424,  1346.4141,     274.5268,    "RC Battlefield"},
	{3,   2496.0549,  -1695.1749, 1014.7422,     179.2174,    "The Johnson House"},
	{10,  366.0248,   -73.3478,   1001.5078,     292.0084,    "Burger shot"},
	{1,   2233.9363,  1711.8038,  1011.6312,     184.3891,    "Caligula's Casino"},
	{2,   269.6405,   305.9512,   999.1484,      215.6625,    "Katie's Lovenest"},
	{2,   414.2987,   -18.8044,   1001.8047,     41.4265,     "Barber Shop 2 (Reece's)"},
	{2,   1.1853,     -3.2387,    999.4284,      87.5718,     "Angel Pine Trailer"},
	{18,  -30.9875,   -89.6806,   1003.5469,     359.8401,    "24/7 (version 3)"},
	{18,  161.4048,   -94.2416,   1001.8047,     0.7938,      "Zip"},
	{3,   -2638.8232, 1407.3395,  906.4609,      94.6794,     "The Pleasure Domes"},
	{5,   1267.8407,  -776.9587,  1091.9063,     231.3418,    "Madd Dogg's Mansion"},
	{2,   2536.5322,  -1294.8425, 1044.125,      254.9548,    "Big Smoke's Crack Palace"},
	{5,   2350.1597,  -1181.0658, 1027.9766,     99.1864,     "Burning Desire Building"},
	{1,   -2158.6731, 642.09,     1052.375,      86.5402,     "Wu-Zi Mu's"},
	{10,  419.8936,   2537.1155,  10.0000,       67.6537,     "Abandoned AC tower"},
	{14,  256.9047,   -41.6537,   1002.0234,     85.8774,     "Wardrobe/Changing room"},
	{14,  204.1658,   -165.7678,  1000.5234,     181.7583,    "Didier Sachs"},
	{12,  1133.35,    -7.8462,    1000.6797,     165.8482,    "Casino (Redsands West)"},
	{14,  -1420.4277, 1616.9221,  1052.5313,     159.1255,    "Kickstart Stadium"},
	{17,  488.4389,   -11.4271,   1000.6797,     130.6844,    "Club"},
	{18,  1727.2853,  -1642.9451, 20.2254,       172.4193,    "Atrium"},
	{16,  -202.842,   -24.0325,   1002.2734,     252.8154,    "Los Santos Tattoo Parlor"},
	{5,   2233.6919,  -1112.8107, 1050.8828,     8.6483,      "Safe House group 1"},
	{6,   1211.2484,  1049.0234,  1050.9410,     170.9341,    "Safe House group 2"},
	{9,   2319.1272,  -1023.9562, 1050.2109,     167.3959,    "Safe House group 3"},
	{10,  2261.0977,  -1137.8833, 1050.6328,     266.88,      "Safe House group 4"},
	{17,  -944.2402,  1886.1536,  5.0051,        179.8548,    "Sherman Dam"},
	{16,  -24.6959,   -130.3763,  1003.5469,     178.9616,    "24/7 (version 4)"},
	{15,  2217.281,   -1150.5349, 1025.7969,     273.7328,    "Jefferson Motel"},
	{1,   1.5491,     23.3183,    1199.5938,     359.9054,    "Jet Interior"},
	{1,   681.6216,   -451.8933,  -25.6172,      166.166,     "The Welcome Pump"},
	{3,   234.6087,   1187.8195,  1080.2578,     349.4844,    "Burglary House X1"},
	{2,   225.5707,   1240.0643,  1082.1406,     96.2852,     "Burglary House X2"},
	{1,   224.288,    1289.1907,  1082.1406,     359.868,     "Burglary House X3"},
	{5,   239.2819,   1114.1991,  1080.9922,     270.2654,    "Burglary House X4"},
	{15,  207.5219,   -109.7448,  1005.1328,     358.62,      "Binco"},
	{15,  295.1391,   1473.3719,  1080.2578,     352.9526,    "4 Burglary houses"},
	{15,  -1417.8927, 932.4482,   1041.5313,     0.7013,      "Blood Bowl Stadium"},
	{12,  446.3247,   509.9662,   1001.4195,     330.5671,    "Budget Inn Motel Room"},
	{0,   2306.3826,  -15.2365,   26.7496,       274.49,      "Palamino Bank"},
	{0,   2331.8984,  6.7816,     26.5032,       100.2357,    "Palamino Diner"},
	{0,   663.0588,   -573.6274,  16.3359,       264.9829,    "Dillimore Gas Station"},
	{18,  -227.5703,  1401.5544,  27.7656,       269.2978,    "Lil' Probe Inn"},
	{0,   -688.1496,  942.0826,   13.6328,       177.6574,    "Torreno's Ranch"},
	{0,   -1916.1268, 714.8617,   46.5625,       152.2839,    "Zombotech - lobby area"},
	{0,   818.7714,   -1102.8689, 25.794,        91.1439,     "Crypt in LS cemetery (temple)"},
	{0,   255.2083,   -59.6753,   1.5703,        1.4645,      "Blueberry Liquor Store"},
	{2,   446.626,    1397.738,   1084.3047,     343.9647,    "Pair of Burglary Houses"},
	{5,   227.3922,   1114.6572,  1080.9985,     267.459,     "Crack Den"},
	{5,   227.7559,   1114.3844,  1080.9922,     266.2624,    "Burglary House X11"},
	{4,   261.1165,   1287.2197,  1080.2578,     178.9149,    "Burglary House X12"},
	{4,   291.7626,   -80.1306,   1001.5156,     290.2195,    "Ammu-nation (version 3)"},
	{4,   449.0172,   -88.9894,   999.5547,      89.6608,     "Jay's Diner"},
	{4,   -27.844,    -26.6737,   1003.5573,     184.3118,    "24/7 (version 5)"},
	{0,   2135.2004,  -2276.2815, 20.6719,       318.59,      "Warehouse 3"},
	{4,   306.1966,   307.819,    1003.3047,     203.1354,    "Michelle's Love Nest*"},
	{10,  24.3769,    1341.1829,  1084.375,      8.3305,      "Burglary House X14"},
	{1,   963.0586,   2159.7563,  1011.0303,     175.313,     "Sindacco Abatoir"},
	{0,   2548.4807,  2823.7429,  10.8203,       270.6003,    "K.A.C.C. Military Fuels Depot"},
	{0,   215.1515,   1874.0579,  13.1406,       177.5538,    "Area 69"},
	{4,   221.6766,   1142.4962,  1082.6094,     184.9618,    "Burglary House X13"},
	{12,  2323.7063,  -1147.6509, 1050.7101,     206.5352,    "Unused Safe House"},
	{6,   344.9984,   307.1824,   999.1557,      193.643,     "Millie's Bedroom"},
	{12,  411.9707,   -51.9217,   1001.8984,     173.3449,    "Barber Shop"},
	{4,   -1421.5618, -663.8262,  1059.5569,     170.9341,    "Dirtbike Stadium"},
	{6,   773.8887,   -47.7698,   1000.5859,     10.7161,     "Cobra Gym"},
	{6,   246.6695,   65.8039,    1003.6406,     7.9562,      "Los Santos Police Department"},
	{14,  -1864.9434, 55.7325,    1055.5276,     85.8541,     "Los Santos Airport"},
	{4,   -262.1759,  1456.6158,  1084.3672,     82.459,      "Burglary House X15"},
	{5,   22.861,     1404.9165,  1084.4297,     349.6158,    "Burglary House X16"},
	{5,   140.3679,   1367.8837,  1083.8621,     349.2372,    "Burglary House X17"},
	{3,   1494.8589,  1306.48,    1093.2953,     196.065,     "Bike School"},
	{14,  -1813.213,  -58.012,    1058.9641,     335.3199,    "Francis International Airport"},
	{16,  -1401.067,  1265.3706,  1039.8672,     178.6483,    "Vice Stadium"},
	{6,   234.2826,   1065.229,   1084.2101,     4.3864,      "Burglary House X18"},
	{6,   -68.5145,   1353.8485,  1080.2109,     3.5742,      "Burglary House X19"},
	{6,   -2240.1028, 136.973,    1035.4141,     269.0954,    "Zero's RC Shop"},
	{6,   297.144,    -109.8702,  1001.5156,     20.2254,     "Ammu-nation (version 4)"},
	{6,   316.5025,   -167.6272,  999.5938,      10.3031,     "Ammu-nation (version 5)"},
	{15,  -285.2511,  1471.197,   1084.375,      85.6547,     "Burglary House X20"},
	{6,   -26.8339,   -55.5846,   1003.5469,     3.9528,      "24/7 (version 6)"},
	{6,   442.1295,   -52.4782,   999.7167,      177.9394,    "Secret Valley Diner"},
	{2,   2182.2017,  1628.5848,  1043.8723,     224.8601,    "Rosenberg's Office in Caligulas"},
	{6,   748.4623,   1438.2378,  1102.9531,     0.6069,      "Fanny Batter's Whore House"},
	{8,   2807.3604,  -1171.7048, 1025.5703,     193.7117,    "Colonel Furhberger's"},
	{9,   366.0002,   -9.4338,    1001.8516,     160.528,     "Cluckin' Bell"},
	{1,   2216.1282,  -1076.3052, 1050.4844,     86.428,      "The Camel's Toe Safehouse"},
	{1,   2268.5156,  1647.7682,  1084.2344,     99.7331,     "Caligula's Roof"},
	{2,   2236.6997,  -1078.9478, 1049.0234,     2.5706,      "Old Venturas Strip Casino"},
	{3,   -2031.1196, -115.8287,  1035.1719,     190.1877,    "Driving School"},
	{8,   2365.1089,  -1133.0795, 1050.875,      177.3947,    "Verdant Bluffs Safehouse"},
	{0,   1168.512,   1360.1145,  10.9293,       196.5933,    "Bike School"},
	{9,   315.4544,   976.5972,   1960.8511,     359.6368,    "Andromada"},
	{10,  1893.0731,  1017.8958,  31.8828,       86.1044,     "Four Dragons' Janitor's Office"},
	{11,  501.9578,   -70.5648,   998.7578,      171.5706,    "Bar"},
	{8,   -42.5267,   1408.23,    1084.4297,     172.068,     "Burglary House X21"},
	{11,  2283.3118,  1139.307,   1050.8984,     19.7032,     "Willowfield Safehouse"},
	{9,   84.9244,    1324.2983,  1083.8594,     159.5582,    "Burglary House X22"},
	{9,   260.7421,   1238.2261,  1084.2578,     84.3084,     "Burglary House X23"},
	{0,   -1658.1656, 1215.0002,  7.25,          103.9074,    "Otto's Autos"},
	{0,   -1961.6281, 295.2378,   35.4688,       264.4891,    "Wang Cars"},
	{11,  2003.1178,  1015.1948,  33.008,        351.5789,    "Four Dragons' Managerial Suite"},
	{0,   1087.5002,  2092.8938,  15.3504,		  92.5994,    "Mafia Chip Making Factory"},
	{1,   -794.806396, 497.738037, 1376.195312,   0.0    ,    "Liberty city inside"},
	{1,   452.489990, -18.179698, 1001.132812,    0.0    ,    "World of coqe"}
};


////////////////////////////////////////////////////////////////////////////////
//==============================================================================
////////////////////////////////////////////////////////////////////////////////
//weapons
new const aWeaponNames[][20] =
{
	{"Punch"},
	{"Brass Knuckles"},
	{"Golf Club"},
	{"Night Stick"},
	{"Knife"},
	{"Bat"},
	{"Shovel"},
	{"Pool Cue"},
	{"Katana"},
	{"Chainsaw"},
	{"Dildo"},
	{"Vibrator1"},
	{"Vibrator2"},
	{"Vibrator3"},
	{"Flowers"},
	{"Cane"},
	{"Grenade"},
	{"Tear Gas"},
	{"Molotov"},
	{"N/A"},//19
	{"N/A"},//20
	{"N/A"},//21
	{"Pistol"},
	{"Silencer"},
	{"Deagle"},
	{"Shotgun"},
	{"Sawnoff"},
	{"Spas12"},
	{"Mac-10"},
	{"Mp5"},
	{"AK-47"},
	{"M4"},
	{"Tec-9"},
	{"Rifle"},
	{"Sniper"},
	{"RPG"},
	{"HeatSeeker"},
	{"Flamethrower"},
	{"Minigun"},
	{"Satchel"},
	{"Detonator"},
	{"Spraycan"},
	{"Extinguisher"},
	{"Camera"},
	{"Nightvision"},
	{"Infrared"},
	{"Parachute"},
	{"N/A"},//47
	{"N/A"},//48
	{"Vehicle Collision"},//49
	{"HeliKill"},//50
	{"Explosion"},//51
	{"N/A"},//52
	{"N/A"},//53
	{"Long Fall"}//54
};

////////////////////////////////////////////////////////////////////////////////
//==============================================================================
////////////////////////////////////////////////////////////////////////////////
//colors

#define COLOR_JOIN 				0x61B000AA
#define COLOR_LEFT 				0xD60019AA
#define COLOR_GREY 				0xAFAFAFAA //grigio
#define COLOR_GREEN 			0x33AA33AA //verde
#define COLOR_YELLOW 			0xFFFF00AA //giallo
#define COLOR_PINK 				0xFF66FFAA //rosa
#define COLOR_BLUE 				0x0000BBAA //blu
#define COLOR_ORANGE 			0xFF9900AA //arancione
#define COLOR_PURPLE 			0x990099AA //viola
#define COLOR_BROWN 			0x663300AA //marrone
#define COLOR_DARKRED 			0x660000AA //rosso scuro
#define COLOR_DARKBLUE 			0x000066AA //blu scuro
#define COLOR_WHITE 			0xFFFFFFAA
#define TD_NERO 				0x00000066
#define WINNER_ROSSO 			0xD0000044
#define WINNER_GREEN 			0x14AE0044
#define COLORE_RICERCATO		0xFF00FFAA

#define yellow	 				0xFFFF00AA
#define green 					0x33FF33AA
#define red 					0xFF0000AA
#define white 					0xFFFFFFAA
#define pink 					0xCCFF00FF
#define blue 					0x00FFFFAA
#define grey 					0xC0C0C0AA

#define COLOR_RED				0xFF0000AA //rosso
#define COLOR_LIGHTBLUE 		0x33CCFFAA //azzurro

#define COLORE_SCRITTE  FFFFFF
#define COLORE_SEZIONE  E7CECE

#define COLORE_ENABLED  00FF04
#define COLORE_DISABLED FF0000

#define SEZIONE_TEAMA   357ADC
#define SEZIONE_TEAMB   5FE038

#define COLOR_DM                0xb52727AA


////////////////////////////////////////////////////////////////////////////////
new stringo[128];

////////////////////////////////////////////////////////////////////////////////
//==============================================================================
////////////////////////////////////////////////////////////////////////////////
//worlds
#define GAME_WORLD      100
#define GUNGAME_WORLD   25
//#define WORLD_DM        15//removed
#define NORMAL_WORLD    0
#define MIN_GM_WORLD    150

////////////////////////////////////////////////////////////////////////////////
//==============================================================================
////////////////////////////////////////////////////////////////////////////////
//new kick/ban td stuff
new bool:__kick_handled[MAX_PLAYERS];
// ahaha, in questi momenti ti manca l'overload delle funzioni
// report_health will take care of get player health and report it
/*
native _Kick(playerid, kicker, reason[], stuff[] = '\0')
*/
stock _Kick(playerid, kicker, reason[], stuff[] = '\0')
{
	// If kicker is GAMEMODE_ID_ARR
	// The message will be something like:
	// {name} has been kicked for {reason} ({stuff})
	// Example:
	// revo has been kicked for Low FPS (15 / 20)
	// revo has been kicked for Invalid file (vorbisfile.dll)
	//  "    "   "     "    "     "      "        "            (50 // 30)

	// If kicker is a valid player
	// The message will be something like:
	// {name} has been kicked by {name} ({reason})
	// stuff will be empty, and ignored.

	if (kicker == GAMEMODE_ID_ARR)
	{
	    // kicker is ignored

	    if (stuff[0] != '\0')
	    {
	    	format (stringo, sizeof stringo, "%s has been kicked for %s (%s)", Player[playerid][Nickname], reason, stuff);
		}
		else
		{
		    format (stringo, sizeof stringo, "%s has been kicked for %s", Player[playerid][Nickname], reason);
		}
	}
	else
	{
	    // kicker is a valid player

	    if (stuff[0] != '\0')
	    {
			format (stringo, sizeof stringo, "%s has been kicked by %s (%s) (%s)", Player[playerid][Nickname], Player[kicker][Nickname], reason, stuff);
		}
		else
		{
		    format (stringo, sizeof stringo, "%s has been kicked by %s (%s)", Player[playerid][Nickname], Player[kicker][Nickname], reason);
		}
	}

	// If the player was in game, the health will be added in the message.
	if (Player[playerid][InGame])
	{
	    // get player health
		new Float:h, Float:a;

	 	GetPlayerHealth(playerid, h);
		GetPlayerArmour(playerid, a);

	    format (stringo, sizeof stringo, "%s (%d // %d)", stringo, floatround (h), floatround (a));
	}

	SendClientMessageToAll (COLOR_GREY, stringo);
//	SendClientMessage (playerid, -1, "now u are kicked ihi");
	defer _RKick(playerid); // The player will be kicked after 5 ms.
	__kick_handled[playerid] = true; // the kick-message is already handled
	return true;
}

stock _Ban(playerid, banner, reason[], stuff[] = '\0', bool:newban = false, bantype = 0)
{
	// If kicker is GAMEMODE_ID_ARR
	// The message will be something like:
	// {name} has been banned for {reason} ({stuff})
	// Example:
	// revo has been banned for Low FPS (15 / 20)
	// revo has been banned for Invalid file (vorbisfile.dll)
	//  "    "   "     "    "     "      "        "            (50 // 30)

	// If kicker is a valid player
	// The message will be something like:
	// {name} has been banned by {name} ({reason})
	// stuff will be empty, and ignored.

	if (banner == GAMEMODE_ID_ARR)
	{
	    // kicker is ignored

	    if (stuff[0] != '\0')
	    {
	    	format (stringo, sizeof stringo, "%s has been banned for %s (%s)", Player[playerid][Nickname], reason, stuff);
		}
		else
		{
		    format (stringo, sizeof stringo, "%s has been banned for %s", Player[playerid][Nickname], reason);
		}
	}
	else
	{
	    // kicker is a valid player

	    if (stuff[0] != '\0')
	    {
			format (stringo, sizeof stringo, "%s has been banned by %s (%s) (%s)", Player[playerid][Nickname], Player[banner][Nickname], reason, stuff);
		}
		else
		{
		    format (stringo, sizeof stringo, "%s has been banned by %s (%s)", Player[playerid][Nickname], Player[banner][Nickname], reason);
		}
	}

	// If the player was in game, the health will be added in the message.
	if (Player[playerid][InGame])
	{
	    // get player health
		new Float:h, Float:a;

	 	GetPlayerHealth(playerid, h);
		GetPlayerArmour(playerid, a);

	    format (stringo, sizeof stringo, "%s (%d // %d)", stringo, h, a);
	}

	if (newban)
	{
		new
		    ip [16];
		GetPlayerIp (playerid, ip, 16);

        MySQLStatus[TotalQuerys] ++;
		mysql_tquery (g_MySQLConnection, sprintf("INSERT INTO bans (time, nickname, serial, ip, bantype, reason, adminban) VALUES ('%d', '%s', '%s', '%s', '%d', '%s', '%s')",
		    gettime(), Player[playerid][Nickname], Player[playerid][Serial], ip, bantype, reason, Player[banner][Nickname]), "", "");
	}

	SendClientMessageToAll (-1, stringo);
//	SendClientMessage (playerid, -1, "now u are banned ihi");
	defer _RBan(playerid); // The player will be banned after 5 ms.
	__kick_handled[playerid] = true; // used in ban too.
	return true;
}

// 900 ms
timer _RKick[900](playerid) {
	return Kick (playerid);
}

timer _RBan[900](playerid) {
	return Ban (playerid);
}
////////////////////////////////////////////////////////////////////////////////
//==============================================================================
////////////////////////////////////////////////////////////////////////////////
//kick/ban td stuff

new Text:BlackScreen;
/*
stock KickEx(playerid, reason[], kicker[] = "")
{// nascondere i textdraw -  non lo fa?
	TextDrawShowForPlayer(playerid, BlackScreen);
	ShowPlayerDialog(playerid, 0, DIALOG_STYLE_MSGBOX, "Kicked!", sprintf("Kicked! Admin: %s Reason: %s", kicker, reason), "Close", "");

	defer _RKick(playerid);
	//SetTimerEx("_RKick", 5, false, "i", playerid);
	return 1;
}



//forward _RKick(playerid);
//public _RKick(playerid) return Kick (playerid);

#define Kick KickEx
*/
/*stock BanExEx(playerid, nonewban = 0, bantype = 0, reason[] = "", bannerid = INVALID_PLAYER_ID)
{// come sopra
	if (!nonewban)
	{
		new
		    ip [16];
		GetPlayerIp (playerid, ip, 16);

		mysql_function_query (g_MySQLConnection, sprintf("INSERT INTO bans (time, nickname, serial, ip, bantype, reason, adminban) VALUES ('%d', '%s', '%s', '%s', '%d', '%s', '%s')",
		    0, Player[playerid][Nickname], Player[playerid][Serial], ip, bantype, reason), false, "", "");
	}

	TextDrawShowForPlayer(playerid, BlackScreen);
	ShowPlayerDialog(playerid, 0, DIALOG_STYLE_MSGBOX, "Banned!", sprintf("You are banned! Reason: %s", reason), "Close", "");
	return Ban(playerid);
}


stock BanExEx(playerid, bool:newban = false, bantype = 0, reason[] = "", banner[] = "")
{
	if (newban)
	{
		new
		    ip [16];
		GetPlayerIp (playerid, ip, 16);

        MySQLStatus[TotalQuerys] ++;
		mysql_tquery (g_MySQLConnection, sprintf("INSERT INTO bans (time, nickname, serial, ip, bantype, reason, adminban) VALUES ('%d', '%s', '%s', '%s', '%d', '%s', '%s')",
		    0, Player[playerid][Nickname], Player[playerid][Serial], ip, bantype, reason, banner), "", "");
	}

	TextDrawShowForPlayer(playerid, BlackScreen);
	ShowPlayerDialog(playerid, 0, DIALOG_STYLE_MSGBOX, "Banned!", sprintf("You are banned! Admin: %s - Reason: %s", banner, reason), "Close", "");
	return Ban( playerid );
}

#define Ban BanExEx
*/
////////////////////////////////////////////////////////////////////////////////
//==============================================================================
////////////////////////////////////////////////////////////////////////////////
//strings
//#define SendClientMessage(%1,%2,%3,%4);   format(stringo, 128, %3, %4), SendClientMessage(%1, %2, stringo);
//#define SendClientMessageToAll(%1,%2,%3);   format(stringo, 128, %2, %3), SendClientMessageToAll(%1, stringo);
////////////////////////////////////////////////////////////////////////////////
//==============================================================================
////////////////////////////////////////////////////////////////////////////////
//final result
enum FINALSTATUS
{
    FINALROUND_STATUS_HIDDEN,
    FINALROUND_STATUS_FORCED,
    FINALROUND_STATUS_SHOW,
}
////////////////////////////////////////////////////////////////////////////////
//==============================================================================
////////////////////////////////////////////////////////////////////////////////
//config
#define CONFIG_FILE "FeuerFrei/config/config.ini"
new Float:Lobby[4], Lobby_Int;

enum eConfig
{
		 RTime_Mins,
		 TCp,
	     UCp,
	     Matchmode,
		 TDMKills,
	     PMSpec,
		 EPLLimit,
		 Float:PlLimit,
	     EFpsLimit,
		 FpsLimit,
	     EPingLimit,
		 PingLimit,
		 ReadyType,
	bool:LobbyWeapons,
	bool:LobbyVehicles,
	     GameTime,
         GameWeather,
	bool:GlobalChat,
	bool:UseHealthBars,
	bool:AutoAFK,
	bool:AntiCBug,
		 GameMode,
	//bool:SkinSwap,
	bool:AutoAD,
}
new gConfig[eConfig];

enum PDialogs
{
    PDIALOG_TEAMS,
    PDIALOG_GAMECONFIG,
    PDIALOG_USERS,
    PDIALOG_COMMANDS,
    PDIALOG_DEBUG,
}
////////////////////////////////////////////////////////////////////////////////
//==============================================================================
////////////////////////////////////////////////////////////////////////////////
//matchmodes
enum
{
	MATCHMODE_TCWCW,
	MATCHMODE_NOSCORES
}
////////////////////////////////////////////////////////////////////////////////
//==============================================================================
////////////////////////////////////////////////////////////////////////////////
//teams (e subs)
enum
{
    NULL_TEAM,
    TEAM_A,
    TEAM_B,
    TEAM_REF,
    TEAM_A_SUB,
    TEAM_B_SUB
}
#define MAX_TEAMS 6

enum eTeam
{
	InGameColor,
	OutColor,
	Skin,
	Name[ MAX_TEAM_NAME ],
	RoundWins,
	TDMKills,
	tPlayers,
	bool:tLocked,
}

new iTeam[MAX_TEAMS][eTeam];
new TeamPlayers[MAX_TEAMS];
////////////////////////////////////////////////////////////////////////////////
//==============================================================================
////////////////////////////////////////////////////////////////////////////////
//roles
enum
{
	ATTACKERS,
	DEFENDERS,
	REFEREE
}

new TeamRole[MAX_TEAMS];
////////////////////////////////////////////////////////////////////////////////
//==============================================================================
////////////////////////////////////////////////////////////////////////////////
//new deathmatch code
//dm vars
new bool:DMLocked[ MAX_DMS ];// da rifare quando si avrï¿½ tempo
new DMLocked_Password[ MAX_DMS ][ 22 ];
new Player_DmTry[ MAX_PLAYERS ];

enum E_DEATHMATCHS_DATA
{
	DMName[ 40 ],
	Weapon1,
	Weapon2,
	Weapon3,
	Weapon4,
	Float:Spawn[ 4 ],
	Interior,
}

new const Deathmatchs[MAX_DMS][E_DEATHMATCHS_DATA] =
{
	{"Deagle / Shotgun"		, WEAPON_DEAGLE	, WEAPON_SHOTGUN, 0, 	0,				{2616.3699, 839.7945, 5.3158, 122.8318}, 	0},//1
	{"Sniper / Shotgun"		, WEAPON_SNIPER	, WEAPON_SHOTGUN , 0, 	0,				{-2106.2771,-220.1598,35.3203,121.6337}, 	0},//2
	{"Shotgun / Rifle"		, WEAPON_SHOTGUN , WEAPON_RIFLE , 0, 0,					{1930.8993,702.8873,11.1328,180.7386}, 		0},//3
	{"Sawnoff Shotgun"		, 26			, 0  , 0, 				0,				{1877.4349,-1368.2318,14.4807,205.1792},	0},//4
	{"Spas12 / Silenced"	, 27			, 23 , 0, 				0,				{2309.5798,1495.7523,10.8234,209.5436}, 	0},//5
	{"M4 / Shotgun"			, WEAPON_M4		, WEAPON_SHOTGUN , 0, 	0,				{2670.6831,-2003.9937,13.3828,261.6555}, 	0},//6
	{"Deagle / Rifle"		, WEAPON_DEAGLE	, 33 , 0, 				0,				{1626.0079,759.1389,10.8203,213.2804},	 	0},//7
	{"Deagle / M4"			, WEAPON_DEAGLE	, WEAPON_M4 , 0, 0,						{1089.4222,1074.7415,10.8359,318.8365}, 	0},//8
	{"Deagle"				, WEAPON_DEAGLE	, 0 , 0, 		0,						{-1364.7384,1253.6245,1039.8741,99.9718}, 	16},//9
	{"Deagle / Sniper / Shotgun", 24	, WEAPON_SNIPER , WEAPON_SHOTGUN, 0,		{1852.8964,-1706.6625,31.8047,237.9216}, 	0},//10
	{"Spas12 / Rifle"		, 27, 33 , 0, 0,										{-165.7199,-204.3838,1.4219,113.1300}, 		0},//11
	{"Shotgun"				, WEAPON_SHOTGUN, 0 , 0, 0,								{1413.7786,0.4983,1000.9249,116.6078}, 		1},//12
	{"M4 / MP5"				, WEAPON_M4, WEAPON_MP5 , 0, 0,							{1611.7240,-1081.1041,23.9063,332.2506}, 	0},//13
	{"Deagle / Sniper"		, WEAPON_DEAGLE, WEAPON_SNIPER , 0, 0,					{-2085.5242,211.4770,35.2661,129.1061}, 	0},//14
	{"Deagle / Spas12"		, WEAPON_DEAGLE, 27 , 0, 0,								{-1969.1655,666.6987,46.5683,324.9023}, 	0},//15
	{"Sniper"				, WEAPON_SNIPER, 0 , 0, 0,								{-2054.3374,-193.0038,35.3274,85.7901}, 	0},//16
	{"Sawnoff / Tec"		, 26 , 32 , 0, 0,										{1388.1324,2190.1555,11.0234,131.6341}, 	0},//17
	{"M4"					, WEAPON_M4 , 0 , 0, 0,									{1388.5195,2190.6531,11.0234,134.1407}, 	0},//18
	{"Deagle / Spas12 / M4 / Sniper", WEAPON_DEAGLE, 27 , WEAPON_M4, WEAPON_SNIPER,	{-2142.3972,-203.0793,35.3203,134.2581}, 	0}//19
};

////////////////////////////////////////////////////////////////////////////////
//==============================================================================
////////////////////////////////////////////////////////////////////////////////
//gaming
enum
{
	GAMETYPE_NOTHING,
	GAMETYPE_BASE,
	GAMETYPE_ARENA,
	GAMETYPE_TDM,
	GAMETYPE_INTS,//used only in /readytype e random
	GAMETYPE_GUNGAME,
	GAMETYPE_PVP,
	GAMETYPE_FIGHT,
	GAMETYPE_FALLOUT,
	GAMETYPE_LASTBULLET,
}

new RealRMins;
new RealRSecs;
new RealCPTime;
new bool:RoundStarted = false;
new Gaming = GAMETYPE_NOTHING;
new PlayingRound = 0;
new TotalRounds  = 9;
new bool:CamMove = false;
new Timer_SyncTD;
new GamePaused = 0;
new Round_PVPMode = 0;
new bool:Interior_Base = false;
new LastRoundType = GAMETYPE_NOTHING;
new RoundFightType = 0;
new RoundFightWeapon = -1;
#define INVALID_BASE        -1
new bool:FinalCW = false;

// gungame
new Gungame_CurrentLeaderLVL = 0, Gungame_CurrentLeader = INVALID_PLAYER_ID;

////////////////////////////////////////////////////////////////////////////////
//==============================================================================
////////////////////////////////////////////////////////////////////////////////
//textdraws
////////////////////////////////////////////////////////////////////////////////
//==============================================================================
////////////////////////////////////////////////////////////////////////////////
//admin commands system
enum E_ADMIN_LEVELS
{
	lUser,
	lTmp,
	lMod,
	lNbAdmin,
	lAdmin,
	lRoot,
}

stock IsPlayerAdminEx(playerid, E_ADMIN_LEVELS:lvl, bool:message = true, bool:tmp = false)
{
	if (tmp && Player[playerid][tmpLevel])
	    return true;
	else
	{
		if (E_ADMIN_LEVELS:Player[playerid][aLevel] >= lvl)
		    return true;
		else
		{
		    if (message)
		    {
				SendClientMessage(playerid, red, "You must be an admin to use this command.");
			}
		}
	}
	return false;
}

////////////////////////////////////////////////////////////////////////////////
//==============================================================================
////////////////////////////////////////////////////////////////////////////////
//scenario di gioco
#define MAX_MULTIPLE_SPAWNS     20
enum iScenario
{
	Float:SpawnAttackers[3],
	Float:SpawnDefenders[3],
	BaseName[80],
	BaseDescription[80],
	Interior,
	Float:Checkpoint[3],
	FileID,
	Float:MinY,
	Float:MinX,
	Float:MaxX,
	Float:MaxY,
	Played,
}
new eScenario[iScenario];
new Float:Scenario_MultipleSpawns[ MAX_MULTIPLE_SPAWNS ][ 4 ];
////////////////////////////////////////////////////////////////////////////////
//==============================================================================
////////////////////////////////////////////////////////////////////////////////
//Bases packs
enum ePacks_bases
{
	packName[ 40 ],
	maxBases,
	SQLdb[ 15 ],
}

new const basesPacks[][ ePacks_bases ] =
{
	{"Slaughterfield", 141, "slfd"},
	{"ESL", 91, "esl"},
	{"WarGrounds", 193, "wargrounds"},
	{"NoCbug", 95, "nocbug"},
	{"Warhead", 144, "warhead"}
};
new CurrentGamepack = 1;

COMMAND:loadpack(playerid, params[])
{
	if (!IsPlayerAdminEx(playerid, lAdmin)) return true;

	if (isnull(params))
	{
	    SendClientMessage(playerid, COLOR_RED, "Use /loadpack [Slaughterfield, ESL, WarGrounds, NoCbug, Warhead]");
	    PlayerPlaySound(playerid, SOUND_WRONG, 0.0, 0.0, 0.0);
	    return true;
	}

	if (RoundStarted)
	{
	    SendClientMessage(playerid, COLOR_RED, "You cannot use this command now.");
	    PlayerPlaySound(playerid, SOUND_WRONG, 0.0, 0.0, 0.0);
	    return true;
	}

	for (new i = 0; i < sizeof(basesPacks); i++)
	{
	    if (!strcmp(basesPacks[i][packName], params, true))
	    {
	        CurrentGamepack = i;
            PlayerPlaySound(playerid, SOUND_SUCCESS, 0.0, 0.0, 0.0);

            MySQLStatus[TotalQuerys] ++;
			mysql_tquery(g_MySQLConnection, sprintf("SELECT * FROM bases_%s", basesPacks[CurrentGamepack][SQLdb]), "OnPackSwitch", "i", playerid);
	        return true;
	    }
	}

	SendClientMessage(playerid, red, "Unable to find this pack.");
	PlayerPlaySound(playerid, SOUND_WRONG, 0.0, 0.0, 0.0);
	return true;
}

COMMAND:reload(playerid, params[])
{
	if (!IsPlayerAdminEx(playerid, lAdmin)) return true;

	new id;

	if (sscanf(params, "k<reload_pack>", id))
	{
	    SendClientMessage(playerid, COLOR_RED, "Use /reload [arene/gungames/ints/config] (bases use /loadpack)");
	    PlayerPlaySound(playerid, SOUND_WRONG, 0.0, 0.0, 0.0);
	    return true;
	}

	switch (id)
	{
	    case 0:
	    {
	        // arene
	        MySQLStatus[TotalQuerys] ++;
	        mysql_tquery(g_MySQLConnection, "SELECT * FROM arene", "OnLoadArena", "i", playerid);
	    }
	    case 1:
	    {
	        // gungames
			MySQLStatus[TotalQuerys] ++;
	        mysql_tquery(g_MySQLConnection, "SELECT * FROM gungame", "OnLoadGungame", "i", playerid);
	    }
	    case 2:
	    {
	        // ints
	        MySQLStatus[TotalQuerys] ++;
	        mysql_tquery(g_MySQLConnection, "SELECT * FROM bases_interiors", "OnLoadInt", "i", playerid);
	    }
	    case 3:
	    {
	        // fight
	        MySQLStatus[TotalQuerys] ++;
			mysql_tquery(g_MySQLConnection, "SELECT * FROM fight", "OnLoadFight", "i", playerid);
	    }
	    case 4:
	    {
	        // config
	        MySQLStatus[TotalQuerys] ++;
    		mysql_tquery(g_MySQLConnection, sprintf ("SELECT * FROM config WHERE gid = %d", G_ID), "OnConfigLoaded", "i", playerid);
	    }
	    default:
	    {
		    SendClientMessage(playerid, COLOR_RED, "Use /reload [arene/gungames/ints/config] (bases use /loadpack)");
		    PlayerPlaySound(playerid, SOUND_WRONG, 0.0, 0.0, 0.0);
		    return true;
	    }
	}

    SendClientMessage(playerid, COLOR_RED, "Attendi il messaggio di \"Ok\" per startare un round o qualcosa del genere.");
	return true;
}

SSCANF:reload_pack(string[])
{
	if (!strcmp( string , "arene", true )) return 0;
	else if (!strcmp( string , "gungames", true )) return 1;
	else if (!strcmp( string , "ints", true )) return 2;
	else if (!strcmp( string , "fight", true )) return 3;
	else if (!strcmp( string , "config", true )) return 4;
	return -1;
}

////////////////////////////////////////////////////////////////////////////////
//==============================================================================
////////////////////////////////////////////////////////////////////////////////
//gangzones
new ZonaAttornoCP;
////////////////////////////////////////////////////////////////////////////////
//==============================================================================
////////////////////////////////////////////////////////////////////////////////
//playerinfo
new PlayerText:PlayerInfo[3];
////////////////////////////////////////////////////////////////////////////////
//==============================================================================
////////////////////////////////////////////////////////////////////////////////
//dialogs definizioni
enum
{
    DIALOG_NULL,
    DIALOG_PLAYERSLIST,
    DIALOG_GUN,
	DIALOG_SWITCH,
	DIALOG_CONFIG,
	DIALOG_CONFIG_TEAM1SKIN,
	DIALOG_CONFIG_TEAM2SKIN,
	DIALOG_CONFIG_TEAM3SKIN,
	DIALOG_CONFIG_GAMECONFMODULE,
	DIALOG_CONFIG_TEAMMODULE,
	DIALOG_CONFIG_ROUNDTIME,
	DIALOG_CONFIG_CPSECS,
	DIALOG_CONFIG_TEAMNAMEA,
	DIALOG_CONFIG_TEAMNAMEB,
	DIALOG_CONFIG_DISABLEWEAPONSETS,
	DIALOG_CONFIG_TDMKILLS,
	DIALOG_CONFIG_DEBUGMODULE,
	DIALOG_MYSQLSTATUS,
	DIALOG_PLAY_PRIMO,
	DIALOG_PLAY_TEAM1NAME,
	DIALOG_PLAY_TEAM2NAME,
	DIALOG_WEAPONSET,
	DIALOG_WEAPONSETLIMIT,
	DIALOG_CONFIG_SETWEAPLIMIT,
	DIALOG_SHARELIMITWEAPONSET,
	DIALOG_CONFIG_REFSKIN,
	DIALOG_PLAY_SETROUNDS,
	DIALOG_PLAY_ALLVSBALANCE,
	DIALOG_NETSTATS,
	DIALOG_DEATHMATCHLIST,
	DIALOG_VOTE,
	DIALOG_PLAYERLIST,
	DIALOG_CONFIRMVOTE,
	DIALOG_MUSIC,
	DIALOG_SKINMAIN,
	DIALOG_SKINID,
	DIALOG_SKINBONE,
	DIALOG_SKININDEX,
	DIALOG_SKINOBJECTSLIST,
	DIALOG_SLOTOCCUPATO,
	DIALOG_LOGIN,
	DIALOG_REGISTER,
	DIALOG_FIGHTSTYLE,
	DIALOG_VEHICLE,
	DIALOG_COLOR1VEH,
	DIALOG_COLOR2VEH,
	DIALOG_PAINTJOB,
	DIALOG_PINFO,
	DIALOG_AFKLIST,
	DIALOG_INSERTID,
	DIALOG_CONFIG_FPSLIMIT,
	DIALOG_CONFIG_PLLIMIT,
	DIALOG_CONFIG_PINGLIMIT,
    DIALOG_ADMINSLIST,
    DIALOG_ADMINCOMMANDS,
    DIALOG_MANAGEADMINCOMMAND,
    DIALOG_ADMINCOMMAND_SETLEVEL,
    DIALOG_ADMIN_CMDSHOW,
    DIALOG_DEATHMATCHPASSWORD,
    DIALOG_TELEPORTS,
    DIALOG_SERVERSTATS,
    DIALOG_REQSTATS,
    DIALOG_USERSTATS,
    DIALOG_CHANGEPL,
    DIALOG_CHANGEFPS,
    DIALOG_CHANGEPING,
    #if BUON_NATALE == true
    DIALOG_DESIDERI,
    #endif
    DIALOG_SAVETYPE,
    DIALOG_PVPWEAPONS,
	DIALOG_EDITOR_CREA,
	DIALOG_EDITOR_MODIFICA,
	DIALOG_EDITOR_CREATINGMENU,
	DIALOG_EDITOR_SETNAME,
	EDITOR_BASESAVE_PACK,
	DIALOG_EDITOR_SETLIMITS,
	DIALOG_EDITOR_CREATEGGFF,
	DIALOG_EDITOR_ACTION,
	EDITOR_EDIT_CHOSEPACK,
	DIALOG_EDIT_BASEID,
	DIALOG_EDITING_BASE,
	DIALOG_EDITING_BASENAME,
	DIALOG_EDIT_MODARENA,
	DIALOG_EDITING_ARENA,
	DIALOG_EDITING_ARENANAME,
	DIALOG_BASESPACK_SELECT,
	DIALOG_SCEGLI_MATCH,
	/*
	// dialogs bans
	DIALOG_BANSEARCH,
	DIALOG_BANSEARCH_NICKNAME,
	DIALOG_BANSEARCH_IP,
	DIALOG_BANSEARCH_SERIAL,
	DIALOG_PLAYERINFO,//PLAYER-INFO BANS*/
}

//
////////////////////////////////////////////////////////////////////////////////
//==============================================================================
////////////////////////////////////////////////////////////////////////////////
/*//bans - ban search
#define MAX_BANS_RESULTS                30

enum ep_bans_info
{
	Output_Ban [128],

	// BAN DATA FOR MAX (MAX_BANS_RESULTS)
	// maybe not the better way
	// but i dont want to send too many querys to the mysql
	// cuz might lag
	BANNED_id[MAX_BANS_RESULTS],
	BANNED_nickname[MAX_BANS_RESULTS][24],
	BANNED_serial[MAX_BANS_RESULTS][128],
	BANNED_ip[MAX_BANS_RESULTS][16],
	BANNED_bantype[MAX_BANS_RESULTS],
	BANNED_reason[MAX_BANS_RESULTS][128],
	BANNED_adminban[MAX_BANS_RESULTS][24],
    BANNED_banned[MAX_BANS_RESULTS],
    BANNED_unbannick[MAX_BANS_RESULTS][24],
}
new PlayerBansInfo [MAX_PLAYERS][ep_bans_info];
*/

//
////////////////////////////////////////////////////////////////////////////////
//==============================================================================
////////////////////////////////////////////////////////////////////////////////
//weaponsets - NEW SYSTEM

#define MAX_WEAPON_SETS                 12
#define INVALID_WEAPON_SET              MAX_WEAPON_SETS-1
#define MAX_REAL_SELECT_TEAMS           3

enum eGunmenu
{
  		 SetName[ 90 ],
		 ID1,
		 ID2,
	bool:Limited,
		 Limit,
	bool:Enabled,
		 TeamSelection[ MAX_REAL_SELECT_TEAMS ],
		 LimitedForGM,          // = GAMEMODE_NORMAL x averlo attivo SOLO quando si usa la modalitï¿½ GAMEMODE_NORMAL e cosi via // -1 per tutte
		 DisabledForGm,         // = GAMEMODE_NORMAL x disattivarlo SOLO quando la modalitï¿½ GAMEMODE_NORMAL ï¿½ attiva // -1 per tenerlo attivo x tutte (in base alle regole settate in precedenza)
}

new Weaponsets[ ][ eGunmenu ] =
{
	{ "Deagle / Ak47"     , WEAPON_DEAGLE , WEAPON_AK47     , false , 30 , true   , { 0 , 0 , 0 }  , -1 			    , -1				},//0
	{ "Deagle / Rifle"    , WEAPON_DEAGLE , WEAPON_RIFLE    , false , 30 , true   , { 0 , 0 , 0 }  , -1 			    , -1				},//1
	{ "Deagle / Shotgun"  , WEAPON_DEAGLE , WEAPON_SHOTGUN  , false , 30 , true   , { 0 , 0 , 0 }  , -1 			    , -1				},//2

	{ "M4 / Shotgun"      , WEAPON_M4     , WEAPON_SHOTGUN  , false , 30 , true   , { 0 , 0 , 0 }  , -1 	   		    , -1				},//3
	{ "M4 / MP5" 		  , WEAPON_M4     , WEAPON_MP5 	    , false , 30 , true   , { 0 , 0 , 0 }  , -1 			    , -1				},//4

	{ "Shotgun / Rifle"   , WEAPON_SHOTGUN, WEAPON_RIFLE 	, false , 30 , true   , { 0 , 0 , 0 }  , -1 			    , -1				},//5

	{ "Sniper / Shotgun"  , WEAPON_SNIPER , WEAPON_SHOTGUN  , true  , 1 , true   , { 0 , 0 , 0 }  , -1              	, -1                },//6
	{ "Sniper / MP5"  	  , WEAPON_SNIPER , WEAPON_MP5      , true  , 1 , true   , { 0 , 0 , 0 }  , -1              	, -1                },//7

	{ "Spas12 / Silenced" , 27            , WEAPON_SILENCED , true  , 1 , true   , { 0 , 0 , 0 }  , -1              	, GAMEMODE_NOCBUG	},//8
	{ "Spas12 / Rifle"    , 27            , 33 				, true  , 1 , true   , { 0 , 0 , 0 }  , -1              	, GAMEMODE_NOCBUG   },//9

	{ "Deagle / M4"       , WEAPON_DEAGLE , WEAPON_M4       , false , 30 , false  , { 0 , 0 , 0 }  , GAMEMODE_NOCBUG 	, -1 				},//10
	{ "Sniper / Deagle"   , WEAPON_SNIPER , WEAPON_DEAGLE   , true  , 1  , false  , { 0 , 0 , 0 }  , GAMEMODE_NOCBUG 	, -1                },//11

	{ " "    , 0          , 0 				, false  , 1 , false  , { 0 , 0 , 0 }  , -1              					, -1        		}//12
};

new
	wstr[ 1050 ];

stock MostraWeaponset(playerid)
{
/*						format(stringo, sizeof stringo, "»» Team {e55757}%s{"#SC_TEAMA"} won for {e55757}%s{"#SC_TEAMA"} with {e55757}%d{"#SC_TEAMA"} HP remaining. (%d/%d)", iTeam[winner][Name], GetWinTypeString(wintype), hp, PlayingRound, TotalRounds);
                        SendClientMessageToAll(0x0469FFAA, stringo);
					}
					case TEAM_B:
					{
					    // [fixhere]  (fixed)
						format(stringo, sizeof stringo, "»» Team {7b8ef7}%s{"#SC_TEAMB"} won for {7b8ef7}%s{"#SC_TEAMB"} with {7b8ef7}%d{"#SC_TEAMB"} HP remaining. (%d/%d)", iTeam[winner][Name], GetWinTypeString(wintype), hp, PlayingRound, TotalRounds);
                        SendClientMessageToAll(0x43E41EAA, stringo);*/
//	wstr = "";
	new
	    team = Player[playerid][Team]
	;

	// verde: 96E55E
	// rosso: E55E5E
	// grigio (?): B1C27F

	wstr = "{CFE55E}#\tChosen/Availability\t\tWeaponset name\n";
	for (new i = 0; i < MAX_WEAPON_SETS; i++)
	{
	    if (i == INVALID_WEAPON_SET) break;

	    if (Weaponsets[i][DisabledForGm] == gConfig[ GameMode ])
	    {
			format(wstr, sizeof wstr, "%s{E55E5E}%d\tDisabled\t\t\t%s\n", wstr, i, Weaponsets[i][SetName]);
	    }
	    else
	    {
		    if (Weaponsets[i][LimitedForGM] == gConfig[ GameMode ])
		    {
		        // il weaponset ï¿½ disponibile solo sulla modalitï¿½ in corso
		        if (Weaponsets[i][Limited] == true )
		        {
		            if (Weaponsets[i][TeamSelection][team] == Weaponsets[i][Limit])
		            {
		    			if (Player[playerid][Team] == TEAM_A)
					    {
					        // [fixhere]
		            		format(wstr, sizeof wstr, "%s{e55757}%d\t%d/%d\t\t\t\t%s\n", wstr, i, Weaponsets[i][TeamSelection][team], Weaponsets[i][Limit] , Weaponsets[i][SetName]);
						}
						else
						{
						    // [fixhere]
		            		format(wstr, sizeof wstr, "%s{7b8ef7}%d\t%d/%d\t\t\t\t%s\n", wstr, i, Weaponsets[i][TeamSelection][team], Weaponsets[i][Limit] , Weaponsets[i][SetName]);
						}
					}
		            else
		            {
		                if (Player[playerid][Team] == TEAM_A)
		                {
		            		format(wstr, sizeof wstr, "%s{"#SC_TEAMA"}%d\t%d/%d\t\t\t\t%s\n", wstr, i, Weaponsets[i][TeamSelection][team], Weaponsets[i][Limit] , Weaponsets[i][SetName]);
		                }
		                else
		                {
		            		format(wstr, sizeof wstr, "%s{"#SC_TEAMB"}%d\t%d/%d\t\t\t\t%s\n", wstr, i, Weaponsets[i][TeamSelection][team], Weaponsets[i][Limit] , Weaponsets[i][SetName]);
						}
					}
				}
		        else
		        {
		            if (Player[playerid][Team] == TEAM_A)
		            {
			            format(wstr, sizeof wstr, "%s{"#SC_TEAMA"}%d\t%d/%d\t\t\t\t%s\n", wstr, i, Weaponsets[i][TeamSelection][team], MAX_PLAYERS, Weaponsets[i][SetName]);
		            }
		            else
		            {
			            format(wstr, sizeof wstr, "%s{"#SC_TEAMB"}%d\t%d/%d\t\t\t\t%s\n", wstr, i, Weaponsets[i][TeamSelection][team], MAX_PLAYERS, Weaponsets[i][SetName]);
		            }
		        }
		    }
		    else
		    {
		        if (Weaponsets[i][Enabled])
		        {
					if (Weaponsets[i][Limited] == true )
					{
			  			if (Weaponsets[i][TeamSelection][team] == Weaponsets[i][Limit])
						{
						    if (Player[playerid][Team] == TEAM_A)
						    {
						        // [fixhere]
			           			format(wstr, sizeof wstr, "%s{e55757}%d\t%d/%d\t\t\t\t%s\n", wstr, i, Weaponsets[i][TeamSelection][team], Weaponsets[i][Limit] , Weaponsets[i][SetName]);
						    }
						    else
						    {
						        // [fixhere]
					     		format(wstr, sizeof wstr, "%s{7b8ef7}%d\t%d/%d\t\t\t\t%s\n", wstr, i, Weaponsets[i][TeamSelection][team], Weaponsets[i][Limit] , Weaponsets[i][SetName]);
						    }
//			           		format(wstr, sizeof wstr, "%s{B1C27F}%d\t%d/%d\t\t\t\t%s\n", wstr, i, Weaponsets[i][TeamSelection][team], Weaponsets[i][Limit] , Weaponsets[i][SetName]);
			  			}
			  			else
			  			{
			                if (Player[playerid][Team] == TEAM_A)
			                {
			           			format(wstr, sizeof wstr, "%s{"#SC_TEAMA"}%d\t%d/%d\t\t\t\t%s\n", wstr, i, Weaponsets[i][TeamSelection][team], Weaponsets[i][Limit] , Weaponsets[i][SetName]);
							}
							else
							{
								format(wstr, sizeof wstr, "%s{"#SC_TEAMB"}%d\t%d/%d\t\t\t\t%s\n", wstr, i, Weaponsets[i][TeamSelection][team], Weaponsets[i][Limit] , Weaponsets[i][SetName]);
							}
						}
					}
					else
					{
     					if (Player[playerid][Team] == TEAM_A)
          				{
							format(wstr, sizeof wstr, "%s{"#SC_TEAMA"}%d\t%d/%d\t\t\t\t%s\n", wstr, i, Weaponsets[i][TeamSelection][team], MAX_PLAYERS, Weaponsets[i][SetName]);
						}
						else
						{
							format(wstr, sizeof wstr, "%s{"#SC_TEAMB"}%d\t%d/%d\t\t\t\t%s\n", wstr, i, Weaponsets[i][TeamSelection][team], MAX_PLAYERS, Weaponsets[i][SetName]);
						}
					}
				}
				else
				{
				    format(wstr, sizeof wstr, "%s{E55E5E}%d\tDisabled\t\t\t%s\n", wstr, i, Weaponsets[i][SetName]);
				}
			}
		}
	}

	ShowPlayerDialog(playerid, DIALOG_WEAPONSET, DIALOG_STYLE_LIST, "Weaponsets", wstr, "Choose", "");
	return true;
}
////////////////////////////////////////////////////////////////////////////////
//==============================================================================
////////////////////////////////////////////////////////////////////////////////
//sync
new
	Float:Sync_Health[MAX_PLAYERS],
	Float:Sync_Armour[MAX_PLAYERS],
	Sync_Weapons_ID[MAX_PLAYERS][13],
	Sync_Weapons_AMMO[MAX_PLAYERS][13],
	Sync_InCorso[MAX_PLAYERS],
	SyncLocked[MAX_PLAYERS];
////////////////////////////////////////////////////////////////////////////////
//==============================================================================
////////////////////////////////////////////////////////////////////////////////
//wintype
enum
{
    WINTYPE_ELIMINAZIONE,
    WINTYPE_CHECKPOINT,
    WINTYPE_TIME,
    WINTYPE_ENDING,
    WINTYPE_HEALTH,
    WINTYPE_EVERYONEFELL,//fallout
}
////////////////////////////////////////////////////////////////////////////////
//==============================================================================
////////////////////////////////////////////////////////////////////////////////
//map icons
#define MAPICON_ATTACKERSPAWN       0
#define ATTACKERSMAP_ICON           38
#define MAPICON_TYPE_ATTSPAWN       MAPICON_GLOBAL// definisce il tipo in cui la map icon "spawn" deve essere creata
////////////////////////////////////////////////////////////////////////////////
//==============================================================================
////////////////////////////////////////////////////////////////////////////////
//tds
new Text:GeneralTD[2];
/*
#define MAX_FINAL_TD  24
new Text:FinalTD[MAX_FINAL_TD];
new HideFinalTD_Timer;
new bool:FinalRound_TDs = false;
*/
////////////////////////////////////
new PlayerText:TD_Player_Damages[2][5];

new Text:DamageTeamB;
new Text:DamageTeamA;
new TotalTeamDMG[MAX_TEAMS];
new Timer:TeamHitsTimer[MAX_TEAMS] = {Timer:-1, ...};
////////////////////////////////////////////////////////////////////////////////
//==============================================================================
////////////////////////////////////////////////////////////////////////////////
//final cw
new Text:FinalTCWScreen[32];
new bool:FinalShow[ MAX_PLAYERS ];
new bool:FinalReady = false;
////////////////////////////////////////////////////////////////////////////////
//==============================================================================
////////////////////////////////////////////////////////////////////////////////
///ready ststem
#define BASE_NOT_CHOSEN     -1
new bool:PlayerReady[MAX_PLAYERS] = {false, ...};
new MinReadyPlayers = 4;
////////////////////////////////////////////////////////////////////////////////
//==============================================================================
////////////////////////////////////////////////////////////////////////////////
//td players list
new Text:TeamPlayers_TD;

// cp td
new Text:CPTimer;
////////////////////////////////////////////////////////////////////////////////
//==============================================================================
////////////////////////////////////////////////////////////////////////////////
//timeouts / crash
// <!--------------------------- !->> arena vars
new Player_outSecs[MAX_PLAYERS] = {10,...};
new bool:Player_outArena[MAX_PLAYERS] = {false,...};

//list of possibile attached objects
enum eAttachObjects
{
	oModel,
	oName[128],
	cat_name
}

new const lAttachObjects[][eAttachObjects] =
{
	{0,    "Weapons",       1},
	{325 , "Flowers", 0},
	{326 , "Cane", 0},
	{331 , "Brass Knuckles", 0},
	{333 , "Golf Club", 0},
	{334 , "Night Stick", 0},
	{335 , "Combat Knife", 0},
	{336 , "Baseball Bat", 0},
	{337 , "Shovel",  0},
	{338 , "Pool Cue", 0},
	{339 , "Katana", 0},
	{341 , "Chainsaw", 0},
	{342 , "Frag Grenade", 0},
	{343 , "Tear Gas Grenade", 0},
	{344 , "Molotov Cocktail", 0},
	{345 , "Hydra / Hunter Missile", 0},
	{346 , "Colt 45 Pistol", 0},
	{347 , "Silenced Pistol", 0},
	{348 , "Desert Eagle", 0},
	{349 , "Regular Shotgun", 0},
	{350 , "Sawn-Off Shotgun", 0},
	{351 , "Combat Shotgun", 0},
	{352 , "Micro Uzi", 0},
	{353 , "MP5", 0},
	{354 , "Hydra Flare", 0},
	{355 , "AK47 Assault Rifle", 0},
	{356 , "M4 Assault Rifle", 0},
	{357 , "Country Rifle", 0},
	{358 , "Sniper Rifle", 0},
	{359 , "Rocket Launcher", 0},
	{361 , "Flamethrower", 0},
	{362 , "Minigun", 0},
	{363 , "Satchel Charges", 0},
	{364 , "Detonator", 0},
	{365 , "Spray Paint Can", 0},
	{366 , "Fire Extinguisher", 0},
	{367 , "Camera", 0},
	{368 , "Night Vision Goggles", 0},
	{369 , "Infra-Red Goggles", 0},
	{371 , "Parachute", 0},
	{372 , "Tec-9", 0},
	{0,    "Abbigliamento", 1},
	{18921, "Beretto 1", 0},
	{18922, "Beretto 2", 0},
	{18923, "Beretto 3", 0},
	{18924, "Beretto 4", 0},
	{19006, "GlassesType1", 0},
	{19007, "GlassesType2", 0},
	{19008, "GlassesType3", 0},
	{19009, "GlassesType4", 0},
	{19010, "GlassesType5", 0},
	{19011, "GlassesType6", 0},
	{19012, "GlassesType7", 0},
	{19013, "GlassesType8", 0},
	{19014, "GlassesType9", 0},
	{19015, "GlassesType10", 0},
	{19016, "GlassesType11", 0},
	{19017, "GlassesType12", 0},
	{19018, "GlassesType13", 0},
	{19019, "GlassesType14", 0},
	{19020, "GlassesType15", 0},
	{19021, "GlassesType16", 0},
	{19022, "GlassesType17", 0},
	{19023, "GlassesType18", 0},
	{19024, "GlassesType19", 0},
	{19025, "GlassesType20", 0},
	{19026, "GlassesType21", 0},
	{19027, "GlassesType22", 0},
	{19028, "GlassesType23", 0},
	{19029, "GlassesType24", 0},
	{19030, "GlassesType25", 0},
	{19031, "GlassesType26", 0},
	{19032, "GlassesType27", 0},
	{19033, "GlassesType28", 0},
	{19034, "GlassesType29", 0},
	{19035, "GlassesType30", 0},
	{18891, "Bandana1", 0},
	{18892, "Bandana2", 0},
	{18893, "Bandana3", 0},
	{18894, "Bandana4", 0},
	{18895, "Bandana5", 0},
	{18896, "Bandana6", 0},
	{18897, "Bandana7", 0},
	{18898, "Bandana8", 0},
	{18899, "Bandana9", 0},
	{18900, "Bandana10", 0},
	{18901, "Bandana11", 0},
	{18902, "Bandana12", 0},
	{18903, "Bandana13", 0},
	{18904, "Bandana14", 0},
	{18905, "Bandana15", 0},
	{18906, "Bandana16", 0},
	{18907, "Bandana17", 0},
	{18908, "Bandana18", 0},
	{18909, "Bandana19", 0},
	{18910, "Bandana20", 0},
	{18640, "Hair1", 0},
	{18975, "Hair2", 0},
	{19136, "Hair4", 0},
	{19274, "Hair5", 0},
	{19138, "PoliceGlasses1", 0},
	{19139, "PoliceGlasses2", 0},
	{19140, "PoliceGlasses3", 0},
	{0,     "Varie",     1},
	{18632, "FishingRod", 0},
	{18633, "GTASAWrench1", 0},
	{18634, "GTASACrowbar1", 0},
	{18635, "GTASAHammer1", 0},
	{18636, "PoliceCap1", 0},
	{18637, "PoliceShield1", 0},
	{18638, "HardHat1", 0},
	{18639, "BlackHat1", 0},
	{18640, "Hair1", 0},
	{18641, "Flashlight1", 0},
	{18642, "Taser1", 0},
	{18643, "LaserPointer1", 0},
	{18644, "Screwdriver1", 0},
	{18936, "Helmet1", 0},
	{18937, "Helmet2", 0},
	{18938, "Helmet3", 0},
	{18645, "MotorcycleHelmet1", 0},
	{18976, "MotorcycleHelmet2", 0},
	{18977, "MotorcycleHelmet3", 0},
	{18978, "MotorcycleHelmet4", 0},
	{18979, "MotorcycleHelmet5", 0},
	{19141, "SWATHelmet1", 0},
	{19142, "SWATArmour1", 0},
	{18643, "LaserPointer1", 0},
	{19080, "LaserPointer2", 0},
	{19081, "LaserPointer3", 0},
	{19082, "LaserPointer4", 0},
	{19083, "LaserPointer5", 0},
	{19084, "LaserPointer6", 0}
};

////////////////////////////////////////////////////////////////////////////////
//==============================================================================
////////////////////////////////////////////////////////////////////////////////
//bone list

enum bOneList
{
    BoneID,
	BoneName[20]
}

new BoneList[][bOneList] =
{
	{1, "Spine"},
	{2, "Head"},
	{3, "Left upper arm"},
	{4, "Right upper arm"},
	{5, "Left hand"},
	{6, "Right hand"},
	{7, "Left thigh"},
	{8, "Right thigh"},
	{9, "Left foot"},
	{10, "Right foot"},
	{11, "Right calf"},
	{12, "Left calf"},
	{13, "Left forearm"},
	{14, "Right forearm"},
	{15, "Left clavicle"},
	{16, "Right clavicle"},
	{17, "Neck"},
	{18, "Jaw"}
};

// <!-------------------------------------------------------------------------!>
// veh labs
new Text3D:VehLabel[MAX_VEHICLES];
// <!------------------------------------------------------------------------!> //
enum FightingStyles
{
	f_Name[10],
	f_ID
}

new FightStyle[6][FightingStyles] =
{
	{"Normal",4},
	{"Boxing",5},
	{"Kung Fu",6},
	{"Knee-Head",7},
	{"Grab-Kick",15},
	{"Elbow",16}
};

// <!------------------!> //
new
	Team1_StartHP,
	Team2_StartHP
;

// Spec list / and more
new PlayerText:PlayerSpecList;
//new PlayerText:SpecPlayerInfo[9];
//new SpecTimer[MAX_PLAYERS];

// new spec system td
#define MAX_SPECINFO_TDS 			 9
new Text:PlayerSpecInfo[MAX_PLAYERS][MAX_SPECINFO_TDS];

////////////////////////////////////////////////////////////////////////////////
//==============================================================================
////////////////////////////////////////////////////////////////////////////////
//vehicle infos
enum eVeh
{
	Color1,
	Color2,
	Float:LHealth,
	bool:Created,
	Paint,
//	Text:VehTD[7]
}
new iVeh[MAX_VEHICLES][eVeh];
new Iterator:iVehicles<MAX_VEHICLES>;

// sigma td
//new Text:SigmaTextdraw;

#define RADIO_URL "http://shoutcast.unitedradio.it:1301/listen.pls"

// !--------------------------------------------------------------------------!
//new Text:RoundPaused;

// --
new PlayerText:PlayerKillTD;
new Timer:PlayerKillTimer[ MAX_PLAYERS ];

////////////////////////////////////////////////////////////////////////////////
//==============================================================================
////////////////////////////////////////////////////////////////////////////////
// /afk system
new
	const randAfk_sprites[ ][ 20 ] =
	{
	    {"loadsc12:loadsc12"}, {"loadsc11:loadsc11"}, {"loadsc10:loadsc10"},
	    {"loadsc1:loadsc1"}, {"loadsc8:loadsc8"}, {"loadsc9:loadsc9"},
	    {"loadsc7:loadsc7"}, {"loadsc6:loadsc6"}, {"loadsc5:loadsc5"},
	    {"loadsc4:loadsc4"}, {"loadsc3:loadsc3"}, {"loadsc2:loadsc2"},
	    {"loadsc14:loadsc14"}, {"loadsc13:loadsc13"}
	};

new PlayerText:Player_AfkTD[ 4 ];
new Timer:PlayerAfk_RandomSprite[ MAX_PLAYERS ] = {Timer:-1, ...};
////////////////////////////////////////////////////////////////////////////////
//==============================================================================
////////////////////////////////////////////////////////////////////////////////
//"first blood" system
new
	bool:RoundFirstBlood = false;
////////////////////////////////////////////////////////////////////////////////
//==============================================================================
////////////////////////////////////////////////////////////////////////////////
//statistic system
enum E_ServerStats
{
	Gamemode_Runs,
	TotalConnectedPlayers,
	TotalKills,
	PlayedBases,
	PlayedArene,
	PlayedTDMS,
	PlayedPVP,
	PlayedInteriors,
	PlayedGunGame,
	PlayedMassacre,
	#if BUON_NATALE == true
    BabboNatale,
    #endif
}

new ServerStats[ E_ServerStats ];

forward Server_ReadStats( );
public Server_ReadStats( )
{
	new text[10];

	cache_get_field_content (0, "bases", text); ServerStats[PlayedBases] = strval( text );
	cache_get_field_content (0, "arene", text); ServerStats[PlayedArene] = strval( text );
	cache_get_field_content (0, "tdms", text); ServerStats[PlayedTDMS] = strval( text );
	cache_get_field_content (0, "pvp", text); ServerStats[PlayedPVP] = strval( text );
	cache_get_field_content (0, "ints", text); ServerStats[PlayedInteriors] = strval( text );
	cache_get_field_content (0, "gungame", text); ServerStats[PlayedGunGame] = strval( text );
	cache_get_field_content (0, "runs", text); ServerStats[Gamemode_Runs] = strval( text );
	cache_get_field_content (0, "connect", text); ServerStats[TotalConnectedPlayers] = strval( text );
	cache_get_field_content (0, "kills", text); ServerStats[TotalKills] = strval( text );
  	cache_get_field_content (0, "scores", text); sscanf(text, "p<,>dd", iTeam[TEAM_A][RoundWins], iTeam[TEAM_B][RoundWins]);

    SendRconCommand( sprintf( "mapname Lobby %d:%d" , iTeam[TEAM_A][RoundWins] , iTeam[TEAM_B][RoundWins] ) );

    RefreshTextGeneralTD();
    RefreshTeamPlayers_TD();

    FullyReady++;
	print(">> Server stats loaded!");
	return 1;
}

stock Server_RefreshStats( E_ServerStats:stats , aumento )
{
    ServerStats[stats] = ServerStats[stats] + aumento;
	new q[16];

	switch (stats)
	{
	    case PlayedBases: 				q = "bases";
	    case PlayedArene: 				q = "arene";
	    case PlayedTDMS: 				q = "tdms";
	    case PlayedPVP: 				q = "pvp";
	    case PlayedInteriors: 			q = "ints";
	    case PlayedGunGame: 			q = "gungame";
	    case PlayedMassacre: 			q = "massacre";
	    case Gamemode_Runs:	 			q = "runs";
	    case TotalConnectedPlayers: 	q = "connect";
	    case TotalKills: 				q = "kills";
	}

    MySQLStatus[TotalQuerys] ++;
	mysql_tquery(g_MySQLConnection, sprintf("UPDATE stats SET %s = '%d' WHERE gid = %d", q, ServerStats[stats], G_ID), "", "");
	return true;
}

//
new Text3D:WelcomeLabel;

////////////////////////////////////////////////////////////////////////////////
//==============================================================================
////////////////////////////////////////////////////////////////////////////////
//auto-detect afk
new PlayerAfk_Seconds[MAX_PLAYERS];
// server password
new Srv_Password[ 20 ];
////////////////////////////////////////////////////////////////////////////////
//==============================================================================
////////////////////////////////////////////////////////////////////////////////
//start
#define MAX_SECONDI_START       5
new SecondiStart = MAX_SECONDI_START;
////////////////////////////////////////////////////////////////////////////////
//==============================================================================
////////////////////////////////////////////////////////////////////////////////
// fps system
//new pDrunkLevelLast[MAX_PLAYERS];
new pFPS[MAX_PLAYERS];
////////////////////////////////////////////////////////////////////////////////
//==============================================================================
////////////////////////////////////////////////////////////////////////////////
//gungame mode
#define MAX_GUNGAME_LEVELS      14
new GunGame_Weapons[ MAX_GUNGAME_LEVELS + 1 ] = {
	22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 38
};
////////////////////////////////////////////////////////////////////////////////
//==============================================================================
////////////////////////////////////////////////////////////////////////////////
//lol misc
//new GM_UpTime;
new Timer:CammUpdate;
////////////////////////////////////////////////////////////////////////////////
//==============================================================================
////////////////////////////////////////////////////////////////////////////////
//main
main() { }
//==============================================================================
//==============================================================================
//==============================================================================
stock Float:GetPlayerPacketloss(playerid)
{//s7rev
	new
	    pack[ 280 ],
	    pa[ 12 ];

    GetPlayerNetworkStats(playerid, pack, 280);
    strmid(pa, pack, (strfind(pack, "Packetloss:")+11), 280);
    return floatstr(pa);
}
////////////////////////////////////////////////////////////////////////////////
//==============================================================================
////////////////////////////////////////////////////////////////////////////////
//debug
/*enum Debug
{
	Error,
	Warning,
	Debugging,
	Log,
	SessionStart,
	SessionClose
}

stock DebugMessage( Debug:type , position[ ] = " " , error[ ] = " " )
{
	new
	    File:f = fopen( "FeuerFrei/logs/debug.txt" , io_append ) ,
	    h,
	    m,
	    s,
	    y,
	    mO,
	    d,
	    str[ 200 ];

	gettime( h , m , s );
	getdate( y , mO , d );

	switch (Debug:type) {
	    case Error: format( str , sizeof str , "[%d:%d:%d] Error (%s): %s\r\n" , h , m , s , position , error );
		case Warning: format( str , sizeof str , "[%d:%d:%d] Warning (%s): %s\r\n" , h , m , s , position , error );
	    case Debugging: format( str , sizeof str , "[%d:%d:%d] Debug (%s): %s\r\n" , h , m , s , position , error );
	    case Log: format( str , sizeof str , "[%d:%d:%d] Chat-Log (%s): %s\r\n" , h , m , s , position , error );
		case SessionStart: {
		    format( str , sizeof str , " =================== "#GAMEMODE_NAME" ===================\r\n");
		    format( str , sizeof str , "%s Sessione di debug startata alle %d:%d:%d del %d/%d/%d\r\n" , str , h , m , s , d , mO , y );
		    format( str , sizeof str , "%s =================== "#GAMEMODE_NAME" ===================\r\n\r\n\r\n" , str);
		}
		case SessionClose: {
		    format( str , sizeof str , " =================== "#GAMEMODE_NAME" ===================\r\n");
		    format( str , sizeof str , "%s Sessione di debug chiusa alle %d:%d:%d del %d/%d/%d\r\n" , str , h , m , s , d , mO , y );
		    format( str , sizeof str , "%s =================== "#GAMEMODE_NAME" ===================\r\n\r\n\r\n" , str);
		}
	}

	fwrite( f , str );
	fclose( f );
	return true;
}
*/
////////////////////////////////////////////////////////////////////////////////
//==============================================================================
////////////////////////////////////////////////////////////////////////////////
//teleports
#define MAX_TELEPORTS       14
enum dTeleports
{
	tName[ 40 ],
	Float:tX,
	Float:tY,
	Float:tZ,
	Float:tA,
	tInterior
}

new const TeleportPlaces[ ][ dTeleports ] =
{
	{"Santa Maria Beach", 540.6865,-1822.4678,6.0625,225.6962,0}, // teleport_santa maria beach
	{"Grove Street",2511.2207,-1671.2394,13.4439,75.2555,0}, // teleport_grove street
	{"Stazione LV",2838.3838,1290.8411,11.3906,87.9746,0}, // teleport_Las Venturas Stazione
	{"Airport LV",1315.2328,1268.5601,10.8203,0.6582,0}, // teleport_Las Venturas Airport
	{"Area 51",206.4263,1862.3396,13.1406,327.7161,0}, // teleport_area 51
	{"Stazione SF",-1969.2272,119.9277,27.6875,1.4704,0}, // teleport_San Fierro Stazione
	{"Airport SF",-1549.2258,-444.1982,6.1182,58.2261,0}, // teleport_San Fierro Airport
	{"Gelataio",-2381.8521,-584.8930,132.1172,124.1102,0}, // teleport_San Fierro Gelataio
	{"Monte Chiliad",-2313.4502,-1650.2561,483.7031,209.4789,0}, // teleport_Monte chilliad
	{"Campi da tennis",-2714.0195,-265.4413,7.1484,85.2515,0}, // teleport_Campi da tennis
	{"Campo da golf",1290.7729,2784.7307,10.8203,350.7911,0}, // teleport_Campo da golf
	{"Police LV",2291.0225,2428.9697,10.8203,181.1288,0}, // teleport_Las venturas police department
	{"Relax",2617.6453,2436.7112,14.8672,178.6022,0} // teleport_RelaX
};
////////////////////////////////////////////////////////////////////////////////
//==============================================================================
////////////////////////////////////////////////////////////////////////////////
//spec verse
#define SPEC_VERSE_UP       1
#define SPEC_VERSE_DOWN     2
////////////////////////////////////////////////////////////////////////////////
//==============================================================================
////////////////////////////////////////////////////////////////////////////////
/*//skin preview
enum eSP
{
	Float:sp_pX,
	Float:sp_pY,
	Float:sp_pZ,
	Float:sp_pA,
	Float:sp_cX,
	Float:sp_cY,
	Float:sp_cZ,
	Int,
}
new SkinPreview[  ][ eSP ] =
{
	{1222.7867,-8.2353,1001.3281,67.4136,1216.4957,-5.6133,1001.3281,2}, // // a
	{2147.3875,1622.9578,993.6882,124.2062,2141.3269,1618.0509,993.6882,1}, // // a_1
	{-2666.0007,1423.0581,912.4063,46.8306,-2669.5547,1426.7521,912.4063,3}, // // a_3
	{1141.4183,-8.2679,1000.6719,93.0778,1138.2205,-8.1769,1000.6797,12}, // // a
	{1119.2666,-1.8439,1000.6902,267.5212,1122.3611,-1.7411,1000.6797,12}, // // a_12
	{-1431.4005,1596.1224,1054.3153,5.1752,-1431.4539,1600.2766,1054.1157,14}, // // a
	{476.5459,-13.6136,1003.6953,151.2683,474.2085,-19.3027,1003.6953,17}, // // a
	{487.1442,-25.9763,1003.5941,36.9448,482.9544,-22.1766,1003.1094,17}, // // a_17
	{487.8728,-2.7048,1002.3828,181.3126,487.3480,-8.4942,1000.6719,17}, // // a_17
	{1726.1786,-1639.7078,27.2196,170.8225,1726.0981,-1641.6001,27.2283,0} // // a
};unbannick
*/
new Text:SkinSelection_TDs;
////////////////////////////////////////////////////////////////////////////////
//==============================================================================
////////////////////////////////////////////////////////////////////////////////
//esl mode + varius modes
new Text:ESLModeReady[4];

stock RefreshReadyTDs_Esl( )
{
	if (gConfig[GameMode] != GAMEMODE_ESL) return true;

	new szA[(MAX_PLAYER_NAME * 8)],szB[(MAX_PLAYER_NAME * 8)], rA, rB;

	foreach(new i:Player)
	{
		if(Player[i][Team] == TEAM_A)
		{
		    if (PlayerReady[i] == true)
		    {
		        strcat(szA, sprintf( "~"#GT_TEAMA"~~h~~h~%s ~g~~h~V~n~", Player[i][Nickname] ) );
		        rA++;
		    }
  			else strcat(szA, sprintf( "~"#GT_TEAMA"~~h~~h~%s ~r~~h~X~n~", Player[i][Nickname] ) );
		}
		else if(Player[i][Team] == TEAM_B)
		{
		    if (PlayerReady[i] == true)
		    {
		        strcat(szB, sprintf( "~"#GT_TEAMB"~~h~~h~%s ~g~~h~V~n~", Player[i][Nickname] ) );
		        rB++;
		    }
		    else strcat(szB, sprintf( "~"#GT_TEAMB"~~h~~h~%s ~r~~h~X~n~", Player[i][Nickname] ) );
		}
	}

	TextDrawSetString(ESLModeReady[0], sprintf( "~r~~h~%s (%d players ready)", iTeam[TEAM_A][Name] , rA ) );
	TextDrawSetString(ESLModeReady[1], sprintf( "~b~~h~%s (%d players ready)", iTeam[TEAM_B][Name] , rB ) );

	TextDrawSetString(ESLModeReady[2], szB );
	TextDrawSetString(ESLModeReady[3], szA );
	return true;
}
////////////////////////////////////////////////////////////////////////////////
//==============================================================================
////////////////////////////////////////////////////////////////////////////////
//no hits
//new Text:TD_NotHits;
new Text:TD_NoHitsScritta;
new bool:AntiHits = false;
////////////////////////////////////////////////////////////////////////////////
//==============================================================================
////////////////////////////////////////////////////////////////////////////////
//ini loads

stock SetPlayerCheckpointEx( playerid , Float:x , Float:y, Float:z , Float:size )
{
	DisablePlayerCheckpoint( playerid );
	SetPlayerCheckpoint( playerid , x , y , z , size );
	return true;
}

//#define SetPlayerCheckpoint SetPlayerCheckpointEx

new bool:UnPausingRunning = false;

// notice stuff
new notice[ 100 ];

// timeout stuff
new bool:timeoutPlayer[MAX_PLAYERS];

////////////////////////////////////////////////////////////////////////////////
//==============================================================================
////////////////////////////////////////////////////////////////////////////////
//death msg stuff

new const deathMessages[][20] =
{
	{"Obliterated"},
	{"Massacred"},
	{"Raped"},
	{"Nagraned"},
	{"Decapitated"},
	{"Slaughtered"},
	{"K.O.'d"},
	{"Murdered"},
	{"Fucked"}
};

////////////////////////////////////////////////////////////////////////////////
new Timer:AutoHide_TD;

////////////////////////////////////////////////////////////////////////////////
//==============================================================================
////////////////////////////////////////////////////////////////////////////////
//hint stuff
/*new Text: HintTD;

new hintFrasi[][150] =
{
	{"~b~~h~Hint:~w~ You can now use /switch (TEAMNAME) to change team"},
//	{"~b~~h~Hint:~w~ Use /distance in-game to see your distance from your team mates"},
	{"~b~~h~Hint:~w~ Use /ready or /vote to start a round"},
	{"~b~~h~Hint:~w~ Check your stats online! http://sigmaseven.forumfree.it/?pag=bestdm"}
//	{"~r~~h~WARNING:~w~ Report any bug with /report"}
//	{"~r~~h~WARNING:~w~ THIS VERSION CAN BE UNSTABLE, REPORT ANY BUG YOU SEE ABOUT HEALTH/ARMOUR INDICATORS."}
};

new Timer:hint_timer;

//forward Hint_ChangeFrase();
timer Hint_ChangeFrase[20000]()
{
    TextDrawSetString(HintTD, hintFrasi[random(sizeof hintFrasi)]);
}
*/
//hintFrasi[random(sizeof hintFrasi)]
new Timer:CamMoving_Round;

////////////////////////////////////////////////////////////////////////////////
//==============================================================================
////////////////////////////////////////////////////////////////////////////////
//help key
// il simbolo @ viene sostitutio con la distanza
new frasiHelp[][ 128 ] =
{
	"Help me! I'm @ ft away from you!",
	"I'm taking fire... Need Assistance here (@ away)!",
	"Cover me, they are here! (@ away)",
	"They're from me, come to me i need Help! (@ away)"
};

new HelperLocked[MAX_PLAYERS] = {false, ...};

/*
	new frase[ 128 ];
	strcat(frase, frasiHelp[random(sizeof frasiHelp)]);

	new dist   = strfind(frase, "@", true);

	new
	    Float:fX,
	    Float:fY,
	    Float:fZ;

	foreach(new i:Player)
	{
	    if (Player[i][Team] == pT)
	    {
	        GetPlayerPos(i, fX, fY, fZ);
			iDist = GetPlayerDistanceFromPoint(i, fX, fY, fZ);

			strdel(frase, dist, dist+1);
			strins(frase, numstr(iDist), dist);

			SendClientMessage(i, iTeam[pT][InGameColor], "(Team) %s:{FFFFFF} (%d) %s", Player[playerid][Nickname], playerid, frasiHelp[iFrase]);
            PlayerPlaySound(i, 45400, 0.0, 0.0, 0.0);
	    }
	}
*/

/*
	// -p- => Conta i players nei suoi pressi (9.0 ft)
	// -d- => Stampa la distanza da ogni player dello stesso team

	new frasiHelp[][ 128 ] =
	{
		"Help me! I'm -d- ft away from you!",
		"I'm taking fire... Need Assistance here (-d- away)!",
		"Cover me -p- players are here!",
		"They're -p- players from me, come to me i need Help!"
	};

	new
		iFrase = random( sizeof frasiHelp );

	for (new i = 0, j = strlen(frasiHelp[iFrase]; i < j; i++)
	{
		if (frasiHelp[iFrase][i] == '-' && frasiHelp[iFrase][i + 2] == '-') // simbolo di cambio
		{// opero su i + 1 perchï¿½ attualmente punto sul primo carattere -
		    if (frasiHelp[iFrase][i + 1] == 'd')
		    {
				// prendo la distanza (?)
		    }
		    else if (frasiHelp[iFrase][i + 1] == 'p')
		    {
		        // conteggio i players
		    }
		}
	}

*/

#if BUON_NATALE == true
new ListaDesideri;

#endif

stock GetHisSubTeam(playerid)
{
	return (Player[playerid][Team] == TEAM_A ? TEAM_A_SUB : (Player[playerid][Team] == TEAM_B ? TEAM_B_SUB : 0 ));
}

stock SubTeamToTeam(playerid)
{
	return (Player[playerid][Team] == TEAM_A_SUB ? TEAM_A : (Player[playerid][Team] == TEAM_B_SUB ? TEAM_B : 0 ));
}

// ============================================================================ //
// TIMEOUT DATA

new Float:timeout_Pos[MAX_PLAYERS][4];
new Float:timeout_Health[MAX_PLAYERS];
new Float:timeout_Armour[MAX_PLAYERS];
new timeout_Team[MAX_PLAYERS];

// ==============================================================================

#define GAMEMODE_PASSWORD                   "cDeRVSJ59QqXJizIfBODZ370jE4JYnm4"
											//http://generator.my-addr.com/generate_random_string_online-and-string_random_generator_tool.php

// ============================================================================ //
// LaunchCompatibility

#define MAX_FIGHTS                                                             10
#define MAX_GUNGAME                                                             10
#define MAX_LASTBULLET                          1       //
#define MAX_ARENE       													  32
#define MAX_BASES       													193
#define MAX_INTS                                                        23
/*
stock LaunchCompatibility() {
	if (fexist("compatibility_mode_slfd/backup.txt")) {
	    // Il file esiste, quindi ho almeno una copia di tutto
	    // Procedo con la lettura

	    // Il motivo per cui gli accounts non sono presenti ï¿½ che:
	    // 1. Contengono informazioni sensibili
		// 2. Dovrebbero essere SEMPRE up-to-date

		for (new i = 0; i < MAX_BASES; i ++) {
			INI_ParseFile (sprintf ("compatibility_mode_slfd/bases/%d.txt", i), "COMPATIBILITY_BASES", .extra = i, .bExtra = true);

			printf("Compatibilitï¿½: Bases:: id: %d (%s)", i, sprintf ("compatibility_mode_slfd/bases/%d.txt"));
		}

		for (new i = 0; i < MAX_ARENE; i ++) {
			INI_ParseFile (sprintf ("compatibility_mode_slfd/arene/%d.txt", i), "COMPATIBILITY_ARENE", .extra = i, .bExtra = true);

			printf("Compatibilitï¿½: Arene:: id: %d", i);
		}

		for (new i = 0; i < MAX_INTS; i ++) {
			INI_ParseFile (sprintf ("compatibility_mode_slfd/ints/%d.txt", i), "COMPATIBILITY_INTS", .extra = i, .bExtra = true);

			printf("Compatibilitï¿½: Ints:: id: %d", i);
		}

		for (new i = 0; i < MAX_GUNGAME; i ++) {
			INI_ParseFile (sprintf ("compatibility_mode_slfd/gungame/%d.txt", i), "COMPATIBILITY_GUNGAMES", .extra = i, .bExtra = true);

			printf("Compatibilitï¿½: Gungame:: id: %d", i);
		}

		for (new i = 0; i < MAX_FIGHTS; i ++) {
			INI_ParseFile (sprintf ("compatibility_mode_slfd/fights/%d.txt", i), "COMPATIBILITY_FIGHTS", .extra = i, .bExtra = true);

            printf("Compatibilitï¿½: Fights:: id: %d", i);
		}

		for (new i = 0; i < MAX_LASTBULLET; i ++) {
			INI_ParseFile (sprintf ("compatibility_mode_slfd/lastbullet/%d.txt", i), "COMPATIBILITY_BULLET", .extra = i, .bExtra = true);

			printf("Compatibilitï¿½: LB:: id: %d (%d)", i, fexist(sprintf ("compatibility_mode_slfd/lastbullet/%d.txt", i)));
		}

		INI_ParseFile ("compatibility_mode_slfd/teams.txt", "COMPATIBILITY_TEAMS", .bPassTag = true);
		printf("Compatibilitï¿½: Teams: (temp file: %d)", fexist("compatibility_mode_slfd/teams.txt") );
		INI_ParseFile ("compatibility_mode_slfd/config.txt", "COMPATIBILITY_CONFIG");
		printf("Compatibilitï¿½: Config:: (config: %d)", fexist("compatibility_mode_slfd/teams.txt") );
		INI_ParseFile ("compatibility_mode_slfd/weaponsets.txt", "COMPATIBILITY_WEAPONSETS", .bPassTag = true);
		printf("Compatibilitï¿½: WPS:: (%d)", fexist("compatibility_mode_slfd/weaponsets.txt"));

		iTeam[TEAM_A_SUB][InGameColor] = 0xB28C8CAA;
		iTeam[TEAM_A_SUB][OutColor] = 0xB28C8CAA;

		iTeam[TEAM_B_SUB][InGameColor] = 0xD0D4ACAA;
		iTeam[TEAM_B_SUB][OutColor] = 0xD0D4ACAA;

		AddPlayerClass(59                     		,   Lobby[0], Lobby[1], Lobby[2], Lobby[3], 0, 0, 0, 0, 0, 0);
		AddPlayerClass(iTeam[TEAM_A][Skin]    		, 	Lobby[0], Lobby[1], Lobby[2], Lobby[3], 0, 0, 0, 0, 0, 0);
		AddPlayerClass(iTeam[TEAM_A_SUB][Skin]   	, 	Lobby[0], Lobby[1], Lobby[2], Lobby[3], 0, 0, 0, 0, 0, 0);
		AddPlayerClass(iTeam[TEAM_B][Skin]    		, 	Lobby[0], Lobby[1], Lobby[2], Lobby[3], 0, 0, 0, 0, 0, 0);
		AddPlayerClass(iTeam[TEAM_B_SUB][Skin]    	, 	Lobby[0], Lobby[1], Lobby[2], Lobby[3], 0, 0, 0, 0, 0, 0);
		AddPlayerClass(iTeam[TEAM_REF][Skin]  		, 	Lobby[0], Lobby[1], Lobby[2], Lobby[3], 0, 0, 0, 0, 0, 0);

	    SendRconCommand( sprintf( "mapname Lobby %d:%d" , iTeam[TEAM_A][RoundWins] , iTeam[TEAM_B][RoundWins] ) );

	    RefreshTextGeneralTD();
	    RefreshTeamPlayers_TD();
	}
	return true;
}
*/
// !===========================================================================!193

enum e_struct_scenario
{
	Float:bAttackers[3],
	Float:bDefenders[3],
	Float:bCheckpoint[3], // home
	bInterior,
	bPlayed,
	bName[40],
	bool:Exists,
	Float:bMinY,
	Float:bMinX,
	Float:bMaxX,
	Float:bMaxY,
	bool:bForPVP,
	MySQLid,
}

new bBases[MAX_BASES][e_struct_scenario];

forward OnLoadBase();
public OnLoadBase()
{
    FullyReady++;
	new rows, fields;
	cache_get_data(rows, fields);

	if (rows > MAX_BASES) rows = MAX_BASES;

	new tmp[60], i = 0;

	for(new x = 0; x < MAX_BASES; x++) bBases[x][Exists] = false;

	for (i = 0; i < rows; i++)
	{
	    cache_get_field_content (i, "att", tmp);
	    sscanf(tmp, "p<,>fff", bBases[i][bAttackers][0], bBases[i][bAttackers][1], bBases[i][bAttackers][2]);

	    cache_get_field_content (i, "def", tmp);
	    sscanf(tmp, "p<,>fff", bBases[i][bDefenders][0], bBases[i][bDefenders][1], bBases[i][bDefenders][2]);

	    cache_get_field_content (i, "home", tmp);
	    sscanf(tmp, "p<,>fff", bBases[i][bCheckpoint][0], bBases[i][bCheckpoint][1], bBases[i][bCheckpoint][2]);

	    cache_get_field_content (i, "interior" , tmp); 	bBases[i][bInterior] = strval (tmp);
	    cache_get_field_content (i, "played"   , tmp); 	bBases[i][bPlayed] = strval (tmp);
	    cache_get_field_content (i, "name"     , tmp); 	strcpy_2(bBases[i][bName], tmp);
	    cache_get_field_content (i, "id"       , tmp); 	bBases[i][MySQLid] = strval (tmp);

	    bBases[i][Exists] = true;

		/**
		 * Se true significa che la gamemode deve creare una copia di queste informazioni
		 * per rendere disponibile la gamemode anche quando il database non ï¿½ disponibile
		*/

/*		if (createCopy == true)
		{
		    new INI:copy =
				INI_Open (sprintf("compatibility_mode_slfd/bases/%d.txt", i));

			INI_WriteString (copy, "att", sprintf ("%f,%f,%f", bBases[i][bAttackers][0], bBases[i][bAttackers][1], bBases[i][bAttackers][2]));
			INI_WriteString (copy, "def", sprintf ("%f,%f,%f", bBases[i][bDefenders][0], bBases[i][bDefenders][1], bBases[i][bDefenders][2]));
			INI_WriteString (copy, "home", sprintf ("%f,%f,%f", bBases[i][bCheckpoint][0], bBases[i][bCheckpoint][1], bBases[i][bCheckpoint][2]));

			INI_WriteInt (copy, "played", bBases[i][bPlayed]);
			INI_WriteInt (copy, "interior", bBases[i][bInterior]);
			INI_WriteString (copy, "name", bBases[i][bName]);

			INI_Close (copy);
		}*/
	}

	printf(">> Loaded %d bases (%d)", i, CurrentGamepack);
	return 1;
}
/*

forward COMPATIBILITY_BASES(i, name[], tmp[]);
public COMPATIBILITY_BASES(i, name[], tmp[])
{
	printf("COMPATIBILITY_BASES %d %s %s", i, name, tmp);
	if (!strcmp(name, "att", true)) {
	    sscanf(tmp, "p<,>fff", bBases[i][bAttackers][0], bBases[i][bAttackers][1], bBases[i][bAttackers][2]);
	}
	else if (!strcmp(name, "att", true)) {
	    sscanf(tmp, "p<,>fff", bBases[i][bDefenders][0], bBases[i][bDefenders][1], bBases[i][bDefenders][2]);
	}
	else if (!strcmp(name, "home", true)) {
	    sscanf(tmp, "p<,>fff", bBases[i][bCheckpoint][0], bBases[i][bCheckpoint][1], bBases[i][bCheckpoint][2]);
	}
	else if (!strcmp(name, "interior", true)) {
	    bBases[i][bInterior] = strval (tmp);
	}
	else if (!strcmp(name, "played", true)) {
	    bBases[i][bPlayed] = strval (tmp);
	}
	else if (!strcmp(name, "name", true)) {
	    strcpy_2(bBases[i][bName], tmp);
	}
	else if (!strcmp(name, "id", true)) {
		bBases[i][MySQLid] = strval (tmp);
	}

    bBases[i][Exists] = true;
}
*/
forward OnPackSwitch(p);
public OnPackSwitch(p)
{
	new rows, fields;
	cache_get_data(rows, fields);

	if (rows > MAX_BASES) rows = MAX_BASES;

	new tmp[60], i = 0;

	for(new x = 0; x < MAX_BASES; x++) bBases[x][Exists] = false;

	for (i = 0; i < rows; i++)
	{
	    cache_get_field_content (i, "att", tmp);
	    sscanf(tmp, "p<,>fff", bBases[i][bAttackers][0], bBases[i][bAttackers][1], bBases[i][bAttackers][2]);

	    cache_get_field_content (i, "def", tmp);
	    sscanf(tmp, "p<,>fff", bBases[i][bDefenders][0], bBases[i][bDefenders][1], bBases[i][bDefenders][2]);

	    cache_get_field_content (i, "home", tmp);
	    sscanf(tmp, "p<,>fff", bBases[i][bCheckpoint][0], bBases[i][bCheckpoint][1], bBases[i][bCheckpoint][2]);

	    cache_get_field_content (i, "interior" , tmp); 	bBases[i][bInterior] = strval (tmp);
	    cache_get_field_content (i, "played"   , tmp); 	bBases[i][bPlayed] = strval (tmp);
	    cache_get_field_content (i, "name"     , tmp); 	strcpy_2(bBases[i][bName], tmp);
	    cache_get_field_content (i, "id"       , tmp); 	bBases[i][MySQLid] = strval (tmp);

	    bBases[i][Exists] = true;
	}

	format(stringo, sizeof stringo, "Admin/Mod {"#COLOR_SYSTEM_FOCUS"}%s{"#COLOR_SYSTEM_REST"} has loaded {"#COLOR_SYSTEM_FOCUS"}%s{"#COLOR_SYSTEM_REST"} bases pack.", Player[p][Nickname], basesPacks[CurrentGamepack][packName]);
    SendClientMessageToAll(COLOR_SYSTEM, stringo);
	return 1;
}


new aArene[MAX_ARENE][e_struct_scenario];

forward OnLoadArena(a);
public OnLoadArena(a)
{
    FullyReady++;
	new rows, fields, i, tmp[60];
	cache_get_data(rows, fields);

	for(new x = 0; x < MAX_ARENE; x++) { aArene[x][Exists] = false; aArene[x][bForPVP] = false; }

	for (i = 0; i < rows; i++)
	{
	    cache_get_field_content (i, "att", tmp);
	    sscanf(tmp, "p<,>fff", aArene[i][bAttackers][0], aArene[i][bAttackers][1], aArene[i][bAttackers][2]);

	    cache_get_field_content (i, "def", tmp);
	    sscanf(tmp, "p<,>fff", aArene[i][bDefenders][0], aArene[i][bDefenders][1], aArene[i][bDefenders][2]);

	    cache_get_field_content (i, "home", tmp);
	    sscanf(tmp, "p<,>fff", aArene[i][bCheckpoint][0], aArene[i][bCheckpoint][1], aArene[i][bCheckpoint][2]);

	    cache_get_field_content (i, "Zmax", tmp);
	    sscanf(tmp, "p<,>ff", aArene[i][bMaxX], aArene[i][bMaxY]);

	    cache_get_field_content (i, "Zmin", tmp);
	    sscanf(tmp, "p<,>ff", aArene[i][bMinX], aArene[i][bMinY]);

/*
	else if(!strcmp(identifier, "Zmin"))
	{
	    eScenario[MinX] = x;
	    eScenario[MinY] = y;
	}
	else if(!strcmp(identifier, "Zmax"))
	{
	    eScenario[MaxX] = x;
	    eScenario[MaxY] = y;
	}

*/
	    cache_get_field_content (i, "interior" , tmp); 	aArene[i][bInterior] = strval (tmp);
	    cache_get_field_content (i, "played"   , tmp); 	aArene[i][bPlayed] = strval (tmp);
	    cache_get_field_content (i, "name"     , tmp); 	strcpy_2(aArene[i][bName], tmp);
	    cache_get_field_content (i, "forpvp"   , tmp);  aArene[i][bForPVP] = bool:strval (tmp);
	    cache_get_field_content (i, "id"       , tmp); 	aArene[i][MySQLid] = strval (tmp);

	    aArene[i][Exists] = true;
/*
		if (createCopy == true)
		{
		    new INI:copy =
				INI_Open (sprintf("compatibility_mode_slfd/arene/%d.txt", i));

			INI_WriteString (copy, "att", sprintf ("%f,%f,%f", aArene[i][bAttackers][0], aArene[i][bAttackers][1], aArene[i][bAttackers][2]));
			INI_WriteString (copy, "def", sprintf ("%f,%f,%f", aArene[i][bDefenders][0], aArene[i][bDefenders][1], aArene[i][bDefenders][2]));
			INI_WriteString (copy, "home", sprintf ("%f,%f,%f", aArene[i][bCheckpoint][0], aArene[i][bCheckpoint][1], aArene[i][bCheckpoint][2]));

			INI_WriteString (copy, "Zmax", sprintf ("%f,%f", aArene[i][bMaxX], aArene[i][bMaxY]));
			INI_WriteString (copy, "Zmin", sprintf ("%f,%f", aArene[i][bMinX], aArene[i][bMinY]));

			INI_WriteInt (copy, "played", aArene[i][bPlayed]);
			INI_WriteInt (copy, "interior", aArene[i][bInterior]);
			INI_WriteString (copy, "name", aArene[i][bName]);
			INI_WriteBool (copy, "forpvp", aArene[i][bForPVP]);

			INI_Close (copy);
		}*/
	}

    printf(">> Loaded %d arene", i);

    if (a != -1)
    {
        SendClientMessage(a, COLOR_SYSTEM, "Reload finished.");
    }
	return 1;
}
/*
forward COMPATIBILITY_ARENE(i, name[], tmp[]);
public COMPATIBILITY_ARENE(i, name[], tmp[])
{
	printf("COMPATIBILITY_ARENE %d %s %s", i, name, tmp);
	if (!strcmp(name, "att", true)) {
	    sscanf(tmp, "p<,>fff", aArene[i][bAttackers][0], aArene[i][bAttackers][1], aArene[i][bAttackers][2]);
	}
	else if (!strcmp(name, "att", true)) {
	    sscanf(tmp, "p<,>fff", aArene[i][bDefenders][0], aArene[i][bDefenders][1], aArene[i][bDefenders][2]);
	}
	else if (!strcmp(name, "home", true)) {
	    sscanf(tmp, "p<,>fff", aArene[i][bCheckpoint][0], aArene[i][bCheckpoint][1], aArene[i][bCheckpoint][2]);
	}
	else if (!strcmp(name, "interior", true)) {
	    aArene[i][bInterior] = strval (tmp);
	}
	else if (!strcmp(name, "played", true)) {
	    aArene[i][bPlayed] = strval (tmp);
	}
	else if (!strcmp(name, "name", true)) {
	    strcpy_2(aArene[i][bName], tmp);
	}
	else if (!strcmp(name, "id", true)) {
		aArene[i][MySQLid] = strval (tmp);
	}
	else if (!strcmp(name, "forpvp", true)) {
		aArene[i][bForPVP] = bool:strval (tmp);
	}
	else if (!strcmp(name, "Zmax", true)) {
		sscanf(tmp, "p<,>ff", aArene[i][bMaxX], aArene[i][bMaxY]);
	}
	else if (!strcmp(name, "Zmin", true)) {
	    sscanf(tmp, "p<,>ff", aArene[i][bMinX], aArene[i][bMinY]);
	}
    aArene[i][Exists] = true;
}
*/
new iBases[MAX_INTS][e_struct_scenario];

forward OnLoadInt(a);
public OnLoadInt(a)
{
    FullyReady++;
	new rows, fields, i, tmp[60];
	cache_get_data(rows, fields);

	for(new x = 0; x < MAX_INTS; x++) iBases[x][Exists] = false;

	for (i = 0; i < rows; i++)
	{
	    cache_get_field_content (i, "att", tmp);
	    sscanf(tmp, "p<,>fff", iBases[i][bAttackers][0], iBases[i][bAttackers][1], iBases[i][bAttackers][2]);

	    cache_get_field_content (i, "def", tmp);
	    sscanf(tmp, "p<,>fff", iBases[i][bDefenders][0], iBases[i][bDefenders][1], iBases[i][bDefenders][2]);

	    cache_get_field_content (i, "home", tmp);
	    sscanf(tmp, "p<,>fff", iBases[i][bCheckpoint][0], iBases[i][bCheckpoint][1], iBases[i][bCheckpoint][2]);

	    cache_get_field_content (i, "interior" , tmp); 	iBases[i][bInterior] = strval (tmp);
	    cache_get_field_content (i, "played"   , tmp); 	iBases[i][bPlayed] = strval (tmp);
	    cache_get_field_content (i, "name"     , tmp); 	strcpy_2(iBases[i][bName], tmp);
	    cache_get_field_content (i, "id"       , tmp); 	iBases[i][MySQLid] = strval (tmp);

	    iBases[i][Exists] = true;
/*
		if (createCopy == true)
		{
		    new INI:copy =
				INI_Open (sprintf("compatibility_mode_slfd/ints/%d.txt", i));

			INI_WriteString (copy, "att", sprintf ("%f,%f,%f", iBases[i][bAttackers][0], iBases[i][bAttackers][1], iBases[i][bAttackers][2]));
			INI_WriteString (copy, "def", sprintf ("%f,%f,%f", iBases[i][bDefenders][0], iBases[i][bDefenders][1], iBases[i][bDefenders][2]));
			INI_WriteString (copy, "home", sprintf ("%f,%f,%f", iBases[i][bCheckpoint][0], iBases[i][bCheckpoint][1], iBases[i][bCheckpoint][2]));

			INI_WriteInt (copy, "played", iBases[i][bPlayed]);
			INI_WriteInt (copy, "interior", iBases[i][bInterior]);
			INI_WriteString (copy, "name", iBases[i][bName]);

			INI_Close (copy);
		}*/
	}

    printf(">> Loaded %d ints bases", i);

    if (a != -1)
    {
        SendClientMessage(a, COLOR_SYSTEM, "Reload ok.");
    }
	return 1;
}
/*
forward COMPATIBILITY_INTS(i, name[], tmp[]);
public COMPATIBILITY_INTS(i, name[], tmp[])
{
    printf("COMPATIBILITY_INTS %d %s %s", i, name, tmp);
	if (!strcmp(name, "att", true)) {
	    sscanf(tmp, "p<,>fff", iBases[i][bAttackers][0], iBases[i][bAttackers][1], iBases[i][bAttackers][2]);
	}
	else if (!strcmp(name, "att", true)) {
	    sscanf(tmp, "p<,>fff", iBases[i][bDefenders][0], iBases[i][bDefenders][1], iBases[i][bDefenders][2]);
	}
	else if (!strcmp(name, "home", true)) {
	    sscanf(tmp, "p<,>fff", iBases[i][bCheckpoint][0], iBases[i][bCheckpoint][1], iBases[i][bCheckpoint][2]);
	}
	else if (!strcmp(name, "interior", true)) {
	    iBases[i][bInterior] = strval (tmp);
	}
	else if (!strcmp(name, "played", true)) {
	    iBases[i][bPlayed] = strval (tmp);
	}
	else if (!strcmp(name, "name", true)) {
	    strcpy_2(iBases[i][bName], tmp);
	}
	else if (!strcmp(name, "id", true)) {
		iBases[i][MySQLid] = strval (tmp);
	}

    iBases[i][Exists] = true;
}*/

new gGunGame[MAX_GUNGAME][e_struct_scenario];
new Float:gGunGame_SpecialSpawns[MAX_GUNGAME][20][3];

forward OnLoadGungame(b);
public OnLoadGungame(b)
{
    FullyReady++;
	new rows, fields, i, tmp[60];
	cache_get_data(rows, fields);

	for(new x = 0; x < MAX_GUNGAME; x++) gGunGame[x][Exists] = false;
//	new INI:copy;

	for (i = 0; i < rows; i++)
	{
	    cache_get_field_content (i, "interior" , tmp); 	gGunGame[i][bInterior] = strval (tmp);
	    cache_get_field_content (i, "played"   , tmp); 	gGunGame[i][bPlayed] = strval (tmp);
	    cache_get_field_content (i, "name"     , tmp); 	strcpy_2(gGunGame[i][bName], tmp);
	    cache_get_field_content (i, "id"       , tmp); 	gGunGame[i][MySQLid] = strval (tmp);
	    cache_get_field_content (i, "zona"     , tmp);
	    sscanf(tmp, "p<,>ffff", gGunGame[i][bMaxX], gGunGame[i][bMaxY], gGunGame[i][bMinX], gGunGame[i][bMinY]);
		printf("Gungame (#%d) zone: %f %f %f %f", i, gGunGame[i][bMaxX], gGunGame[i][bMaxY], gGunGame[i][bMinX], gGunGame[i][bMinY]);
/*
		if (createCopy == true)
		{
		    copy =
				INI_Open (sprintf("compatibility_mode_slfd/gungames/%d.txt", i));

			INI_WriteInt (copy, "played", gGunGame[i][bPlayed]);
			INI_WriteInt (copy, "interior", gGunGame[i][bInterior]);
			INI_WriteString (copy, "name", gGunGame[i][bName]);

			INI_WriteString (copy, "Zmax", sprintf ("%f,%f", gGunGame[i][bMaxX], gGunGame[i][bMaxY]));
			INI_WriteString (copy, "Zmin", sprintf ("%f,%f", gGunGame[i][bMinX], gGunGame[i][bMinY]));
		}
*/
	    gGunGame[i][Exists] = true;

	    for (new a = 1; a <= 20; a++)
	    {
	        cache_get_field_content (i, sprintf("s%d", a), tmp);

	        sscanf(tmp, "p<,>fff", gGunGame_SpecialSpawns[i][a - 1][0], gGunGame_SpecialSpawns[i][a - 1][1], gGunGame_SpecialSpawns[i][a - 1][2]);
/*
			if (createCopy == true)
			{
				INI_WriteString (copy, sprintf ("s%d", a), sprintf ("%f,%f,%f", gGunGame_SpecialSpawns[i][a - 1][0], gGunGame_SpecialSpawns[i][a - 1][1], gGunGame_SpecialSpawns[i][a - 1][2]));
			}*/
	    }

	    //if (createCopy == true) INI_Close (copy);
	}

    printf(">> Loaded %d gungames", i);

    if (b != -1)
    {
        SendClientMessage(b, COLOR_SYSTEM, "Reload ok.");
    }
	return 1;
}
/*
forward COMPATIBILITY_GUNGAMES(i, name[], tmp[]);
public COMPATIBILITY_GUNGAMES(i, name[], tmp[])
{
    printf("COMPATIBILITY_GUNGAMES %d %s %s", i, name, tmp);

    for (new a = 1; a <= 20; a++) {
		if (!strcmp(name, sprintf("s%d", i), true)) {
	    	sscanf(tmp, "p<,>fff", gGunGame_SpecialSpawns[i][a - 1][0], gGunGame_SpecialSpawns[i][a - 1][1], gGunGame_SpecialSpawns[i][a - 1][2]);
	    	break;
		}
	}

 	if (!strcmp(name, "interior", true)) {
	    gGunGame[i][bInterior] = strval (tmp);
	}
	else if (!strcmp(name, "played", true)) {
	    gGunGame[i][bPlayed] = strval (tmp);
	}
	else if (!strcmp(name, "name", true)) {
	    strcpy_2(gGunGame[i][bName], tmp);
	}
	else if (!strcmp(name, "id", true)) {
		gGunGame[i][MySQLid] = strval (tmp);
	}
	else if (!strcmp(name, "Zmax", true)) {
		gGunGame[i][MySQLid] = strval (tmp);
		sscanf(tmp, "p<,>ff", gGunGame[i][bMaxX], gGunGame[i][bMaxY]);
	}
	else if (!strcmp(name, "Zmin", true)) {
		gGunGame[i][bForPVP] = bool:strval (tmp);
	    sscanf(tmp, "p<,>ff", gGunGame[i][bMinX], gGunGame[i][bMinY]);
	}
    gGunGame[i][Exists] = true;
}

*/
enum e_fight_struct
{
	fInterior,
	fName [40],
	Float:fMaxX,
	Float:fMaxY,
	Float:fMinX,
	Float:fMinY,
//	fBestPlayer [24],
//	fScoreBest,
	fPlayed,
	fSize,
	bool:fExists,
	fMySQLid,

	/*
	    cache_get_field_content (i, "Zmax", tmp);
	    sscanf(tmp, "p<,>ff", aArene[i][bMaxX], aArene[i][bMaxY]);

	    cache_get_field_content (i, "Zmin", tmp);
	    sscanf(tmp, "p<,>ff", aArene[i][bMinX], aArene[i][bMinY]);
	*/
}

#define FIGHTSIZE_ONEVSONE      0
#define FIGHTSIZE_ALLVSALL      1

#define MAX_FIGHT_SPAWNS            20

new fFights[MAX_FIGHTS][e_fight_struct];
new Float:fFights_Spawns[MAX_FIGHTS][MAX_FIGHT_SPAWNS][3];

new PlayerAvversario[MAX_PLAYERS] = {INVALID_PLAYER_ID, ...};

forward OnLoadFight(p);
public OnLoadFight(p)
{
    FullyReady++;
	new rows, fields, i, tmp[60];
	cache_get_data(rows, fields);

	for(new x = 0; x < MAX_FIGHTS; x++) fFights[x][fExists] = false;
//	new INI:copy;

	for(i = 0; i < rows; i++)
	{
	    cache_get_field_content (i, "interior"   , tmp); 	fFights[i][fInterior] = strval (tmp);
	    cache_get_field_content (i, "played"     , tmp); 	fFights[i][fPlayed] = strval (tmp);
	    cache_get_field_content (i, "name"       , tmp); 	strcpy_2(fFights[i][fName], tmp);
	    cache_get_field_content (i, "id"         , tmp); 	fFights[i][fMySQLid] = strval (tmp);
	    cache_get_field_content (i, "size"       , tmp); 	fFights[i][fSize] = strval (tmp);
//	    cache_get_field_content (i, "bestplayer" , tmp); 	fFights[i][fBestPlayer] = strval (tmp);
//	    cache_get_field_content (i, "wins"       , tmp); 	fFights[i][fScoreBest] = strval (tmp);

	    cache_get_field_content (i, "Zmax", tmp);
	    sscanf(tmp, "p<,>ff", fFights[i][fMaxX], fFights[i][fMaxY]);

	    cache_get_field_content (i, "Zmin", tmp);
	    sscanf(tmp, "p<,>ff", fFights[i][fMinX], fFights[i][fMinY]);

	    printf("XMax: %f XMin: %f YMax: %f YMin: %f", fFights[i][fMaxX], fFights[i][fMinX], fFights[i][fMaxY], fFights[i][fMinY]);
/*
		if (createCopy == true)
		{
		    copy =
				INI_Open (sprintf("compatibility_mode_slfd/fights/%d.txt", i));

			INI_WriteInt (copy, "played", fFights[i][fPlayed]);
			INI_WriteInt (copy, "interior", fFights[i][fInterior]);
			INI_WriteString (copy, "name", fFights[i][fName]);

			INI_WriteString (copy, "Zmax", sprintf ("%f,%f", fFights[i][fMaxX], fFights[i][fMaxY]));
			INI_WriteString (copy, "Zmin", sprintf ("%f,%f", fFights[i][fMinX], fFights[i][fMinY]));
		}
*/
		for (new e = 0; e < MAX_FIGHT_SPAWNS; e++)
		{
	    	cache_get_field_content (i, sprintf ("spawn%d", e), tmp);
	    	if (tmp[0] == '\0') continue;
			sscanf(tmp, "p<,>fff", fFights_Spawns[i][e][0], fFights_Spawns[i][e][1], fFights_Spawns[i][e][2]);
/*
			if (createCopy == true)
			{
				INI_WriteString (copy, sprintf ("spawn%d", e), sprintf ("%f,%f,%f", fFights_Spawns[i][e][0], fFights_Spawns[i][e][1], fFights_Spawns[i][e][2]));
			}*/
		}

		fFights[i][fExists] = true;

		//if (createCopy == true) INI_Close (copy);

	}

	printf(">> Loaded %d fights.", i);

    if (p != -1)
    {
        SendClientMessage(p, COLOR_SYSTEM, "Reload ok.");
    }
	return true;
}
/*
forward COMPATIBILITY_FIGHTS(i, name[], tmp[]);
public COMPATIBILITY_FIGHTS(i, name[], tmp[])
{
    printf("COMPATIBILITY_FIGHTS %d %s %s", i, name, tmp);

    for (new e = 0; e < MAX_FIGHT_SPAWNS; e++){
		if (!strcmp(name, sprintf("spawn%d", e), true)) {
	    	sscanf(tmp, "p<,>fff", fFights_Spawns[i][e][0], fFights_Spawns[i][e][1], fFights_Spawns[i][e][2]);
	    	break;
		}
	}

 	if (!strcmp(name, "interior", true)) {
	    fFights[i][fInterior] = strval (tmp);
	}
	else if (!strcmp(name, "played", true)) {
	    fFights[i][fPlayed] = strval (tmp);
	}
	else if (!strcmp(name, "name", true)) {
	    strcpy_2(fFights[i][fName], tmp);
	}
	else if (!strcmp(name, "id", true)) {
		fFights[i][fMySQLid] = strval (tmp);
	}
	else if (!strcmp(name, "Zmax", true)) {
		sscanf(tmp, "p<,>ff", fFights[i][fMaxX], fFights[i][fMaxY]);
	}
	else if (!strcmp(name, "Zmin", true)) {
	    sscanf(tmp, "p<,>ff", fFights[i][fMinX], fFights[i][fMinY]);
	}

    fFights[i][fExists] = true;
}
*/
new lBullet [MAX_LASTBULLET][e_fight_struct]; // la _struct_ del fight va bene pure per last bullet
new Float:lBullet_Spawns [MAX_LASTBULLET][MAX_FIGHT_SPAWNS][3];// idem per MAX_FIGHT_SPAWNS

forward OnLoadLastBullet(p);
public OnLoadLastBullet (p)
{
    FullyReady++;
	new rows, fields, i, tmp[60];
	cache_get_data(rows, fields);

	for(new x = 0; x < MAX_LASTBULLET; x++) lBullet[x][fExists] = false;
//	new INI:copy;

	for(i = 0; i < rows; i++)
	{
	    cache_get_field_content (i, "interior"   , tmp); 	lBullet[i][fInterior] = strval (tmp);
	    cache_get_field_content (i, "played"     , tmp); 	lBullet[i][fPlayed] = strval (tmp);
	    cache_get_field_content (i, "name"       , tmp); 	strcpy_2(lBullet[i][fName], tmp);
	    cache_get_field_content (i, "id"         , tmp); 	lBullet[i][fMySQLid] = strval (tmp);

	    cache_get_field_content (i, "Zmax", tmp);
	    #if GAMEMODE_DEBUG == true
		print(tmp);
		#endif
	    sscanf(tmp, "p<,>ff", lBullet[i][fMaxX], lBullet[i][fMaxY]);

	    cache_get_field_content (i, "Zmin", tmp);
	    #if GAMEMODE_DEBUG == true
		print(tmp);
		#endif
  		sscanf(tmp, "p<,>ff", lBullet[i][fMinX], lBullet[i][fMinY]);

	    printf("XMax: %f XMin: %f YMax: %f YMin: %f", lBullet[i][fMaxX], lBullet[i][fMinX], lBullet[i][fMaxY], lBullet[i][fMinY]);
/*
		if (createCopy == true)
		{
		    copy =
				INI_Open (sprintf("compatibility_mode_slfd/lastbullet/%d.txt", i));

			INI_WriteInt (copy, "played", lBullet[i][fPlayed]);
			INI_WriteInt (copy, "interior", lBullet[i][fInterior]);
			INI_WriteString (copy, "name", lBullet[i][fName]);

			INI_WriteString (copy, "Zmax", sprintf ("%f,%f", lBullet[i][fMaxX], lBullet[i][fMaxY]));
			INI_WriteString (copy, "Zmin", sprintf ("%f,%f", lBullet[i][fMinX], lBullet[i][fMinY]));
		}
*/
		for (new e = 0; e < MAX_FIGHT_SPAWNS; e++)
		{
	    	cache_get_field_content (i, sprintf ("spawn%d", e), tmp);
	    	if (tmp[0] == '\0') continue;
			sscanf(tmp, "p<,>fff", lBullet_Spawns[i][e][0], lBullet_Spawns[i][e][1], lBullet_Spawns[i][e][2]);

			#if GAMEMODE_DEBUG == true
			printf("Last Bullet spawns (%d): %f %f %f", e, lBullet_Spawns[i][e][0], lBullet_Spawns[i][e][1], lBullet_Spawns[i][e][2]);
			#endif
/*
			if (createCopy == true)
			{
				INI_WriteString (copy, sprintf ("spawn%d", e), sprintf ("%f,%f,%f", lBullet_Spawns[i][e][0], lBullet_Spawns[i][e][1], lBullet_Spawns[i][e][2]));
			}*/
		}

  //      if (createCopy == true) INI_Close (copy);

		lBullet[i][fExists] = true;
	}

	printf(">> Loaded %d last bullet arena.", i);

    if (p != -1)
    {
        SendClientMessage(p, COLOR_SYSTEM, "Reload ok.");
    }
}
/*
forward COMPATIBILITY_BULLET(i, name[], tmp[]);
public COMPATIBILITY_BULLET(i, name[], tmp[])
{
    printf("COMPATIBILITY_BULLET %d %s %s", i, name, tmp);

    for (new e = 0; e < MAX_FIGHT_SPAWNS; e++){
		if (!strcmp(name, sprintf("spawn%d", e), true)) {
	    	sscanf(tmp, "p<,>fff", lBullet_Spawns[i][e][0], lBullet_Spawns[i][e][1], lBullet_Spawns[i][e][2]);
	    	break;
		}
	}

 	if (!strcmp(name, "interior", true)) {
	    lBullet[i][fInterior] = strval (tmp);
	}
	else if (!strcmp(name, "played", true)) {
	    lBullet[i][fPlayed] = strval (tmp);
	}
	else if (!strcmp(name, "name", true)) {
	    strcpy_2(lBullet[i][fName], tmp);
	}
	else if (!strcmp(name, "id", true)) {
		lBullet[i][fMySQLid] = strval (tmp);
	}
	else if (!strcmp(name, "Zmax", true)) {
		sscanf(tmp, "p<,>ff", lBullet[i][fMaxX], lBullet[i][fMaxY]);
	}
	else if (!strcmp(name, "Zmin", true)) {
	    sscanf(tmp, "p<,>ff", lBullet[i][fMinX], lBullet[i][fMinY]);
	}

    lBullet[i][fExists] = true;
}

*/
// #weaponsets
forward OnLoadWeaponsets();
public OnLoadWeaponsets()
{
    FullyReady++;
	new rows, fields, i, r, tmp[20];
	cache_get_data(rows, fields);

	new id;
//	new INI:copy;

/*	if (createCopy)
		copy = INI_Open ("compatibility_mode_slfd/weaponsets.txt");
*/
	for (i = 0, r = (rows > MAX_WEAPON_SETS ? MAX_WEAPON_SETS - 1 : rows) ; i < r; i++)
	{
	    cache_get_field_content (i, "id", tmp); id = strval (tmp);

	    cache_get_field_content (i, "mselection", tmp); Weaponsets[id][Limit] = strval (tmp);
	    cache_get_field_content (i, "limited", tmp); Weaponsets[id][Limited] = bool:strval (tmp);
	    cache_get_field_content (i, "enabled", tmp); Weaponsets[id][Enabled] = bool:strval (tmp);

	/*	if (createCopy == true)
		{
			INI_SetTag (copy, numstr(id));

			INI_WriteInt (copy, "limit", Weaponsets[id][Limit]);
			INI_WriteBool (copy, "limited", Weaponsets[id][Limited]);
			INI_WriteBool (copy, "enabled", Weaponsets[id][Enabled]);
		}*/
	}
	/*
	if (createCopy)
		INI_Close (copy);*/

	printf(">> Loaded config for %d weaponsets.", i);

	Server_RefreshStats(Gamemode_Runs, 1);

    FullyReady ++;
	printf(" .. I'm ready in %d s (Steps: %d / %d) (Heapspace: %i Kb free)!", gettime() - StartTick, FullyReady, FULLY_READY_STEPS, heapspace() / 1024);

	SendClientMessageToAll(-1, "*** Gamemode loaded!");
	return 1;
}
/*
forward COMPATIBILITY_WEAPONSETS(tag[], name[], tmp[]);
public COMPATIBILITY_WEAPONSETS(tag[], name[], tmp[])
{
    printf("COMPATIBILITY_WEAPONSETS %s %s %s", tag, name, tmp);

	new
	    id = strval (tag);

 	if (!strcmp(name, "limit", true)) {
	    Weaponsets[id][Limit] = strval (tmp);
	}
	else if (!strcmp(name, "limited", true)) {
	    Weaponsets[id][Limited] = bool:strval (tmp);
	}
	else if (!strcmp(name, "enabled", true)) {
	    Weaponsets[id][Enabled] = bool:strval (tmp);
	}
}


new NotMoving[MAX_PLAYERS];
new WeaponID[MAX_PLAYERS];
new CheckCrouch[MAX_PLAYERS];
new Ammo[MAX_PLAYERS][48];
*/
////////////////////////////////////////////////////////////////////////////////
//==============================================================================
////////////////////////////////////////////////////////////////////////////////
//vote system
enum VoteTypes
{
	VOTETYPE_NULL,
	VOTETYPE_RESETSCORES,
	VOTETYPE_STARTBASE,
	VOTETYPE_STARTARENA,
	VOTETYPE_STARTINT,
	VOTETYPE_PLAYERKICK,
	VOTETYPE_STARTGUNGAME,
	VOTETYPE_STARTTDM,
	VOTETYPE_ESLADD,
	VOTETYPE_MINPLAYERS,
}

enum E_VOTES_DATAS
{
    VoteTypes:Votetype,
    VoteInformations,       		// esempio id del player da kickare, oppure id della base da startare
    Votes,   						// voti che ha ricevuto
	VoteStarter,         			// chi ha startato questa votazione
	Timer:TimerVotazione,  			// variabile timer della votazione
	bool:Started,               	// la votazione ï¿½ startata?
	bool:IHaveVoted[MAX_PLAYERS],   // indica se il player passando ha giï¿½ votato VotesRunning[VOTAZIONE_ID][IHaveVoted][PLAYERID]
}

new VotesRunning[MAX_VOTAZIONI][E_VOTES_DATAS];
new Timer:StartingVoting = Timer:-1;
new bool:VoteTypeEnabled[12] = {true, ...};


COMMAND:vote(playerid, params[])
{
/*
	if (Iter_Count(Player) < 1)
	    return SendClientMessage(playerid, COLOR_RED, "You cannot start a vote now!");
*/
	new id, tmp[50];

	if(sscanf(params, "s[50]I(-1)", tmp, id))
	{
 		SendClientMessage(playerid, COLOR_SYSTEM, "Use /vote [aad,arena,tdm,int,gungame,resetscores,playerkick] [ID]");
		if (gConfig[GameMode] == GAMEMODE_ESL) {
		    SendClientMessage(playerid, COLOR_SYSTEM, "ESL Votes: /vote [add, minplayers]");
		}
	    return true;
	}

    if (!strcmp(tmp, "aad", true))
    {
	    if (!VoteTypeEnabled[_:VOTETYPE_STARTBASE])
	        return SendClientMessage(playerid, COLOR_RED, "AAD vote Disabled.");

	    if (RoundStarted)
	        return SendClientMessage(playerid, COLOR_RED, "Round already started.");

		if (Player[playerid][Voted])
		    return SendClientMessage(playerid, COLOR_RED, "You already voted for vote-start.");

		new bool:already_started = false;

		if (id == -1 || id > MAX_BASES)
		    return SendClientMessage(playerid, COLOR_SYSTEM, "Use /vote [aad] [ID]");

		if (!bBases[id][Exists])
		    return SendClientMessage(playerid, COLOR_RED, "Invalid base id");

		for (new i = 0; i < sizeof(VotesRunning); i++)
		{
		    if (VotesRunning[i][VoteStarter] == playerid)
		    {
		        already_started = true;
		    }

		    if (VotesRunning[i][Votetype] == VOTETYPE_STARTBASE)
		    {
			    if (VotesRunning[i][VoteInformations] == id)
			    {
			        VotesRunning[i][Votes] ++;
			        format(stringo, sizeof stringo, "{"#COLOR_SYSTEM_FOCUS"}%s{"#COLOR_SYSTEM_REST"} voted for AAD round. (ID: %d | Votes: %d)", Player[playerid][Nickname], VotesRunning[i][VoteInformations], VotesRunning[i][Votes]);
                    SendClientMessageToAll(COLOR_SYSTEM, stringo);
					return true;
			    }
			}
		}

		if (already_started)
		{
		    SendClientMessage(playerid, COLOR_RED, "You can take part in every vote, but you cannot start a new one.");
		    return true;
		}

		new
			freeslot = -1;

		for (new i = 0; i < MAX_VOTAZIONI; i++)
		{
		    if (!VotesRunning[i][Started])
		    {
		        freeslot = i;
		    }
		}

		// votazione non presente
		if (freeslot == -1)
			return SendClientMessage(playerid, COLOR_RED, "You cannot start other votes");

		VotesRunning[freeslot][VoteInformations] 	= id;
		VotesRunning[freeslot][Votes] 				= 1;
		VotesRunning[freeslot][Votetype] 			= VOTETYPE_STARTBASE;
		VotesRunning[freeslot][VoteStarter] 		= playerid;
		VotesRunning[freeslot][Started] 			= true;
//		VotesRunning[StartedVotes][TimerVotazione] 		= SetTimerEx("Finish_Votazione", 120000, false, "i", StartedVotes);
        Player[playerid][Voted]			 			= true;

        format(stringo, sizeof stringo, "{"#COLOR_SYSTEM_FOCUS"}%s{"#COLOR_SYSTEM_REST"} voted for AAD round. (ID: %d | Votes: %d)", Player[playerid][Nickname], VotesRunning[freeslot][VoteInformations], VotesRunning[freeslot][Votes]);
        SendClientMessageToAll(COLOR_SYSTEM, stringo);
		if (StartingVoting == Timer:-1) // avvia il primo timer degli starting
		{
            //StartingVoting = SetTimer("FinishVotazioni_Starting", VOTE_VOTETIME, false);
            StartingVoting = defer FinishVotazioni_Starting();
		}
	}
	else if (!strcmp(tmp, "arena", true))
	{
	    if (!VoteTypeEnabled[_:VOTETYPE_STARTARENA])
	        return SendClientMessage(playerid, COLOR_RED, "Arena vote Disabled.");

	    if (RoundStarted)
	        return SendClientMessage(playerid, COLOR_RED, "Round already started.");

		if (Player[playerid][Voted])
		    return SendClientMessage(playerid, COLOR_RED, "You already voted for vote-start.");

		new bool:already_started = false;

		if (id == -1 || id > MAX_ARENE)
		    return SendClientMessage(playerid, COLOR_SYSTEM, "Use /vote [arena] [ID]");

		if (!aArene[id][Exists])
		    return SendClientMessage(playerid, COLOR_RED, "Invalid Arena id");

		for (new i = 0; i < sizeof(VotesRunning); i++)
		{
		    if (VotesRunning[i][VoteStarter] == playerid)
		    {
		        already_started = true;
		    }

		    if (VotesRunning[i][Votetype] == VOTETYPE_STARTARENA)
		    {
			    if (VotesRunning[i][VoteInformations] == id)
			    {
			        VotesRunning[i][Votes] ++;

			        format(stringo, sizeof stringo,"{"#COLOR_SYSTEM_FOCUS"}%s{"#COLOR_SYSTEM_REST"} voted for Arena round. (ID: %d | Votes: %d)", Player[playerid][Nickname], VotesRunning[i][VoteInformations], VotesRunning[i][Votes]);
                    SendClientMessageToAll(COLOR_SYSTEM, stringo);
					return true;
			    }
			}
		}

		if (already_started)
		{
		    SendClientMessage(playerid, COLOR_RED, "You can take part in every vote, but you cannot start a new one.");
		    return true;
		}

		new
			freeslot = -1;

		for (new i = 0; i < MAX_VOTAZIONI; i++)
		{
		    if (!VotesRunning[i][Started])
		    {
		        freeslot = i;
		    }
		}

		// votazione non presente
		if (freeslot == -1)
			return SendClientMessage(playerid, COLOR_RED, "You cannot start other votes");

		VotesRunning[freeslot][VoteInformations] 	= id;
		VotesRunning[freeslot][Votes] 				= 1;
		VotesRunning[freeslot][Votetype] 			= VOTETYPE_STARTARENA;
		VotesRunning[freeslot][VoteStarter] 		= playerid;
		VotesRunning[freeslot][Started] 			= true;
//		VotesRunning[StartedVotes][TimerVotazione] 		= SetTimerEx("Finish_Votazione", 120000, false, "i", StartedVotes);
        Player[playerid][Voted] 					= true;

        format(stringo, sizeof stringo, "{"#COLOR_SYSTEM_FOCUS"}%s{"#COLOR_SYSTEM_REST"} voted for Arena round. (ID: %d | Votes: %d)", Player[playerid][Nickname], VotesRunning[freeslot][VoteInformations], VotesRunning[freeslot][Votes]);
        SendClientMessageToAll(COLOR_SYSTEM, stringo);

		if (StartingVoting == Timer:-1) // avvia il primo timer degli starting
		{
            //StartingVoting = SetTimer("FinishVotazioni_Starting", VOTE_VOTETIME, false);
            StartingVoting = defer FinishVotazioni_Starting();
		}
	}//VOTETYPE_STARTTDM
	else if (!strcmp(tmp, "tdm", true))
	{
	    if (!VoteTypeEnabled[_:VOTETYPE_STARTTDM])
	        return SendClientMessage(playerid, COLOR_RED, "TDM vote Disabled.");

	    if (RoundStarted)
	        return SendClientMessage(playerid, COLOR_RED, "Round already started.");

		if (Player[playerid][Voted])
		    return SendClientMessage(playerid, COLOR_RED, "You already voted for vote-start.");

		new bool:already_started = false;

		if (id == -1 || id > MAX_ARENE)
		    return SendClientMessage(playerid, COLOR_SYSTEM, "Use /vote [tdm] [ID]");

		if (!aArene[id][Exists])
		    return SendClientMessage(playerid, COLOR_RED, "Invalid Gungame id");

		for (new i = 0; i < sizeof(VotesRunning); i++)
		{
		    if (VotesRunning[i][VoteStarter] == playerid)
		    {
		        already_started = true;
		    }

		    if (VotesRunning[i][Votetype] == VOTETYPE_STARTGUNGAME)
		    {
			    if (VotesRunning[i][VoteInformations] == id)
			    {
			        VotesRunning[i][Votes] ++;
			        format(stringo, sizeof stringo, "{"#COLOR_SYSTEM_FOCUS"}%s{"#COLOR_SYSTEM_REST"} voted for TDM round. (ID: %d | Votes: %d)", Player[playerid][Nickname], VotesRunning[i][VoteInformations], VotesRunning[i][Votes]);
                    SendClientMessageToAll(COLOR_SYSTEM, stringo);
					return true;
			    }
			}
		}

		if (already_started)
		{
		    SendClientMessage(playerid, COLOR_RED, "You can take part in every vote, but you cannot start a new one.");
		    return true;
		}

		new
			freeslot = -1;

		for (new i = 0; i < MAX_VOTAZIONI; i++)
		{
		    if (!VotesRunning[i][Started])
		    {
		        freeslot = i;
		    }
		}

		// votazione non presente
		if (freeslot == -1)
			return SendClientMessage(playerid, COLOR_RED, "You cannot start other votes");

		VotesRunning[freeslot][VoteInformations] 	= id;
		VotesRunning[freeslot][Votes] 				= 1;
		VotesRunning[freeslot][Votetype] 			= VOTETYPE_STARTTDM;
		VotesRunning[freeslot][VoteStarter] 		= playerid;
		VotesRunning[freeslot][Started] 			= true;
//		VotesRunning[StartedVotes][TimerVotazione] 		= SetTimerEx("Finish_Votazione", 120000, false, "i", StartedVotes);
        Player[playerid][Voted] 					= true;

        format(stringo, sizeof stringo, "{"#COLOR_SYSTEM_FOCUS"}%s{"#COLOR_SYSTEM_REST"} voted for TDM round. (ID: %d | Votes: %d)", Player[playerid][Nickname], VotesRunning[freeslot][VoteInformations], VotesRunning[freeslot][Votes]);
        SendClientMessageToAll(COLOR_SYSTEM, stringo);

		if (StartingVoting == Timer:-1) // avvia il primo timer degli starting
		{
            //StartingVoting = SetTimer("FinishVotazioni_Starting", VOTE_VOTETIME, false);
            StartingVoting = defer FinishVotazioni_Starting();
		}
	}
	else if (!strcmp(tmp, "gungame", true))
	{
	    if (!VoteTypeEnabled[_:VOTETYPE_STARTGUNGAME])
	        return SendClientMessage(playerid, COLOR_RED, "Gungame vote Disabled.");

	    if (RoundStarted)
	        return SendClientMessage(playerid, COLOR_RED, "Round already started.");

		if (Player[playerid][Voted])
		    return SendClientMessage(playerid, COLOR_RED, "You already voted for vote-start.");

		new bool:already_started = false;

		if (id == -1 || id > MAX_GUNGAME)
		    return SendClientMessage(playerid, COLOR_SYSTEM, "Use /vote [gungame] [ID]");

		if (!gGunGame[id][Exists])
		    return SendClientMessage(playerid, COLOR_RED, "Invalid Gungame id");

		for (new i = 0; i < sizeof(VotesRunning); i++)
		{
		    if (VotesRunning[i][VoteStarter] == playerid)
		    {
		        already_started = true;
		    }

		    if (VotesRunning[i][Votetype] == VOTETYPE_STARTGUNGAME)
		    {
			    if (VotesRunning[i][VoteInformations] == id)
			    {
			        VotesRunning[i][Votes] ++;
			        format(stringo, sizeof stringo, "{"#COLOR_SYSTEM_FOCUS"}%s{"#COLOR_SYSTEM_REST"} voted for Gungame round. (ID: %d | Votes: %d)", Player[playerid][Nickname], VotesRunning[i][VoteInformations], VotesRunning[i][Votes]);
                    SendClientMessageToAll(COLOR_SYSTEM, stringo);
					return true;
			    }
			}
		}

		if (already_started)
		{
		    SendClientMessage(playerid, COLOR_RED, "You can take part in every vote, but you cannot start a new one.");
		    return true;
		}

		new
			freeslot = -1;

		for (new i = 0; i < MAX_VOTAZIONI; i++)
		{
		    if (!VotesRunning[i][Started])
		    {
		        freeslot = i;
		    }
		}

		// votazione non presente
		if (freeslot == -1)
			return SendClientMessage(playerid, COLOR_RED, "You cannot start other votes");

		VotesRunning[freeslot][VoteInformations] 	= id;
		VotesRunning[freeslot][Votes] 				= 1;
		VotesRunning[freeslot][Votetype] 			= VOTETYPE_STARTGUNGAME;
		VotesRunning[freeslot][VoteStarter] 		= playerid;
		VotesRunning[freeslot][Started] 			= true;
//		VotesRunning[StartedVotes][TimerVotazione] 		= SetTimerEx("Finish_Votazione", 120000, false, "i", StartedVotes);
        Player[playerid][Voted] 					= true;

        format(stringo, sizeof stringo, "{"#COLOR_SYSTEM_FOCUS"}%s{"#COLOR_SYSTEM_REST"} voted for Gungame round. (ID: %d | Votes: %d)", Player[playerid][Nickname], VotesRunning[freeslot][VoteInformations], VotesRunning[freeslot][Votes]);
        SendClientMessageToAll(COLOR_SYSTEM, stringo);

		if (StartingVoting == Timer:-1) // avvia il primo timer degli starting
		{
            //StartingVoting = SetTimer("FinishVotazioni_Starting", VOTE_VOTETIME, false);
            StartingVoting = defer FinishVotazioni_Starting();
		}
	}
 	else if (!strcmp(tmp, "playerkick", true))
	{
	    /*
	    SendClientMessage(playerid, COLOR_RED, "* Votekick is disabled.");
		#error commenta questo se togli il commento grande
		tmp = strtok( params , idx );
		if (isnull(tmp))
		    return SendClientMessage(playerid, COLOR_SYSTEM, "Use /vote playerkick [ID]");

		if (Player[playerid][Voted])
		    return SendClientMessage(playerid, COLOR_RED, "You already voted for vote-start.");

		new id = strval(tmp), bool:already_started = false;

		if (!IsPlayerConnected(id))
		    return SendClientMessage(playerid, COLOR_RED, "Invalid player id");

		if (!IsPlayerAdmin(id) || Player[id][aLevel] > 0)
		    return SendClientMessage(playerid, COLOR_RED, "You cannot start a vote kick with this player (admin)");

		if (Iter_Count(Player) < 4)
		    return SendClientMessage(playerid, COLOR_RED, "4 players must be connected to use vote kick.");

		for (new i = 0; i < sizeof(VotesRunning); i++)
		{
		    if (VotesRunning[i][VoteStarter] == playerid)
		    {
		        already_started = true;
		    }

		    if (VotesRunning[i][Votetype] == VOTETYPE_PLAYERKICK)
		    {
			    if (VotesRunning[i][VoteInformations] == id)
			    {
			        VotesRunning[i][Votes] ++;
			        SendClientMessageToAll(COLOR_SYSTEM, "%s voted to kick %s. (Votes: %d/%d)", Player[playerid][Nickname], Player[VotesRunning[i][VoteInformations]][Nickname], VotesRunning[i][Votes], Iter_Count(Player));
			        return true;
			    }
			}
		}

		if (already_started)
		{
		    SendClientMessage(playerid, COLOR_RED, "Puoi esprimere il tuo voto per ogni votazione, ma ne puoi avviare una sola.");
		    return true;
		}

		new
			freeslot = -1;

		for (new i = 0; i < MAX_VOTAZIONI; i++)
		{
		    if (!VotesRunning[i][Started])
		    {
		        freeslot = i;
		    }
		}

		// votazione non presente
		if (freeslot == -1)
			return SendClientMessage(playerid, COLOR_RED, "Non puoi avviare altre votazioni");

		VotesRunning[freeslot][VoteInformations] 	= id;
		VotesRunning[freeslot][Votes] 				= 1;
		VotesRunning[freeslot][Votetype] 			= VOTETYPE_PLAYERKICK;
		VotesRunning[freeslot][VoteStarter] 		= playerid;
		VotesRunning[freeslot][Started] 			= true;
		VotesRunning[freeslot][TimerVotazione] 		= SetTimerEx("Finish_Votazione", 120000, false, "i", freeslot);
        Player[playerid][Voted][freeslot] 			= true;

        SendClientMessageToAll(COLOR_SYSTEM, "%s voted to kick %s. (Votes: %d/%d)", Player[playerid][Nickname], Player[VotesRunning[freeslot][VoteInformations]][Nickname], VotesRunning[freeslot][Votes], Iter_Count(Player));
		*/
	}
	else if (!strcmp(tmp, "resetscores", true))
	{
	    if (!VoteTypeEnabled[_:VOTETYPE_RESETSCORES])
	        return SendClientMessage(playerid, COLOR_RED, "Resetscores vote Disabled.");

	    if (Player[playerid][nVoted])
	        return SendClientMessage(playerid, COLOR_RED, "You already voted for resetscores.");

	    if (gConfig[Matchmode] == MATCHMODE_NOSCORES)
	        return SendClientMessage(playerid, COLOR_RED, "Matchmode is NO SCORES.");

		if (RoundStarted)
  			SendClientMessageToAll(COLOR_SYSTEM, "A round is in progress, you cannot start a resetscores vote now.");

	    new
	        freeslot = -1;

		for (new i = 0; i < MAX_VOTAZIONI; i++)
		{
		    if (VotesRunning[i][Started] == true)
		    {
				if (VotesRunning[i][Votetype] == VOTETYPE_RESETSCORES)
				{
				    Player[playerid][nVoted] 					= true;
				    VotesRunning[i][Votes] ++;
			        format(stringo, sizeof stringo, "{"#COLOR_SYSTEM_FOCUS"}%s{"#COLOR_SYSTEM_REST"} voted to resetscores. (Votes: %d/%d)", Player[playerid][Nickname], VotesRunning[i][Votes], Iter_Count(Player));
                    SendClientMessageToAll(COLOR_SYSTEM, stringo);

					if (VotesRunning[i][Votes] == Iter_Count(Player))
				    {
				        stop VotesRunning[i][TimerVotazione];
					    SendClientMessageToAll(COLOR_SYSTEM, "The vote to reset scores is finished! All players voted Yes!");

						/*
						foreach(new x:Player)
						{
						    Player[x][Kills] = 0;
						    Player[x][Deaths] = 0;
						    Player[x][Damage] = 0;
						    Player[x][RKills] = 0;
						    Player[x][RDamage] = 0;
							SetPlayerScore(x, 0);
						}

						// Clean up all stats
						for (new x = 0; x < MAX_PLAYERS; x++)
						{
						    Player[x][Kills] = 0;
						    Player[x][Deaths] = 0;
						    Player[x][Damage] = 0;
						    Player[x][RKills] = 0;
						    Player[x][RDamage] = 0;
						    SetPlayerScore(x, 0);
						}

						if (gConfig[Matchmode] != MATCHMODE_NOSCORES)
						{
							iTeam[TEAM_A][RoundWins] = 0;
							iTeam[TEAM_B][RoundWins] = 0;
						}

						PlayingRound = 0;
						RefreshTextGeneralTD();*/
						ResetScores();
				    }
				    return true;
				}
			}
			else
			{
			    freeslot = i;
			}
		}

		if (freeslot == -1)
		    return SendClientMessage(playerid, COLOR_RED, "Non puoi avviare altre votazioni");

		VotesRunning[freeslot][VoteInformations] 	= 0;
		VotesRunning[freeslot][Votes] 				= 1;
		VotesRunning[freeslot][Votetype] 			= VOTETYPE_RESETSCORES;
		VotesRunning[freeslot][VoteStarter] 		= playerid;
		VotesRunning[freeslot][Started] 			= true;
		VotesRunning[freeslot][TimerVotazione] 		= defer Finish_Votazione(freeslot); //SetTimerEx("Finish_Votazione", VOTE_VOTETIME, false, "i", freeslot);
        Player[playerid][nVoted] 					= true;

        format(stringo, sizeof stringo, "{"#COLOR_SYSTEM_FOCUS"}%s{"#COLOR_SYSTEM_REST"} voted to reset scores. (Votes: %d/%d)", Player[playerid][Nickname], VotesRunning[freeslot][Votes], Iter_Count(Player));
        SendClientMessageToAll(COLOR_SYSTEM, stringo);
	}
	else if (!strcmp(tmp, "add", true))
	{
	    if (gConfig[GameMode] != GAMEMODE_ESL) {
	        SendClientMessage(playerid, COLOR_RED, "Questa votazione ï¿½ valida solo durante la modalitï¿½ ESL.");
	        return true;
	    }

	    if (!IsPlayerConnected(id)) {
	        SendClientMessage(playerid, COLOR_RED, "Invalid ID. Use /vote add [PLAYER_ID]");
	        return true;
	    }

	    if (id == playerid)
	    {
	        SendClientMessage(playerid, COLOR_RED, "NO");
	        return true;
	    }

	    // domani ï¿½ oggi
	    // ed ï¿½ giï¿½ qua

	    if (!VoteTypeEnabled[_:VOTETYPE_ESLADD])
	        return SendClientMessage(playerid, COLOR_RED, "ADD vote Disabled.");

		if (!RoundStarted)
  			SendClientMessageToAll(COLOR_SYSTEM, "A round isn't in progress, you cannot start an add vote now.");

	    new
	        freeslot = -1;

		for (new i = 0; i < MAX_VOTAZIONI; i++)
		{
		    if (VotesRunning[i][Started] == true)
		    {
				if (VotesRunning[i][Votetype] == VOTETYPE_ESLADD && VotesRunning[i][VoteInformations] == id)
				{
					if (VotesRunning[i][IHaveVoted][playerid])
					{
					    SendClientMessage(playerid, COLOR_RED, "You already voted for add him.");
					    return true;
					}

					VotesRunning[i][IHaveVoted][playerid] = true;
				    VotesRunning[i][Votes] ++;
			        format(stringo, sizeof stringo, "{"#COLOR_SYSTEM_FOCUS"}%s{"#COLOR_SYSTEM_REST"} voted to add %s. (Votes: %d/%d)", Player[playerid][Nickname], VotesRunning[i][Votes], Iter_Count(Player));
                    SendClientMessageToAll(COLOR_SYSTEM, stringo);

				    if (VotesRunning[i][Votes] == Iter_Count(Player) - 1)
				    {
				        stop VotesRunning[i][TimerVotazione];
				        format(stringo, sizeof stringo, "The vote to add %d is finished! All players voted Yes!", Player[id][Nickname]);
                        SendClientMessageToAll(COLOR_SYSTEM, stringo);
						//add id
					    cmd_add(GAMEMODE_ID_ARR, numstr(id));
				    }
				    return true;
				}
			}
			else
			{
			    freeslot = i;
			}
		}

		if (freeslot == -1)
		    return SendClientMessage(playerid, COLOR_RED, "Non puoi avviare altre votazioni");

		VotesRunning[freeslot][Votes] 				= 1;
		VotesRunning[freeslot][Votetype] 			= VOTETYPE_ESLADD;
		VotesRunning[freeslot][VoteStarter] 		= playerid;
		VotesRunning[freeslot][Started] 			= true;
        VotesRunning[freeslot][IHaveVoted][playerid] = true;
        VotesRunning[freeslot][VoteInformations]    = id;

        format(stringo, sizeof stringo, "{"#COLOR_SYSTEM_FOCUS"}%s{"#COLOR_SYSTEM_REST"} voted to add %s. (Votes: %d/%d)", Player[playerid][Nickname], Player[id][Nickname], VotesRunning[freeslot][Votes], Iter_Count(Player)-1);
        SendClientMessageToAll(COLOR_SYSTEM, stringo);

	    if (VotesRunning[freeslot][Votes] == Iter_Count(Player) - 1)
	    {
	        format(stringo, sizeof stringo, "The vote to add %d is finished! All players voted Yes!", Player[id][Nickname]);
            SendClientMessageToAll(COLOR_SYSTEM, stringo);
			//add id
		    cmd_add(GAMEMODE_ID_ARR, numstr(id));
	    }
	    else
		{
			VotesRunning[freeslot][TimerVotazione] 		= defer Finish_Votazione(freeslot); //SetTimerEx("Finish_Votazione", VOTE_VOTETIME, false, "i", freeslot);
		}
	}
	else if (!strcmp(tmp, "minplayers", true))
	{
	    if (Iter_Count(Player) < 4) {
	        SendClientMessage(playerid, COLOR_RED, "Questa votazione richiede almeno 4 players.");
	        return true;
	    }

	    if (gConfig[GameMode] != GAMEMODE_ESL) {
	        SendClientMessage(playerid, COLOR_RED, "Questa votazione ï¿½ valida solo durante la modalitï¿½ ESL.");
	        return true;
	    }

	    if (id == 0 || id > 19) {
	        SendClientMessage(playerid, COLOR_RED, "Invalid Num. Use /vote minplayers [MIN PLAYERS]");
	        return true;
	    }

	    // domani ï¿½ oggi
	    // ed ï¿½ giï¿½ qua

	    if (!VoteTypeEnabled[_:VOTETYPE_MINPLAYERS])
	        return SendClientMessage(playerid, COLOR_RED, "Min Players vote Disabled.");

		if (RoundStarted)
  			SendClientMessageToAll(COLOR_SYSTEM, "A round is in progress, you cannot start a vote now.");

	    new
	        freeslot = -1;

		for (new i = 0; i < MAX_VOTAZIONI; i++)
		{
		    if (VotesRunning[i][Started] == true)
		    {
				if (VotesRunning[i][Votetype] == VOTETYPE_MINPLAYERS && VotesRunning[i][VoteInformations] == id)
				{
					if (VotesRunning[i][IHaveVoted][playerid])
					{
					    SendClientMessage(playerid, COLOR_RED, "You already voted!.");
					    return true;
					}

					VotesRunning[i][IHaveVoted][playerid] = true;
				    VotesRunning[i][Votes] ++;
			        format(stringo, sizeof stringo, "{"#COLOR_SYSTEM_FOCUS"}%s{"#COLOR_SYSTEM_REST"} voted to change min players to %d. (Votes: %d/%d)", Player[playerid][Nickname], id, VotesRunning[i][Votes], Iter_Count(Player));
                    SendClientMessageToAll(COLOR_SYSTEM, stringo);

				    if (VotesRunning[i][Votes] == Iter_Count(Player))
				    {
				        stop VotesRunning[i][TimerVotazione];
				        format(stringo, sizeof stringo, "The vote to change min players to %d is finished! All players voted Yes!", Player[id][Nickname]);
                        SendClientMessageToAll(COLOR_SYSTEM, stringo);
						//change min players for /ready
					    //cmd_add(GAMEMODE_ID_ARR, numstr(id));

					    MinReadyPlayers = id;
				    }
				    return true;
				}
			}
			else
			{
			    freeslot = i;
			}
		}

		if (freeslot == -1)
		    return SendClientMessage(playerid, COLOR_RED, "Non puoi avviare altre votazioni");

		VotesRunning[freeslot][Votes] 				= 1;
		VotesRunning[freeslot][Votetype] 			= VOTETYPE_MINPLAYERS;
		VotesRunning[freeslot][VoteStarter] 		= playerid;
		VotesRunning[freeslot][Started] 			= true;
		VotesRunning[freeslot][TimerVotazione] 		= defer Finish_Votazione(freeslot); //SetTimerEx("Finish_Votazione", VOTE_VOTETIME, false, "i", freeslot);
        VotesRunning[freeslot][IHaveVoted][playerid]       = true;
        VotesRunning[freeslot][VoteInformations]    = id;

        format(stringo, sizeof stringo, "{"#COLOR_SYSTEM_FOCUS"}%s{"#COLOR_SYSTEM_REST"} voted to change min players to %d. (Votes: %d/%d)", Player[playerid][Nickname], id, VotesRunning[freeslot][Votes], Iter_Count(Player));
        SendClientMessageToAll(COLOR_SYSTEM, stringo);
	}
	//
	return true;
}

//forward Finish_Votazione(idx);
timer Finish_Votazione[VOTE_VOTETIME](idx)
{
	switch (VotesRunning[idx][Votetype])
	{
	    case VOTETYPE_MINPLAYERS:
	    {
            new num = VotesRunning[idx][VoteInformations];

            if (gConfig[GameMode] == GAMEMODE_ESL)
            {
	            if (VotesRunning[idx][Votes] == (Iter_Count(Player)))
	            {
                    format (stringo, sizeof stringo, "The vote to change min players to %d is finished! All players voted Yes!", num);
                    SendClientMessageToAll(COLOR_SYSTEM, stringo);

					MinReadyPlayers = num;
				}
				else
				{
				    format(stringo, sizeof stringo, "The vote to change min players to %d failed!", num);
					SendClientMessageToAll(COLOR_SYSTEM, stringo);
				}
			}
			else
			{
				SendClientMessageToAll(COLOR_RED, "Voting failed. (No more esl?)");
			}
	    }
	    case VOTETYPE_ESLADD:
	    {
			new id = VotesRunning[idx][VoteInformations];

			if (IsPlayerConnected(id))
			{
				if (gConfig[GameMode] == GAMEMODE_ESL)
				{
					if (RoundStarted)
					{
					    if (VotesRunning[idx][Votes] == (Iter_Count(Player) - 1))
					    {
						    format(stringo, sizeof stringo, "The vote to add %s is finished! All players voted Yes!", Player[id][Nickname]);
						    SendClientMessageToAll(COLOR_SYSTEM, stringo);

						    cmd_add(GAMEMODE_ID_ARR, numstr(id));
						}
						else
						{
						    format(stringo, sizeof stringo, "The vote to add %s failed!", Player[id][Nickname]);
						    SendClientMessageToAll(COLOR_SYSTEM, stringo);
						}
					}
					else
					{
					    format(stringo, sizeof stringo, "Voting about %s failed. (Round ended)", Player[id][Nickname]);
					    SendClientMessageToAll(COLOR_RED, stringo);
					}
				}
				else
				{
				    format(stringo, sizeof stringo, "Voting about %s failed. (No more esl?)", Player[id][Nickname]);
                    SendClientMessageToAll(COLOR_RED, stringo);
				}
			}
			else
			{
			    format (stringo, sizeof stringo, "Voting about %s failed. (Disconnected?)", Player[id][Nickname]);
			    SendClientMessageToAll(COLOR_RED, stringo);
			}
	    }/*
	    case VOTETYPE_PLAYERKICK:
	    {
			new id = VotesRunning[idx][VoteInformations];

			if (!IsPlayerConnected(id))
   			{
		   		SendClientMessageToAll(COLOR_RED, "Voting about %s failed. (Disconnected?)", Player[id][Nickname]);
				return 1;
			}

			if (!IsPlayerAdmin(id) || E_ADMIN_LEVELS:Player[id][aLevel] > lMod)
   			{
		   		SendClientMessageToAll(COLOR_RED, "Voting about %s failed. (Admin)", Player[id][Nickname]);
				return 1;
			}

			if (VotesRunning[idx][Votes] == (Iter_Count(Player) - 1))
			{
			    SendClientMessageToAll(COLOR_SYSTEM, "The vote to kick %s is finished! All players voted Yes!", Player[id][Nickname]);
			    Kick(id, "Votekick");
			}
			else
			{
			    SendClientMessageToAll(COLOR_SYSTEM, "The vote to kick %s failed!", Player[id][Nickname]);
			}
	    }*/
	    case VOTETYPE_RESETSCORES:
	    {
	        if (RoundStarted)
	        {
	            SendClientMessageToAll(COLOR_SYSTEM, "The vote to reset scores failed! (Round started)");
	        }
	        else
	        {
				if (VotesRunning[idx][Votes] == Iter_Count(Player))
				{
				    SendClientMessageToAll(COLOR_SYSTEM, "The vote to reset scores is finished! All players voted Yes!");

					/*
					foreach(new i:Player)
					{
					    Player[i][Kills] = 0;
					    Player[i][Deaths] = 0;
					    Player[i][Damage] = 0;
					    Player[i][RKills] = 0;
					    Player[i][RDamage] = 0;
						SetPlayerScore(i, 0);

						PlayerTextDrawSetString (i, PlayerInfo[1], "DMG ~b~~h~0~n~~w~Tot. DMG ~b~~h~0");
					}


					for (new i = 0; i < MAX_PLAYERS; i++)
					{
					    Player[i][Kills] = 0;
					    Player[i][Deaths] = 0;
					    Player[i][Damage] = 0;
					    Player[i][RKills] = 0;
					    Player[i][RDamage] = 0;

						SetPlayerScore(i, 0);
						PlayerTextDrawSetString (i, PlayerInfo[1], "DMG ~b~~h~0~n~~w~Tot. DMG ~b~~h~0");
					}

					if (gConfig[Matchmode] != MATCHMODE_NOSCORES)
					{
						iTeam[TEAM_A][RoundWins] = 0;
						iTeam[TEAM_B][RoundWins] = 0;
					}

					PlayingRound = 0;
					RefreshTextGeneralTD();*/
					ResetScores();
				}
				else
				{
				    SendClientMessageToAll(COLOR_SYSTEM, "The vote to reset scores failed!");
				}
			}

			for (new i = 0; i < MAX_PLAYERS; i++)
				Player[i][nVoted] = false;
	    }
	}

	VotesRunning[idx][Started] 				= false;
  	VotesRunning[idx][Votes]   				= 0;
	VotesRunning[idx][VoteInformations]   	= -1;
 	VotesRunning[idx][Votetype]   			= VOTETYPE_NULL;
  	VotesRunning[idx][VoteStarter]   		= INVALID_PLAYER_ID;

  	for (new i = 0; i < MAX_PLAYERS; i++)
  	    VotesRunning[idx][IHaveVoted][i] = false;
  	return true;
}
//acierno elisa<_<stfu .i.
//forward FinishVotazioni_Starting();
timer FinishVotazioni_Starting[VOTE_VOTETIME]()
{
	new
	    maxVotedId = -1,
	    maxVotes = 0,
	    maxVotessID = -1,
	    maxVotesType = 0;

    StartingVoting = Timer:-1;
	for (new i = 0; i < sizeof(VotesRunning); i++)
	{
	    if (VotesRunning[i][Started] == false) continue;
	    if (VotesRunning[i][Votetype] == VOTETYPE_STARTBASE || VotesRunning[i][Votetype] == VOTETYPE_STARTARENA || VotesRunning[i][Votetype] == VOTETYPE_STARTINT || VotesRunning[i][Votetype] == VOTETYPE_STARTGUNGAME)
	    {
		    if (VotesRunning[i][Votes] >= maxVotes)
		    {
		        maxVotes 	 = VotesRunning[i][Votes];
		        maxVotedId 	 = i;
		        maxVotessID  = VotesRunning[i][VoteInformations];
		        maxVotesType = _:VotesRunning[i][Votetype];
		    }

		    VotesRunning[i][Started] 			= false;
		    VotesRunning[i][Votes]   			= 0;
			VotesRunning[i][VoteInformations]   = -1;
		    VotesRunning[i][Votetype]   		= VOTETYPE_NULL;
		    VotesRunning[i][VoteStarter]   		= INVALID_PLAYER_ID;
		}
	}

	for(new x = 0; x < MAX_PLAYERS; x++)
	    Player[x][Voted] = false;

	if (maxVotedId != -1)
	{
	    switch (maxVotesType)
	    {
	        case VOTETYPE_STARTBASE:
			{
	            format(stringo, sizeof stringo, "* Vote finished, Base (%d) has won with %d votes.", maxVotessID, maxVotes);
	            SendClientMessageToAll(COLOR_SYSTEM, stringo);

				StartRound(maxVotessID, GAMETYPE_BASE);
			}
	        case VOTETYPE_STARTARENA:
			{
				StartRound(maxVotessID, GAMETYPE_ARENA);
				format(stringo, sizeof stringo, "* Vote finished, Arena (%d) has won with %d votes.", maxVotessID, maxVotes);
				SendClientMessageToAll(COLOR_SYSTEM, stringo);
			}
	        case VOTETYPE_STARTINT:
			{
			    Interior_Base = true;
				StartRound(maxVotessID, GAMETYPE_BASE);
				format(stringo, sizeof stringo, "* Vote finished, Interior (%d) has won with %d votes.", maxVotessID, maxVotes);
				SendClientMessageToAll(COLOR_SYSTEM, stringo);
			}
	        case VOTETYPE_STARTGUNGAME:
			{
				StartRound(maxVotessID, GAMETYPE_GUNGAME);
				format(stringo, sizeof stringo, "* Vote finished, Gungame (%d) has won with %d votes.", maxVotessID, maxVotes);
				SendClientMessageToAll(COLOR_SYSTEM, stringo);
			}
//http://revonline.comuf.com/Fotografie-0461.jpg
	    }
	}
	else
	{
		SendClientMessageToAll(COLOR_SYSTEM, "* Not any vote found.");
	}
}


new Menu:DemoBase_MenuPOS, Menu:DemoArena_MenuPOS;

// !===========================================================================!

#define MYSQL_TYPE_TCW          (0)
#define MYSQL_TYPE_CW           (1)

// !===========================================================================!

#define BANTYPE_IP              (0)
#define BANTYPE_NICKNAME        (1)
#define BANTYPE_SERIAL          (2)

// !===========================================================================!

#define MAX_STATIC_TEXTDRAWS    (35)
new Text:FineRound_Static[MAX_STATIC_TEXTDRAWS];

#define MAX_TCW_ROUNDS          (20)

enum e_td_dynamic_info
{
	Text:BluePlayers,
	Text:GreenPlayers,
	Text:BlueKills,
	Text:BlueDamages,
	Text:GreenKills,
	Text:GreenDamage,
	Text:TotalKGreen,
	Text:TotalDGreen,
	Text:TotalKBlue,
	Text:TotalDBlue,
	Text:Top2_Nick,
	Text:Top2_Stats,
	Text:Top3_Nick,
	Text:Top1_Nick,
	Text:Top3_Stats,
	Text:Top1_Stats,
	Text:RoundsInfo,
	Text:AttDefWin,
	Text:Stringa_Winner2,
	Text:Stringa_TeamWin,
	Text:Stringa_Winner1,
	Text:Stringa_RoundInfo,
	Text:Stringa_TmpBest,
}

new FineRound_Dynamic[MAX_TCW_ROUNDS][e_td_dynamic_info];

//new bool:PlayerYVote[MAX_PLAYERS] = {false, ...};

//#define PAUSED_BY_ADMIN 		100
//#define VOTEUNPAUSE_BY_EVERYONE 101
//#define MAX_PAUSE_USES  		1			// max pause by Y
/*
new PausedBy = NULL_TEAM;
new bool:LimitPauseUse[MAX_TEAMS];
*/
// Auto a/D cicle
new AutoAD_Cycle;

// PVP Weapons // RANDOM_SPAWN_ROUND
#define MAX_PVP_WEAPONS         5 // numero massimo di armi che si possono usare nel pvp
new PVPWeapons [MAX_PVP_WEAPONS];

// Fight 1 vs 1 players
new Iterator:ovoPlayers<MAX_PLAYERS>;
new Iterator:ovoInGame<MAX_PLAYERS>;

// tronchi
/*#define MAX_TRONCHI     				20
new tottronchi = 0;
new tronchi_primiid[MAX_TRONCHI];
*/

// editor stuff
new
	Editor_WorkingType[ MAX_PLAYERS ],
	Editor_Name[ MAX_PLAYERS ][ 60 ],
	Float:Editor_Checkpoint[MAX_PLAYERS][3],
	Float:Editor_Attackers[MAX_PLAYERS][3],
	Float:Editor_Defenders[MAX_PLAYERS][3],
	Float:Editor_AreaLimits1[MAX_PLAYERS][2],
	Float:Editor_AreaLimits2[MAX_PLAYERS][2],
	bool:Editor_SettingSpawn[MAX_PLAYERS],
	Float:Editor_SpawnsPos[MAX_PLAYERS][20][3],
	Editor_CurrentSpawnID[MAX_PLAYERS],
	Editor_GangZoneTest[MAX_PLAYERS] = {-1, ...},
	Editing_BaseID[MAX_PLAYERS]//// base come arena come etc.
	;

		/**
			** aggiungere tra i dialogs id
			EDITOR_EDIT_CHOSEPACK,
			DIALOG_EDIT_BASEID,
			DIALOG_EDITING_BASE,
			DIALOG_EDITING_BASENAME,

			new Editing_BaseID[MAX_PLAYERS];
		*/

#define QUERY_STRING_SIZE			1440 // si, ha bisogno di piï¿½ di 1024 caratteri.

enum // Working type
{
	EDITOR_WORKTYPE_NOONE,
	EDITOR_WORKTYPE_BASE,
	EDITOR_WORKTYPE_ARENA,
	EDITOR_WORKTYPE_GUNGAME,
	EDITOR_WORKTYPE_FIGHT,
	EDITOR_WORKINGTYPE_EDITINGBASE,
	EDITOR_WORKINGTYPE_EDITINGARENA,
}

// !===========================================================================!
// Fallout scena
#define MAX_FALLOUT_OBJECTS     100
new fallout_ambientazione [MAX_FALLOUT_OBJECTS];
new fallout_obj_status[MAX_FALLOUT_OBJECTS] = {0, ...};
new fallout_alive_objs = 99;
new Timer:fallout_object_timer[MAX_FALLOUT_OBJECTS];
new bool:fallout_obj_timerstart[MAX_FALLOUT_OBJECTS] = {false, ...};
new fallout_timers_startati = 0;

stock CreaPiattaforma ()
{
	fallout_ambientazione[0] = CreateDynamicObject(1697, 2482.1921, -1660.4783, 160.0000, 31.8000, 0.0000, 0.0000);
 	fallout_ambientazione[1] = CreateDynamicObject(1697, 2477.7395, -1660.4783, 160.0000, 31.8000, 0.0000, 0.0000);
  	fallout_ambientazione[2] = CreateDynamicObject(1697, 2473.2869, -1660.4783, 160.0000, 31.8000, 0.0000, 0.0000);
	fallout_ambientazione[3] = CreateDynamicObject(1697, 2468.8343, -1660.4783, 160.0000, 31.8000, 0.0000, 0.0000);
	fallout_ambientazione[4] = CreateDynamicObject(1697, 2464.3817, -1660.4783, 160.0000, 31.8000, 0.0000, 0.0000);
	fallout_ambientazione[5] = CreateDynamicObject(1697, 2459.9291, -1660.4783, 160.0000, 31.8000, 0.0000, 0.0000);
	fallout_ambientazione[6] = CreateDynamicObject(1697, 2455.4765, -1660.4783, 160.0000, 31.8000, 0.0000, 0.0000);
	fallout_ambientazione[7] = CreateDynamicObject(1697, 2451.0239, -1660.4783, 160.0000, 31.8000, 0.0000, 0.0000);
	fallout_ambientazione[8] = CreateDynamicObject(1697, 2446.5713, -1660.4783, 160.0000, 31.8000, 0.0000, 0.0000);
	fallout_ambientazione[9] = CreateDynamicObject(1697, 2442.1187, -1660.4783, 160.0000, 31.8000, 0.0000, 0.0000);
	fallout_ambientazione[10] = CreateDynamicObject(1697, 2482.1921, -1655.1112, 160.0000, 31.8000, 0.0000, 0.0000);
	fallout_ambientazione[11] = CreateDynamicObject(1697, 2477.7395, -1655.1112, 160.0000, 31.8000, 0.0000, 0.0000);
	fallout_ambientazione[12] = CreateDynamicObject(1697, 2473.2869, -1655.1112, 160.0000, 31.8000, 0.0000, 0.0000);
	fallout_ambientazione[13] = CreateDynamicObject(1697, 2468.8343, -1655.1112, 160.0000, 31.8000, 0.0000, 0.0000);
	fallout_ambientazione[14] = CreateDynamicObject(1697, 2464.3817, -1655.1112, 160.0000, 31.8000, 0.0000, 0.0000);
	fallout_ambientazione[15] = CreateDynamicObject(1697, 2459.9291, -1655.1112, 160.0000, 31.8000, 0.0000, 0.0000);
	fallout_ambientazione[16] = CreateDynamicObject(1697, 2455.4765, -1655.1112, 160.0000, 31.8000, 0.0000, 0.0000);
	fallout_ambientazione[17] = CreateDynamicObject(1697, 2451.0239, -1655.1112, 160.0000, 31.8000, 0.0000, 0.0000);
	fallout_ambientazione[18] = CreateDynamicObject(1697, 2446.5713, -1655.1112, 160.0000, 31.8000, 0.0000, 0.0000);
	fallout_ambientazione[19] = CreateDynamicObject(1697, 2442.1187, -1655.1112, 160.0000, 31.8000, 0.0000, 0.0000);
	fallout_ambientazione[20] = CreateDynamicObject(1697, 2482.1921, -1649.7442, 160.0000, 31.8000, 0.0000, 0.0000);
	fallout_ambientazione[21] = CreateDynamicObject(1697, 2477.7395, -1649.7442, 160.0000, 31.8000, 0.0000, 0.0000);
	fallout_ambientazione[22] = CreateDynamicObject(1697, 2473.2869, -1649.7442, 160.0000, 31.8000, 0.0000, 0.0000);
	fallout_ambientazione[23] = CreateDynamicObject(1697, 2468.8343, -1649.7442, 160.0000, 31.8000, 0.0000, 0.0000);
	fallout_ambientazione[24] = CreateDynamicObject(1697, 2464.3817, -1649.7442, 160.0000, 31.8000, 0.0000, 0.0000);
	fallout_ambientazione[25] = CreateDynamicObject(1697, 2459.9291, -1649.7442, 160.0000, 31.8000, 0.0000, 0.0000);
	fallout_ambientazione[26] = CreateDynamicObject(1697, 2455.4765, -1649.7442, 160.0000, 31.8000, 0.0000, 0.0000);
	fallout_ambientazione[27] = CreateDynamicObject(1697, 2451.0239, -1649.7442, 160.0000, 31.8000, 0.0000, 0.0000);
	fallout_ambientazione[28] = CreateDynamicObject(1697, 2446.5713, -1649.7442, 160.0000, 31.8000, 0.0000, 0.0000);
	fallout_ambientazione[29] = CreateDynamicObject(1697, 2442.1187, -1649.7442, 160.0000, 31.8000, 0.0000, 0.0000);
	fallout_ambientazione[30] = CreateDynamicObject(1697, 2482.1921, -1644.3772, 160.0000, 31.8000, 0.0000, 0.0000);
	fallout_ambientazione[31] = CreateDynamicObject(1697, 2477.7395, -1644.3772, 160.0000, 31.8000, 0.0000, 0.0000);
	fallout_ambientazione[32] = CreateDynamicObject(1697, 2473.2869, -1644.3772, 160.0000, 31.8000, 0.0000, 0.0000);
	fallout_ambientazione[33] = CreateDynamicObject(1697, 2468.8343, -1644.3772, 160.0000, 31.8000, 0.0000, 0.0000);
	fallout_ambientazione[34] = CreateDynamicObject(1697, 2464.3817, -1644.3772, 160.0000, 31.8000, 0.0000, 0.0000);
	fallout_ambientazione[35] = CreateDynamicObject(1697, 2459.9291, -1644.3772, 160.0000, 31.8000, 0.0000, 0.0000);
	fallout_ambientazione[36] = CreateDynamicObject(1697, 2455.4765, -1644.3772, 160.0000, 31.8000, 0.0000, 0.0000);
	fallout_ambientazione[37] = CreateDynamicObject(1697, 2451.0239, -1644.3772, 160.0000, 31.8000, 0.0000, 0.0000);
	fallout_ambientazione[38] = CreateDynamicObject(1697, 2446.5713, -1644.3772, 160.0000, 31.8000, 0.0000, 0.0000);
	fallout_ambientazione[39] = CreateDynamicObject(1697, 2442.1187, -1644.3772, 160.0000, 31.8000, 0.0000, 0.0000);
	fallout_ambientazione[40] = CreateDynamicObject(1697, 2482.1921, -1639.0102, 160.0000, 31.8000, 0.0000, 0.0000);
	fallout_ambientazione[41] = CreateDynamicObject(1697, 2477.7395, -1639.0102, 160.0000, 31.8000, 0.0000, 0.0000);
	fallout_ambientazione[42] = CreateDynamicObject(1697, 2473.2869, -1639.0102, 160.0000, 31.8000, 0.0000, 0.0000);
	fallout_ambientazione[43] = CreateDynamicObject(1697, 2468.8343, -1639.0102, 160.0000, 31.8000, 0.0000, 0.0000);
	fallout_ambientazione[44] = CreateDynamicObject(1697, 2464.3817, -1639.0102, 160.0000, 31.8000, 0.0000, 0.0000);
	fallout_ambientazione[45] = CreateDynamicObject(1697, 2459.9291, -1639.0102, 160.0000, 31.8000, 0.0000, 0.0000);
	fallout_ambientazione[46] = CreateDynamicObject(1697, 2455.4765, -1639.0102, 160.0000, 31.8000, 0.0000, 0.0000);
	fallout_ambientazione[47] = CreateDynamicObject(1697, 2451.0239, -1639.0102, 160.0000, 31.8000, 0.0000, 0.0000);
	fallout_ambientazione[48] = CreateDynamicObject(1697, 2446.5713, -1639.0102, 160.0000, 31.8000, 0.0000, 0.0000);
	fallout_ambientazione[49] = CreateDynamicObject(1697, 2442.1187, -1639.0102, 160.0000, 31.8000, 0.0000, 0.0000);
	fallout_ambientazione[50] = CreateDynamicObject(1697, 2482.1921, -1633.6432, 160.0000, 31.8000, 0.0000, 0.0000);
	fallout_ambientazione[51] = CreateDynamicObject(1697, 2477.7395, -1633.6432, 160.0000, 31.8000, 0.0000, 0.0000);
	fallout_ambientazione[52] = CreateDynamicObject(1697, 2473.2869, -1633.6432, 160.0000, 31.8000, 0.0000, 0.0000);
	fallout_ambientazione[53] = CreateDynamicObject(1697, 2468.8343, -1633.6432, 160.0000, 31.8000, 0.0000, 0.0000);
	fallout_ambientazione[54] = CreateDynamicObject(1697, 2464.3817, -1633.6432, 160.0000, 31.8000, 0.0000, 0.0000);
	fallout_ambientazione[55] = CreateDynamicObject(1697, 2459.9291, -1633.6432, 160.0000, 31.8000, 0.0000, 0.0000);
	fallout_ambientazione[56] = CreateDynamicObject(1697, 2455.4765, -1633.6432, 160.0000, 31.8000, 0.0000, 0.0000);
	fallout_ambientazione[57] = CreateDynamicObject(1697, 2451.0239, -1633.6432, 160.0000, 31.8000, 0.0000, 0.0000);
	fallout_ambientazione[58] = CreateDynamicObject(1697, 2446.5713, -1633.6432, 160.0000, 31.8000, 0.0000, 0.0000);
	fallout_ambientazione[59] = CreateDynamicObject(1697, 2442.1187, -1633.6432, 160.0000, 31.8000, 0.0000, 0.0000);
	fallout_ambientazione[60] = CreateDynamicObject(1697, 2482.1921, -1628.2762, 160.0000, 31.8000, 0.0000, 0.0000);
	fallout_ambientazione[61] = CreateDynamicObject(1697, 2477.7395, -1628.2762, 160.0000, 31.8000, 0.0000, 0.0000);
	fallout_ambientazione[62] = CreateDynamicObject(1697, 2473.2869, -1628.2762, 160.0000, 31.8000, 0.0000, 0.0000);
	fallout_ambientazione[63] = CreateDynamicObject(1697, 2468.8343, -1628.2762, 160.0000, 31.8000, 0.0000, 0.0000);
	fallout_ambientazione[64] = CreateDynamicObject(1697, 2464.3817, -1628.2762, 160.0000, 31.8000, 0.0000, 0.0000);
	fallout_ambientazione[65] = CreateDynamicObject(1697, 2459.9291, -1628.2762, 160.0000, 31.8000, 0.0000, 0.0000);
	fallout_ambientazione[66] = CreateDynamicObject(1697, 2455.4765, -1628.2762, 160.0000, 31.8000, 0.0000, 0.0000);
	fallout_ambientazione[67] = CreateDynamicObject(1697, 2451.0239, -1628.2762, 160.0000, 31.8000, 0.0000, 0.0000);
	fallout_ambientazione[68] = CreateDynamicObject(1697, 2446.5713, -1628.2762, 160.0000, 31.8000, 0.0000, 0.0000);
	fallout_ambientazione[69] = CreateDynamicObject(1697, 2442.1187, -1628.2762, 160.0000, 31.8000, 0.0000, 0.0000);
	fallout_ambientazione[70] = CreateDynamicObject(1697, 2482.1921, -1622.9092, 160.0000, 31.8000, 0.0000, 0.0000);
	fallout_ambientazione[71] = CreateDynamicObject(1697, 2477.7395, -1622.9092, 160.0000, 31.8000, 0.0000, 0.0000);
	fallout_ambientazione[72] = CreateDynamicObject(1697, 2473.2869, -1622.9092, 160.0000, 31.8000, 0.0000, 0.0000);
	fallout_ambientazione[73] = CreateDynamicObject(1697, 2468.8343, -1622.9092, 160.0000, 31.8000, 0.0000, 0.0000);
	fallout_ambientazione[74] = CreateDynamicObject(1697, 2464.3817, -1622.9092, 160.0000, 31.8000, 0.0000, 0.0000);
	fallout_ambientazione[75] = CreateDynamicObject(1697, 2459.9291, -1622.9092, 160.0000, 31.8000, 0.0000, 0.0000);
	fallout_ambientazione[76] = CreateDynamicObject(1697, 2455.4765, -1622.9092, 160.0000, 31.8000, 0.0000, 0.0000);
	fallout_ambientazione[77] = CreateDynamicObject(1697, 2451.0239, -1622.9092, 160.0000, 31.8000, 0.0000, 0.0000);
	fallout_ambientazione[78] = CreateDynamicObject(1697, 2446.5713, -1622.9092, 160.0000, 31.8000, 0.0000, 0.0000);
	fallout_ambientazione[79] = CreateDynamicObject(1697, 2442.1187, -1622.9092, 160.0000, 31.8000, 0.0000, 0.0000);
	fallout_ambientazione[80] = CreateDynamicObject(1697, 2482.1921, -1617.5422, 160.0000, 31.8000, 0.0000, 0.0000);
	fallout_ambientazione[81] = CreateDynamicObject(1697, 2477.7395, -1617.5422, 160.0000, 31.8000, 0.0000, 0.0000);
	fallout_ambientazione[82] = CreateDynamicObject(1697, 2473.2869, -1617.5422, 160.0000, 31.8000, 0.0000, 0.0000);
	fallout_ambientazione[83] = CreateDynamicObject(1697, 2468.8343, -1617.5422, 160.0000, 31.8000, 0.0000, 0.0000);
	fallout_ambientazione[84] = CreateDynamicObject(1697, 2464.3817, -1617.5422, 160.0000, 31.8000, 0.0000, 0.0000);
	fallout_ambientazione[85] = CreateDynamicObject(1697, 2459.9291, -1617.5422, 160.0000, 31.8000, 0.0000, 0.0000);
	fallout_ambientazione[86] = CreateDynamicObject(1697, 2455.4765, -1617.5422, 160.0000, 31.8000, 0.0000, 0.0000);
	fallout_ambientazione[87] = CreateDynamicObject(1697, 2451.0239, -1617.5422, 160.0000, 31.8000, 0.0000, 0.0000);
	fallout_ambientazione[88] = CreateDynamicObject(1697, 2446.5713, -1617.5422, 160.0000, 31.8000, 0.0000, 0.0000);
	fallout_ambientazione[89] = CreateDynamicObject(1697, 2442.1187, -1617.5422, 160.0000, 31.8000, 0.0000, 0.0000);
	fallout_ambientazione[90] = CreateDynamicObject(1697, 2482.1921, -1612.1752, 160.0000, 31.8000, 0.0000, 0.0000);
	fallout_ambientazione[91] = CreateDynamicObject(1697, 2477.7395, -1612.1752, 160.0000, 31.8000, 0.0000, 0.0000);
	fallout_ambientazione[92] = CreateDynamicObject(1697, 2473.2869, -1612.1752, 160.0000, 31.8000, 0.0000, 0.0000);
	fallout_ambientazione[93] = CreateDynamicObject(1697, 2468.8343, -1612.1752, 160.0000, 31.8000, 0.0000, 0.0000);
	fallout_ambientazione[94] = CreateDynamicObject(1697, 2464.3817, -1612.1752, 160.0000, 31.8000, 0.0000, 0.0000);
	fallout_ambientazione[95] = CreateDynamicObject(1697, 2459.9291, -1612.1752, 160.0000, 31.8000, 0.0000, 0.0000);
	fallout_ambientazione[96] = CreateDynamicObject(1697, 2455.4765, -1612.1752, 160.0000, 31.8000, 0.0000, 0.0000);
	fallout_ambientazione[97] = CreateDynamicObject(1697, 2451.0239, -1612.1752, 160.0000, 31.8000, 0.0000, 0.0000);
	fallout_ambientazione[98] = CreateDynamicObject(1697, 2446.5713, -1612.1752, 160.0000, 31.8000, 0.0000, 0.0000);
	fallout_ambientazione[99] = CreateDynamicObject(1697, 2442.1187, -1612.1752, 160.0000, 31.8000, 0.0000, 0.0000);

	for (new i = 0; i < 100; i++) fallout_obj_status[i] = 0;
	fallout_timers_startati = 0;
	return true;
}

stock DistruggiPiattaforma()
{
	for (new i = 0; i < 100; i++)
	{
	    stop fallout_object_timer[i];

		if (IsValidObject(fallout_ambientazione[i]))
		{
			DestroyDynamicObject (fallout_ambientazione[i]);
	    }

	    fallout_obj_status [i] = 0;
	    fallout_object_timer [i] = Timer:-1;
	    fallout_obj_timerstart [i] = false;
	}

	fallout_timers_startati = 0;
	fallout_alive_objs = 99;
}

// =============================================================================
// Last bullet mode

// livesleft
new PlayerText:LifesLeft;
new PlayerLifesLeft[ MAX_PLAYERS ] = {3, ...};

/*
LifesLeft = CreatePlayerTextDraw(playerid, 578.000000, 57.000000, "3 lives left");
PlayerTextDrawAlignment(playerid, LifesLeft, 2);
PlayerTextDrawBackgroundColor(playerid, LifesLeft, 51);
PlayerTextDrawFont(playerid, LifesLeft, 2);
PlayerTextDrawLetterSize(playerid, LifesLeft, 0.210000, 1.100000);
PlayerTextDrawColor(playerid, LifesLeft, -1);
PlayerTextDrawSetOutline(playerid, LifesLeft, 1);
PlayerTextDrawSetProportional(playerid, LifesLeft, 1);

//
LifesLeft
*/
////////////////////////////////////////////////////////////////////////////////
//==============================================================================
////////////////////////////////////////////////////////////////////////////////
new bool:sys_m_onplayerdeath[MAX_PLAYERS] = {false, ...}; // puï¿½ causare vari bug se usato male
new sys_m_PlayerKillerid[MAX_PLAYERS];
new sys_m_PlayerReason[MAX_PLAYERS];

//
new bool:g_PlayerFreezed[MAX_PLAYERS] = {false, ...};

// =============================================================================
// nuovo sistema round stats
new Text:RoundStats[4];
/*enum e_componenti_roundstats
{
	Text:rStats_ABar,
	Text:rStats_BBar,
	Text:rStats_Time,
	Text:rStats_Background,
	Text:rStats_AStats,
	Text:rStats_BStats,
	Text:rStats_AHits,
	Text:rStats_BHits,
}
new Text:RoundStats[e_componenti_roundstats];
*/
// =============================================================================
// TCW/CW SQL DB connection
//new g_TCWCWConnection;
/*
enum e_web_match
{
    MatchID,
    g_Connection
}
new webMatch[e_web_match];*/

// =) ==========================================================================
new PlayerText:PlayerScorer_TD0;
new PlayerText:PlayerScorer_TD1;
new Timer:Player_ScorerTimer[MAX_PLAYERS];
////////////////////////////////////////////////////////////////////////////////
//==============================================================================
////////////////////////////////////////////////////////////////////////////////
//new webmatch code
#define URL_HTTP            			 "s7domina.gel-gaming.co.uk/matchs/sys/"

/**
 * Questi define contengono gli URL tipici per il salvataggio delle informazioni
 * Riguardanti il match
 * Fanno tutti riferimento a URL_HTTP per l'url della system-folder /sys/
 */

#define MATCH_NAMECHANGE                URL_HTTP"nameteams.php"     // Cambia i nomi dei teams
#define MATCH_CREATEMATCH               URL_HTTP"startmatch.php"    // Crea il match
#define MATCH_PREPAREROUND              URL_HTTP"prepareround.php"  // "Prepara" il .db a ricevere un round
#define MATCH_ENDMATCH                  URL_HTTP"endmatch.php"      // comunica la fine del match

/**
 * HTTP(
 */
// ranks corrispondenti - kills continui
/*
new PlayerKills_Continui[MAX_PLAYERS];

enum e_ranks(*= 5)
{
	io_playa = 1,
	io_homie,
}

new
    rankCorrispondente[][20] = {
        "Playa",
		"Homie",
		"Jacker",
		"Gangsta",
		"High roller",
		"Hitman",
		"Godfather",
		"Most respected"
    };*/

//rankCorrispondente[PlayerKills_Continui[killerid]]

new Timer:VehicleUpdate_Timer;

//==============================================================================
//==============================================================================
new PlayerList_Arr[MAX_PLAYERS][MAX_PLAYERS]; // tecnicamente dovrebbe andare bene
											  // ma un dialog raggiunge veramente il max_players ?

new PlayerGunMenu_Arr[MAX_PLAYERS][sizeof aWeaponNames];


// =====================================================================================================================

new Timer:auto_resumeTimer = Timer:-1;

// =====================================================================================================================

// !===========================================================================!
new esl_timeoutPlayers = 0;

stock _TogglePlayerControllable(playerid, toggle)
{
    TogglePlayerControllable (playerid, toggle);
    g_PlayerFreezed [playerid] = !toggle;
    // g_PlayerFreezed
    // TRUE SE IL PLAYER ï¿½ FREEZATO
    // FALSE SE IL PLAYER ï¿½ SFREEZATO
    // -
    // TogglePlayerControllable
    // Funziona in modo inverso
    // 0 se il player ï¿½ freezato  (o deve essere)
    // 1 se il player ï¿½ sfreezato (o deve essere)
    samp_ac_Controllable(playerid, toggle);
    return true;
}

#undef TogglePlayerControllable
#define TogglePlayerControllable _TogglePlayerControllable

new bool:bADisableAC = false;
new Timer:AC_START_TIMER;
new Timer:auto_disable_ac;


// hex colors - label
#define HEX_HEALTH_COLOR_VEH        00FF28
#define HEX_OTHER_COLOR             FF0000
#define HEX_BLACK_HEALTH            000000

//
new CurrentMatchID = -1;

#define MAX_MATCHS          10

enum e_match_info_cached
{
	c_matchID,//MySQL ID
//	c_teamA[24],//change 24 w/ MAX_TEAM_NAME
//	c_teamB[24],//^
	c_scoreA,
	c_scoreB,
	c_pRounds,
	c_tRounds,
	c_tTime,
}

//emh.. bad.. but ok.
new CachedMatchInfo[MAX_PLAYERS][MAX_MATCHS][e_match_info_cached];
new c_Cached_MatchInfo_TeamNamesA[MAX_PLAYERS][MAX_MATCHS][MAX_TEAM_NAME];//read in the enum
new c_Cached_MatchInfo_TeamNamesB[MAX_PLAYERS][MAX_MATCHS][MAX_TEAM_NAME];

// -------------------------------------------------------------------------------
new Text:RoundStart_TD1;
new Text:RoundStart_TD2;
new Text:RoundStart_TD3;

stock ChangeTeamName(team, inputtext[])
{
	strcpy_2(iTeam[team][Name], inputtext);

	RefreshReadyTDs_Esl ();
	SyncTextdraw(1);

	if(gConfig[Matchmode] != MATCHMODE_NOSCORES)
	{
		SendRconCommand(sprintf("mapname Lobby %s %d:%d %s", iTeam[TEAM_A][Name], iTeam[TEAM_A][RoundWins], iTeam[TEAM_B][RoundWins], iTeam[TEAM_B][Name]));
	}

	MySQLStatus[TotalQuerys] ++; mysql_tquery(g_MySQLConnection, sprintf("UPDATE teams SET name = '%s' WHERE id = '%d' AND gid = %d", inputtext, team, G_ID), "", "");

	if (team == TEAM_A) {
	    TextDrawSetString(Classtd_SpawnTN[6], sprintf("~r~~h~~h~%s", inputtext));
	    format(iTeam[TEAM_A_SUB][Name], 128, "Sub-%s", inputtext);
	}
	else if (team == TEAM_B) {
	    TextDrawSetString(Classtd_SpawnTN[7], sprintf("~b~~h~~h~%s", inputtext));
	    format(iTeam[TEAM_B_SUB][Name], 128, "Sub-%s", inputtext);
	}
}

// [fine global]

new Player_LastVeh[MAX_PLAYERS]={-1,...};
new Player_LastSeat[MAX_PLAYERS]={128,...};

// =============================================================================
// =============================================================================
public OnUsingAnotherPC(playerid)
{
    format(stringo, sizeof(stringo), "** Anticheat: {"#COLOR_SYSTEM_FOCUS"}%s{"#COLOR_SYSTEM_RESET"} might be using the 2 PC trick.", Player[playerid][Nickname]);
    SendClientMessageToAll(COLOR_SYSTEM, stringo);
    return 1;
}

// should be moved at the end of the gm
/*
enum e_td_spawn_info
{
	Text:tdBackground,
	Text:tdGamemodeName,
	Text:tdNotice,
	Text:tdLimitsInfo,
	Text:tdMaxPing,
	Text:tdMaxPL,
	Text:tdMinFPS,
	Text:tdChTeam,

	Text:tdBGTeamA,
	Text:tdTXTTeamA,
	Text:tdTXTTeamASub,

	Text:tdBGTeamB,
	Text:tdTXTTeamB,
	Text:tdTXTTeamBSub,

	Text:tdBGTeamREF,
	Text:tdTXTTeamREF,
	Text:tdTXTTeamREFSub,
}

new TDSpawnInfo[e_td_spawn_info];

stock CreateNewSpawnTD()
{
	new Text:t = TDSpawnInfo[tdBackground] = TextDrawCreate(210.000000, 110.000000, "_");
	TextDrawBackgroundColor(t, 255);
	TextDrawFont(t, 1);
	TextDrawLetterSize(t, 0.500000, 16.000000);
	TextDrawColor(t, -1);
	TextDrawSetOutline(t, 0);
	TextDrawSetProportional(t, 1);
	TextDrawSetShadow(t, 1);
	TextDrawUseBox(t, 1);
	TextDrawBoxColor(t, 34);
	TextDrawTextSize(t, 440.000000, 10.000000);

	t = TDSpawnInfo[tdGamemodeName] = TextDrawCreate(329.000000, 114.000000, "Welcome to GM_NAME");
	TextDrawAlignment(t, 2);
	TextDrawBackgroundColor(t, 255);
	TextDrawFont(t, 0);
	TextDrawLetterSize(t, 0.539999, 1.000000);
	TextDrawColor(t, -1);
	TextDrawSetOutline(t, 0);
	TextDrawSetProportional(t, 1);
	TextDrawSetShadow(t, 1);

	t = TDSpawnInfo[tdNotice] = TextDrawCreate(210.000000, 127.000000, "Notice:~n~Very Long Notice Hello World:) He");
	TextDrawBackgroundColor(t, 255);
	TextDrawFont(t, 2);
	TextDrawLetterSize(t, 0.170000, 0.899999);
	TextDrawColor(t, -1);
	TextDrawSetOutline(t, 0);
	TextDrawSetProportional(t, 1);
	TextDrawSetShadow(t, 1);

	t = TDSpawnInfo[tdLimitsInfo] = TextDrawCreate(390.000000, 127.000000, "Gamemode limits");
	TextDrawAlignment(t, 2);
	TextDrawBackgroundColor(t, 255);
	TextDrawFont(t, 2);
	TextDrawLetterSize(t, 0.190000, 0.899999);
	TextDrawColor(t, -1);
	TextDrawSetOutline(t, 0);
	TextDrawSetProportional(t, 1);
	TextDrawSetShadow(t, 1);

	t = TDSpawnInfo[tdMaxPing] = TextDrawCreate(390.000000, 137.000000, "Max Ping: X (Disabled)");
	TextDrawAlignment(t, 2);
	TextDrawBackgroundColor(t, 255);
	TextDrawFont(t, 2);
	TextDrawLetterSize(t, 0.190000, 0.899999);
	TextDrawColor(t, -1);
	TextDrawSetOutline(t, 0);
	TextDrawSetProportional(t, 1);
	TextDrawSetShadow(t, 1);

	t = TDSpawnInfo[tdMaxPL] = TextDrawCreate(390.000000, 147.000000, "Max PL: X (Disabled)");
	TextDrawAlignment(t, 2);
	TextDrawBackgroundColor(t, 255);
	TextDrawFont(t, 2);
	TextDrawLetterSize(t, 0.190000, 0.899999);
	TextDrawColor(t, -1);
	TextDrawSetOutline(t, 0);
	TextDrawSetProportional(t, 1);
	TextDrawSetShadow(t, 1);

	t = TDSpawnInfo[tdMinFPS] = TextDrawCreate(390.000000, 157.000000, "Min FPS: X (Disabled)");
	TextDrawAlignment(t, 2);
	TextDrawBackgroundColor(t, 255);
	TextDrawFont(t, 2);
	TextDrawLetterSize(t, 0.190000, 0.899999);
	TextDrawColor(t, -1);
	TextDrawSetOutline(t, 0);
	TextDrawSetProportional(t, 1);
	TextDrawSetShadow(t, 1);

	t = TDSpawnInfo[tdChTeam] = TextDrawCreate(329.000000, 167.000000, "Choose the team:");
	TextDrawAlignment(t, 2);
	TextDrawBackgroundColor(t, 255);
	TextDrawFont(t, 0);
	TextDrawLetterSize(t, 0.539999, 1.000000);
	TextDrawColor(t, -1);
	TextDrawSetOutline(t, 0);
	TextDrawSetProportional(t, 1);
	TextDrawSetShadow(t, 1);

	// si ripete per ogni team
	t = TDSpawnInfo[tdBGTeamA] = TextDrawCreate(210.000000, 180.000000, "_");
//	TextDrawBackgroundColor(t, 255);
	TextDrawFont(t, TEXT_DRAW_FONT_MODEL_PREVIEW);
	TextDrawLetterSize(t, 0.500000, 8.200000);
	TextDrawSetShadow(t, 1);
	TextDrawUseBox(t, 1);
	TextDrawBoxColor(t, 0x000000FF);
	TextDrawTextSize(t, 267.000000, 0.000000);
	TextDrawSetPreviewModel(t, 128);

	t = TDSpawnInfo[tdBGTeamA] = TextDrawCreate(210.000000, 180.000000, "_");
	TextDrawFont(t, TEXT_DRAW_FONT_MODEL_PREVIEW);
	TextDrawUseBox(t, 1);
	TextDrawBoxColor(t, 0x000000FF);
	TextDrawTextSize(t, 200.000000, 100.000000);
	TextDrawSetPreviewModel(t, 123); //Display model 0 (CJ Skin)

	new PlayerText:textdraw;
	textdraw = CreatePlayerTextDraw(playerid, 320.0, 240.0, "_");
	PlayerTextDrawFont(playerid, textdraw, TEXT_DRAW_FONT_MODEL_PREVIEW);
	PlayerTextDrawUseBox(playerid, textdraw, 1);
	PlayerTextDrawBoxColor(playerid, textdraw, 0x000000FF);
	PlayerTextDrawTextSize(playerid, textdraw, 40.0, 40.0);
//	PlayerTextDrawSetPreviewModel(playerid, textdraw, 411); // Show an Infernus (model 411)
	PlayerTextDrawSetPreviewModel(playerid, textdraw, 128); //Display model 0 (CJ Skin)
	//PlayerTextDrawSetPreviewModel(playerid, textdraw, 18646); //Display model 18646 (police light object)
	PlayerTextDrawShow(playerid, textdraw);


	t = TDSpawnInfo[tdTXTTeamA] = TextDrawCreate(238.000000, 235.000000, "Team A");
	TextDrawAlignment(t, 2);
	TextDrawBackgroundColor(t, 255);
	TextDrawFont(t, 1);
	TextDrawLetterSize(t, 0.240000, 1.000000);
	TextDrawColor(t, -1);
	TextDrawSetOutline(t, 0);
	TextDrawSetProportional(t, 1);
	TextDrawSetShadow(t, 1);

	t = TDSpawnInfo[tdTXTTeamASub] = TextDrawCreate(239.000000, 244.000000, "Sub");
	TextDrawAlignment(t, 2);
	TextDrawBackgroundColor(t, 255);
	TextDrawFont(t, 1);
	TextDrawLetterSize(t, 0.240000, 1.000000);
	TextDrawColor(t, -1);
	TextDrawSetOutline(t, 0);
	TextDrawSetProportional(t, 1);
	TextDrawSetShadow(t, 1);
}*/

enum MySQL_Data {
	mysql_Host[64],
	mysql_User[64],
	mysql_Password[64],
	mysql_Database[64]
}

new MySQLData[MySQL_Data];

forward parseMySQLData(tag[], name[], value[]);
public parseMySQLData(tag[], name[], value[])
{
	printf("parseMySQLData, name = %s - value = %s", name, value);

	if (!strcmp(name, "host")) {
	    strcpy_2(MySQLData[mysql_Host], value);
	} else if (!strcmp(name, "user")) {
        strcpy_2(MySQLData[mysql_User], value);
	} else if (!strcmp(name, "password")) {
	    if (value[0] == '\0') {
	    	strcpy_2(MySQLData[mysql_Password], "");
            return true;
		}
        strcpy_2(MySQLData[mysql_Password], value);
	} else if (!strcmp(name, "db")) {
        strcpy_2(MySQLData[mysql_Database], value);
	}
	
	return true;
}

// gamemode
public OnGameModeInit()
{
   // CreateNewSpawnTD ();


	strcat(Player[GAMEMODE_ID_ARR][Nickname], "Gamemode", 24);
	Player[GAMEMODE_ID_ARR][aLevel] = _:lRoot;

	SendRconCommand("reloadbans");
	//SetNameTagDrawDistance (9.0);
    antiDeAMX();
    StartTick = gettime();

    G_ID = GAMEMODE_SERVER_1;

	// new bind [24];
	// GetServerVarAsString ("bind", bind, 24);

	// if (strlen (bind) < 1)
	// {
	// 	print ("Unable to set a valid G_ID.");
	//     SendRconCommand ("exit");
	//     return true;
	// }
	// else
	// {
	// 	new
	// 	    port = GetServerVarAsInt ("port");
	// 	/*
	// 	if (!strcmp(bind, "91.121.154.28", true) && port == 7777)
	// 	{
	// 		G_ID = GAMEMODE_SECONDSERVER;
	// 		198.20.110.133:7782
	// 	}*/
	//  	if (!strcmp(bind, "198.20.110.133", true) && port == 7782)
	// 	{
	// 		G_ID = GAMEMODE_SERVER_1;
	// 	}
	// 	else if (!strcmp(bind, "5.175.191.48", true) && port == 1237)
	// 	{
	// 		G_ID = GAMEMODE_SERVER_2; // # Deve essere test server
	// 	}
	// 	else if (!strcmp(bind, "127.0.0.1", true) && port == 7777)
	// 	{
	// 	    G_ID = GAMEMODE_SERVER_2;
	// 	}
	// 	else
	// 	{
	// 		print ("Unable to set a valid G_ID.");
	// 	    SendRconCommand ("exit");
	// 	    return true;
	// 	}
	// }

	printf (">> Gamemode is ready with G_ID: %d", G_ID);

	//	DebugMessage( Ses
	// ShowPlayerMarkers(0);

//	strcpy_2(Player[COLLISION_ID][Nickname], "Collision");

	print("... "#GAMEMODE_NAME" -");
	print("		Please wait...");

    print("Waiting for MySQL...");

//    mysql_debug(ENABLE_DEBUGGING);
	INI_ParseFile("slfd_mysql.ini", "parseMySQLData", .bPassTag = true);
	
	if (MySQLData[mysql_Password][0] == '\0') {
		print("no password");
        strcpy_2(MySQLData[mysql_Password], "");
	}

	printf("Connection to: host = %s user = %s db = %s", MySQLData[mysql_Host], MySQLData[mysql_User], MySQLData[mysql_Database]);

	g_MySQLConnection = mysql_connect(MySQLData[mysql_Host],
									  MySQLData[mysql_User],
									  MySQLData[mysql_Database],
									  MySQLData[mysql_Password],
									  .autoreconnect = true);

	print(".. I'm connected! Wow!");
	printf("g_MySQLConnection == %d", g_MySQLConnection);

    MySQLStatus[TotalQuerys] ++;
    mysql_tquery(g_MySQLConnection, sprintf("SELECT * FROM config WHERE gid = %d", G_ID), "OnConfigLoaded", "i", -1);
    MySQLStatus[TotalQuerys] ++;
	mysql_tquery(g_MySQLConnection, sprintf("SELECT * FROM stats WHERE gid = %d", G_ID), "Server_ReadStats", "");
	MySQLStatus[TotalQuerys] ++;
	mysql_tquery(g_MySQLConnection, sprintf("SELECT * FROM teams WHERE gid = %d", G_ID), "OnTeamsLoaded", "");
	MySQLStatus[TotalQuerys] ++;
	mysql_tquery(g_MySQLConnection, sprintf("SELECT * FROM bases_%s", basesPacks[CurrentGamepack][SQLdb]), "OnLoadBase", "");
	MySQLStatus[TotalQuerys] ++;
	mysql_tquery(g_MySQLConnection, "SELECT * FROM arene", "OnLoadArena", "i", -1);
	MySQLStatus[TotalQuerys] ++;
	mysql_tquery(g_MySQLConnection, "SELECT * FROM bases_interiors", "OnLoadInt", "i", -1);
	MySQLStatus[TotalQuerys] ++;
	mysql_tquery(g_MySQLConnection, "SELECT * FROM gungame", "OnLoadGungame", "i", -1);
	MySQLStatus[TotalQuerys] ++;
	mysql_tquery(g_MySQLConnection, "SELECT * FROM fight", "OnLoadFight", "i", -1);
    MySQLStatus[TotalQuerys] ++;
 	mysql_tquery(g_MySQLConnection, "SELECT * FROM lastbullet", "OnLoadLastBullet", "i", -1);// last query
	MySQLStatus[TotalQuerys] ++;
	mysql_tquery(g_MySQLConnection, sprintf("SELECT * FROM weaponsets WHERE gid = %d", G_ID), "OnLoadWeaponsets", "");// last query

    MySQLStatus[TotalQuerys] ++;
	printf("Gamemode ID: %d", G_ID);

	// default team inits
	iTeam[TEAM_REF][OutColor] 		= 0xDCF000AA;
	iTeam[TEAM_REF][InGameColor] 	= iTeam[TEAM_REF][OutColor];
	iTeam[TEAM_A_SUB][Skin]         = 156;
	iTeam[TEAM_B_SUB][Skin]         = 212;

	iTeam [TEAM_A][OutColor] 		= 0xe56b6bAA;
	iTeam [TEAM_A][InGameColor] 	= 0xff0505AA;

	iTeam [TEAM_B][OutColor] 		= 0x798ac0aa;
	iTeam [TEAM_B][InGameColor] 	= 0x0469FFaa;

    // init vars
	TeamRole[TEAM_A] 		= ATTACKERS;
	TeamRole[TEAM_B] 		= DEFENDERS;
	TeamRole[TEAM_REF] 		= REFEREE;

	gConfig[Matchmode] 		= MATCHMODE_NOSCORES;
	gConfig[PMSpec]    		= 1;
	gConfig[GlobalChat] 	= true;

	// textdraws
    CreateGameTextdraws();
//	Label_AddStaticVehicle(431,3.7989,-2668.8308,40.5313,182.2343,59,83); //
//	Label_AddStaticVehicle(431,2.2695,-2638.4487,40.2421,183.3906,59,83); //
//	Label_AddStaticVehicle(431,-3.8256,-2613.9644,40.0794,198.4038,59,83); //
//	Label_AddStaticVehicle(431,-9.9754,-2596.8359,39.8037,200.7877,59,83); //

	// gamemode init
	UsePlayerPedAnims();
	EnableStuntBonusForAll(0);
	DisableInteriorEnterExits();
	SetGravity(0.008);
	AllowInteriorWeapons(1);
	EnableVehicleFriendlyFire();
//	InitMapObjects();

	// timers
	VehicleUpdate_Timer = repeat OnVehicleUpdate();

    // password
	GetServerVarAsString( "password" , Srv_Password , sizeof Srv_Password );

	// vote system
	for (new i = 0; i < MAX_VOTAZIONI; i++)
	{
 		VotesRunning[i][Started] 			= false;
 		VotesRunning[i][Votes]   			= 0;
		VotesRunning[i][VoteInformations]   = -1;
   		VotesRunning[i][Votetype]   		= VOTETYPE_NULL;
   		VotesRunning[i][VoteStarter]   		= INVALID_PLAYER_ID;
	}

	// labels stuff
	//SetTimer( "PlayersLabels_Update" , 1580 , true );
	//SetTimer( "MoneyUpdate"			 , 1350 , true );

	// gamemode ready
	SetGameModeText(#GAMEMODE_NAME);
//    GM_UpTime = gettime();

    // menu
	DemoBase_MenuPOS = CreateMenu("Demo Base", 2, 22.0, 131.0, 100.0, 150.0);
    AddMenuItem(DemoBase_MenuPOS, 0, "A~r~ttackers");
    AddMenuItem(DemoBase_MenuPOS, 0, "D~b~efenders");
    AddMenuItem(DemoBase_MenuPOS, 0, "C~y~heckpoint");

	DemoArena_MenuPOS = CreateMenu("Demo Arena", 2, 22.0, 131.0, 100.0, 150.0);
    AddMenuItem(DemoArena_MenuPOS, 0, "S~r~pawn 1");
    AddMenuItem(DemoArena_MenuPOS, 0, "S~b~pawn 2");
    AddMenuItem(DemoArena_MenuPOS, 0, "C~y~enter");

    #if BUON_NATALE == true
    	CreateDynamicObject(19076, 22.1707, -2660.4319, 40.5383-1.0,0,0,300);			//xmas tree
     	CreateDynamicObject(19054, 22.1707, -2660.4319+1.0, 40.5383-0.4,0,0,300);		//XmasBox1
      	CreateDynamicObject(19058, 22.1707+1.0, -2660.4319, 40.5383-0.4,0,0,300);		//XmasBox5
       	CreateDynamicObject(19056, 22.1707, -2660.4319-1.0, 40.5383-0.4,0,0,300);		//XmasBox3
       	CreateDynamicObject(19057, 22.1707-1.0, -2660.4319, 40.5383-0.4,0,0,300);		//XmasBox4
       	CreateDynamicObject(19058, 22.1707-1.5, -2660.4319+1.5, 40.5383-1.0,0,0,300);	//XmasBox5
        CreateDynamicObject(19055, 22.1707+1.5, -2660.4319-1.5, 40.5383-1.0,0,0,300);	//XmasBox2
        CreateDynamicObject(19057, 22.1707+1.5, -2660.4319+1.5, 40.5383-1.0,0,0,300);	//XmasBox4
        CreateDynamicObject(19054, 22.1707-1.5, -2660.4319-1.5, 40.5383-1.0,0,0,300);	//XmasBox1
        CreateDynamicObject(3526, 22.1707, -2660.4319, 40.5383-1.0,0,0,300);		    //Airportlight - for flashing affect

        Create3DTextLabel("Per Dark", -1, 889.9296, -24.3401, 63.4903, 20.0, 0);

		ListaDesideri = CreatePickup(1239, 3, 892.6461,-27.1026,63.3243, 0);

    #endif

	iTeam[TEAM_A][tLocked] 		= false;
	iTeam[TEAM_B][tLocked] 		= false;
	iTeam[TEAM_REF][tLocked] 	= false;
	iTeam[TEAM_A_SUB][tLocked] 	= false;
	iTeam[TEAM_B_SUB][tLocked] 	= false;
	
	if (fexist("slfd_objects.txt"))
	{
	    print("File slfd_objects.txt ok.");

		new
		    File:f = fopen("slfd_objects.txt", io_read);

		new
		    Float:x,
		    Float:y,
		    Float:z,
		    Float:rx,
		    Float:ry,
		    Float:rz,
			id;

		while (fread(f, stringo))
		{
			sscanf(stringo, "p<,>iffffff", id, x, y, z, rx, ry, rz);

			// I dont save object id cuz the objects created will be destroyed by samp
			// if not report a bug, i will fix fast :3
			CreateDynamicObject(id, x, y, z, rx, ry, rz);
		}

		fclose (f);
	}
   	return true;
}

public OnPlayerPickUpPickup(playerid, pickupid)
{
	#if BUON_NATALE == true
    if(pickupid == ListaDesideri)
    {
		ShowPlayerDialog(playerid, DIALOG_DESIDERI, DIALOG_STYLE_INPUT, "Esprimi un desiderio!", "Scrivi anche tu una lettera a babbo natale!", "Invia", "Chiudi");
    }
    #endif
    return 1;
}

forward OnConfigLoaded(i);
public OnConfigLoaded(i)
{
	new rows, fields;
	cache_get_data(rows, fields);

	if (!rows || !fields)
	{
	    print(">> Error: Invalid gamemode config. (MySQL)");
	}
	else
	{
		new tmp[100];

	    cache_get_field_content(0, "roundtime", tmp); gConfig[RTime_Mins] = strval(tmp);
	    cache_get_field_content(0, "tcp", tmp); gConfig[TCp] = strval(tmp);
	    cache_get_field_content(0, "cp", tmp); gConfig[UCp] = bool:strval(tmp);
	    cache_get_field_content(0, "ready", tmp); gConfig[ReadyType] = strval(tmp);
	    cache_get_field_content(0, "tdmkills", tmp); gConfig[TDMKills] = strval(tmp);
	    cache_get_field_content(0, "lobbyv", tmp); gConfig[LobbyVehicles] = bool:strval(tmp);
	    cache_get_field_content(0, "lobbyw", tmp); gConfig[LobbyWeapons] = bool:strval(tmp);
	    cache_get_field_content(0, "time", tmp); gConfig[GameTime] = strval(tmp);
	    cache_get_field_content(0, "weather", tmp); gConfig[GameWeather] = strval(tmp);
	    cache_get_field_content(0, "hb", tmp); gConfig[UseHealthBars] = bool:strval(tmp);
	    cache_get_field_content(0, "anticbug", tmp); gConfig[AntiCBug] = bool:strval(tmp);
	    //cache_get_field_content(0, "skinswap", tmp); gConfig[SkinSwap] = bool:strval(tmp);
	    cache_get_field_content(0, "autoad", tmp); gConfig[AutoAD] = bool:strval(tmp);

	    cache_get_field_content(0, "usefps", tmp); gConfig[EFpsLimit] = strval(tmp);
	    cache_get_field_content(0, "fpslimit", tmp); gConfig[FpsLimit] = strval(tmp);

	    cache_get_field_content(0, "useping", tmp); gConfig[EPingLimit] = strval(tmp);
	    cache_get_field_content(0, "pinglimit", tmp); gConfig[PingLimit] = strval(tmp);

	    cache_get_field_content(0, "usepl", tmp); gConfig[EPLLimit] = strval(tmp);
	    cache_get_field_content(0, "pllimit", tmp); gConfig[PlLimit] = floatstr (tmp);

	    cache_get_field_content(0, "notice", notice);

	    cache_get_field_content(0, "lobby", tmp);
	    sscanf(tmp, "p<,>ffff", Lobby[0], Lobby[1], Lobby[2], Lobby[3]);

        cache_get_field_content(0, "pvpweaps", tmp);
	    sscanf(tmp, "p<,>dD(0)D(0)D(0)D(0)", PVPWeapons[0], PVPWeapons[1], PVPWeapons[2], PVPWeapons[3], PVPWeapons[4]);

		SetWorldTime(gConfig[GameTime]);
		SetWeather(gConfig[GameWeather]);

		WelcomeLabel 	   = Create3DTextLabel(TXT_WELCOME_LABEL, 0x0055FFAA, Lobby[0], Lobby[1], Lobby[2], DRAWDISTANCE_WELCOMELABEL, 0);

	    print(">> Gamemode config loaded!");
	}

	if (i != -1)
	{
	    SendClientMessage(i, COLOR_SYSTEM, "Ok!");
	}

	FullyReady++;
	return 1;
}
/*
forward COMPATIBILITY_CONFIG(name[], tmp[]);//CONTROLLARE SE BUGGA
public COMPATIBILITY_CONFIG(name[], tmp[])
{
    printf("COMPATIBILITY_CONFIG %s %s", name, tmp);

	if (!strcmp(name, "roundtime", true)) {
	    gConfig[RTime_Mins] = strval (tmp);
	}
	else if (!strcmp(name, "tcp", true)) {
	    gConfig[TCp] = bool:strval (tmp);
	}
	else if (!strcmp(name, "cp", true)) {
	    gConfig[UCp] = strval (tmp);
	}
	else if (!strcmp(name, "ready", true)) {
	    gConfig[ReadyType] = strval (tmp);
	}
	else if (!strcmp(name, "tdmkills", true)) {
	    gConfig[TDMKills] = strval (tmp);
	}
	else if (!strcmp(name, "lobbyv", true)) {
	    gConfig[LobbyVehicles] = bool:strval (tmp);
	}
	else if (!strcmp(name, "lobbyw", true)) {
	    gConfig[LobbyWeapons] = bool:strval (tmp);
	}
	else if (!strcmp(name, "time", true)) {
	    gConfig[GameTime] = strval (tmp);
	}
	else if (!strcmp(name, "weather", true)) {
	    gConfig[GameWeather] = strval (tmp);
	}
	else if (!strcmp(name, "hb", true)) {
	    gConfig[UseHealthBars] = bool:strval (tmp);
	}
	else if (!strcmp(name, "anticbug", true)) {
	    gConfig[AntiCBug] = bool:strval (tmp);
	}
	else if (!strcmp(name, "autoad", true)) {
	    gConfig[AutoAD] = bool:strval (tmp);
	}
	else if (!strcmp(name, "usefps", true)) {
	    gConfig[EFpsLimit] = strval (tmp);
	}
	else if (!strcmp(name, "fpslimit", true)) {
	    gConfig[FpsLimit] = strval (tmp);
	}
	else if (!strcmp(name, "useping", true)) {
	    gConfig[EPingLimit] = strval (tmp);
	}
	else if (!strcmp(name, "pinglimit", true)) {
	    gConfig[PingLimit] = strval (tmp);
	}
	else if (!strcmp(name, "usepl", true)) {
	    gConfig[EPLLimit] = strval (tmp);
	}
	else if (!strcmp(name, "pllimit", true)) {
	    gConfig[PlLimit] = floatstr (tmp);
	}
	else if (!strcmp(name, "notice", true)) {
	    strcpy(notice, tmp);
	}
	else if (!strcmp(name, "lobby", true)) {
	    sscanf(tmp, "p<,>ffff", Lobby[0], Lobby[1], Lobby[2], Lobby[3]);
	}
	else if (!strcmp(name, "pvpweaps", true)) {
	    sscanf(tmp, "p<,>dD(0)D(0)D(0)D(0)", PVPWeapons[0], PVPWeapons[1], PVPWeapons[2], PVPWeapons[3], PVPWeapons[4]);
	}
}
*/
forward OnTeamsLoaded();
public OnTeamsLoaded()
{
	new rows, fields;
	cache_get_data(rows, fields);

	if (rows < 3)
	{
	    print(">> Error: La tabella teams non ï¿½ valida per questa versione della gamemode.");
	}
	else
	{
	    new tmp[ 14 ];
/*
	   	cache_get_field_content (0, "name", iTeam[TEAM_A][Name], .max_len = MAX_TEAM_NAME);
		strins(iTeam[TEAM_A_SUB][Name], sprintf("Sub-%s", iTeam[TEAM_A][Name]), 0);
*/
	   	cache_get_field_content (0, "skin", tmp); iTeam[TEAM_A][Skin] = strval(tmp); //
//	   	cache_get_field_content (0, "ingamecolor", tmp, .max_len = 14); iTeam[TEAM_A][InGameColor] = strval(tmp); //
//	   	cache_get_field_content (0, "outcolor", tmp, .max_len = 14); iTeam[TEAM_A][OutColor] = strval(tmp); //
/*
	   	cache_get_field_content (1, "name", iTeam[TEAM_B][Name], .max_len = MAX_TEAM_NAME);
	   	strins(iTeam[TEAM_B_SUB][Name], sprintf("Sub-%s", iTeam[TEAM_B][Name]), 0);
*/
	   	cache_get_field_content (1, "skin", tmp); iTeam[TEAM_B][Skin] = strval(tmp); //
//	   	cache_get_field_content (1, "ingamecolor", tmp, .max_len = 14); iTeam[TEAM_B][InGameColor] = strval(tmp); //
//	   	cache_get_field_content (1, "outcolor", tmp, .max_len = 14); iTeam[TEAM_B][OutColor] = strval(tmp); //

	   	cache_get_field_content (2, "name", iTeam[TEAM_REF][Name], .max_len = MAX_TEAM_NAME);
	   	cache_get_field_content (2, "skin", tmp, .max_len = 14); iTeam[TEAM_REF][Skin] = strval(tmp); //
//	   	cache_get_field_content (2, "ingamecolor", tmp); iTeam[TEAM_REF][InGameColor] = strval(tmp); //
//	   	cache_get_field_content (2, "outcolor", tmp); iTeam[TEAM_REF][OutColor] = strval(tmp); //

		ChangeTeamName(TEAM_A, "Attackers");
		ChangeTeamName(TEAM_B, "Defenders");

	   	printf("ID: %d (%s)(Sub: %s) - skin %d - color in: %d - color out: %d", TEAM_A, iTeam[TEAM_A][Name], iTeam[TEAM_A_SUB][Name], iTeam[TEAM_A][Skin], iTeam[TEAM_A][InGameColor], iTeam[TEAM_A][OutColor]);
	   	printf("ID: %d (%s)(Sub: %s) - skin %d - color in: %d - color out: %d", TEAM_B, iTeam[TEAM_B][Name], iTeam[TEAM_B_SUB][Name], iTeam[TEAM_B][Skin], iTeam[TEAM_B][InGameColor], iTeam[TEAM_B][OutColor]);
	   	printf("ID: %d (%s) - skin %d - color in: %d - color out: %d", TEAM_REF, iTeam[TEAM_REF][Name], iTeam[TEAM_REF][Skin], iTeam[TEAM_REF][InGameColor], iTeam[TEAM_REF][OutColor]);

		print(">> Teams loaded!");

	    TextDrawSetString(Classtd_SpawnTN[6], sprintf("~r~~h~~h~%s", iTeam[TEAM_A][Name]));
	    TextDrawSetString(Classtd_SpawnTN[7], sprintf("~b~~h~~h~%s", iTeam[TEAM_B][Name]));

		/**
// versione R23
[12:08:47] ID: 1 (s7)(Sub: Sub-s7) - skin 53 - color in: 74055594 - color out: 203913642
[12:08:47] ID: 2 (UeK)(Sub: Sub-UeK) - skin 230 - color in: 113902353 - color out: 190810564
[12:08:47] ID: 3 (Ref) - skin 217 - color in: -588250966 - color out: -588250966

// versione R7 del plugin
[18:16:11] ID: 1 (s7)(Sub: Sub-s7) - skin 53 - color in: 74055594 - color out: 2039136426
[18:16:11] ID: 2 (KV)(Sub: Sub-KV) - skin 230 - color in: 1139023530 - color out: 1908105642
[18:16:11] ID: 3 (Ref) - skin 217 - color in: -588250966 - color out: -588250966

		 * Se true significa che la gamemode deve creare una copia di queste informazioni
		 * per rendere disponibile la gamemode anche quando il database non ï¿½ disponibile

		if (createCopy == true)
		{
		    new
		        INI:copy = INI_Open ("compatibility_mode_slfd/teams.txt");

			INI_SetTag (copy, "teama");

			INI_WriteInt (copy, "skin", iTeam[TEAM_A][Skin]);
			INI_WriteString (copy, "name", iTeam[TEAM_A][Name]);
			INI_WriteHex (copy, "ingamecolor", iTeam[TEAM_A][InGameColor]);
			INI_WriteHex (copy, "outcolor", iTeam[TEAM_A][OutColor]);

			INI_SetTag (copy, "teamb");

			INI_WriteInt (copy, "skin", iTeam[TEAM_B][Skin]);
			INI_WriteString (copy, "name", iTeam[TEAM_B][Name]);
			INI_WriteHex (copy, "ingamecolor", iTeam[TEAM_B][InGameColor]);
			INI_WriteHex (copy, "outcolor", iTeam[TEAM_B][OutColor]);

			INI_SetTag (copy, "ref");

			INI_WriteInt (copy, "skin", iTeam[TEAM_REF][Skin]);
			INI_WriteString (copy, "name", iTeam[TEAM_REF][Name]);
			INI_WriteHex (copy, "ingamecolor", iTeam[TEAM_REF][InGameColor]);
			INI_WriteHex (copy, "outcolor", iTeam[TEAM_REF][OutColor]);

			INI_Close (copy);
		}*/
	}

	iTeam[TEAM_B_SUB][InGameColor] = 0xB28C8CAA;
	iTeam[TEAM_B_SUB][OutColor] = 0xB28C8CAA;

	iTeam[TEAM_A_SUB][InGameColor] = 0xD0D4ACAA;
	iTeam[TEAM_A_SUB][OutColor] = 0xD0D4ACAA;

	AddPlayerClass(59                     		,   Lobby[0], Lobby[1], Lobby[2], Lobby[3], 0, 0, 0, 0, 0, 0);
	AddPlayerClass(iTeam[TEAM_A][Skin]    		, 	Lobby[0], Lobby[1], Lobby[2], Lobby[3], 0, 0, 0, 0, 0, 0);
	AddPlayerClass(iTeam[TEAM_A_SUB][Skin]   	, 	Lobby[0], Lobby[1], Lobby[2], Lobby[3], 0, 0, 0, 0, 0, 0);
	AddPlayerClass(iTeam[TEAM_B][Skin]    		, 	Lobby[0], Lobby[1], Lobby[2], Lobby[3], 0, 0, 0, 0, 0, 0);
	AddPlayerClass(iTeam[TEAM_B_SUB][Skin]    	, 	Lobby[0], Lobby[1], Lobby[2], Lobby[3], 0, 0, 0, 0, 0, 0);
	AddPlayerClass(iTeam[TEAM_REF][Skin]  		, 	Lobby[0], Lobby[1], Lobby[2], Lobby[3], 0, 0, 0, 0, 0, 0);

	FullyReady++;
	return 1;
}

//COMPATIBILITY_CONFIG
/*
forward COMPATIBILITY_TEAMS(tag[], name[], tmp[]);//CONTROLLARE SE BUGGA
public COMPATIBILITY_TEAMS(tag[], name[], tmp[])
{
	printf("Teams: %s %s %s", tag, name, tmp);

	new
	    team = 0;

	if (!strcmp( tag , "teama" , true )) {
		team = TEAM_A;
	}
	else if (!strcmp( tag , "teamb" , true )) {
        team = TEAM_B;
	}
	else if (!strcmp( tag , "ref" , true )) {
        team = TEAM_REF;
	}

	if (!strcmp( name , "skin" , true )) {
		iTeam[team][Skin] = strval (tmp);
	}
	else if (!strcmp( name , "ingamecolor" , true )) {
    	iTeam[team][InGameColor] = HexToInt (tmp);
	}
	else if (!strcmp( name , "outcolor" , true )) {
        iTeam[team][OutColor] = HexToInt (tmp);
	}
	else if (!strcmp( name , "name" , true )) {
		strcpy_2(iTeam[team][Name], tmp);
		strins(iTeam[team == TEAM_A ? TEAM_A_SUB : TEAM_B_SUB][Name], sprintf("Sub-%s", tmp), 0);
	}
}*/

/*// Array[][] = Array su cui lavorare
// arrayIndex = Index dove lavorare
// size = sizeof array = Grandezza dell'array

stock revSort(array[][], arrayIndex = 0, size = sizeof array) // double sort algoritmo
{
	new tmp1, tmp2;

	for (new i = 0; i < size; i++)
	{
	    for (new k = 0; k < size -1 ; k++)
	    {
	        if (array[k][arrayIndex] > array[k + 1][arrayIndex])
	        {
	            tmp1 = array[k][0];
	            tmp2 = array[k][1];

	            array[k][0] 	= array[k + 1][0];
	            array[k][1] 	= array[k + 1][1];

	            array[k + 1][0] = tmp1;
	            array[k + 1][1] = tmp2;
	        }
	    }
	}

	return true;
}*/

//existproperty()

stock GetClan( const nickname[ ] )
{
	new
	    tag[ 12 ],
	    start    = strfind( nickname , "[" ) ,
	    end      = strfind( nickname , "]" );

	if ( start == -1 || start == -1 )
		return tag; //nulla

	if ( start > end )
	    return tag; // nulla

	strmid( tag , nickname , start + 1 , end );
	return tag; //ritorna la tag
}

new g_stored_original_name[80];

enum {
	STATE_DISABLED,
	STATE_WAITING,
	STATE_ENABLED,
}

new AC_State = STATE_DISABLED;

new
    consegutive = 0,
	lastKiller = INVALID_PLAYER_ID;


public OnGameModeExit()
{
	print("... Closing "#GAMEMODE_NAME" -");
	print("		Please wait...");

	if (AC_GetEnabled() == true) SendRconCommand ( sprintf ( "hostname %s", g_stored_original_name ) );

	Delete3DTextLabel( WelcomeLabel );
//    DebugMessage( SessionClose );
//    Td_Pause_Destroy();
    mysql_close (g_MySQLConnection);
//	mysql_close (webMatch[g_Connection]);
	stop VehicleUpdate_Timer;

    print(" .. Goodbye!");
	return true;
}

// spawn player
stock SpawnPlayerSelection(playerid, team)
{
    new auto_assign[ 21 ];

	if (team == -1)
	{
	    team = GetTeamWithLessMembers();
 		auto_assign = "(Auto-Assign)";
	}

	//SendClientMessageToAll(-1,"SpawnPlayerSelection");
	if (FullyReady != FULLY_READY_STEPS) {
	    format (stringo, sizeof stringo, "Wait! The gamemode is sill in loading, might bug... (%d / "#FULLY_READY_STEPS")", FullyReady);
	    SendClientMessage (playerid, -1, stringo);
	}

	SetPlayerTime(playerid, gConfig[GameTime], 0);

	if (!Player[ playerid ][ Loggen ] && Player[ playerid ][ AccountExist ])
	{
	    ShowPlayerDialog(playerid, DIALOG_LOGIN, DIALOG_STYLE_PASSWORD, "Login", "You must be logged in to spawn.", "Login", "");
	    return false;
	}

	if (iTeam [team][tLocked]) {
	    GameTextForPlayer (playerid, "~r~Locked team", 3000, 3);
	    return false;
	}

	if (Player[playerid][Team] != NULL_TEAM)
		iTeam[Player[playerid][Team]][tPlayers] --;

	TextDrawHideForPlayer( playerid , SkinSelection_TDs );

    StopAudioStreamForPlayer(playerid);

   	TextDrawHideForPlayer(playerid, Classtd_SpawnTN[0]);
	TextDrawHideForPlayer(playerid, Classtd_SpawnTN[1]);
	TextDrawHideForPlayer(playerid, Classtd_SpawnTN[2]);
	TextDrawHideForPlayer(playerid, Classtd_SpawnTN[3]);
	TextDrawHideForPlayer(playerid, Classtd_SpawnTN[4]);
	TextDrawHideForPlayer(playerid, Classtd_SpawnTN[5]);
	TextDrawHideForPlayer(playerid, Classtd_SpawnTN[6]);
	TextDrawHideForPlayer(playerid, Classtd_SpawnTN[7]);
	TextDrawHideForPlayer(playerid, Classtd_SpawnTN[8]);

    FirstCreated[playerid] = 0;
	Player[playerid][Team] = team;

	TextDrawShowForPlayer(playerid, GeneralTD[0]);
	TextDrawShowForPlayer(playerid, GeneralTD[1]);

	TextDrawShowForPlayer(playerid, TeamPlayers_TD);

	PlayerTextDrawShow(playerid, PlayerInfo[0]);
	PlayerTextDrawShow(playerid, PlayerInfo[1]);
	PlayerTextDrawShow(playerid, PlayerInfo[2]);

	switch (team)
	{
		case TEAM_A:
		{
		    iTeam[TEAM_A][tPlayers] ++;
		    format(stringo, sizeof stringo, "{"#SC_TEAMA"}%s{FFFFFF} has spawned as {"#SC_TEAMA"}%s{FFFFFF} ({"#SC_TEAMA"}Attackers{FFFFFF}) %s", Player[playerid][Nickname], iTeam[TEAM_A][Name], auto_assign);
		}
		case TEAM_A_SUB:
		{
		    iTeam[TEAM_A_SUB][tPlayers] ++;
		    format(stringo, sizeof stringo, "{"#SC_TEAMSA"}%s{FFFFFF} has spawned as {"#SC_TEAMSA"}%s{FFFFFF} ({"#SC_TEAMSA"}Sub{FFFFFF}) %s", Player[playerid][Nickname], iTeam[TEAM_A_SUB][Name], auto_assign);
		}
		case TEAM_B:
		{
            iTeam[TEAM_B][tPlayers] ++;
		    format(stringo, sizeof stringo, "{"#SC_TEAMB"}%s{FFFFFF} has spawned as {"#SC_TEAMB"}%s{FFFFFF} ({"#SC_TEAMB"}Defenders{FFFFFF}) %s", Player[playerid][Nickname], iTeam[TEAM_B][Name], auto_assign);
		}
		case TEAM_B_SUB:
		{
		    iTeam[TEAM_B_SUB][tPlayers] ++;
		    format(stringo, sizeof stringo, "{"#SC_TEAMSB"}%s{FFFFFF} has spawned as {"#SC_TEAMSB"}%s{FFFFFF} ({"#SC_TEAMSB"}Sub{FFFFFF}) %s", Player[playerid][Nickname], iTeam[TEAM_B_SUB][Name], auto_assign);
		}
		case TEAM_REF:
		{
		    iTeam[TEAM_REF][tPlayers] ++;
		    format(stringo, sizeof stringo, "{"#SC_TEAMR"}%s{FFFFFF} has spawned as {"#SC_TEAMR"}%s{FFFFFF} ({"#SC_TEAMR"}Ref{FFFFFF})", Player[playerid][Nickname], iTeam[TEAM_REF][Name], auto_assign);
		}
	}

	SendClientMessageToAll(-1, stringo);

	SetSpawnInfo(playerid, Player[playerid][Team], GetPlayerSkinEx(playerid), Lobby[0] - MAX_RANDOM_SPAWN + random( MAX_RANDOM_SPAWN ), Lobby[1] - MAX_RANDOM_SPAWN + random( MAX_RANDOM_SPAWN ), Lobby[2], Lobby[3], 0, 0, 0, 0, 0, 0);
	TogglePlayerSpectating (playerid, 0);

	if (gConfig[GameMode] == GAMEMODE_ESL && !RoundStarted)
	{
 		TextDrawShowForPlayer(playerid, ESLModeReady[0]);
 		TextDrawShowForPlayer(playerid, ESLModeReady[1]);
 		TextDrawShowForPlayer(playerid, ESLModeReady[2]);
 		TextDrawShowForPlayer(playerid, ESLModeReady[3]);

 		RefreshReadyTDs_Esl();
	}
	else if (RoundStarted)
	{
		TextDrawShowForPlayer(playerid, RoundStats[0]);
		TextDrawShowForPlayer(playerid, RoundStats[1]);
		TextDrawShowForPlayer(playerid, RoundStats[2]);
		TextDrawShowForPlayer(playerid, RoundStats[3]);
	}

	RefreshTeamPlayers_TD();
	return true;
}

stock PutPlayerInSkinSelection(playerid)
{
	Player[playerid][fake_selection] = false;
	SetPlayerTime(playerid, 0, 0);
	//SpawnPlayer(playerid);
    TogglePlayerSpectating (playerid, 1);

	// inizializzo
    TextDrawShowForPlayer(playerid, Classtd_SpawnTN[0]);
	TextDrawShowForPlayer(playerid, Classtd_SpawnTN[1]);
	TextDrawShowForPlayer(playerid, Classtd_SpawnTN[2]);
	TextDrawShowForPlayer(playerid, Classtd_SpawnTN[3]);
	TextDrawShowForPlayer(playerid, Classtd_SpawnTN[4]);
	TextDrawShowForPlayer(playerid, Classtd_SpawnTN[5]);
	TextDrawShowForPlayer(playerid, Classtd_SpawnTN[6]);
	TextDrawShowForPlayer(playerid, Classtd_SpawnTN[7]);
	TextDrawShowForPlayer(playerid, Classtd_SpawnTN[8]);

	PlayerTextDrawHide(playerid, PlayerInfo[0]);
	PlayerTextDrawHide(playerid, PlayerInfo[1]);
	PlayerTextDrawHide(playerid, PlayerInfo[2]);

	TextDrawHideForPlayer(playerid, RoundStats[0]);
	TextDrawHideForPlayer(playerid, RoundStats[1]);
	TextDrawHideForPlayer(playerid, RoundStats[2]);
	TextDrawHideForPlayer(playerid, RoundStats[3]);

	TextDrawHideForPlayer(playerid, GeneralTD[0]);
	TextDrawHideForPlayer(playerid, GeneralTD[1]);

	if(Player[playerid][RadioStream] == false)
	{
	    PlayAudioStreamForPlayer(playerid, RADIO_URL);
	}

//	SetPlayerPos(playerid, -2721.4504,-318.3214,7.8438 );
//	SetPlayerFacingAngle(playerid, 47.9919 );
	// bisogna prendere una pos per la cam
	InterpolateCameraPos(playerid, 2523.975, -1749.962, 57.202, 2277.878, -1313.666, 57.202, 20000, CAMERA_MOVE);
	InterpolateCameraLookAt(playerid, 2523.755, -1749.572, 56.3075, 2277.658, -1313.276, 56.3075, 20000, CAMERA_MOVE);

	SelectTextDraw(playerid, 0xFFFFFF);
}


public OnPlayerRequestClass(playerid, classid)
{
	if (Player[playerid][SkinSelection]) {
	    // do le informazioni di spawn almeno le prime..
	    SetSpawnInfo (playerid, NO_TEAM, 0, 2489.5845,-1663.0780,13.3359,78.3537, 0, 0, 0, 0, 0, 0);
		PutPlayerInSkinSelection (playerid);
		//SpawnPlayer (playerid);
		return true;
	}
	/*
    pClassid[playerid] = classid;

    TextDrawShowForPlayer( playerid , SkinSelection_TDs );
    PlayerTextDrawShow(playerid, Classtd_SpawnTN[0]);
	PlayerTextDrawShow(playerid, Classtd_SpawnTN[1]);
	PlayerTextDrawShow(playerid, Classtd_SpawnTN[2]);
	PlayerTextDrawShow(playerid, Classtd_SpawnTN[3]);
	PlayerTextDrawShow(playerid, Classtd_SpawnTN[4]);
	PlayerTextDrawShow(playerid, Classtd_SpawnTN[5]);
	PlayerTextDrawShow(playerid, Classtd_SpawnTN[6]);
	PlayerTextDrawShow(playerid, Classtd_SpawnTN[7]);
	PlayerTextDrawShow(playerid, Classtd_SpawnTN[8]);

	PlayerTextDrawHide(playerid, PlayerInfo[0]);
	PlayerTextDrawHide(playerid, PlayerInfo[1]);
	PlayerTextDrawHide(playerid, PlayerInfo[2]);

	TextDrawHideForPlayer(playerid, RoundStats[0]);
	TextDrawHideForPlayer(playerid, RoundStats[1]);
	TextDrawHideForPlayer(playerid, RoundStats[2]);
	TextDrawHideForPlayer(playerid, RoundStats[3]);

	TextDrawHideForPlayer(playerid, GeneralTD[0]);
	TextDrawHideForPlayer(playerid, GeneralTD[1]);

	switch (pClassid[playerid])
	{
	    case 0:
	    {
	        PlayerTextDrawSetString(playerid, Classtd_SpawnTN, "~r~Auto-Assign");
	    }
	    case 1:
	    {
	        PlayerTextDrawSetString(playerid, Classtd_SpawnTN, sprintf("~"#GT_TEAMA"~%s ~w~(~"#GT_TEAMA"~~h~%s~w~)" , GetRoleName( TeamRole[ TEAM_A ] ) , iTeam[ TEAM_A ][ Name ] ));
	    }
	    case 2:
	    {
	        PlayerTextDrawSetString(playerid, Classtd_SpawnTN, sprintf("~"#GT_TEAMA"~%s ~w~(~"#GT_TEAMA"~~h~%s~w~)" , "Sub" , iTeam[ TEAM_A_SUB ][ Name ] ));
	    }
	    case 3:
	    {
	        PlayerTextDrawSetString(playerid, Classtd_SpawnTN, sprintf("~"#GT_TEAMB"~%s ~w~(~"#GT_TEAMB"~~h~%s~w~)" , GetRoleName( TeamRole[ TEAM_B ] ) , iTeam[ TEAM_B ][ Name ] ));
	    }
	    case 4:
	    {
	        PlayerTextDrawSetString(playerid, Classtd_SpawnTN, sprintf("~"#GT_TEAMB"~%s ~w~(~"#GT_TEAMB"~~h~%s~w~)" , "Sub" , iTeam[ TEAM_B_SUB ][ Name ] ));
	    }
	    case 5:
	    {
	        PlayerTextDrawSetString(playerid, Classtd_SpawnTN, "~y~Referee");
	    }
	}

	if(!Player[playerid][MusicClass] && Player[playerid][RadioStream] == false)
	{
	    Player[playerid][MusicClass]  = true;
	    PlayAudioStreamForPlayer(playerid, RADIO_URL);
	}

	SetPlayerPos(playerid, -2721.4504,-318.3214,7.8438 );
	SetPlayerFacingAngle(playerid, 47.9919 );
	SetPlayerCameraPos(playerid, -2727.3826,-311.8189,7.0391);
	SetPlayerCameraLookAt(playerid, -2721.4504,-318.3214,7.8438);*/
	return true;
}

stock PlaySoundForAll(soundid)
{
	foreach(new i:Player)
	{
		PlayerPlaySound(i, soundid, 0.0, 0.0, 0.0);
	}
}

public OnPlayerConnect(playerid)
{
    Player_LastVeh[playerid] = -1;
	Player[playerid][SkinSelection] = true;
	Player[playerid][fake_selection] = false;

	// send alway connect msg
    Server_RefreshStats(TotalConnectedPlayers, 1);

	// msg-ingresso
	// 0xAFAFAFAA
    GetPlayerName(playerid, Player[playerid][Nickname], 24);
    //new ip[16];
    GetPlayerIp (playerid, Player[playerid][WhoIs_uIp], 16);
	//new country[ 158 playerid];
	GetPlayerCountry(playerid, Player[playerid][WhoIs_Country], 158);
	GetPlayerISP(playerid, Player[playerid][WhoIs_Isp], 60);
	GetPlayerCity(playerid, Player[playerid][WhoIs_City], 40);


	new admin[ STRLIB_RETURN_SIZE ];
//			admin = sprintf( "{AFAFAF}%s{FFFFFF} ({AFAFAF}%d{FFFFFF}) has connected. ({AFAFAF}%s{FFFFFF}) ({AFAFAF}%s{FFFFFF})" , Player[extraid][Nickname], extraid, Player[extraid][WhoIs_Country], Player[extraid][WhoIs_uIp] );
	admin = sprintf( "%s (%d) has connected. (%s) (%s)" , Player[playerid][Nickname], playerid, Player[playerid][WhoIs_Country], Player[playerid][WhoIs_uIp] );
	new utente[ STRLIB_RETURN_SIZE ];
//			utente = sprintf( "{AFAFAF}%s{FFFFFF} ({AFAFAF}%d{FFFFFF}) has connected. ({AFAFAF}%s{FFFFFF})" , Player[extraid][Nickname], extraid, Player[extraid][WhoIs_Country] );
	utente = sprintf( "%s (%d) has connected. (%s)" , Player[playerid][Nickname], playerid, Player[playerid][WhoIs_Country] );

	foreach(new i:Player)
	{
	    if (Player[i][aLevel] >= _:lMod || IsPlayerAdmin(i))
	    {
	        SendClientMessage(i, COLOR_GREY, admin);
	    }
	    else
	    {
	        SendClientMessage(i, COLOR_GREY, utente);
	    }
	}

	PlaySoundForAll(1054);//fix eventuali suoni (musiche)

	Player[playerid][ConnectedNow] = true;
	Player[playerid][LastHP] = 0;
	Player[playerid][LastArmour] = 0;
	Player[playerid][InRestoring] = false;

	if (FullyReady != FULLY_READY_STEPS)
	{
		SendClientMessage(playerid, -1, "The gamemode is still loading.. wait a bit!");
	}

	Player[playerid][Connected] = true;
//	Player[playerid][pMatchID] = -1;

	// Quando il giocatore si collega assegna il matchID corrispondente

//	new oldname[24];
//	oldname = Player[playerid][Nickname];
	/*
    for (new i = 0; i < MAX_MATCH_DATA; ++ i)
    {
        if (!strcmp(PlayerMatch[i][mNickname], Player[playerid][Nickname], true)) {
            // Same player
            //

            Player[playerid][pMatchID] = i;
			PlayerMatch [i][mConnected] = true;

			// assign variables
	   		Player[playerid][Kills]  		 = PlayerMatch[i][mKills];
			Player[playerid][Damage] 		 = PlayerMatch[i][mDamage];
			Player[playerid][Deaths] 		 = PlayerMatch[i][mDeaths];
			Player[playerid][RKills] 	 	 = PlayerMatch[i][mRKills];
			Player[playerid][RDamage] 		 = PlayerMatch[i][mRDamage];
			Player[playerid][RDeaths] 		 = PlayerMatch[i][mRDeaths];
            break;
        }
    }*/
    /*
    // name should be the same, case too.
    if (strcmp(oldname, Player[playerid][Nickname], false)) {
        // is not the same player;
        // reset his stats.

   		Player[playerid][Kills]  		 = 0;
		Player[playerid][Damage] 		 = 0;
		Player[playerid][Deaths] 		 = 0;
		Player[playerid][RKills] 	 	 = 0;
		Player[playerid][RDamage] 		 = 0;
		Player[playerid][RDeaths] 		 = 0;
    }
    */
	Player[playerid][Nickname_WOTag] = RemoveClan (Player[playerid][Nickname]);
	SetPlayerColor(playerid, COLOR_GREY);

	strcpy_2(Player[playerid][LastWritten], "_");
	Player[playerid][fInWaiting]  = false;

	new ip[16]; GetPlayerIp(playerid, ip, 16);

	// ban check system
	//Player[playerid][Serial] = " ";
    gpci( playerid , Player[playerid][Serial] , 50 );

//    mysql_function_query (g_MySQLConnection, sprintf ("SELECT CASE WHEN bantype = 0 THEN ip WHEN bantype = 1 THEN nickname ELSE serial END as 'risorsa', bantype, adminban FROM bans WHERE nickname = '%s' AND banned = 1", Player[playerid][Nickname]), true, "OnPlayerBanCheck", "i", playerid);

	new query [300];
	format (query, sizeof query, "SELECT CASE WHEN bantype = 0 THEN ip WHEN bantype = 1 THEN nickname ELSE serial END as 'risorsa', bantype, adminban FROM bans WHERE (nickname = '%s' OR serial = '%s' OR ip = '%s') AND banned = 1", Player[playerid][Nickname], Player[playerid][Serial], ip);
	mysql_tquery (g_MySQLConnection, query, "OnPlayerBanCheck", "i", playerid);
    MySQLStatus[TotalQuerys] ++;

	if(Player[playerid][AfkLabelCreated] == true)
 	{
  	    PlayerAfk_Seconds[playerid] = 0;
		Delete3DTextLabel(Player[playerid][AfkLabel]);
		Player[playerid][AfkLabelCreated] = false;
	}

	Player[ playerid ][ Weapons ][ 0 ] = 0;
	Player[ playerid ][ Weapons ][ 1 ] = 0;
	Player[ playerid ][ Weapons ][ 2 ] = 0;
	Player[ playerid ][ Weapons ][ 3 ] = 0;
	Player[ playerid ][ Weapons ][ 4 ] = 0;
	Player[ playerid ][ Weapons ][ 5 ] = 0;
	Player[ playerid ][ Weapons ][ 6 ] = 0;
	Player[ playerid ][ Weapons ][ 7 ] = 0;
	Player[ playerid ][ Weapons ][ 8 ] = 0;
	Player[ playerid ][ Weapons ][ 9 ] = 0;
	Player[ playerid ][ Weapons ][ 10 ] = 0;
	Player[ playerid ][ Weapons ][ 11 ] = 0;
	Player[ playerid ][ Weapons ][ 12 ] = 0;

	Editing_BaseID[playerid] = -1;

	Editor_WorkingType [playerid] = EDITOR_WORKTYPE_NOONE;

	Player[playerid][AllowDM][0] = false;
	Player[playerid][AllowDM][1] = false;
	Player[playerid][AllowDM][2] = false;
	Player[playerid][AllowDM][3] = false;
	Player[playerid][AllowDM][4] = false;
	Player[playerid][AllowDM][5] = false;
	Player[playerid][AllowDM][6] = false;
	Player[playerid][AllowDM][7] = false;
	Player[playerid][AllowDM][8] = false;
	Player[playerid][AllowDM][9] = false;
	Player[playerid][AllowDM][10] = false;
	Player[playerid][AllowDM][11] = false;
	Player[playerid][AllowDM][12] = false;
	/*
	for (new i = 0; i < MAX_MULTI_HITS ; i++)
	{
	    //dHealth
		Player[ playerid ][ HitID ][i]  		= INVALID_PLAYER_ID ;
		Player[ playerid ][ Amount ][i]     	= 0 ;
        Player[ playerid ][ dWeaponID ][i]     	= 0 ;
        Player[ playerid ][ dHealth ][i]     	= 0 ;

		Player[ playerid ][ tHitID ][i]  		= INVALID_PLAYER_ID ;
		Player[ playerid ][ tAmount ][i]     	= 0 ;
		Player[ playerid ][ tdWeaponID ][i]     = 0 ;
	}
	*/
	/*
	Player[playerid][TD1_ID][0] = INVALID_PLAYER_ID;
	Player[playerid][TD1_Weap][0] = 0;
	Player[playerid][TD1_Dmg][0] = 0;
	Player[playerid][TD1_Health][0] = 0;
	Player[playerid][TD1_Natural][0] = false;

	Player[playerid][TD0_ID][0] = INVALID_PLAYER_ID;
	aWeaponNames[Player[Player[playerid][TD0_Weap][0]][TD0_WEAP][playerid]] = 0;
	Player[playerid][TD0_Dmg][0] = 0;
	Player[playerid][TD0_Health][0] = 0;
	Player[playerid][TD0_Natural][0] = false;

	Player[playerid][TD1_ID][1] = INVALID_PLAYER_ID;
	Player[playerid][TD1_Weap][1] = 0;
	Player[playerid][TD1_Dmg][1] = 0;
	Player[playerid][TD1_Health][1] = 0;
	Player[playerid][TD1_Natural][1] = false;

	Player[playerid][TD0_ID][1] = INVALID_PLAYER_ID;
	Player[playerid][TD0_Weap][1] = 0;
	Player[playerid][TD0_Dmg][1] = 0;
	Player[playerid][TD0_Health][1] = 0;
	Player[playerid][TD0_Natural][1] = false;

	Player[playerid][TD1_ID][2] = INVALID_PLAYER_ID;
	Player[playerid][TD1_Weap][2] = 0;
	Player[playerid][TD1_Dmg][2] = 0;
	Player[playerid][TD1_Health][2] = 0;
	Player[playerid][TD1_Natural][2] = false;

	Player[playerid][TD0_ID][2] = INVALID_PLAYER_ID;
	Player[playerid][TD0_Weap][2] = 0;
	Player[playerid][TD0_Dmg][2] = 0;
	Player[playerid][TD0_Health][2] = 0;
	Player[playerid][TD0_Natural][2] = false;

	Player[playerid][TD1_ID][3] = INVALID_PLAYER_ID;
	Player[playerid][TD1_Weap][3] = 0;
	Player[playerid][TD1_Dmg][3] = 0;
	Player[playerid][TD1_Health][3] = 0;
	Player[playerid][TD1_Natural][3] = false;

	Player[playerid][TD0_ID][3] = INVALID_PLAYER_ID;
	Player[playerid][TD0_Weap][3] = 0;
	Player[playerid][TD0_Dmg][3] = 0;
	Player[playerid][TD0_Health][3] = 0;
	Player[playerid][TD0_Natural][3] = false;

	Player[playerid][TD1_ID][4] = INVALID_PLAYER_ID;
	Player[playerid][TD1_Weap][4] = 0;
	Player[playerid][TD1_Dmg][4] = 0;
	Player[playerid][TD1_Health][4] = 0;
	Player[playerid][TD1_Natural][4] = false;

	Player[playerid][TD0_ID][4] = INVALID_PLAYER_ID;
	Player[playerid][TD0_Weap][4] = 0;
	Player[playerid][TD0_Dmg][4] = 0;
	Player[playerid][TD0_Health][4] = 0;
	Player[playerid][TD0_Natural][4] = false;
	*/

	Player[playerid][TD0_ID][0] = INVALID_PLAYER_ID;
	Player[playerid][TD1_ID][0] = INVALID_PLAYER_ID;
	Player[playerid][TD0_WEAP][0] = 0;
	Player[playerid][TD1_WEAP][0] = 0;
	Player[playerid][TD0_DMG][0] = 0;
	Player[playerid][TD1_DMG][0] = 0;
	Player[playerid][TD0_HEALTH][0] = 0;
	Player[playerid][TD1_HEALTH][0] = 0;


	Player[playerid][TD0_ID][1] = INVALID_PLAYER_ID;
	Player[playerid][TD1_ID][1] = INVALID_PLAYER_ID;
	Player[playerid][TD0_WEAP][1] = 0;
	Player[playerid][TD1_WEAP][1] = 0;
	Player[playerid][TD0_DMG][1] = 0;
	Player[playerid][TD1_DMG][1] = 0;
	Player[playerid][TD0_HEALTH][1] = 0;
	Player[playerid][TD1_HEALTH][1] = 0;


	Player[playerid][TD0_ID][2] = INVALID_PLAYER_ID;
	Player[playerid][TD1_ID][2] = INVALID_PLAYER_ID;
	Player[playerid][TD0_WEAP][2] = 0;
	Player[playerid][TD1_WEAP][2] = 0;
	Player[playerid][TD0_DMG][2] = 0;
	Player[playerid][TD1_DMG][2] = 0;
	Player[playerid][TD0_HEALTH][2] = 0;
	Player[playerid][TD1_HEALTH][2] = 0;


	Player[playerid][TD0_ID][3] = INVALID_PLAYER_ID;
	Player[playerid][TD1_ID][3] = INVALID_PLAYER_ID;
	Player[playerid][TD0_WEAP][3] = 0;
	Player[playerid][TD1_WEAP][3] = 0;
	Player[playerid][TD0_DMG][3] = 0;
	Player[playerid][TD1_DMG][3] = 0;
	Player[playerid][TD0_HEALTH][3] = 0;
	Player[playerid][TD1_HEALTH][3] = 0;


	Player[playerid][TD0_ID][4] = INVALID_PLAYER_ID;
	Player[playerid][TD1_ID][4] = INVALID_PLAYER_ID;
	Player[playerid][TD0_WEAP][4] = 0;
	Player[playerid][TD1_WEAP][4] = 0;
	Player[playerid][TD0_DMG][4] = 0;
	Player[playerid][TD1_DMG][4] = 0;
	Player[playerid][TD0_HEALTH][4] = 0;
	Player[playerid][TD1_HEALTH][4] = 0;
	Player[playerid][tmpLevel]       = false;

    Player[playerid][InDm]       	 = -1;
    Player[playerid][InGame]         = 0;
    Player[playerid][Weaponset]  	 = INVALID_WEAPON_SET;
//	SyncLocked[playerid]        	 = false;

  //  pDrunkLevelLast[playerid]   	 = 0;
    pFPS[playerid]          		 = 0;
	InSpec[playerid]                 = -1;
	Player[playerid][Skin]           = 0;
	Player[playerid][Muted]          = false;
	Player[playerid][RconFails]      = 0;
	Player[playerid][IsAfk]          = false;
//	Player[playerid][MusicClass]     = true;
	Player[playerid][Label_PlInfo]   = Text3D:-1;
	Player[playerid][RadioStream]    = false;
	Player[playerid][AfkLabel]       = Text3D:-1;
	PlayerReady[playerid]            = false;
	Player[playerid][aLevel]         = 0;
	Player[playerid][Connected]      = true;
    Player[playerid][Loggen]         = false;
    Player[playerid][AccountExist]   = false;
	Player[playerid][Spawned] 		 = false;
	FirstCreated[playerid] 			 = 0;
	Sync_InCorso[playerid]           = 0;
	Player[playerid][lastSpawnedVeh] = -1;
	timeoutPlayer[playerid]          = false;

    //
    PlayerPlaySound(playerid, 1098, 0.0, 0.0, 0.0);

	// textdraws
/*	PlayerInfo = CreatePlayerTextDraw(playerid, 1.000000, 387.000000, "~y~~h~FPS: ~w~-~n~~y~~h~Kills: ~w~-~n~~y~~h~Damage: ~w~-~n~~y~~h~Packetloss: ~w~-");
	PlayerTextDrawBackgroundColor(playerid, PlayerInfo, 40);//td kills: 40 - vecchio: 255
	PlayerTextDrawFont(playerid, PlayerInfo, 1);
	PlayerTextDrawLetterSize(playerid, PlayerInfo, 0.219999, 0.899999);// td kills: 0.219999, 0.899999 - vecchio: 0.229998, 1.100000
	PlayerTextDrawColor(playerid, PlayerInfo, -1);
	PlayerTextDrawSetOutline(playerid, PlayerInfo, 1);
	PlayerTextDrawSetProportional(playerid, PlayerInfo, 1);
	PlayerTextDrawSetShadow(playerid, PlayerInfo, 1);
*/
	/*
	vecchi playerinfo
	PlayerInfo[1] = CreatePlayerTextDraw(playerid, 2.000000, 416.000000, "~b~~h~Damage ~w~0~n~~b~~h~T. Dmg ~w~0");
	PlayerTextDrawBackgroundColor(playerid, PlayerInfo[1], 255);
	PlayerTextDrawFont(playerid, PlayerInfo[1], 1);
	PlayerTextDrawLetterSize(playerid, PlayerInfo[1], 0.209999, 0.799998);
	PlayerTextDrawColor(playerid, PlayerInfo[1], -1);
	PlayerTextDrawSetOutline(playerid, PlayerInfo[1], 0);
	PlayerTextDrawSetProportional(playerid, PlayerInfo[1], 1);
	PlayerTextDrawSetShadow(playerid, PlayerInfo[1], 1);


	PlayerInfo[2] = CreatePlayerTextDraw(playerid, 1.000000, 395.000000, "~b~~h~~h~FPS ~w~100");
	PlayerTextDrawBackgroundColor(playerid, PlayerInfo[2], 255);
	PlayerTextDrawFont(playerid, PlayerInfo[2], 1);
	PlayerTextDrawLetterSize(playerid, PlayerInfo[2], 0.209999, 0.799998);
	PlayerTextDrawColor(playerid, PlayerInfo[2], -1);
	PlayerTextDrawSetOutline(playerid, PlayerInfo[2], 0);
	PlayerTextDrawSetProportional(playerid, PlayerInfo[2], 1);
	PlayerTextDrawSetShadow(playerid, PlayerInfo[2], 1);

	PlayerInfo[0] = CreatePlayerTextDraw(playerid, 2.000000, 402.000000, "~b~~h~~h~Ping ~w~135~n~~b~~h~~h~PL ~w~11.4%");
	PlayerTextDrawBackgroundColor(playerid, PlayerInfo[0], 255);
	PlayerTextDrawFont(playerid, PlayerInfo[0], 1);
	PlayerTextDrawLetterSize(playerid, PlayerInfo[0], 0.209999, 0.799998);
	PlayerTextDrawColor(playerid, PlayerInfo[0], -1);
	PlayerTextDrawSetOutline(playerid, PlayerInfo[0], 0);
	PlayerTextDrawSetProportional(playerid, PlayerInfo[0], 1);
	PlayerTextDrawSetShadow(playerid, PlayerInfo[0], 1);
	*/

	// nuovo
	PlayerInfo[1] = CreatePlayerTextDraw(playerid, 3.000000, 410.000000, "DMG ~b~~h~0~n~~w~Tot. DMG ~b~~h~0");
	PlayerTextDrawBackgroundColor(playerid, PlayerInfo[1], 48);
	PlayerTextDrawFont(playerid, PlayerInfo[1], 1);
	PlayerTextDrawLetterSize(playerid, PlayerInfo[1], 0.209999, 0.799998);
	PlayerTextDrawColor(playerid, PlayerInfo[1], -1);
	PlayerTextDrawSetOutline(playerid, PlayerInfo[1], 1);
	PlayerTextDrawSetProportional(playerid, PlayerInfo[1], 1);

	PlayerInfo[0] = CreatePlayerTextDraw(playerid, 554.000000, -2.000000, "_");
	PlayerTextDrawAlignment(playerid, PlayerInfo[0], 2);
	PlayerTextDrawBackgroundColor(playerid, PlayerInfo[0], 255);
	PlayerTextDrawFont(playerid, PlayerInfo[0], 1);
	PlayerTextDrawLetterSize(playerid, PlayerInfo[0], 0.500000, 1.500000);
	PlayerTextDrawColor(playerid, PlayerInfo[0], -1);
	PlayerTextDrawSetOutline(playerid, PlayerInfo[0], 0);
	PlayerTextDrawSetProportional(playerid, PlayerInfo[0], 1);
	PlayerTextDrawSetShadow(playerid, PlayerInfo[0], 1);
	PlayerTextDrawUseBox(playerid, PlayerInfo[0], 1);
	PlayerTextDrawBoxColor(playerid, PlayerInfo[0], 32);
	PlayerTextDrawTextSize(playerid, PlayerInfo[0], 0.000000, 105.000000);

	PlayerInfo[2] = CreatePlayerTextDraw(playerid, 554.000000, 3.000000, "FPS ~b~~h~0 ~w~Ping ~b~~h~0 ~w~PL ~b~~h~0");
	PlayerTextDrawAlignment(playerid, PlayerInfo[2], 2);
	PlayerTextDrawBackgroundColor(playerid, PlayerInfo[2], 48);
	PlayerTextDrawFont(playerid, PlayerInfo[2], 1);
	PlayerTextDrawLetterSize(playerid, PlayerInfo[2], 0.209999, 0.799998);
	PlayerTextDrawColor(playerid, PlayerInfo[2], -1);
	PlayerTextDrawSetOutline(playerid, PlayerInfo[2], 1);
	PlayerTextDrawSetProportional(playerid, PlayerInfo[2], 1);

	/*PlayerKillTD[0] = CreatePlayerTextDraw(playerid, 323.000000, 358.000000, "_");
	PlayerTextDrawAlignment(playerid, PlayerKillTD[0], 2);
	PlayerTextDrawBackgroundColor(playerid, PlayerKillTD[0], 255);
	PlayerTextDrawFont(playerid, PlayerKillTD[0], 1);
	PlayerTextDrawLetterSize(playerid, PlayerKillTD[0], 0.500000, 2.700000);
	PlayerTextDrawColor(playerid, PlayerKillTD[0], -1);
	PlayerTextDrawSetOutline(playerid, PlayerKillTD[0], 0);
	PlayerTextDrawSetProportional(playerid, PlayerKillTD[0], 1);
	PlayerTextDrawSetShadow(playerid, PlayerKillTD[0], 1);
	PlayerTextDrawUseBox(playerid, PlayerKillTD[0], 1);
	PlayerTextDrawBoxColor(playerid, PlayerKillTD[0], 101);
	PlayerTextDrawTextSize(playerid, PlayerKillTD[0], 0.000000, -210.000000);

	PlayerKillTD[1] = CreatePlayerTextDraw(playerid, 323.000000, 360.000000, "~b~~h~- You have Slaughtered ~g~~h~[s7]Morgenstern -");
	PlayerTextDrawAlignment(playerid, PlayerKillTD[1], 2);
	PlayerTextDrawBackgroundColor(playerid, PlayerKillTD[1], 255);
	PlayerTextDrawFont(playerid, PlayerKillTD[1], 1);
	PlayerTextDrawLetterSize(playerid, PlayerKillTD[1], 0.250000, 2.000000);
	PlayerTextDrawColor(playerid, PlayerKillTD[1], -1);
	PlayerTextDrawSetOutline(playerid, PlayerKillTD[1], 0);
	PlayerTextDrawSetProportional(playerid, PlayerKillTD[1], 1);
	PlayerTextDrawSetShadow(playerid, PlayerKillTD[1], 2);*/

	// PlayerKillTD
	PlayerKillTD = CreatePlayerTextDraw(playerid, 325.000000, 338.000000, "You killed ~g~~h~[s7]Morgenstern");
	PlayerTextDrawAlignment(playerid, PlayerKillTD, 2);
	PlayerTextDrawBackgroundColor(playerid, PlayerKillTD, 96);
	PlayerTextDrawFont(playerid, PlayerKillTD, 1);
	PlayerTextDrawLetterSize(playerid, PlayerKillTD, 0.330000, 1.299998);
	PlayerTextDrawColor(playerid, PlayerKillTD, -1);
	PlayerTextDrawSetOutline(playerid, PlayerKillTD, 1);
	PlayerTextDrawSetProportional(playerid, PlayerKillTD, 1);

	/*
	// old td
	TD_Player_Damages[0] = CreatePlayerTextDraw(playerid, 140.000000, 361.000000, "s7rev +150 // Deagle");
	PlayerTextDrawBackgroundColor(playerid, TD_Player_Damages[0], 40);
	PlayerTextDrawFont(playerid, TD_Player_Damages[0], 1);
	PlayerTextDrawLetterSize(playerid, TD_Player_Damages[0], 0.219999, 0.899999);
	PlayerTextDrawColor(playerid, TD_Player_Damages[0], 753474474);
	PlayerTextDrawSetOutline(playerid, TD_Player_Damages[0], 1);
	PlayerTextDrawSetProportional(playerid, TD_Player_Damages[0], 1);

	TD_Player_Damages[1] = CreatePlayerTextDraw(playerid, 473.000000, 361.000000, "abc -123 // Spas12");
	PlayerTextDrawAlignment(playerid, TD_Player_Damages[1], 3);
	PlayerTextDrawBackgroundColor(playerid, TD_Player_Damages[1], 34);
	PlayerTextDrawFont(playerid, TD_Player_Damages[1], 1);
	PlayerTextDrawLetterSize(playerid, TD_Player_Damages[1], 0.219999, 0.899999);
	PlayerTextDrawColor(playerid, TD_Player_Damages[1], -384099414);
	PlayerTextDrawSetOutline(playerid, TD_Player_Damages[1], 1);
	PlayerTextDrawSetProportional(playerid, TD_Player_Damages[1], 1);
	*/

	// new td
	// verde
	new PlayerText:tt = TD_Player_Damages[0][0] = CreatePlayerTextDraw(playerid, 143.000000, 353.000000, "~g~~h~Morgenstern ~w~-46 /~g~~h~ Deagle ~w~(~r~~h~~h~40~w~)");
	PlayerTextDrawBackgroundColor(playerid, tt, 48);
	PlayerTextDrawFont(playerid, tt, 1);
	PlayerTextDrawLetterSize(playerid, tt, 0.200000, 1.000000);
	PlayerTextDrawColor(playerid, tt, -1);
	PlayerTextDrawSetOutline(playerid, tt, 1);
	PlayerTextDrawSetProportional(playerid, tt, 1);

	tt = TD_Player_Damages[0][1] = CreatePlayerTextDraw(playerid, 143.000000, 363.000000, "~g~~h~Morgenstern ~w~-46 /~g~~h~ Deagle ~w~(~r~~h~~h~40~w~)");
	PlayerTextDrawBackgroundColor(playerid, tt, 48);
	PlayerTextDrawFont(playerid, tt, 1);
	PlayerTextDrawLetterSize(playerid, tt, 0.200000, 1.000000);
	PlayerTextDrawColor(playerid, tt, -1);
	PlayerTextDrawSetOutline(playerid, tt, 1);
	PlayerTextDrawSetProportional(playerid, tt, 1);

	tt = TD_Player_Damages[0][2] = CreatePlayerTextDraw(playerid, 143.000000, 373.000000, "~g~~h~Morgenstern ~w~-46 /~g~~h~ Deagle ~w~(~r~~h~~h~40~w~)");
	PlayerTextDrawBackgroundColor(playerid, tt, 48);
	PlayerTextDrawFont(playerid, tt, 1);
	PlayerTextDrawLetterSize(playerid, tt, 0.200000, 1.000000);
	PlayerTextDrawColor(playerid, tt, -1);
	PlayerTextDrawSetOutline(playerid, tt, 1);
	PlayerTextDrawSetProportional(playerid, tt, 1);

	tt = TD_Player_Damages[0][3] = CreatePlayerTextDraw(playerid, 143.000000, 383.000000, "~g~~h~Morgenstern ~w~-46 /~g~~h~ Deagle ~w~(~r~~h~~h~40~w~)");
	PlayerTextDrawBackgroundColor(playerid, tt, 48);
	PlayerTextDrawFont(playerid, tt, 1);
	PlayerTextDrawLetterSize(playerid, tt, 0.200000, 1.000000);
	PlayerTextDrawColor(playerid, tt, -1);
	PlayerTextDrawSetOutline(playerid, tt, 1);
	PlayerTextDrawSetProportional(playerid, tt, 1);

	tt = TD_Player_Damages[0][4] = CreatePlayerTextDraw(playerid, 143.000000, 393.000000, "~g~~h~Morgenstern ~w~-46 /~g~~h~ Deagle ~w~(~r~~h~~h~40~w~)");
	PlayerTextDrawBackgroundColor(playerid, tt, 48);
	PlayerTextDrawFont(playerid, tt, 1);
	PlayerTextDrawLetterSize(playerid, tt, 0.200000, 1.000000);
	PlayerTextDrawColor(playerid, tt, -1);
	PlayerTextDrawSetOutline(playerid, tt, 1);
	PlayerTextDrawSetProportional(playerid, tt, 1);

/*
	PlayerTextDrawShow(playerid, TD_Player_Damages[0][0]);
	PlayerTextDrawShow(playerid, TD_Player_Damages[0][1]);
	PlayerTextDrawShow(playerid, TD_Player_Damages[0][2]);
	PlayerTextDrawShow(playerid, TD_Player_Damages[0][3]);
	PlayerTextDrawShow(playerid, TD_Player_Damages[0][4]);
*/

	// rosso
	tt = TD_Player_Damages[1][0] = CreatePlayerTextDraw(playerid, 395.000000, 353.000000, "~r~~h~Morgenstern ~w~-46 /~r~~h~ Deagle ~w~(~r~~h~~h~40~w~)");
	PlayerTextDrawBackgroundColor(playerid, tt, 48);
	PlayerTextDrawFont(playerid, tt, 1);
	PlayerTextDrawLetterSize(playerid, tt, 0.200000, 1.000000);
	PlayerTextDrawColor(playerid, tt, -1);
	PlayerTextDrawSetOutline(playerid, tt, 1);
	PlayerTextDrawSetProportional(playerid, tt, 1);

	tt = TD_Player_Damages[1][1] = CreatePlayerTextDraw(playerid, 395.000000, 363.000000, "~r~~h~Morgenstern ~w~-46 /~r~~h~ Deagle ~w~(~r~~h~~h~40~w~)");
	PlayerTextDrawBackgroundColor(playerid, tt, 48);
	PlayerTextDrawFont(playerid, tt, 1);
	PlayerTextDrawLetterSize(playerid, tt, 0.200000, 1.000000);
	PlayerTextDrawColor(playerid, tt, -1);
	PlayerTextDrawSetOutline(playerid, tt, 1);
	PlayerTextDrawSetProportional(playerid, tt, 1);

	tt = TD_Player_Damages[1][2] = CreatePlayerTextDraw(playerid, 395.000000, 373.000000, "~r~~h~Morgenstern ~w~-46 /~r~~h~ Deagle ~w~(~r~~h~~h~40~w~)");
	PlayerTextDrawBackgroundColor(playerid, tt, 48);
	PlayerTextDrawFont(playerid, tt, 1);
	PlayerTextDrawLetterSize(playerid, tt, 0.200000, 1.000000);
	PlayerTextDrawColor(playerid, tt, -1);
	PlayerTextDrawSetOutline(playerid, tt, 1);
	PlayerTextDrawSetProportional(playerid, tt, 1);

	tt = TD_Player_Damages[1][3] = CreatePlayerTextDraw(playerid, 395.000000, 383.000000, "~r~~h~Morgenstern ~w~-46 /~r~~h~ Deagle ~w~(~r~~h~~h~40~w~)");
	PlayerTextDrawBackgroundColor(playerid, tt, 48);
	PlayerTextDrawFont(playerid, tt, 1);
	PlayerTextDrawLetterSize(playerid, tt, 0.200000, 1.000000);
	PlayerTextDrawColor(playerid, tt, -1);
	PlayerTextDrawSetOutline(playerid, tt, 1);
	PlayerTextDrawSetProportional(playerid, tt, 1);

	tt = TD_Player_Damages[1][4] = CreatePlayerTextDraw(playerid, 395.000000, 393.000000, "~r~~h~Morgenstern ~w~-46 /~r~~h~ Deagle ~w~(~r~~h~~h~40~w~)");
	PlayerTextDrawBackgroundColor(playerid, tt, 48);
	PlayerTextDrawFont(playerid, tt, 1);
	PlayerTextDrawLetterSize(playerid, tt, 0.200000, 1.000000);
	PlayerTextDrawColor(playerid, tt, -1);
	PlayerTextDrawSetOutline(playerid, tt, 1);
	PlayerTextDrawSetProportional(playerid, tt, 1);

/*
	PlayerTextDrawShow(playerid, TD_Player_Damages[1][0]);
	PlayerTextDrawShow(playerid, TD_Player_Damages[1][1]);
	PlayerTextDrawShow(playerid, TD_Player_Damages[1][2]);
	PlayerTextDrawShow(playerid, TD_Player_Damages[1][3]);
	PlayerTextDrawShow(playerid, TD_Player_Damages[1][4]);
*/

	PlayerSpecList = CreatePlayerTextDraw(playerid, 548.000000, 354.000000, "~b~~h~Spectators~n~~w~[s7]ReVo_~n~~w~[s7]Morgenstern~n~~w~[s7]FULMYCOTONE~n~~w~[s7]DarK_Blue");
	PlayerTextDrawBackgroundColor(playerid, PlayerSpecList, 255);
	PlayerTextDrawFont(playerid, PlayerSpecList, 1);
	PlayerTextDrawLetterSize(playerid, PlayerSpecList, 0.190000, 0.900000);
	PlayerTextDrawColor(playerid, PlayerSpecList, -1);
	PlayerTextDrawSetOutline(playerid, PlayerSpecList, 0);
	PlayerTextDrawSetProportional(playerid, PlayerSpecList, 1);
	PlayerTextDrawSetShadow(playerid, PlayerSpecList, 1);
	/*
	PlayerSpecList[0] = CreatePlayerTextDraw(playerid, 540.000000, 380.000000, "~r~~h~~h~Specting you:");
	PlayerTextDrawBackgroundColor(playerid, PlayerSpecList[0], 255);
	PlayerTextDrawFont(playerid, PlayerSpecList[0], 2);
	PlayerTextDrawLetterSize(playerid, PlayerSpecList[0], 0.300000, 0.899999);
	PlayerTextDrawColor(playerid, PlayerSpecList[0], -1);
	PlayerTextDrawSetOutline(playerid, PlayerSpecList[0], 0);
	PlayerTextDrawSetProportional(playerid, PlayerSpecList[0], 1);
	PlayerTextDrawSetShadow(playerid, PlayerSpecList[0], 1);

	PlayerSpecList[1] = CreatePlayerTextDraw(playerid, 550.000000, 390.000000, "_");
	PlayerTextDrawBackgroundColor(playerid, PlayerSpecList[1], 255);
	PlayerTextDrawFont(playerid, PlayerSpecList[1], 2);
	PlayerTextDrawLetterSize(playerid, PlayerSpecList[1], 0.240000, 0.699999);
	PlayerTextDrawColor(playerid, PlayerSpecList[1], -1);
	PlayerTextDrawSetOutline(playerid, PlayerSpecList[1], 0);
	PlayerTextDrawSetProportional(playerid, PlayerSpecList[1], 1);
	PlayerTextDrawSetShadow(playerid, PlayerSpecList[1], 1);

	*/
	/*
	SpecPlayerInfo[0] = CreatePlayerTextDraw(playerid, 555.000000, 289.000000, "~y~[s7]Morgenstern");
	PlayerTextDrawAlignment(playerid, SpecPlayerInfo[0], 2);
	PlayerTextDrawBackgroundColor(playerid, SpecPlayerInfo[0], 255);
	PlayerTextDrawFont(playerid, SpecPlayerInfo[0], 3);
	PlayerTextDrawLetterSize(playerid, SpecPlayerInfo[0], 0.300000, 1.000000);
	PlayerTextDrawColor(playerid, SpecPlayerInfo[0], -1);
	PlayerTextDrawSetOutline(playerid, SpecPlayerInfo[0], 0);
	PlayerTextDrawSetProportional(playerid, SpecPlayerInfo[0], 1);
	PlayerTextDrawSetShadow(playerid, SpecPlayerInfo[0], 1);

	SpecPlayerInfo[1] = CreatePlayerTextDraw(playerid, 554.000000, 299.000000, "~g~~h~Kills~w~: 0");
	PlayerTextDrawAlignment(playerid, SpecPlayerInfo[1], 2);
	PlayerTextDrawBackgroundColor(playerid, SpecPlayerInfo[1], 255);
	PlayerTextDrawFont(playerid, SpecPlayerInfo[1], 3);
	PlayerTextDrawLetterSize(playerid, SpecPlayerInfo[1], 0.300000, 1.000000);
	PlayerTextDrawColor(playerid, SpecPlayerInfo[1], -1);
	PlayerTextDrawSetOutline(playerid, SpecPlayerInfo[1], 0);
	PlayerTextDrawSetProportional(playerid, SpecPlayerInfo[1], 1);
	PlayerTextDrawSetShadow(playerid, SpecPlayerInfo[1], 1);

	SpecPlayerInfo[2] = CreatePlayerTextDraw(playerid, 555.000000, 309.000000, "~r~~h~Damage~w~: 1200");
	PlayerTextDrawAlignment(playerid, SpecPlayerInfo[2], 2);
	PlayerTextDrawBackgroundColor(playerid, SpecPlayerInfo[2], 255);
	PlayerTextDrawFont(playerid, SpecPlayerInfo[2], 3);
	PlayerTextDrawLetterSize(playerid, SpecPlayerInfo[2], 0.300000, 1.000000);
	PlayerTextDrawColor(playerid, SpecPlayerInfo[2], -1);
	PlayerTextDrawSetOutline(playerid, SpecPlayerInfo[2], 0);
	PlayerTextDrawSetProportional(playerid, SpecPlayerInfo[2], 1);
	PlayerTextDrawSetShadow(playerid, SpecPlayerInfo[2], 1);

	SpecPlayerInfo[3] = CreatePlayerTextDraw(playerid, 558.000000, 319.000000, "~y~~h~Ping~w~: 50");
	PlayerTextDrawAlignment(playerid, SpecPlayerInfo[3], 2);
	PlayerTextDrawBackgroundColor(playerid, SpecPlayerInfo[3], 255);
	PlayerTextDrawFont(playerid, SpecPlayerInfo[3], 3);
	PlayerTextDrawLetterSize(playerid, SpecPlayerInfo[3], 0.300000, 1.000000);
	PlayerTextDrawColor(playerid, SpecPlayerInfo[3], -1);
	PlayerTextDrawSetOutline(playerid, SpecPlayerInfo[3], 0);
	PlayerTextDrawSetProportional(playerid, SpecPlayerInfo[3], 1);
	PlayerTextDrawSetShadow(playerid, SpecPlayerInfo[3], 1);

	SpecPlayerInfo[4] = CreatePlayerTextDraw(playerid, 542.000000, 339.000000, "~p~~h~Packetloss~w~: 6.0");
	PlayerTextDrawAlignment(playerid, SpecPlayerInfo[4], 2);
	PlayerTextDrawBackgroundColor(playerid, SpecPlayerInfo[4], 255);
	PlayerTextDrawFont(playerid, SpecPlayerInfo[4], 3);
	PlayerTextDrawLetterSize(playerid, SpecPlayerInfo[4], 0.300000, 1.000000);
	PlayerTextDrawColor(playerid, SpecPlayerInfo[4], -1);
	PlayerTextDrawSetOutline(playerid, SpecPlayerInfo[4], 0);
	PlayerTextDrawSetProportional(playerid, SpecPlayerInfo[4], 1);
	PlayerTextDrawSetShadow(playerid, SpecPlayerInfo[4], 1);

	SpecPlayerInfo[5] = CreatePlayerTextDraw(playerid, 560.000000, 329.000000, "~b~~h~FPS~w~: 62");
	PlayerTextDrawAlignment(playerid, SpecPlayerInfo[5], 2);
	PlayerTextDrawBackgroundColor(playerid, SpecPlayerInfo[5], 255);
	PlayerTextDrawFont(playerid, SpecPlayerInfo[5], 3);
	PlayerTextDrawLetterSize(playerid, SpecPlayerInfo[5], 0.300000, 1.000000);
	PlayerTextDrawColor(playerid, SpecPlayerInfo[5], -1);
	PlayerTextDrawSetOutline(playerid, SpecPlayerInfo[5], 0);
	PlayerTextDrawSetProportional(playerid, SpecPlayerInfo[5], 1);
	PlayerTextDrawSetShadow(playerid, SpecPlayerInfo[5], 1);

	SpecPlayerInfo[6] = CreatePlayerTextDraw(playerid, 560.000000, 349.000000, "~g~~h~~h~Weapons~w~:");
	PlayerTextDrawAlignment(playerid, SpecPlayerInfo[6], 2);
	PlayerTextDrawBackgroundColor(playerid, SpecPlayerInfo[6], 255);
	PlayerTextDrawFont(playerid, SpecPlayerInfo[6], 3);
	PlayerTextDrawLetterSize(playerid, SpecPlayerInfo[6], 0.300000, 1.000000);
	PlayerTextDrawColor(playerid, SpecPlayerInfo[6], -1);
	PlayerTextDrawSetOutline(playerid, SpecPlayerInfo[6], 0);
	PlayerTextDrawSetProportional(playerid, SpecPlayerInfo[6], 1);
	PlayerTextDrawSetShadow(playerid, SpecPlayerInfo[6], 1);

	SpecPlayerInfo[0] = CreatePlayerTextDraw(playerid, 487.000000, 345.000000, "~g~~h~s7rev ~r~100 ~w~100");
	PlayerTextDrawBackgroundColor(playerid, SpecPlayerInfo[0], 96);
	PlayerTextDrawFont(playerid, SpecPlayerInfo[0], 1);
	PlayerTextDrawLetterSize(playerid, SpecPlayerInfo[0], 0.270000, 1.000000);
	PlayerTextDrawColor(playerid, SpecPlayerInfo[0], -1);
	PlayerTextDrawSetOutline(playerid, SpecPlayerInfo[0], 1);
	PlayerTextDrawSetProportional(playerid, SpecPlayerInfo[0], 1);

	SpecPlayerInfo[1] = CreatePlayerTextDraw(playerid, 487.000000, 355.000000, "~g~~h~Damage ~w~400");
	PlayerTextDrawBackgroundColor(playerid, SpecPlayerInfo[1], 96);
	PlayerTextDrawFont(playerid, SpecPlayerInfo[1], 1);
	PlayerTextDrawLetterSize(playerid, SpecPlayerInfo[1], 0.270000, 1.000000);
	PlayerTextDrawColor(playerid, SpecPlayerInfo[1], -1);
	PlayerTextDrawSetOutline(playerid, SpecPlayerInfo[1], 1);
	PlayerTextDrawSetProportional(playerid, SpecPlayerInfo[1], 1);

	SpecPlayerInfo[2] = CreatePlayerTextDraw(playerid, 487.000000, 364.000000, "~g~~h~Kills: ~w~3");
	PlayerTextDrawBackgroundColor(playerid, SpecPlayerInfo[2], 96);
	PlayerTextDrawFont(playerid, SpecPlayerInfo[2], 1);
	PlayerTextDrawLetterSize(playerid, SpecPlayerInfo[2], 0.270000, 1.000000);
	PlayerTextDrawColor(playerid, SpecPlayerInfo[2], -1);
	PlayerTextDrawSetOutline(playerid, SpecPlayerInfo[2], 1);
	PlayerTextDrawSetProportional(playerid, SpecPlayerInfo[2], 1);

	SpecPlayerInfo[3] = CreatePlayerTextDraw(playerid, 553.000000, 358.000000, "_");
	PlayerTextDrawAlignment(playerid, SpecPlayerInfo[3], 2);
	PlayerTextDrawBackgroundColor(playerid, SpecPlayerInfo[3], 255);
	PlayerTextDrawFont(playerid, SpecPlayerInfo[3], 1);
	PlayerTextDrawLetterSize(playerid, SpecPlayerInfo[3], 0.500000, 2.500000);
	PlayerTextDrawColor(playerid, SpecPlayerInfo[3], -1);
	PlayerTextDrawSetOutline(playerid, SpecPlayerInfo[3], 0);
	PlayerTextDrawSetProportional(playerid, SpecPlayerInfo[3], 1);
	PlayerTextDrawSetShadow(playerid, SpecPlayerInfo[3], 1);
	PlayerTextDrawUseBox(playerid, SpecPlayerInfo[3], 1);
	PlayerTextDrawBoxColor(playerid, SpecPlayerInfo[3], 96);
	PlayerTextDrawTextSize(playerid, SpecPlayerInfo[3], 0.000000, -2.000000);

	SpecPlayerInfo[4] = CreatePlayerTextDraw(playerid, 556.000000, 364.000000, "~g~~h~Ping: ~w~150");
	PlayerTextDrawBackgroundColor(playerid, SpecPlayerInfo[4], 96);
	PlayerTextDrawFont(playerid, SpecPlayerInfo[4], 1);
	PlayerTextDrawLetterSize(playerid, SpecPlayerInfo[4], 0.270000, 1.000000);
	PlayerTextDrawColor(playerid, SpecPlayerInfo[4], -1);
	PlayerTextDrawSetOutline(playerid, SpecPlayerInfo[4], 1);
	PlayerTextDrawSetProportional(playerid, SpecPlayerInfo[4], 1);

	SpecPlayerInfo[5] = CreatePlayerTextDraw(playerid, 555.000000, 355.000000, "~g~~h~FPS: ~w~50");
	PlayerTextDrawBackgroundColor(playerid, SpecPlayerInfo[5], 96);
	PlayerTextDrawFont(playerid, SpecPlayerInfo[5], 1);
	PlayerTextDrawLetterSize(playerid, SpecPlayerInfo[5], 0.270000, 1.000000);
	PlayerTextDrawColor(playerid, SpecPlayerInfo[5], -1);
	PlayerTextDrawSetOutline(playerid, SpecPlayerInfo[5], 1);
	PlayerTextDrawSetProportional(playerid, SpecPlayerInfo[5], 1);

	SpecPlayerInfo[6] = CreatePlayerTextDraw(playerid, 543.000000, 383.000000, "~b~~h~WPS: ~w~Deagle~g~~h~/~w~Shotgun");
	PlayerTextDrawAlignment(playerid, SpecPlayerInfo[6], 2);
	PlayerTextDrawBackgroundColor(playerid, SpecPlayerInfo[6], 96);
	PlayerTextDrawFont(playerid, SpecPlayerInfo[6], 1);
	PlayerTextDrawLetterSize(playerid, SpecPlayerInfo[6], 0.270000, 1.000000);
	PlayerTextDrawColor(playerid, SpecPlayerInfo[6], -1);
	PlayerTextDrawSetOutline(playerid, SpecPlayerInfo[6], 1);
	PlayerTextDrawSetProportional(playerid, SpecPlayerInfo[6], 1);

	SpecPlayerInfo[7] = CreatePlayerTextDraw(playerid, 556.000000, 373.000000, "~g~~h~PL: ~w~0.0%");
	PlayerTextDrawBackgroundColor(playerid, SpecPlayerInfo[7], 96);
	PlayerTextDrawFont(playerid, SpecPlayerInfo[7], 1);
	PlayerTextDrawLetterSize(playerid, SpecPlayerInfo[7], 0.270000, 1.000000);
	PlayerTextDrawColor(playerid, SpecPlayerInfo[7], -1);
	PlayerTextDrawSetOutline(playerid, SpecPlayerInfo[7], 1);
	PlayerTextDrawSetProportional(playerid, SpecPlayerInfo[7], 1);

	SpecPlayerInfo[8] = CreatePlayerTextDraw(playerid, 487.000000, 373.000000, "~g~~h~T.Dmg: ~w~5940");
	PlayerTextDrawBackgroundColor(playerid, SpecPlayerInfo[8], 96);
	PlayerTextDrawFont(playerid, SpecPlayerInfo[8], 1);
	PlayerTextDrawLetterSize(playerid, SpecPlayerInfo[8], 0.270000, 1.000000);
	PlayerTextDrawColor(playerid, SpecPlayerInfo[8], -1);
	PlayerTextDrawSetOutline(playerid, SpecPlayerInfo[8], 1);
	PlayerTextDrawSetProportional(playerid, SpecPlayerInfo[8], 1);*/

	new Text:t = PlayerSpecInfo[playerid][0] = TextDrawCreate(487.000000, 345.000000, "bug");
	TextDrawBackgroundColor(t, 96);
	TextDrawFont(t, 1);
	TextDrawLetterSize(t, 0.270000, 1.000000);
	TextDrawColor(t, -1);
	TextDrawSetOutline(t, 1);
	TextDrawSetProportional(t, 1);

	t = PlayerSpecInfo[playerid][1] = TextDrawCreate(487.000000, 355.000000, "bug");//dmg
	TextDrawBackgroundColor(t, 96);
	TextDrawFont(t, 1);
	TextDrawLetterSize(t, 0.270000, 1.000000);
	TextDrawColor(t, -1);
	TextDrawSetOutline(t, 1);
	TextDrawSetProportional(t, 1);

	t = PlayerSpecInfo[playerid][2] = TextDrawCreate(487.000000, 364.000000, "bug");//kils
	TextDrawBackgroundColor(t, 96);
	TextDrawFont(t, 1);
	TextDrawLetterSize(t, 0.270000, 1.000000);
	TextDrawColor(t, -1);
	TextDrawSetOutline(t, 1);
	TextDrawSetProportional(t, 1);

	t = PlayerSpecInfo[playerid][3] = TextDrawCreate(553.000000, 358.000000, "_");
	TextDrawAlignment(t, 2);
	TextDrawBackgroundColor(t, 255);
	TextDrawFont(t, 1);
	TextDrawLetterSize(t, 0.500000, 2.500000);
	TextDrawColor(t, -1);
	TextDrawSetOutline(t, 0);
	TextDrawSetProportional(t, 1);
	TextDrawSetShadow(t, 1);
	TextDrawUseBox(t, 1);
	TextDrawBoxColor(t, 96);
	TextDrawTextSize(t, 0.000000, -2.000000);

	t = PlayerSpecInfo[playerid][4] = TextDrawCreate(556.000000, 364.000000, "bug");//ping
	TextDrawBackgroundColor(t, 96);
	TextDrawFont(t, 1);
	TextDrawLetterSize(t, 0.270000, 1.000000);
	TextDrawColor(t, -1);
	TextDrawSetOutline(t, 1);
	TextDrawSetProportional(t, 1);

	t = PlayerSpecInfo[playerid][5] = TextDrawCreate(555.000000, 355.000000, "bug");//fps
	TextDrawBackgroundColor(t, 96);
	TextDrawFont(t, 1);
	TextDrawLetterSize(t, 0.270000, 1.000000);
	TextDrawColor(t, -1);
	TextDrawSetOutline(t, 1);
	TextDrawSetProportional(t, 1);

	t = PlayerSpecInfo[playerid][6] = TextDrawCreate(543.000000, 383.000000, "bug");//wps
	TextDrawAlignment(t, 2);
	TextDrawBackgroundColor(t, 96);
	TextDrawFont(t, 1);
	TextDrawLetterSize(t, 0.270000, 1.000000);
	TextDrawColor(t, -1);
	TextDrawSetOutline(t, 1);
	TextDrawSetProportional(t, 1);

	t = PlayerSpecInfo[playerid][7] = TextDrawCreate(556.000000, 373.000000, "bug");//pl
	TextDrawBackgroundColor(t, 96);
	TextDrawFont(t, 1);
	TextDrawLetterSize(t, 0.270000, 1.000000);
	TextDrawColor(t, -1);
	TextDrawSetOutline(t, 1);
	TextDrawSetProportional(t, 1);

	t = PlayerSpecInfo[playerid][8] = TextDrawCreate(487.000000, 373.000000, "bug");//tot dmg
	TextDrawBackgroundColor(t, 96);
	TextDrawFont(t, 1);
	TextDrawLetterSize(t, 0.270000, 1.000000);
	TextDrawColor(t, -1);
	TextDrawSetOutline(t, 1);
	TextDrawSetProportional(t, 1);
	/*
	Classtd_SpawnTN = CreatePlayerTextDraw(playerid, 327.000000, 321.000000, "_");
	PlayerTextDrawAlignment(playerid, Classtd_SpawnTN, 2);
	PlayerTextDrawBackgroundColor(playerid, Classtd_SpawnTN, 255);
	PlayerTextDrawFont(playerid, Classtd_SpawnTN, 3);
	PlayerTextDrawLetterSize(playerid, Classtd_SpawnTN, 0.529999, 2.500000);
	PlayerTextDrawColor(playerid, Classtd_SpawnTN, -1);
	PlayerTextDrawSetOutline(playerid, Classtd_SpawnTN, 1);
	PlayerTextDrawSetProportional(playerid, Classtd_SpawnTN, 1);
	*/

	// -- Fine spawn tds

	Player_AfkTD[0] = CreatePlayerTextDraw(playerid, -1.000000, -1.000000, randAfk_sprites[ random( sizeof randAfk_sprites - 1 ) ]);
	PlayerTextDrawBackgroundColor(playerid, Player_AfkTD[0], 255);
	PlayerTextDrawFont(playerid, Player_AfkTD[0], 4);
	PlayerTextDrawLetterSize(playerid, Player_AfkTD[0], 0.500000, 1.000000);
	PlayerTextDrawColor(playerid, Player_AfkTD[0], -1);
	PlayerTextDrawSetOutline(playerid, Player_AfkTD[0], 0);
	PlayerTextDrawSetProportional(playerid, Player_AfkTD[0], 1);
	PlayerTextDrawSetShadow(playerid, Player_AfkTD[0], 1);
	PlayerTextDrawUseBox(playerid, Player_AfkTD[0], 1);
	PlayerTextDrawBoxColor(playerid, Player_AfkTD[0], 255);
	PlayerTextDrawTextSize(playerid, Player_AfkTD[0], 641.000000, 451.000000);

	Player_AfkTD[1] = CreatePlayerTextDraw(playerid, 220.000000, 188.000000, "_");
	PlayerTextDrawBackgroundColor(playerid, Player_AfkTD[1], 255);
	PlayerTextDrawFont(playerid, Player_AfkTD[1], 1);
	PlayerTextDrawLetterSize(playerid, Player_AfkTD[1], 0.500000, 3.000000);
	PlayerTextDrawColor(playerid, Player_AfkTD[1], -1);
	PlayerTextDrawSetOutline(playerid, Player_AfkTD[1], 0);
	PlayerTextDrawSetProportional(playerid, Player_AfkTD[1], 1);
	PlayerTextDrawSetShadow(playerid, Player_AfkTD[1], 1);
	PlayerTextDrawUseBox(playerid, Player_AfkTD[1], 1);
	PlayerTextDrawBoxColor(playerid, Player_AfkTD[1], 85);
	PlayerTextDrawTextSize(playerid, Player_AfkTD[1], 410.000000, 10.000000);

	Player_AfkTD[2] = CreatePlayerTextDraw(playerid, 238.000000, 187.000000, "You are now set as AFK");
	PlayerTextDrawBackgroundColor(playerid, Player_AfkTD[2], 255);
	PlayerTextDrawFont(playerid, Player_AfkTD[2], 0);
	PlayerTextDrawLetterSize(playerid, Player_AfkTD[2], 0.500000, 1.000000);
	PlayerTextDrawColor(playerid, Player_AfkTD[2], -1);
	PlayerTextDrawSetOutline(playerid, Player_AfkTD[2], 1);
	PlayerTextDrawSetProportional(playerid, Player_AfkTD[2], 1);

	Player_AfkTD[3] = CreatePlayerTextDraw(playerid, 224.000000, 204.000000, "Use /afk again to come back from AFK");
	PlayerTextDrawBackgroundColor(playerid, Player_AfkTD[3], 255);
	PlayerTextDrawFont(playerid, Player_AfkTD[3], 2);
	PlayerTextDrawLetterSize(playerid, Player_AfkTD[3], 0.210000, 1.000000);
	PlayerTextDrawColor(playerid, Player_AfkTD[3], -1);
	PlayerTextDrawSetOutline(playerid, Player_AfkTD[3], 1);
	PlayerTextDrawSetProportional(playerid, Player_AfkTD[3], 1);

	PlayerScorer_TD0 = CreatePlayerTextDraw(playerid, 318.000000, 108.000000, "_");
	PlayerTextDrawAlignment(playerid, PlayerScorer_TD0, 2);
	PlayerTextDrawBackgroundColor(playerid, PlayerScorer_TD0, 32);
	PlayerTextDrawFont(playerid, PlayerScorer_TD0, 1);
	PlayerTextDrawLetterSize(playerid, PlayerScorer_TD0, 0.260000, 1.000000);
	PlayerTextDrawColor(playerid, PlayerScorer_TD0, -1);
	PlayerTextDrawSetOutline(playerid, PlayerScorer_TD0, 1);
	PlayerTextDrawSetProportional(playerid, PlayerScorer_TD0, 1);

	PlayerScorer_TD1 = CreatePlayerTextDraw(playerid, 319.000000, 117.000000, "_");
	PlayerTextDrawAlignment(playerid, PlayerScorer_TD1, 2);
	PlayerTextDrawBackgroundColor(playerid, PlayerScorer_TD1, 32);
	PlayerTextDrawFont(playerid, PlayerScorer_TD1, 2);
	PlayerTextDrawLetterSize(playerid, PlayerScorer_TD1, 0.190000, 0.899999);
	PlayerTextDrawColor(playerid, PlayerScorer_TD1, -1);
	PlayerTextDrawSetOutline(playerid, PlayerScorer_TD1, 1);
	PlayerTextDrawSetProportional(playerid, PlayerScorer_TD1, 1);

//	TextDrawShowForPlayer(playerid, SigmaTextdraw);

	Player[playerid][Label_PlInfo] = Create3DTextLabel("_", 0x00FF28FF, 0.0, 0.0, 0.0, 10.0, 0, .testLOS = 1);
	Attach3DTextLabelToPlayer(Player[playerid][Label_PlInfo], playerid, 0.0, 0.0, -0.8);

	new extraid = playerid;
//	mysql_format(g_MySQLConnection, szQuery, "SELECT skin, level, kills, deaths, weapons, serial FROM users WHERE nickname = '%s'", Player[playerid][Nickname]);
	//	mysql_query(szQuery, THREAD_CONNCHECK, playerid, g_MySQLConnection);
	// WHY SEND QUERY IF THE CONNECTION IS LOST?
	// GUARDARE SOTTO (MYSQL_PING() == -1)
	mysql_tquery(g_MySQLConnection, sprintf("SELECT skin, level, kills, deaths, weapons, serial FROM users WHERE nickname = '%s'", Player[playerid][Nickname]), "OnUserChecking", "ii", THREAD_CONNECTING, extraid);
	MySQLStatus[TotalQuerys] ++;
/*
  	#if TIMEOUT_STORAGE_SYSTEM == TIMEOUT_SQLITE
  	new DBStatement:stmt = db_prepare( g_DB , "SELECT COUNT(*), health, armour, team, kills, deaths, damage, rkills, rdamage, rdeaths, pos FROM timeouts WHERE nickname = ? LIMIT 1" );

	new
	    timeout_data = 0;

  	stmt_bind_value(stmt, 0, DB::TYPE_STRING , Player[extraid][Nickname], 24);

    stmt_bind_result_field(stmt, 0, DB::TYPE_INT   , timeout_data);
    stmt_bind_result_field(stmt, 1, DB::TYPE_FLOAT , timeout_Health[extraid]);
    stmt_bind_result_field(stmt, 2, DB::TYPE_FLOAT , timeout_Armour[extraid]);
    stmt_bind_result_field(stmt, 3, DB::TYPE_INT   , timeout_Team[extraid]);
    stmt_bind_result_field(stmt, 4, DB::TYPE_INT   , Player[extraid][Kills]);
    stmt_bind_result_field(stmt, 5, DB::TYPE_INT   , Player[extraid][Deaths]);
    stmt_bind_result_field(stmt, 6, DB::TYPE_INT   , Player[extraid][Damage]);
    stmt_bind_result_field(stmt, 7, DB::TYPE_INT   , Player[extraid][RKills]);
    stmt_bind_result_field(stmt, 8, DB::TYPE_INT   , Player[extraid][RDamage]);
    stmt_bind_result_field(stmt, 9, DB::TYPE_INT   , Player[extraid][RDeaths]);

    new tmp [24];
    stmt_bind_result_field(stmt, 10, DB::TYPE_STRING   , tmp, 24);

	if (stmt_execute(stmt)) { while (stmt_fetch_row(stmt)) { } }

	if (timeout_data) {

		sscanf(tmp, "p<,>ffff", timeout_Pos[extraid][0], timeout_Pos[extraid][1], timeout_Pos[extraid][2], timeout_Pos[extraid][3]);

		timeoutPlayer[extraid] = true;
		format(stringo, sizeof stringo, "Player {"#COLOR_SYSTEM_FOCUS"}%s{"#COLOR_SYSTEM_REST"} (%d) is ready to be re-added.", Player[extraid][Nickname], extraid);
        SendClientMessageToAll(COLOR_SYSTEM, stringo);

		PlayerTextDrawSetString (extraid, PlayerInfo[1], sprintf("DMG ~b~~h~%d~n~~w~Tot. DMG ~b~~h~%d", Player[extraid][RDamage], Player[extraid][Damage]));
	}
//PlayerTextDrawSetString (i, PlayerInfo[1], "DMG ~b~~h~0~n~~w~Tot. DMG ~b~~h~0");
	stmt_close (stmt);

	printf("SQLite timeouted: %d", timeout_data);
  	#endif
*/
	// CONTROLLO SE LA CONNESSIONE CON IL DATABASE ï¿½ DISPONIBILE
	// SE NON DISPONIBILE (-1)
	/*
	if (mysql_ping () == -1) { // DOPO L'AGGIORNAMENTO ALLA VERSIONE R23 DEL PLUGIN MYSQL_pING NON ï¿½ PIï¿½ DISPONIBILE
	    // LA CONNESSIONE NON ï¿½ DISPONIBILE
	    // SHOULD BE CHANGED
	    // AND THE CONNECT MESSAGE SHOULD BE MOVED IN ONPLAYERCONNECT
	    // SO IF THE DB IS NOT AVAITABLE JUST
	    //new ip[16];

	    GetPlayerIp (extraid, Player[extraid][WhoIs_uIp], 16);
		//new country[ 158 ];
		GetPlayerCountry(extraid, Player[extraid][WhoIs_Country], 158);
		GetPlayerISP(extraid, Player[extraid][WhoIs_Isp], 60);
		GetPlayerCity(extraid, Player[extraid][WhoIs_City], 40);


		new admin[ STRLIB_RETURN_SIZE ];
		admin = sprintf( "{AFAFAF}%s{FFFFFF} ({AFAFAF}%d{FFFFFF}) has connected. ({AFAFAF}%s{FFFFFF}) ({AFAFAF}%s{FFFFFF})" , Player[extraid][Nickname], extraid, Player[extraid][WhoIs_Country], Player[extraid][WhoIs_uIp] );
		new utente[ STRLIB_RETURN_SIZE ];
		utente = sprintf( "{AFAFAF}%s{FFFFFF} ({AFAFAF}%d{FFFFFF}) has connected. ({AFAFAF}%s{FFFFFF})" , Player[extraid][Nickname], extraid, Player[extraid][WhoIs_Country] );

		foreach(new i:Player)
		{
		    if (Player[i][aLevel] >= _:lMod || IsPlayerAdmin(i))
		    {
		        SendClientMessage(i, 0x6CCC46AA, admin);
		    }
		    else
		    {
		        SendClientMessage(i, 0x6CCC46AA, utente);
		    }
		}

		PlaySoundForAll(1054);//fix eventuali suoni (musiche)

		SendClientMessage(extraid, -1, " " );
		SendClientMessage(extraid, -1, " " );
		SendClientMessage(extraid, -1, " " );
		SendClientMessage(extraid, -1, " " );
		SendClientMessage(extraid, -1, " " );
		SendClientMessage(extraid, -1, " " );
		SendClientMessage(extraid, -1, " " );
		SendClientMessage(extraid, -1, " " );
		SendClientMessage(extraid, -1, " " );
		SendClientMessage(extraid, -1, " " );
		SendClientMessage(extraid, -1, " " );
		SendClientMessage(extraid, -1, " " );
		SendClientMessage(extraid, -1, " " );
		SendClientMessage(extraid, -1, "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~" );
	    SendClientMessage(extraid, COLOR_SYSTEM, "Welcome {"#COLOR_SYSTEM_FOCUS"}%s{"#COLOR_SYSTEM_REST"} to "#GAMEMODE_NAME"! Use /help to know all commands", Player[extraid][Nickname], GetReadyStartType());
		SendClientMessage(extraid, COLOR_LIGHTBLUE, "(NOTICE) %s" , notice );

	  	#if TIMEOUT_STORAGE_SYSTEM == TIMEOUT_SQLITE
	  	new DBStatement:stmt = db_prepare( g_DB , "SELECT COUNT(*), health, armour, team, kills, deaths, damage, rkills, rdamage, rdeaths, pos FROM timeouts WHERE nickname = ? LIMIT 1" );

		new
		    timeout_data = 0;

	  	stmt_bind_value(stmt, 0, DB::TYPE_STRING , Player[extraid][Nickname], 24);

	    stmt_bind_result_field(stmt, 0, DB::TYPE_INT   , timeout_data);
	    stmt_bind_result_field(stmt, 1, DB::TYPE_FLOAT , timeout_Health[extraid]);
	    stmt_bind_result_field(stmt, 2, DB::TYPE_FLOAT , timeout_Armour[extraid]);
	    stmt_bind_result_field(stmt, 3, DB::TYPE_INT   , timeout_Team[extraid]);
	    stmt_bind_result_field(stmt, 4, DB::TYPE_INT   , Player[extraid][Kills]);
	    stmt_bind_result_field(stmt, 5, DB::TYPE_INT   , Player[extraid][Deaths]);
	    stmt_bind_result_field(stmt, 6, DB::TYPE_INT   , Player[extraid][Damage]);
	    stmt_bind_result_field(stmt, 7, DB::TYPE_INT   , Player[extraid][RKills]);
	    stmt_bind_result_field(stmt, 8, DB::TYPE_INT   , Player[extraid][RDamage]);
	    stmt_bind_result_field(stmt, 9, DB::TYPE_INT   , Player[extraid][RDeaths]);

	    new tmp [24];
	    stmt_bind_result_field(stmt, 10, DB::TYPE_STRING   , tmp, 24);

		if (stmt_execute(stmt)) { while (stmt_fetch_row(stmt)) { } }

		if (timeout_data) {

			sscanf(tmp, "p<,>ffff", timeout_Pos[extraid][0], timeout_Pos[extraid][1], timeout_Pos[extraid][2], timeout_Pos[extraid][3]);

			timeoutPlayer[extraid] = true;
			SendClientMessageToAll(COLOR_SYSTEM, "Player {"#COLOR_SYSTEM_FOCUS"}%s{"#COLOR_SYSTEM_REST"} (%d) is ready to be re-added.", Player[extraid][Nickname], extraid);

			PlayerTextDrawSetString (extraid, PlayerInfo[1], sprintf("~b~~h~Damage ~w~%d~n~~b~~h~T. Dmg ~w~%d", Player[extraid][RDamage], Player[extraid][Damage]));
		}

		stmt_close (stmt);

		printf("SQLite timeouted: %d", timeout_data);
	  	#endif
	}
	else
	{

	}*/

	// auto_disable_ac
	if (bADisableAC)
	{
	    bADisableAC = false;
	    stop auto_disable_ac;
	}
	return true;
}

forward OnPlayerBanCheck(playerid);
public OnPlayerBanCheck(playerid)
{
	new rows, fields;
	cache_get_data(rows, fields);

	if (rows)
	{
	    new tmp [129];
	    cache_get_field_content (0, "bantype", tmp);

	    switch ( strval( tmp ) )
	    {
	        case BANTYPE_IP:
	        {
	            cache_get_field_content (0, "risorsa", tmp);
	            new ip [16];
	            GetPlayerIp (playerid, ip, 16);

	            if (!strcmp(ip, tmp))
	            {
	                cache_get_field_content (0, "adminban", tmp);

	         //       Ban ( playerid, false, 0, "IP Bannato" , tmp );

	                _Kick (playerid, GAMEMODE_ID_ARR, "Ban Evading", "IP banned");
	            }
	        }
	        case BANTYPE_NICKNAME:
	        {
	            // giï¿½ so che corrisponde
	            cache_get_field_content (0, "adminban", tmp);
	            //Ban ( playerid , false, 0, "Nickname bannato" , tmp );
	            //_Ban ( playerid , GAMEMODE_ARR_ID,

	            _Kick (playerid, GAMEMODE_ID_ARR, "Ban Evading", "Nickname banned");
	        }
			case BANTYPE_SERIAL:
			{
			    cache_get_field_content (0, "risorsa", tmp);

				if (!strcmp(Player[playerid][Serial], tmp))
				{
				    cache_get_field_content (0, "adminban", tmp);
				    //Ban ( playerid , false, 0, "Serial Bannato" , tmp );

				    _Kick (playerid, GAMEMODE_ID_ARR, "Ban Evading", "Serial banned");
				}
			}
	    }

//#define BANTYPE_IP              (0)
//#define BANTYPE_NICKNAME        (1)
//#define BANTYPE_SERIAL          (2)
	}
	return true;
}

forward OnUserChecking(step, extraid);
public OnUserChecking(step, extraid)
{
	switch (step)
	{
	    case THREAD_CONNECTING:
	    {
	      // if (!IsPlayerConnected(extraid)) return true;

			SendClientMessage(extraid, -1, " " );
			SendClientMessage(extraid, -1, " " );
			SendClientMessage(extraid, -1, " " );
			SendClientMessage(extraid, -1, " " );
			SendClientMessage(extraid, -1, " " );
			SendClientMessage(extraid, -1, " " );
			SendClientMessage(extraid, -1, " " );
			SendClientMessage(extraid, -1, " " );
			SendClientMessage(extraid, -1, " " );
			SendClientMessage(extraid, -1, " " );
			SendClientMessage(extraid, -1, " " );
			SendClientMessage(extraid, -1, " " );
			SendClientMessage(extraid, -1, " " );
			SendClientMessage(extraid, -1, "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~" );

			format(stringo, sizeof stringo, "Welcome {"#COLOR_SYSTEM_FOCUS"}%s{"#COLOR_SYSTEM_REST"} to "#GAMEMODE_NAME"! Use /help to know all commands", Player[extraid][Nickname], GetReadyStartType());
            SendClientMessage(extraid, COLOR_SYSTEM, stringo);

			SendClientMessage(extraid, COLOR_LIGHTBLUE, sprintf( "(NOTICE) %s" , notice ) );

			new rows, fields;
			cache_get_data(rows, fields);

	        if (rows)
	        {
//	            mysql_retrieve_row();
	            cache_get_field_content (0, "serial", Player[ extraid ][ tmp_serial ]);

	            //mysql_get_field ("serial", Player[ extraid ][ tmp_serial ]);

			    Player[ extraid ][ AccountExist ] = true;

			    if (strcmp(Player[ extraid ][ tmp_serial ], Player[ extraid ][ Serial ] ))
			    {
					ShowPlayerDialog(extraid, DIALOG_LOGIN, DIALOG_STYLE_PASSWORD, "Login", "Insert the password you used to register your account", "Login", "");
				}
				else
				{//here
					new tmp[12];
	                cache_get_field_content (0, "skin", tmp);Player[extraid][Skin]=strval(tmp);
	                cache_get_field_content (0, "level", tmp);Player[extraid][aLevel]=strval(tmp);
	                cache_get_field_content (0, "kills", tmp);Player[extraid][GKills]=strval(tmp);
	                cache_get_field_content (0, "deaths", tmp);Player[extraid][GDeaths]=strval(tmp);
	                cache_get_field_content (0, "weapons", tmp);

					sscanf(tmp, "p<,>iiiiiiiiiiii",
     					Player[ extraid ][ Weapons ][ 0 ],
          				Player[ extraid ][ Weapons ][ 1 ],
		           		Player[ extraid ][ Weapons ][ 2 ],
		           	 	Player[ extraid ][ Weapons ][ 3 ],
				        Player[ extraid ][ Weapons ][ 4 ],
				        Player[ extraid ][ Weapons ][ 5 ],
			            Player[ extraid ][ Weapons ][ 6 ],
			            Player[ extraid ][ Weapons ][ 7 ],
		 	            Player[ extraid ][ Weapons ][ 8 ],
			 	        Player[ extraid ][ Weapons ][ 9 ],
	     				Player[ extraid ][ Weapons ][ 10 ],
	       				Player[ extraid ][ Weapons ][ 11 ],
	      				Player[ extraid ][ Weapons ][ 12 ]
					);

				    new r[ 6 ];
		  			switch (Player[extraid][aLevel])
				    {
				        case lUser:  r = "User";
				        case lMod:   r = "Mod";
				        case lAdmin: r = "Admin";
				        case lRoot:  r = "Root";
				        default:     r = "User";
				    }

				    format(stringo, sizeof stringo, "* Auto-login: Welcome back %s, you got automatically logged into your account. (%s)" , Player[ extraid ][ Nickname ], r);
                    SendClientMessage(extraid, green, stringo);

					Player[ extraid ][ Loggen ] = true;
				}
	        }
	        else
	        {
	            SendClientMessage(extraid, COLOR_SYSTEM, "You can create your account by typing /register !");
	        }
			SendClientMessage(extraid, -1, "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~" );
			/*
			if (RoundStarted && gConfig[Matchmode] == MATCHMODE_TCWCW)
			{
 				mysql_tquery(g_MySQLConnection, sprintf("SELECT * FROM timeouts WHERE nickname = '%s' AND gid = %d LIMIT 1", Player[extraid][Nickname], G_ID), "Readd_OnPlayerCheck", "i", extraid);
			}
			*/
			RestorePlayerInfo (extraid);
	    }
	    case THREAD_PLAYERLOGIN:
	    {
     		new psw [129];

			cache_get_field_content(0, "password", psw);

			if (strcmp(psw, Player[extraid][Save_Password]))
			{
		    	ShowPlayerDialog(extraid, DIALOG_LOGIN, DIALOG_STYLE_PASSWORD, "Login", "Invalid password.", "Login", "");
			}
			else
			{//password, skin, level, kills, deaths, weapons, serial
   				SendClientMessage(extraid, COLOR_SYSTEM, "You got successfully logged in!");
   				Player[ extraid ][ Loggen ] = true;

				new tmp[32];
                cache_get_field_content (0, "skin", tmp);   Player[extraid][Skin]=strval(tmp);
                cache_get_field_content (0, "level", tmp);  Player[extraid][aLevel]=strval(tmp);
                cache_get_field_content (0, "kills", tmp);  Player[extraid][GKills]=strval(tmp);
                cache_get_field_content (0, "deaths", tmp); Player[extraid][GDeaths]=strval(tmp);
                cache_get_field_content (0, "weapons", tmp);

			    sscanf(tmp, "p<,>iiiiiiiiiiii",
		            Player[ extraid ][ Weapons ][ 0 ],
		            Player[ extraid ][ Weapons ][ 1 ],
		            Player[ extraid ][ Weapons ][ 2 ],
		            Player[ extraid ][ Weapons ][ 3 ],
		            Player[ extraid ][ Weapons ][ 4 ],
		            Player[ extraid ][ Weapons ][ 5 ],
		            Player[ extraid ][ Weapons ][ 6 ],
		            Player[ extraid ][ Weapons ][ 7 ],
	 	            Player[ extraid ][ Weapons ][ 8 ],
		 	        Player[ extraid ][ Weapons ][ 9 ],
       				Player[ extraid ][ Weapons ][ 10 ],
       				Player[ extraid ][ Weapons ][ 11 ],
       				Player[ extraid ][ Weapons ][ 12 ]
				);

				cache_get_field_content (0, "serial", Player[extraid][Serial]);
			}
	    }
	    case THREAD_VALIDACC:
	    {
			new rows, fields;

			cache_get_data(rows, fields);

			if (rows)
			{
			    SendClientMessage(extraid, COLOR_SYSTEM, "* This account already exists");
			}
			else
			{
			    new szQuery[500], playerid = extraid;
				new
				    szCity	 [ 40 ],
				    szCountry[ 40 ],
				    szIp     [ 16 ],
				    szISP    [ 60 ];

				GetPlayerCountry( extraid , szCountry , 40 );
				GetPlayerCity   ( extraid , szCity    , 40 );
				GetPlayerIp     ( extraid , szIp      , 16 );
				GetPlayerISP    ( extraid , szISP     , 60 );

				format (szQuery, sizeof szQuery, "INSERT INTO users (`id`, `nickname`, `password`, `skin`, `level`, `kills`, `deaths`, `weapons`, `serial`, `location`, `regip`, `country`, `isp`) VALUES (NULL, '%s', '%s', '-1', '0', '0', '0', ' ', '%s', '%s', '%s', '%s', '%s')",
				    Player[extraid][Nickname], Player[extraid][Save_Password], Player[extraid][Serial], szCity, szIp, szCountry, szISP);

			    mysql_tquery (g_MySQLConnection, szQuery, "", "");
			    MySQLStatus[TotalQuerys] ++;

			    SendClientMessage(playerid, COLOR_SYSTEM, "* Account created!");
			    Player[playerid][Loggen] = true;
			}
	    }
	}
	return 1;
}

forward Readd_OnPlayerCheck(playerid);
public Readd_OnPlayerCheck(playerid)
{
	if (!Player[playerid][Connected]) return 1; // player disconnected (?)
	if (!RoundStarted) return 1; // round non piï¿½ in corso

	new rows, fields, tmp[60];
	cache_get_data(rows, fields);

	if (rows == 1) // player effettivamente crashato
	{
		cache_get_field_content (0, "health",  tmp); timeout_Health[playerid]  = floatstr (tmp);
		cache_get_field_content (0, "armour",  tmp); timeout_Armour[playerid]  = floatstr (tmp);
		cache_get_field_content (0, "team",    tmp); timeout_Team[playerid]    = strval (tmp);
		cache_get_field_content (0, "kills",   tmp); Player[playerid][Kills]   = strval (tmp);
		cache_get_field_content (0, "deaths",  tmp); Player[playerid][Deaths]  = strval (tmp);
		cache_get_field_content (0, "damage",  tmp); Player[playerid][Damage]  = strval (tmp);
		cache_get_field_content (0, "rkills",  tmp); Player[playerid][RKills]  = strval (tmp);
		cache_get_field_content (0, "rdeaths", tmp); Player[playerid][RDeaths] = strval (tmp);
		cache_get_field_content (0, "rdamage", tmp); Player[playerid][RDamage] = strval (tmp);

		cache_get_field_content (0, "pos", tmp);
		sscanf(tmp, "p<,>ffff", timeout_Pos[playerid][0], timeout_Pos[playerid][1], timeout_Pos[playerid][2], timeout_Pos[playerid][3]);

		timeoutPlayer[playerid] = true;
		format(stringo, sizeof stringo, "Player {"#COLOR_SYSTEM_FOCUS"}%s{"#COLOR_SYSTEM_REST"} (%d) is ready to be re-added.", Player[playerid][Nickname], playerid);
        SendClientMessageToAll(COLOR_SYSTEM, stringo);

		PlayerTextDrawSetString (playerid, PlayerInfo[1], sprintf("DMG ~b~~h~%d~n~~w~Tot. DMG ~b~~h~%d", Player[playerid][RDamage], Player[playerid][Damage]));

		//MySQLStatus[TotalQuerys] ++; mysql_function_query(g_MySQLConnection, sprintf ("DELETE FROM timeouts WHERE nickname = '%s' AND gid = %d", Player[playerid][Nickname], G_ID), false, "", "");

		//esl_timeoutPlayers
		if (gConfig[GameMode] == GAMEMODE_ESL && auto_resumeTimer != Timer:-1 && GamePaused == 1) {
			cmd_add(GAMEMODE_ID_ARR, numstr(playerid));
			esl_timeoutPlayers --;

            // Tutti i players sono rientrati
            // Spauso il round
            if (esl_timeoutPlayers == 0) {
				if(UnPausingRunning) return 1;
				UnPauseRound ();
				/*
				UnPausingRunning = true;

				defer countdown_unpause();

				//leggi sotto
				stop auto_resumeTimer;

				il timer dovrebbe giï¿½ essere fermo
				if (auto_resumeTimer != Timer:-1) {
					stop auto_resumeTimer;
				}

				foreach (new i:Player) { if (Player[i][InGame]) PlayerPlaySound(i, 1139, 0.0, 0.0, 0.0);  }

				TextDrawSetString( RoundPaused, "Unpausing... ~r~~h~3~r~ 2 1" );*/
            }
		}
	}
	return 1;
}

new PlayerWarnings[ MAX_PLAYERS ];
new pControlli[MAX_PLAYERS];
#define MAX_LIMITS_WARNINGS     5

ptask PlayersLabels_Update[1000](playerid)
{
	// every 1 secs; update fps counter

	static wfps, drunknew;
	static pDrunkLevelLast [MAX_PLAYERS];

	drunknew = GetPlayerDrunkLevel(playerid);

	if (drunknew < 100)
	{
 		SetPlayerDrunkLevel(playerid, 2000);
 	}
	else
	{
		if (pDrunkLevelLast[playerid] != drunknew)
		{
  			wfps = pDrunkLevelLast[playerid] - drunknew;

			if ((wfps > 0) && (wfps < 200))
   				pFPS[playerid] = wfps;

			pDrunkLevelLast[playerid] = drunknew;
   		}
   	}

 	new
	    epl 				= gConfig[EPLLimit],
	    eping 				= gConfig[EPingLimit],
	    efps 				= gConfig[EFpsLimit],
		Float:pll       	= gConfig[PlLimit],
		pingl				= gConfig[PingLimit],
		fpsl				= gConfig[FpsLimit];

	if (Player[playerid][Spawned]) {
	    if (Player[playerid][IsAfk]) return 1;

	    new Float:pl = GetPlayerPacketloss(playerid), ping = GetPlayerPing(playerid);

		format( stringo, sizeof stringo, "{%s}%d{FFFFFF} / {%s}%.1f{FFFFFF}\nFPS: {%s}%d", ( ping > pingl ? ("A70C0C") : ("00FF28") ) , ping , ( pl > pll ? ("A70C0C") : ("00FF28") ) ,  pl , ( pFPS[playerid] < fpsl ? ("A70C0C") : ("00FF28") ) , pFPS[playerid] );
		Update3DTextLabelText(Player[playerid][Label_PlInfo], 0x00FF28FF, stringo);

	//	FPS ~b~~h~40 ~w~Ping ~b~~h~60 ~w~PL ~b~~h~0.2%
		format(stringo, sizeof stringo, "FPS ~b~~h~%d ~w~Ping ~b~~h~%d ~w~PL ~b~~h~%.1f%%", pFPS[playerid], ping, pl);
		PlayerTextDrawSetString(playerid, PlayerInfo[2], stringo);

		if (Player[playerid][InGame]) // ï¿½ in game e qualcuno lo sta spectando
		{
		    if (Player[playerid][Team] == TEAM_B)
		    {
//		    	TextDrawSetString(PlayerSpecInfo[i][0], sprintf ("~g~~h~%s ~r~100 ~w~100", Player[i][Nickname]));
//		    	TextDrawSetString(PlayerSpecInfo[i][1], sprintf ("~g~~h~Damage ~w~%d", Player[i][RDamage]));
//		    	TextDrawSetString(PlayerSpecInfo[i][2], sprintf ("~g~~h~Kills ~w~%d", Player[i][RKills]));

//		    	TextDrawSetString(PlayerSpecInfo[i][8], sprintf ("~g~~h~T.Dmg ~w~%d", Player[i][Damage]));

		    	TextDrawSetString(PlayerSpecInfo[playerid][4], sprintf ("~"#GT_TEAMB"~~h~Ping ~w~%d", ping));
		    	TextDrawSetString(PlayerSpecInfo[playerid][5], sprintf ("~"#GT_TEAMB"~~h~FPS ~w~%d", pFPS[playerid]));

		    	TextDrawSetString(PlayerSpecInfo[playerid][7], sprintf ("~"#GT_TEAMB"~~h~PL ~w~%.1f%%", pl));
			}
			else
			{
//		    	TextDrawSetString(PlayerSpecInfo[i][0], sprintf ("~b~~h~%s ~r~100 ~w~100", Player[i][Nickname]));
//		    	TextDrawSetString(PlayerSpecInfo[i][1], sprintf ("~b~~h~Damage ~w~%d", Player[i][RDamage]));
//		    	TextDrawSetString(PlayerSpecInfo[i][2], sprintf ("~b~~h~Kills ~w~%d", Player[i][RKills]));

//		    	TextDrawSetString(PlayerSpecInfo[i][8], sprintf ("~b~~h~T.Dmg ~w~%d", Player[i][Damage]));

		    	TextDrawSetString(PlayerSpecInfo[playerid][4], sprintf ("~"#GT_TEAMA"~~h~Ping ~w~%d", ping));
		    	TextDrawSetString(PlayerSpecInfo[playerid][5], sprintf ("~"#GT_TEAMA"~~h~FPS ~w~%d", pFPS[playerid]));

		    	TextDrawSetString(PlayerSpecInfo[playerid][7], sprintf ("~"#GT_TEAMA"~~h~PL ~w~%.1f%%", pl));
			}
		}

		if (epl)
		{
			if (pl > pll)
			{
			    PlayerWarnings[playerid] ++;
			    if (PlayerWarnings[playerid] >= MAX_LIMITS_WARNINGS)
			    {
				    format(stringo, sizeof stringo, "%.2f / %.2f", pl, pll);
				//	Kick (playerid, "Packetloss Limit", "Gamemode");
					// stringo are always passed as reference, might bug (?)
					_Kick (playerid, GAMEMODE_ID_ARR, "High Packetloss", stringo);
				}
				else
				{
				    format( stringo, sizeof stringo, "Kicker warning: Packetloss (%.1f) (Warning: %d/%d)", pl, PlayerWarnings[playerid], MAX_LIMITS_WARNINGS);
                    SendClientMessage(playerid, COLOR_GREY, stringo);
					pControlli[playerid] = 0;
				}
			}
		}

		if (eping)
		{
			if (ping > pingl)
			{
			    PlayerWarnings[playerid] ++;
			    if (PlayerWarnings[playerid] >= MAX_LIMITS_WARNINGS)
			    {
				    format(stringo, sizeof stringo, "%d / %d", ping, pingl);
                    //SendClientMessageToAll(COLOR_SYSTEM, stringo);
					//Kick (playerid, "Ping limit!", "Gamemode");
					//see above
					_Kick (playerid, GAMEMODE_ID_ARR, "High Ping", stringo);
				}
				else
				{
				    format(stringo, sizeof stringo, "Kicker warning: Ping (%d) (Warning: %d/%d)", ping, PlayerWarnings[playerid], MAX_LIMITS_WARNINGS);
                    SendClientMessage(playerid, COLOR_GREY, stringo);
					pControlli[playerid] = 0;
				}
			}
		}

		if (efps)
		{
		    if (pFPS[playerid] == 0) return 1;

			if (fpsl > pFPS[playerid])
			{
			    PlayerWarnings[playerid] ++;
			    if (PlayerWarnings[playerid] >= MAX_LIMITS_WARNINGS)
			    {
				    format(stringo, sizeof stringo, "%d / %d", pFPS[playerid], fpsl);
            //        SendClientMessageToAll(COLOR_SYSTEM, stringo);
			//		Kick (playerid, "FPS Limit!", "Gamemode");
					// above
					_Kick (playerid, GAMEMODE_ID_ARR, "Low FPS", stringo);
				}
				else
				{
				    format(stringo, sizeof stringo, "Kicker warning: Fps (%d) (Warning: %d/%d)", pFPS[playerid], PlayerWarnings[playerid], MAX_LIMITS_WARNINGS);
                    SendClientMessage(playerid, COLOR_GREY, stringo);

					pControlli[playerid] = 0;
				}
			}
		}

		pControlli[playerid] ++;//se riesce a fare 5 controlli senza warnings i suoi warnings vengono resettati

		if (pControlli[playerid] == 5)
		{
			pControlli[playerid] = 0;
			PlayerWarnings[playerid] = 0;
		}
	}

	return 1;
}
/*
forward PlayersLabels_Update();// si aggiorna ogni 2300 ms
public PlayersLabels_Update()
{
	new
	    Float:pl,
		ping;

 	new
	    epl 				= gConfig[EPLLimit],
	    eping 				= gConfig[EPingLimit],
	    efps 				= gConfig[EFpsLimit],
		Float:pll       	= gConfig[PlLimit],
		pingl				= gConfig[PingLimit],
		fpsl				= gConfig[FpsLimit];

	foreach (new i:Player)
	{
	    if (!Player[i][Spawned]) continue;
	    if (Player[i][IsAfk]) continue;

	    pl = GetPlayerPacketloss(i), ping = GetPlayerPing(i);

		format( stringo, sizeof stringo, "{%s}%d{FFFFFF} / {%s}%.1f{FFFFFF}\nFPS: {%s}%d", ( ping > gConfig[PingLimit] ? ("A70C0C") : ("619E00") ) , ping , ( pl > gConfig[PlLimit] ? ("A70C0C") : ("619E00") ) ,  pl , ( pFPS[i] < gConfig[FpsLimit] ? ("A70C0C") : ("619E00") ) , pFPS[i] );
		Update3DTextLabelText(Player[i][Label_PlInfo], 0x000000AA, stringo);

	format(stringo, sizeof stringo, "~y~~h~Ping: ~w~%d~n~~y~~h~FPS: ~w~%d~n~~y~~h~Kills: ~w~%d~n~~y~~h~Damage: ~w~%d~n~~y~~h~Packetloss: ~w~%.1f%%", ping, pFPS[i] , Player[i][RKills], Player[i][RDamage], pl);
		PlayerTextDrawSetString(i, PlayerInfo, stringo);

		format(stringo, sizeof stringo, "~b~~h~~h~Ping ~w~%d~n~~b~~h~~h~PL ~w~%.1f%%", ping, pl);
		PlayerTextDrawSetString(i, PlayerInfo[0], stringo);

		format(stringo, sizeof stringo, "~b~~h~~h~FPS ~w~%d", pFPS[i]);
		PlayerTextDrawSetString(i, PlayerInfo[2], stringo);

		if (Player[i][InGame]) // ï¿½ in game e qualcuno lo sta spectando
		{
		    if (Player[i][Team] == TEAM_B)
		    {
//		    	TextDrawSetString(PlayerSpecInfo[i][0], sprintf ("~g~~h~%s ~r~100 ~w~100", Player[i][Nickname]));
//		    	TextDrawSetString(PlayerSpecInfo[i][1], sprintf ("~g~~h~Damage ~w~%d", Player[i][RDamage]));
//		    	TextDrawSetString(PlayerSpecInfo[i][2], sprintf ("~g~~h~Kills ~w~%d", Player[i][RKills]));

//		    	TextDrawSetString(PlayerSpecInfo[i][8], sprintf ("~g~~h~T.Dmg ~w~%d", Player[i][Damage]));

		    	TextDrawSetString(PlayerSpecInfo[i][4], sprintf ("~g~~h~Ping ~w~%d", ping));
		    	TextDrawSetString(PlayerSpecInfo[i][5], sprintf ("~g~~h~FPS ~w~%d", pFPS[i]));

		    	TextDrawSetString(PlayerSpecInfo[i][7], sprintf ("~g~~h~PL ~w~%.1f%%", pl));
			}
			else
			{
//		    	TextDrawSetString(PlayerSpecInfo[i][0], sprintf ("~b~~h~%s ~r~100 ~w~100", Player[i][Nickname]));
//		    	TextDrawSetString(PlayerSpecInfo[i][1], sprintf ("~b~~h~Damage ~w~%d", Player[i][RDamage]));
//		    	TextDrawSetString(PlayerSpecInfo[i][2], sprintf ("~b~~h~Kills ~w~%d", Player[i][RKills]));

//		    	TextDrawSetString(PlayerSpecInfo[i][8], sprintf ("~b~~h~T.Dmg ~w~%d", Player[i][Damage]));

		    	TextDrawSetString(PlayerSpecInfo[i][4], sprintf ("~b~~h~Ping ~w~%d", ping));
		    	TextDrawSetString(PlayerSpecInfo[i][5], sprintf ("~b~~h~FPS ~w~%d", pFPS[i]));

		    	TextDrawSetString(PlayerSpecInfo[i][7], sprintf ("~b~~h~PL ~w~%.1f%%", pl));
			}
		}

		if (epl)
		{
			if (pl > pll)
			{
			    PlayerWarnings[i] ++;
			    if (PlayerWarnings[i] >= MAX_LIMITS_WARNINGS)
			    {
				    SendClientMessageToAll(COLOR_SYSTEM, "%s has been kicked by Gamemode. Packetloss: %.2f / %.2f", Player[i][Nickname], pl, pll);
					Kick (i, "Packetloss Limit", "Gamemode");
				}
				else
				{
				    SendClientMessage(i, COLOR_GREY, "Kicker warning: Packetloss (%.1f) (Warning: %d/%d)", pl, PlayerWarnings[i], MAX_LIMITS_WARNINGS);
				    pControlli[i] = 0;
				}
			}
		}

		if (eping)
		{
			if (ping > pingl)
			{
			    PlayerWarnings[i] ++;
			    if (PlayerWarnings[i] >= MAX_LIMITS_WARNINGS)
			    {
				    SendClientMessageToAll(COLOR_SYSTEM, "%s has been kicked by Gamemode. Ping: %d / %d", Player[i][Nickname], ping, pingl);
					Kick (i, "Ping limit!", "Gamemode");
				}
				else
				{
				    SendClientMessage(i, COLOR_GREY, "Kicker warning: Ping (%d) (Warning: %d/%d)", ping, PlayerWarnings[i], MAX_LIMITS_WARNINGS);
				    pControlli[i] = 0;
				}
			}
		}

		if (efps)
		{
		    if (pFPS[i] == 0) continue;

			if (pFPS[i] < fpsl)
			{
			    PlayerWarnings[i] ++;
			    if (PlayerWarnings[i] >= MAX_LIMITS_WARNINGS)
			    {
				    SendClientMessageToAll(COLOR_SYSTEM, "%s has been kicked by Gamemode. FPS: %d / %d", Player[i][Nickname], pFPS[i], fpsl);
					Kick (i, "FPS Limit!", "Gamemode");
				}
				else
				{
				    SendClientMessage(i, COLOR_GREY, "Kicker warning: Fps (%d) (Warning: %d/%d)", pFPS[i], PlayerWarnings[i], MAX_LIMITS_WARNINGS);
				    pControlli[i] = 0;
				}
			}
		}

		pControlli[i] ++;

		if (pControlli[i] == 5)
		{
			pControlli[i] = 0;
			PlayerWarnings[i] = 0;
		}
	}
}
*/
/*forward NameTagsUpdate();
public NameTagsUpdate()
{
	if (RoundStarted)
	{
		new Float:fX,
			Float:fY,
			Float:fZ;

	    foreach(new i:Player)
	    {
			foreach(new x:Player)
			{
			    if (Player[x][Team] == Player[i][Team]) continue; // stesso team, inutile eseguirlo
			    GetPlayerPos(x, fX, fY, fZ);

			    if (IsPlayerInRangeOfPoint(i, 9.0, fX, fY, fZ))
			    {
			        ShowPlayerNameTagForPlayer(i, x, true);
			    }
			    else
				{
					ShowPlayerNameTagForPlayer(i, x, false);
				}
			}
		}

		SetTimer("NameTagsUpdate", 1400, false);
	}
}*/

ptask MoneyUpdate[2100](playerid)
{
	if (Player[playerid][Spawned]) {
		new Float:hp, Float:a;

		GetPlayerHealth(playerid, hp);
		GetPlayerArmour(playerid, a);

		if (Player[playerid][LastHP] != hp || Player[playerid][LastArmour] != a)
		{
			ResetPlayerMoney(playerid);

			new somma = floatround( hp + a );

			GivePlayerMoney(playerid, -somma);

			if (RoundStarted)
			{
			    if (Player[playerid][InGame])
			    {
				    if (gConfig[ UseHealthBars ])
				    {
				        UpdateHealthBar(playerid, (hp+a));
				        ShowHealthBarForAll(playerid);

						// ad aggiornare lo score dmg ci pensa takedmg
				    }
				    else
				    {
				        SetPlayerScore(playerid, somma);
				    }

					if (Player[playerid][Team] == TEAM_B) TextDrawSetString(PlayerSpecInfo[playerid][0], sprintf ("~"#GT_TEAMB"~~h~%s ~r~%d ~w~%d", Player[playerid][Nickname], floatround (hp), floatround (a)));
					else TextDrawSetString(PlayerSpecInfo[playerid][0], sprintf ("~"#GT_TEAMA"~~h~%s ~r~%d ~w~%d", Player[playerid][Nickname], floatround (hp), floatround (a)));

			    	SyncTextdraw(1);
			    }
			}

		    Player[playerid][LastHP] 	 = floatround (hp);
		    Player[playerid][LastArmour] = floatround (a);
		}
	}

	return 1;
}

/*
forward MoneyUpdate();
public MoneyUpdate()
{
	new Float:hp, Float:a;

	foreach(new i:Player)
	{
		GetPlayerHealth(i, hp);
		GetPlayerArmour(i, a);

		if (Player[i][LastHP] != hp || Player[i][LastArmour] != a)
		{
			ResetPlayerMoney(i);

			new somma = floatround( hp + a );

			GivePlayerMoney(i, -somma);

			if (RoundStarted)
			{
			    if (Player[i][InGame])
			    {
				    if (gConfig[ UseHealthBars ])
				    {
				        UpdateHealthBar(i, (hp+a));
				        ShowHealthBarForAll(i);

						// ad aggiornare lo score dmg ci pensa takedmg
				    }
				    else
				    {
				        SetPlayerScore(i, somma);
				    }

					if (Player[i][Team] == TEAM_B) TextDrawSetString(PlayerSpecInfo[i][0], sprintf ("~g~~h~%s ~r~%d ~w~%d", Player[i][Nickname], floatround (hp), floatround (a)));
					else TextDrawSetString(PlayerSpecInfo[i][0], sprintf ("~b~~h~%s ~r~%d ~w~%d", Player[i][Nickname], floatround (hp), floatround (a)));

			    	SyncTextdraw(1);
			    }

			    Player[i][LastHP] 	  = floatround (hp);
			    Player[i][LastArmour] = floatround (a);
			}
		}
	}
}*/

new const
    disconnectreason[ 3 ][ 21 ] = {
        {"crashed"}, {"disconnected"}, {"been kicked/banned"}
};

public OnPlayerDisconnect(playerid, reason)
{
	if (playerid == lastKiller)
	{
	    consegutive = 0;
	    lastKiller  = INVALID_PLAYER_ID;
	}
	/*
	if (Player[playerid][pMatchID] != -1) {
	    // not connected
	    PlayerMatch [playerid][mConnected] = false;
	    Player[playerid][pMatchID] = -1;
	}
	*/
    Player[playerid][ConnectedNow] = false;
	Player[playerid][Connected] = false;
	Player[playerid][fInWaiting]  = false;
    PlayerWarnings[playerid] = 0;
//    Player[playerid][RKills] = 0;
//    Player[playerid][RDamage] = 0;
    sys_m_onplayerdeath[playerid] = false;

	TextDrawDestroy(PlayerSpecInfo[playerid][0]);
	TextDrawDestroy(PlayerSpecInfo[playerid][1]);
	TextDrawDestroy(PlayerSpecInfo[playerid][2]);
	TextDrawDestroy(PlayerSpecInfo[playerid][3]);
	TextDrawDestroy(PlayerSpecInfo[playerid][4]);
	TextDrawDestroy(PlayerSpecInfo[playerid][5]);
	TextDrawDestroy(PlayerSpecInfo[playerid][6]);
	TextDrawDestroy(PlayerSpecInfo[playerid][7]);
	TextDrawDestroy(PlayerSpecInfo[playerid][8]);

	Player[playerid][PlayerTotalPoints] = 0;

//	KillTimer(Player[playerid][Label_Timer]);
	Delete3DTextLabel(Player[playerid][Label_PlInfo]);
	PlayerTextDrawHide(playerid, PlayerInfo[0]);
	PlayerTextDrawHide(playerid, PlayerInfo[1]);
	PlayerTextDrawHide(playerid, PlayerInfo[2]);

	if( InSpec[playerid] != -1 )
	{
        Spec_RemovePlayerFromSpec(playerid);
	}

    PlayerPlaySound(playerid, 1098, 0.0, 0.0, 0.0);
//	TextDrawHideForPlayer(playerid, SigmaTextdraw);

    new pT = Player[playerid][Team];

    if (gConfig[Matchmode]==MATCHMODE_TCWCW) SavePlayerInfo(playerid);
	if ( RoundStarted && Player[playerid][InGame] )
	{
		new Float:h, Float:a;

	 	GetPlayerHealth(playerid, h);
		GetPlayerArmour(playerid, a);

		if (__kick_handled[playerid] == false)
		{
			format(stringo, sizeof stringo, "%s has %s. (%d // %d)", Player[playerid][Nickname], disconnectreason[ reason ] , floatround(h) , floatround(a));
        	SendClientMessageToAll(COLOR_GREY, stringo);
		}

	    Player[playerid][InGame] = 0;
	    Player_outSecs[playerid] = 10;

		if (!CamMove)
		{
			foreach(new i:Player)
			{
			    if(InSpec[i]==playerid)
				{
		            Spec_SwitchSpec(i, 1);
			    }
			}

			FixHealthBars();
		}

		if (Gaming == GAMETYPE_FIGHT && RoundFightType == FIGHTSIZE_ONEVSONE)
		{
		    Iter_Remove(ovoPlayers, playerid);

		    if (PlayerAvversario[playerid] != INVALID_PLAYER_ID)
		    {
		        new playerid2 = PlayerAvversario[playerid];
			    new avversario = INVALID_PLAYER_ID;
			    PlayerAvversario[playerid] = INVALID_PLAYER_ID;

				if (Iter_Count(ovoInGame) > 1)
				{
				    foreach(new i:ovoInGame)
				    {
				        if (Player[i][fInWaiting])
				        {
				            Player[i][fInWaiting] = false;
				            avversario = i;
				            break;
				        }
				    }

				    if (avversario == INVALID_PLAYER_ID)
				    {
				    	Player[playerid2][fInWaiting] = true;

				    	SetPlayerHealth (playerid2, 100.0);
				    	SendClientMessage (playerid2, COLOR_SYSTEM, "Wait for the next opponent.");
				    	new szString[ 123 ] = "Current fights: ";// szString

				    	new bool:written[MAX_PLAYERS] = {false, ...};

				    	foreach(new i:ovoInGame)
				    	{
				    	    if (written[i]) continue;

				    	    if (!Player[i][fInWaiting])
				    	    {
				    	        format (szString, sizeof szString, "%s%s vs %s ", szString, Player[i][Nickname], Player[PlayerAvversario[i]][Nickname]);

								if (strlen(szString) > 120)
								{
								    SendClientMessage (playerid2, COLOR_SYSTEM, szString);
								    szString = "";
								}

								written[PlayerAvversario[i]] = true;
				    	    }
				    	}

				    	SendClientMessage (playerid2, COLOR_SYSTEM, szString);
					}
					else
					{
					    Player[playerid2][fInWaiting] = false;

					    SetPlayerHealth (playerid2, 100.0);
					    SetPlayerHealth (avversario, 100.0);

						SetPlayerVirtualWorld (playerid2, MIN_GM_WORLD + playerid2);
						SetPlayerVirtualWorld (avversario, MIN_GM_WORLD + playerid2);

						GivePlayerWeapon (playerid2, RoundFightWeapon, 500);

						new id = eScenario[FileID];

	                    PlayerAvversario [avversario] = playerid2;
	                    PlayerAvversario [playerid2]   = avversario;

					    ShowPlayerNameTagForPlayer(playerid2, avversario, true);
					    ShowPlayerNameTagForPlayer(avversario, playerid2, true);

						SetPlayerPos(avversario, fFights_Spawns[id][1][0], fFights_Spawns[id][1][1], fFights_Spawns[id][1][2]);
					}
				}
				else
				{
					EndRound (playerid2);
				}
			}
		}

		RemovePlayerMapIcon(playerid, MAPICON_ATTACKERSPAWN);

		if( pT == TEAM_A )
		{
		    Team1_StartHP -= gConfig[GameMode] == GAMEMODE_NOCBUG ? 100 : 200;

			if (Team1_StartHP == 0)
			    Team1_StartHP = 1;
		}
		else if( pT == TEAM_B )
		{
			Team2_StartHP -= gConfig[GameMode] == GAMEMODE_NOCBUG ? 100 : 200;

			if (Team2_StartHP == 0)
			    Team2_StartHP = 1;
		}

		TeamPlayers[pT] --;
		SyncTextdraw(1);

		if (Gaming == GAMETYPE_BASE)
		{
			if(Player[playerid][Weaponset] != INVALID_WEAPON_SET)
			{
				Weaponsets[Player[playerid][Weaponset]][TeamSelection][pT] --;
			}
			Player[playerid][Weaponset] = INVALID_WEAPON_SET;
		}

		if (gConfig[ Matchmode ] != MATCHMODE_NOSCORES)
		{
			format (stringo, sizeof stringo, "%s is ready to be re-added.", Player[playerid][Nickname]);
			SendClientMessageToAll(COLOR_SYSTEM, stringo);

			if (!CamMove)
			{
/*				new Float:x,Float:y,Float:z,Float:aa;

				GetPlayerPos(playerid, x, y, z);
				GetPlayerFacingAngle(playerid, aa);
*/
// [restore-mysql-timeout] <= point here
//				MySQLStatus[TotalQuerys] ++; mysql_tquery(g_MySQLConnection, sprintf("INSERT INTO timeouts VALUES ('%s', '%f', '%f', '%d', '%d', '%d', '%d', '%d', '%d', '%d', '%s', '%d')", Player[playerid][Nickname], h, a, pT, Player[playerid][Kills], Player[playerid][Deaths], Player[playerid][Damage], Player[playerid][RKills], Player[playerid][RDamage], Player[playerid][RDeaths], sprintf("%f,%f,%f,%f", x, y, z, aa), G_ID), "OnReaddReady", "iffff", playerid, x, y, z, aa);
				/*
				GamePaused = 1;
				TextDrawSetString(RoundPaused, "Round ~r~paused");

				foreach(new i:Player)
				{
				    if(Player[i][InGame])
					{
				        TogglePlayerControllable(i, false);
				        TextDrawShowForPlayer(i, RoundPaused );
				    }
				}
				*/
				PauseRound ();

				//esl_timeoutPlayers
				if (gConfig[GameMode] == GAMEMODE_ESL) {
				    SendClientMessageToAll (COLOR_SYSTEM, "Round will automatically resume in 120 seconds");
				    esl_timeoutPlayers ++;

				    if (auto_resumeTimer != Timer:-1) {
				        stop auto_resumeTimer;
				    }

				    auto_resumeTimer = defer AutoResumeRound();
				}

//				SendClientMessageToAll(COLOR_SYSTEM, "Press Y to vote the round unpausing. Everyone must vote to unpause the round.");
			}
		}

		if(!GamePaused)
		{
		    defer CheckPlayers();
   			//SetTimer("CheckPlayers", DELAY_CHECKPLAYERS, 0);
		}
	}
	else
	{
		if (__kick_handled[playerid] == false)
		{
			format (stringo, sizeof stringo, "%s has %s.", Player[playerid][Nickname], disconnectreason[ reason ]);
        	SendClientMessageToAll(COLOR_GREY, stringo);
        }

		if (Player[playerid][InDm] != -1)
		{
		 	MySQLStatus[TotalQuerys] ++; mysql_tquery(g_MySQLConnection, sprintf("UPDATE bestdmplayer SET damage = '%d', kills = '%d' WHERE nickname = '%s' AND dmid = '%d'", Player[playerid][DDamage], Player[playerid][DKills], Player[playerid][Nickname], Player[playerid][InDm]), "", "");
 		}
	}

	if (pT != NULL_TEAM)
		iTeam[pT][tPlayers] --;

	Player[playerid][Team] = NULL_TEAM;
    DisablePlayerCheckpoint(playerid);
//    DisablePlayerRaceCheckpoint(playerid);
//    PlayerYVote[playerid] = false;

	pSkinAttachObject[playerid][0][ao_model] = 0;
	pSkinAttachObject[playerid][0][ao_bone] = 0;
	pSkinAttachObject[playerid][0][ao_x] = 0.0;
	pSkinAttachObject[playerid][0][ao_y] = 0.0;
	pSkinAttachObject[playerid][0][ao_z] = 0.0;
	pSkinAttachObject[playerid][0][ao_rx] = 0.0;
	pSkinAttachObject[playerid][0][ao_ry] = 0.0;
	pSkinAttachObject[playerid][0][ao_rz] = 0.0;
	pSkinAttachObject[playerid][0][ao_sx] = 0.0;
	pSkinAttachObject[playerid][0][ao_sy] = 0.0;
	pSkinAttachObject[playerid][0][ao_sz] = 0.0;

	pSkinAttachObject[playerid][1][ao_model] = 0;
	pSkinAttachObject[playerid][1][ao_bone] = 0;
	pSkinAttachObject[playerid][1][ao_x] = 0.0;
	pSkinAttachObject[playerid][1][ao_y] = 0.0;
	pSkinAttachObject[playerid][1][ao_z] = 0.0;
	pSkinAttachObject[playerid][1][ao_rx] = 0.0;
	pSkinAttachObject[playerid][1][ao_ry] = 0.0;
	pSkinAttachObject[playerid][1][ao_rz] = 0.0;
	pSkinAttachObject[playerid][1][ao_sx] = 0.0;
	pSkinAttachObject[playerid][1][ao_sy] = 0.0;
	pSkinAttachObject[playerid][1][ao_sz] = 0.0;

	pSkinAttachObject[playerid][2][ao_model] = 0;
	pSkinAttachObject[playerid][2][ao_bone] = 0;
	pSkinAttachObject[playerid][2][ao_x] = 0.0;
	pSkinAttachObject[playerid][2][ao_y] = 0.0;
	pSkinAttachObject[playerid][2][ao_z] = 0.0;
	pSkinAttachObject[playerid][2][ao_rx] = 0.0;
	pSkinAttachObject[playerid][2][ao_ry] = 0.0;
	pSkinAttachObject[playerid][2][ao_rz] = 0.0;
	pSkinAttachObject[playerid][2][ao_sx] = 0.0;
	pSkinAttachObject[playerid][2][ao_sy] = 0.0;
	pSkinAttachObject[playerid][2][ao_sz] = 0.0;

	pSkinAttachObject[playerid][3][ao_model] = 0;
	pSkinAttachObject[playerid][3][ao_bone] = 0;
	pSkinAttachObject[playerid][3][ao_x] = 0.0;
	pSkinAttachObject[playerid][3][ao_y] = 0.0;
	pSkinAttachObject[playerid][3][ao_z] = 0.0;
	pSkinAttachObject[playerid][3][ao_rx] = 0.0;
	pSkinAttachObject[playerid][3][ao_ry] = 0.0;
	pSkinAttachObject[playerid][3][ao_rz] = 0.0;
	pSkinAttachObject[playerid][3][ao_sx] = 0.0;
	pSkinAttachObject[playerid][3][ao_sy] = 0.0;
	pSkinAttachObject[playerid][3][ao_sz] = 0.0;

	pSkinAttachObject[playerid][4][ao_model] = 0;
	pSkinAttachObject[playerid][4][ao_bone] = 0;
	pSkinAttachObject[playerid][4][ao_x] = 0.0;
	pSkinAttachObject[playerid][4][ao_y] = 0.0;
	pSkinAttachObject[playerid][4][ao_z] = 0.0;
	pSkinAttachObject[playerid][4][ao_rx] = 0.0;
	pSkinAttachObject[playerid][4][ao_ry] = 0.0;
	pSkinAttachObject[playerid][4][ao_rz] = 0.0;
	pSkinAttachObject[playerid][4][ao_sx] = 0.0;
	pSkinAttachObject[playerid][4][ao_sy] = 0.0;
	pSkinAttachObject[playerid][4][ao_sz] = 0.0;

	pSkinAttachObject[playerid][5][ao_model] = 0;
	pSkinAttachObject[playerid][5][ao_bone] = 0;
	pSkinAttachObject[playerid][5][ao_x] = 0.0;
	pSkinAttachObject[playerid][5][ao_y] = 0.0;
	pSkinAttachObject[playerid][5][ao_z] = 0.0;
	pSkinAttachObject[playerid][5][ao_rx] = 0.0;
	pSkinAttachObject[playerid][5][ao_ry] = 0.0;
	pSkinAttachObject[playerid][5][ao_rz] = 0.0;
	pSkinAttachObject[playerid][5][ao_sx] = 0.0;
	pSkinAttachObject[playerid][5][ao_sy] = 0.0;
	pSkinAttachObject[playerid][5][ao_sz] = 0.0;

	pSkinAttachObject[playerid][6][ao_model] = 0;
	pSkinAttachObject[playerid][6][ao_bone] = 0;
	pSkinAttachObject[playerid][6][ao_x] = 0.0;
	pSkinAttachObject[playerid][6][ao_y] = 0.0;
	pSkinAttachObject[playerid][6][ao_z] = 0.0;
	pSkinAttachObject[playerid][6][ao_rx] = 0.0;
	pSkinAttachObject[playerid][6][ao_ry] = 0.0;
	pSkinAttachObject[playerid][6][ao_rz] = 0.0;
	pSkinAttachObject[playerid][6][ao_sx] = 0.0;
	pSkinAttachObject[playerid][6][ao_sy] = 0.0;
	pSkinAttachObject[playerid][6][ao_sz] = 0.0;

	pSkinAttachObject[playerid][7][ao_model] = 0;
	pSkinAttachObject[playerid][7][ao_bone] = 0;
	pSkinAttachObject[playerid][7][ao_x] = 0.0;
	pSkinAttachObject[playerid][7][ao_y] = 0.0;
	pSkinAttachObject[playerid][7][ao_z] = 0.0;
	pSkinAttachObject[playerid][7][ao_rx] = 0.0;
	pSkinAttachObject[playerid][7][ao_ry] = 0.0;
	pSkinAttachObject[playerid][7][ao_rz] = 0.0;
	pSkinAttachObject[playerid][7][ao_sx] = 0.0;
	pSkinAttachObject[playerid][7][ao_sy] = 0.0;
	pSkinAttachObject[playerid][7][ao_sz] = 0.0;

	pSkinAttachObject[playerid][8][ao_model] = 0;
	pSkinAttachObject[playerid][8][ao_bone] = 0;
	pSkinAttachObject[playerid][8][ao_x] = 0.0;
	pSkinAttachObject[playerid][8][ao_y] = 0.0;
	pSkinAttachObject[playerid][8][ao_z] = 0.0;
	pSkinAttachObject[playerid][8][ao_rx] = 0.0;
	pSkinAttachObject[playerid][8][ao_ry] = 0.0;
	pSkinAttachObject[playerid][8][ao_rz] = 0.0;
	pSkinAttachObject[playerid][8][ao_sx] = 0.0;
	pSkinAttachObject[playerid][8][ao_sy] = 0.0;
	pSkinAttachObject[playerid][8][ao_sz] = 0.0;

	pSkinAttachObject[playerid][9][ao_model] = 0;
	pSkinAttachObject[playerid][9][ao_bone] = 0;
	pSkinAttachObject[playerid][9][ao_x] = 0.0;
	pSkinAttachObject[playerid][9][ao_y] = 0.0;
	pSkinAttachObject[playerid][9][ao_z] = 0.0;
	pSkinAttachObject[playerid][9][ao_rx] = 0.0;
	pSkinAttachObject[playerid][9][ao_ry] = 0.0;
	pSkinAttachObject[playerid][9][ao_rz] = 0.0;
	pSkinAttachObject[playerid][9][ao_sx] = 0.0;
	pSkinAttachObject[playerid][9][ao_sy] = 0.0;
	pSkinAttachObject[playerid][9][ao_sz] = 0.0;

	if (Player[ playerid ][ IsAfk ])
	{
		Player[playerid][IsAfk]    = false;
		Player[playerid][AfkStart] = 0;
		Player[playerid][Pos_Afk][0] = 0;
		Player[playerid][Pos_Afk][1] = 0;
		Player[playerid][Pos_Afk][2] = 0;
		Player[playerid][Pos_Afk][3] = 0;
		Player[playerid][Afk_Interior] = 0;
		Player[playerid][AfkVW] = 0;

		PlayerTextDrawHide( playerid , Player_AfkTD[ 0 ] );
		PlayerTextDrawHide( playerid , Player_AfkTD[ 1 ] );
		PlayerTextDrawHide( playerid , Player_AfkTD[ 2 ] );
		PlayerTextDrawHide( playerid , Player_AfkTD[ 3 ] );

//		PlayerTextDrawDestroy( playerid , Player_AfkTD[ 0 ] );
//		PlayerTextDrawDestroy( playerid , Player_AfkTD[ 1 ] );
//		PlayerTextDrawDestroy( playerid , Player_AfkTD[ 2 ] );
//		PlayerTextDrawDestroy( playerid , Player_AfkTD[ 3 ] );

		Player[playerid][AfkSeat] = 0;
		Player[playerid][AfkVeh]  = -1;

		if (PlayerAfk_RandomSprite[playerid] != Timer:-1) {
			stop PlayerAfk_RandomSprite[ playerid ];
		}
	}

	PlaySoundForAll(1055);
	RefreshReadyTDs_Esl();
    RefreshTeamPlayers_TD();

//    #if CONN_REMOTE == true
  //  HTTP(playerid, HTTP_POST, #REMOTE_BASE_URL"/saveleave.php", sprintf( "n=%s&sp=nm5b6f56Wm" , Player[ playerid ][ Nickname ] ) , "");
//	#endif

	if (Iter_Count(Player) == 0 && AC_State != STATE_DISABLED)
	{
	    print("The anticheat will be disabled in 2 mins");
		auto_disable_ac = defer AutoDisableAC();
		bADisableAC = true;
	}

	if (Iter_Count(Player) == 0)
	{
	    switch(AC_State)
	    {
	        case STATE_ENABLED:
	        {
			    print("The anticheat will be disabled in 2 mins");
				auto_disable_ac = defer AutoDisableAC();
				bADisableAC = true;
	        }
	        case STATE_WAITING:
	        {
				print("Anticheat launch aborted");
			    AC_Toggle(false);
				stop AC_START_TIMER;

			    AC_State = STATE_DISABLED;
			  	SendRconCommand ( sprintf ("hostname %s", g_stored_original_name) );
	        }
	    }
	}

	__kick_handled[playerid]=false;// reset state
	return true;
}

// SavedPlayer
stock SavePlayerInfo(playerid)
{
	//
	new free_slot = GetFreeSlot();

	if (free_slot == -1) {
	    // Use MySQL timeout system !!
	    printf("SavePlayerInfo -- free_slot -1.. playerid %d", playerid);
	}
	else {
	    /*
	    SavedPlayer[free_slot][sNickname] = Player[playerid][Nickname];
	    SavedPlayer[free_slot][sNickname_WOTag] = Player[playerid][Nickname_WOTag];
	    */
	    strdel(SavedPlayer[free_slot][sNickname], 0, 24);
	    strdel(SavedPlayer[free_slot][sNickname_WOTag], 0, 24);

	    strcat(SavedPlayer[free_slot][sNickname], Player[playerid][Nickname], 24);
	    strcat(SavedPlayer[free_slot][sNickname_WOTag], Player[playerid][Nickname_WOTag], 24);

	    SavedPlayer[free_slot][sKills] = Player[playerid][Kills];
	    SavedPlayer[free_slot][sDeaths] = Player[playerid][Deaths];
	    SavedPlayer[free_slot][sDamage] = Player[playerid][Damage];

	    SavedPlayer[free_slot][sRKills] = Player[playerid][RKills];
	    SavedPlayer[free_slot][sRDeaths] = Player[playerid][RDeaths];
	    SavedPlayer[free_slot][sRDamage] = Player[playerid][RDamage];

	    SavedPlayer[free_slot][sTeam] = Player[playerid][Team];

	    new Float:x, Float:y, Float:z, Float:aa;
	    GetPlayerPos (playerid, x, y, z);
	    GetPlayerFacingAngle (playerid, aa);

	    SavedPlayer[free_slot][sPos][0] = x;
	    SavedPlayer[free_slot][sPos][1] = y;
	    SavedPlayer[free_slot][sPos][2] = z;
        SavedPlayer[free_slot][sPos][3] = aa;

	    new Float:h, Float:a;
	    GetPlayerHealth (playerid, h);
	    GetPlayerArmour (playerid, a);

	    SavedPlayer[free_slot][sHealth] = h;
	    SavedPlayer[free_slot][sArmour] = a;

	    SavedPlayer[free_slot][sPlayed] = Player[playerid][InGame];

	    SavedPlayer[free_slot][sAssigned] = true;
	    /*
	    print("=================================================================");
		printf("Player saved %d playerid", playerid);
		printf("sNickname: %s", SavedPlayer[free_slot][sNickname]);
		printf("sNickname_WOTag: %s", SavedPlayer[free_slot][sNickname_WOTag]);
		printf("sKills: %d", SavedPlayer[free_slot][sKills]);
		printf("sDeaths: %d", SavedPlayer[free_slot][sDeaths]);
		printf("sDamage: %d", SavedPlayer[free_slot][sDamage]);
		printf("sRKills: %d", SavedPlayer[free_slot][sRKills]);
		printf("sRDeaths: %d", SavedPlayer[free_slot][sRDeaths]);
		printf("sRDamage: %d", SavedPlayer[free_slot][sRDamage]);
		printf("sTeam: %d", SavedPlayer[free_slot][sTeam]);
		printf("Pos[0]: %f", SavedPlayer[free_slot][sPos][0]);
		printf("Pos[1]: %f", SavedPlayer[free_slot][sPos][1]);
		printf("Pos[2]: %f", SavedPlayer[free_slot][sPos][2]);
		printf("sHealth: %f", SavedPlayer[free_slot][sHealth]);
		printf("sArmour: %f", SavedPlayer[free_slot][sArmour]);
		printf("sPlayed: %d", SavedPlayer[free_slot][sPlayed]);
		printf("sAssigned: %d", SavedPlayer[free_slot][sAssigned]);
		printf("free_slot: %d", free_slot);
		print("=================================================================");*/
	}
}

stock CheckPlayerInfo(playerid)
{
	for (new i = 0; i < MAX_SAVE_SLOTS; ++i) {
//	    printf("(i: %d) SavedNickname = %s | PlayerNickname = %s | sAssigned = %d", i, SavedPlayer[i][sNickname], Player[playerid][Nickname], SavedPlayer[i][sAssigned]);
	    if (SavedPlayer[i][sAssigned] && !strcmp(SavedPlayer[i][sNickname], Player[playerid][Nickname], false)) {
	        return i;
		}
	}

	return -1;
}

stock RestorePlayerInfo(playerid)
{
	new id = CheckPlayerInfo(playerid);

	if (id != -1) {
	    // lol Player[playerid][Nickname] = SavedPlayer[free_slot][sNickname];
	    Player[playerid][Kills] = SavedPlayer[id][sKills];
	    Player[playerid][Deaths] = SavedPlayer[id][sDeaths];
	    Player[playerid][Damage] = SavedPlayer[id][sDamage];

	    Player[playerid][RKills] = SavedPlayer[id][sRKills];
	    Player[playerid][RDeaths] = SavedPlayer[id][sRDeaths];
	    Player[playerid][RDamage] = SavedPlayer[id][sRDamage];

	    timeout_Team[playerid] = SavedPlayer[id][sTeam];

	    timeout_Pos[playerid][0] = SavedPlayer[id][sPos][0];
	    timeout_Pos[playerid][1] = SavedPlayer[id][sPos][1];
	    timeout_Pos[playerid][2] = SavedPlayer[id][sPos][2];
        timeout_Pos[playerid][3] = SavedPlayer[id][sPos][3];

		timeout_Health[playerid]  = SavedPlayer[id][sHealth];
		timeout_Armour[playerid]  = SavedPlayer[id][sArmour];

        timeoutPlayer[playerid]   = bool:SavedPlayer[id][sPlayed];

        if (timeoutPlayer[playerid]) {
       		format(stringo, sizeof stringo, "Player {"#COLOR_SYSTEM_FOCUS"}%s{"#COLOR_SYSTEM_REST"} (%d) is ready to be re-added.", Player[playerid][Nickname], playerid);
  	  	    SendClientMessageToAll(COLOR_SYSTEM, stringo);
		}

		PlayerTextDrawSetString (playerid, PlayerInfo[1], sprintf("DMG ~b~~h~%d~n~~w~Tot. DMG ~b~~h~%d", Player[playerid][RDamage], Player[playerid][Damage]));

	    SavedPlayer[id][sAssigned] = false;

		return true;
	}
	else
		return false;
}

stock ClearSlot(slot_id) {
    SavedPlayer[id][sAssigned] = false;
	return true;
}

stock GetFreeSlot() {
	for (new i = 0; i < MAX_SAVE_SLOTS; ++i) {
		if (!SavedPlayer[i][sAssigned]) {
		    return i;
		}
	}
	return -1;
}

timer AutoDisableAC[120000]()
{
    bADisableAC = false;
    AC_Toggle(false);
	stop AC_START_TIMER;

    AC_State = STATE_DISABLED;

    SendRconCommand ( sprintf ("hostname %s", g_stored_original_name) );
    SendClientMessageToAll (COLOR_SYSTEM, "The anticheat has been disabled automatically by the gamemode.");
	return true;
}
//The anticheat has been disabled automatically by the gamemode.

forward OnReaddReady(playerid, Float:x, Float:y, Float:z, Float:a);
public OnReaddReady(playerid, Float:x, Float:y, Float:z, Float:a)
{
	format (stringo, sizeof stringo, "%s is ready to be re-added @%.2f, %.2f, %.2f, %.2f", Player[playerid][Nickname], x, y, z, a);
	SendClientMessageToAll(COLOR_SYSTEM, stringo);
}

public OnPlayerSpawn(playerid)
{
	// resetta qui
	if (Player[playerid][SkinSelection]) CancelSelectTextDraw(playerid);
    Player[playerid][SkinSelection] = false;
    Player[playerid][fake_selection] = false;

    g_PlayerFreezed[playerid] = false;
	PlayerPlaySound(playerid, SOUND_SUCCESS, 0.0, 0.0, 0.0);

    Player[playerid][Spawned] = true;
 //   Player[playerid][MusicClass] = false;

	foreach(new i:Player)
	{
	    if (InSpec[i]==playerid)
		{
		    Spec_ChangeSpecTarget(i, playerid);
	    }
	}

	if (Sync_InCorso[playerid])
	{
		ResetPlayerWeapons(playerid);

		GivePlayerWeapon(playerid, Sync_Weapons_ID[playerid][0], Sync_Weapons_AMMO[playerid][0]);
		GivePlayerWeapon(playerid, Sync_Weapons_ID[playerid][1], Sync_Weapons_AMMO[playerid][1]);
		GivePlayerWeapon(playerid, Sync_Weapons_ID[playerid][2], Sync_Weapons_AMMO[playerid][2]);
		GivePlayerWeapon(playerid, Sync_Weapons_ID[playerid][3], Sync_Weapons_AMMO[playerid][3]);
		GivePlayerWeapon(playerid, Sync_Weapons_ID[playerid][4], Sync_Weapons_AMMO[playerid][4]);
		GivePlayerWeapon(playerid, Sync_Weapons_ID[playerid][5], Sync_Weapons_AMMO[playerid][5]);
		GivePlayerWeapon(playerid, Sync_Weapons_ID[playerid][6], Sync_Weapons_AMMO[playerid][6]);
		GivePlayerWeapon(playerid, Sync_Weapons_ID[playerid][7], Sync_Weapons_AMMO[playerid][7]);
		GivePlayerWeapon(playerid, Sync_Weapons_ID[playerid][8], Sync_Weapons_AMMO[playerid][8]);
		GivePlayerWeapon(playerid, Sync_Weapons_ID[playerid][9], Sync_Weapons_AMMO[playerid][9]);
		GivePlayerWeapon(playerid, Sync_Weapons_ID[playerid][10], Sync_Weapons_AMMO[playerid][10]);
		GivePlayerWeapon(playerid, Sync_Weapons_ID[playerid][11], Sync_Weapons_AMMO[playerid][11]);
		GivePlayerWeapon(playerid, Sync_Weapons_ID[playerid][12], Sync_Weapons_AMMO[playerid][12]);

	    SetPlayerHealth(playerid, Sync_Health[playerid]);
	   	SetPlayerArmour(playerid, Sync_Armour[playerid]);

	  	if (RoundStarted)
    	{
    	    if (Player[playerid][InGame])
    	    {
	     		SetPlayerInterior(playerid, eScenario[Interior]);
	     		// RefreshIcons();

	       		if (Gaming != GAMETYPE_GUNGAME && Gaming != GAMETYPE_FIGHT && Gaming != GAMETYPE_FALLOUT && Gaming != GAMETYPE_LASTBULLET)
		        {
	         		SetPlayerTeam(playerid, Player[playerid][Team]);
		        }
		        else
		        {
	         		SetPlayerTeam(playerid, NO_TEAM);
		        }
			}
	    }
	 	else
   		{
   			SetPlayerTeam(playerid, NO_TEAM);
   			SetPlayerColor(playerid, (Player[playerid][InDm] == -1 ? iTeam[Player[playerid][Team]][OutColor] : red));

			if (pSkinAttachObject[playerid][0][ao_model] != 0)
				SetPlayerAttachedObject(playerid, 0, pSkinAttachObject[playerid][0][ao_model], pSkinAttachObject[playerid][0][ao_bone], pSkinAttachObject[playerid][0][ao_x], pSkinAttachObject[playerid][0][ao_y], pSkinAttachObject[playerid][0][ao_z], pSkinAttachObject[playerid][0][ao_rx], pSkinAttachObject[playerid][0][ao_ry], pSkinAttachObject[playerid][0][ao_rz], pSkinAttachObject[playerid][0][ao_sx], pSkinAttachObject[playerid][0][ao_sy], pSkinAttachObject[playerid][0][ao_sz]);

			if (pSkinAttachObject[playerid][1][ao_model] != 0)
				SetPlayerAttachedObject(playerid, 1, pSkinAttachObject[playerid][1][ao_model], pSkinAttachObject[playerid][1][ao_bone], pSkinAttachObject[playerid][1][ao_x], pSkinAttachObject[playerid][1][ao_y], pSkinAttachObject[playerid][1][ao_z], pSkinAttachObject[playerid][1][ao_rx], pSkinAttachObject[playerid][1][ao_ry], pSkinAttachObject[playerid][1][ao_rz], pSkinAttachObject[playerid][1][ao_sx], pSkinAttachObject[playerid][1][ao_sy], pSkinAttachObject[playerid][1][ao_sz]);

			if (pSkinAttachObject[playerid][2][ao_model] != 0)
				SetPlayerAttachedObject(playerid, 2, pSkinAttachObject[playerid][2][ao_model], pSkinAttachObject[playerid][2][ao_bone], pSkinAttachObject[playerid][2][ao_x], pSkinAttachObject[playerid][2][ao_y], pSkinAttachObject[playerid][2][ao_z], pSkinAttachObject[playerid][2][ao_rx], pSkinAttachObject[playerid][2][ao_ry], pSkinAttachObject[playerid][2][ao_rz], pSkinAttachObject[playerid][2][ao_sx], pSkinAttachObject[playerid][2][ao_sy], pSkinAttachObject[playerid][2][ao_sz]);

			if (pSkinAttachObject[playerid][3][ao_model] != 0)
				SetPlayerAttachedObject(playerid, 3, pSkinAttachObject[playerid][3][ao_model], pSkinAttachObject[playerid][3][ao_bone], pSkinAttachObject[playerid][3][ao_x], pSkinAttachObject[playerid][3][ao_y], pSkinAttachObject[playerid][3][ao_z], pSkinAttachObject[playerid][3][ao_rx], pSkinAttachObject[playerid][3][ao_ry], pSkinAttachObject[playerid][3][ao_rz], pSkinAttachObject[playerid][3][ao_sx], pSkinAttachObject[playerid][3][ao_sy], pSkinAttachObject[playerid][3][ao_sz]);

			if (pSkinAttachObject[playerid][4][ao_model] != 0)
				SetPlayerAttachedObject(playerid, 4, pSkinAttachObject[playerid][4][ao_model], pSkinAttachObject[playerid][4][ao_bone], pSkinAttachObject[playerid][4][ao_x], pSkinAttachObject[playerid][4][ao_y], pSkinAttachObject[playerid][4][ao_z], pSkinAttachObject[playerid][4][ao_rx], pSkinAttachObject[playerid][4][ao_ry], pSkinAttachObject[playerid][4][ao_rz], pSkinAttachObject[playerid][4][ao_sx], pSkinAttachObject[playerid][4][ao_sy], pSkinAttachObject[playerid][4][ao_sz]);

			if (pSkinAttachObject[playerid][5][ao_model] != 0)
				SetPlayerAttachedObject(playerid, 5, pSkinAttachObject[playerid][5][ao_model], pSkinAttachObject[playerid][5][ao_bone], pSkinAttachObject[playerid][5][ao_x], pSkinAttachObject[playerid][5][ao_y], pSkinAttachObject[playerid][5][ao_z], pSkinAttachObject[playerid][5][ao_rx], pSkinAttachObject[playerid][5][ao_ry], pSkinAttachObject[playerid][5][ao_rz], pSkinAttachObject[playerid][5][ao_sx], pSkinAttachObject[playerid][5][ao_sy], pSkinAttachObject[playerid][5][ao_sz]);

			if (pSkinAttachObject[playerid][6][ao_model] != 0)
				SetPlayerAttachedObject(playerid, 6, pSkinAttachObject[playerid][6][ao_model], pSkinAttachObject[playerid][6][ao_bone], pSkinAttachObject[playerid][6][ao_x], pSkinAttachObject[playerid][6][ao_y], pSkinAttachObject[playerid][6][ao_z], pSkinAttachObject[playerid][6][ao_rx], pSkinAttachObject[playerid][6][ao_ry], pSkinAttachObject[playerid][6][ao_rz], pSkinAttachObject[playerid][6][ao_sx], pSkinAttachObject[playerid][6][ao_sy], pSkinAttachObject[playerid][6][ao_sz]);

			if (pSkinAttachObject[playerid][7][ao_model] != 0)
				SetPlayerAttachedObject(playerid, 7, pSkinAttachObject[playerid][7][ao_model], pSkinAttachObject[playerid][7][ao_bone], pSkinAttachObject[playerid][7][ao_x], pSkinAttachObject[playerid][7][ao_y], pSkinAttachObject[playerid][7][ao_z], pSkinAttachObject[playerid][7][ao_rx], pSkinAttachObject[playerid][7][ao_ry], pSkinAttachObject[playerid][7][ao_rz], pSkinAttachObject[playerid][7][ao_sx], pSkinAttachObject[playerid][7][ao_sy], pSkinAttachObject[playerid][7][ao_sz]);

			if (pSkinAttachObject[playerid][8][ao_model] != 0)
				SetPlayerAttachedObject(playerid, 8, pSkinAttachObject[playerid][8][ao_model], pSkinAttachObject[playerid][8][ao_bone], pSkinAttachObject[playerid][8][ao_x], pSkinAttachObject[playerid][8][ao_y], pSkinAttachObject[playerid][8][ao_z], pSkinAttachObject[playerid][8][ao_rx], pSkinAttachObject[playerid][8][ao_ry], pSkinAttachObject[playerid][8][ao_rz], pSkinAttachObject[playerid][8][ao_sx], pSkinAttachObject[playerid][8][ao_sy], pSkinAttachObject[playerid][8][ao_sz]);

			if (pSkinAttachObject[playerid][9][ao_model] != 0)
				SetPlayerAttachedObject(playerid, 9, pSkinAttachObject[playerid][9][ao_model], pSkinAttachObject[playerid][9][ao_bone], pSkinAttachObject[playerid][9][ao_x], pSkinAttachObject[playerid][9][ao_y], pSkinAttachObject[playerid][9][ao_z], pSkinAttachObject[playerid][9][ao_rx], pSkinAttachObject[playerid][9][ao_ry], pSkinAttachObject[playerid][9][ao_rz], pSkinAttachObject[playerid][9][ao_sx], pSkinAttachObject[playerid][9][ao_sy], pSkinAttachObject[playerid][9][ao_sz]);
		}

		Sync_InCorso[playerid] = 0;
	}
	else
	{
	    if (RoundStarted)
	    {
			if (gConfig[Matchmode] == MATCHMODE_NOSCORES)
			{
				if (!Player[playerid][InGame])//round startato e non ï¿½ in game
				{
				    if (Player[playerid][ConnectedNow] == true)
				    {
				        if (Gaming == GAMETYPE_TDM || Gaming == GAMETYPE_GUNGAME || Gaming == GAMETYPE_FALLOUT || Gaming == GAMETYPE_LASTBULLET)
				        {
				            /*
				            #define i playerid//=> mi annoiavo :v
				            new pt = Player[playerid][Team];
						    CleanSpecTDs (playerid);

							if(IsPlayerInAnyVehicle(playerid))
							{
								DestroyVehicleEx(GetPlayerVehicleID(playerid));
							}

							//if (InSpec[i]!=-1) Spec_RemovePlayerFromSpec(i);

							Player[playerid][InGame] 	  = 1;
							PlayerAfk_Seconds[playerid] = 0;

//							Player[playerid][RKills] = 0;
//							Player[playerid][RDeaths] = 0;
//							Player[playerid][RDamage] = 0;

							if(TeamRole[pt]==ATTACKERS)
							{
						 		if(Gaming == GAMETYPE_TDM)
								{
									if (Player[i][Team] == TEAM_A)
									{
										TextDrawSetString(PlayerSpecInfo[playerid][6], "~r~~h~WPS: ~w~TDM");
									}
									else
									{
										TextDrawSetString(PlayerSpecInfo[playerid][6], "~b~~h~WPS: ~w~TDM");
									}

									stringo = "";
									strcat(stringo, TXT_TDM_P1" ");
									strcat(stringo, numstr(gConfig[TDMKills]));
									strcat(stringo, TXT_TDM_P2);

									SendClientMessage(playerid, COLOR_GREY, stringo);
									SetSpawnInfo(playerid, Player[playerid][Team], GetPlayerSkinEx(playerid), eScenario[SpawnAttackers][0] - RANDOM_SPAWN_ROUND + random(RANDOM_SPAWN_ROUND), eScenario[SpawnAttackers][1] - RANDOM_SPAWN_ROUND + random(RANDOM_SPAWN_ROUND), eScenario[SpawnAttackers][2], 0.0, 0, 0, 0, 0, 0, 0);
									SetPlayerMapIcon(playerid, MAPICON_ATTACKERSPAWN, eScenario[SpawnAttackers][0], eScenario[SpawnAttackers][1], eScenario[SpawnAttackers][2], ATTACKERSMAP_ICON, 0, MAPICON_TYPE_ATTSPAWN);
								}
								else if(Gaming == GAMETYPE_GUNGAME)
								{
									if (Player[i][Team] == TEAM_A)
									{
										TextDrawSetString(PlayerSpecInfo[i][6], "~r~~h~WPS: ~w~Gungame");
									}
									else
									{
										TextDrawSetString(PlayerSpecInfo[i][6], "~b~~h~WPS: ~w~Gungame");
									}

									SendClientMessage(i, COLOR_GREY, TXT_GUNGAME);
									new rand = random(20);
									SetSpawnInfo(i, i, GetPlayerSkinEx(i), Scenario_MultipleSpawns[rand][0], Scenario_MultipleSpawns[rand][1], Scenario_MultipleSpawns[rand][2], Scenario_MultipleSpawns[rand][3], 0, 0, 0, 0, 0, 0);
								}
							    else if(Gaming == GAMETYPE_FALLOUT)
							    {
									if (Player[i][Team] == TEAM_A)
					  				{
					  					TextDrawSetString(PlayerSpecInfo[i][6], "_");
						  			}
							  		else
							  		{
								  	    TextDrawSetString(PlayerSpecInfo[i][6], "_");
							  		}

								    SendClientMessage(i, COLOR_GREY, TXT_FALLOUT);
									SetSpawnInfo(i, i, GetPlayerSkinEx(i), 2482.1921 - random(39), -1660.4783 + random(47), 161.0000, random(360), 0, 0, 0, 0, 0, 0);
								}
								else if(Gaming == GAMETYPE_LASTBULLET)
								{
									if (Player[i][Team] == TEAM_A)
					  				{
					  					TextDrawSetString(PlayerSpecInfo[i][6], "~b~~h~WPS: ~w~Deagle");
						  			}
							  		else
							  		{
								  	    TextDrawSetString(PlayerSpecInfo[i][6], "~b~~h~WPS: ~w~Deagle");
							  		}

								    SendClientMessage(i, COLOR_GREY, TXT_LASTBULLET);
									SetSpawnInfo(i, i, GetPlayerSkinEx(i), lBullet_Spawns[eScenario[FileID]][i][0], lBullet_Spawns[eScenario[FileID]][i][1], lBullet_Spawns[eScenario[FileID]][i][2], random(360), 0, 0, 0, 0, 0, 0);

									LifesLeft = CreatePlayerTextDraw(i, 578.000000, 57.000000, "_");
									PlayerTextDrawAlignment(i, LifesLeft, 2);
									PlayerTextDrawBackgroundColor(i, LifesLeft, 51);
									PlayerTextDrawFont(i, LifesLeft, 2);
									PlayerTextDrawLetterSize(i, LifesLeft, 0.210000, 1.100000);
									PlayerTextDrawColor(i, LifesLeft, -1);
									PlayerTextDrawSetOutline(i, LifesLeft, 1);
									PlayerTextDrawSetProportional(i, LifesLeft, 1);
								}
							}
							else
							{
						 		if(Gaming == GAMETYPE_TDM)
								{
									if (Player[i][Team] == TEAM_A)
									{
										TextDrawSetString(PlayerSpecInfo[i][6], "~r~~h~WPS: ~w~TDM");
									}
									else
									{
										TextDrawSetString(PlayerSpecInfo[i][6], "~b~~h~WPS: ~w~TDM");
									}

									stringo = "";
									strcat(stringo, TXT_TDM_P1" ");
									strcat(stringo, numstr(gConfig[TDMKills]));
									strcat(stringo, TXT_TDM_P2);

									SendClientMessage(i, COLOR_GREY, stringo);
									SetSpawnInfo(i, Player[i][Team], GetPlayerSkinEx(i), eScenario[SpawnDefenders][0] - RANDOM_SPAWN_ROUND + random(RANDOM_SPAWN_ROUND), eScenario[SpawnDefenders][1] - RANDOM_SPAWN_ROUND + random(RANDOM_SPAWN_ROUND), eScenario[SpawnDefenders][2], 0.0, 0, 0, 0, 0, 0, 0);
								}
								else if(Gaming == GAMETYPE_GUNGAME)
								{
									if (Player[i][Team] == TEAM_A)
									{
										TextDrawSetString(PlayerSpecInfo[i][6], "~r~~h~WPS: ~w~Gungame");
									}
									else
									{
										TextDrawSetString(PlayerSpecInfo[i][6], "~b~~h~WPS: ~w~Gungame");
									}

									SendClientMessage(i, COLOR_GREY, TXT_GUNGAME);
									new rand = random(20);
									SetSpawnInfo(i, i, GetPlayerSkinEx(i), Scenario_MultipleSpawns[rand][0], Scenario_MultipleSpawns[rand][1], Scenario_MultipleSpawns[rand][2], Scenario_MultipleSpawns[rand][3], 0, 0, 0, 0, 0, 0);
								}
							    else if(Gaming == GAMETYPE_FALLOUT)
							    {
									if (Player[i][Team] == TEAM_A)
					  				{
					  					TextDrawSetString(PlayerSpecInfo[i][6], "_");
						  			}
							  		else
							  		{
								  	    TextDrawSetString(PlayerSpecInfo[i][6], "_");
							  		}

								    SendClientMessage(i, COLOR_GREY, TXT_FALLOUT);
									SetSpawnInfo(i, i, GetPlayerSkinEx(i), 2482.1921 - random(39), -1660.4783 + random(47), 161.0000, random(360), 0, 0, 0, 0, 0, 0);
								}
								else if(Gaming == GAMETYPE_LASTBULLET)
								{
									if (Player[i][Team] == TEAM_A)
					  				{
					  					TextDrawSetString(PlayerSpecInfo[i][6], "~b~~h~WPS: ~w~Deagle");
						  			}
							  		else
							  		{
								  	    TextDrawSetString(PlayerSpecInfo[i][6], "~b~~h~WPS: ~w~Deagle");
							  		}

								    SendClientMessage(i, COLOR_GREY, TXT_LASTBULLET);
									SetSpawnInfo(i, i, GetPlayerSkinEx(i), lBullet_Spawns[eScenario[FileID]][i][0], lBullet_Spawns[eScenario[FileID]][i][1], lBullet_Spawns[eScenario[FileID]][i][2], random(360), 0, 0, 0, 0, 0, 0);

									LifesLeft = CreatePlayerTextDraw(i, 578.000000, 57.000000, "_");
									PlayerTextDrawAlignment(i, LifesLeft, 2);
									PlayerTextDrawBackgroundColor(i, LifesLeft, 51);
									PlayerTextDrawFont(i, LifesLeft, 2);
									PlayerTextDrawLetterSize(i, LifesLeft, 0.210000, 1.100000);
									PlayerTextDrawColor(i, LifesLeft, -1);
									PlayerTextDrawSetOutline(i, LifesLeft, 1);
									PlayerTextDrawSetProportional(i, LifesLeft, 1);
								}
							}

							if( pt == TEAM_A )
							{
							    Team1_StartHP += gConfig[GameMode] == GAMEMODE_NOCBUG ? 100 : 200;
							}
							else if( pt == TEAM_B )
							{
								Team2_StartHP += gConfig[GameMode] == GAMEMODE_NOCBUG ? 100 : 200;
							}

							if( Player[i][InDm] != -1 )
							{
							    MySQLStatus[TotalQuerys] ++; mysql_tquery(g_MySQLConnection, sprintf("UPDATE bestdmplayer SET damage = '%d', kills = '%d' WHERE nickname = '%s' AND dmid = '%d'", Player[i][DDamage], Player[i][DKills], Player[i][Nickname], Player[i][InDm]), "", "");
							    Player[i][InDm] = -1;
							}

							if (gConfig[UseHealthBars])
							{
								SetPlayerScore(i, 0);
							}
							else
							{
							    SetPlayerScore(i, gConfig[GameMode] == GAMEMODE_NOCBUG ? 100 : 200);
							}

							if (AntiHits)
							{
		//					    TextDrawShowForPlayer(i, TD_NotHits);
							    TextDrawShowForPlayer(i, TD_NoHitsScritta);
							}

							TeamPlayers[pt]++;
							SetPlayerColor(i, iTeam[pt][InGameColor]);
							SetPlayerVirtualWorld(i, GAME_WORLD);

							if( GamePaused )
							{
							    TogglePlayerControllable( i , false );
							    TextDrawShowForPlayer( i , RoundPaused );
							}
							// all great things are simple, and many can be expressed in single words: freedom, justice, honor, duty, mercy, hope.

							TextDrawShowForPlayer(i, RoundStats[0]);
							TextDrawShowForPlayer(i, RoundStats[1]);
							TextDrawShowForPlayer(i, RoundStats[2]);
							TextDrawShowForPlayer(i, RoundStats[3]);

							TextDrawHideForPlayer(i, TeamPlayers_TD);

							GangZoneShowForPlayer(i, ZonaAttornoCP, GANGZONE_COLORAZIONE);
							SpawnPlayer(i);

					        timeoutPlayer[i] = false;
					        #undef i
							*/

					        __staticAddProcess (playerid);
                            timeoutPlayer[playerid] = false;
					        FixHealthBars();
					        RefreshIcons();

					        format(stringo, sizeof stringo, "{"#COLOR_SYSTEM_FOCUS"}%s{"#COLOR_SYSTEM_REST"} has been auto-brought into the round.", Player[playerid][Nickname]);
                            SendClientMessageToAll(COLOR_SYSTEM, stringo);
						}
				    }
				}
			}
	    }

		if(!Player[playerid][InGame])
		{
		    SetPlayerTeam(playerid, playerid);
	        SetPlayerInterior(playerid, Lobby_Int);
	        SetPlayerVirtualWorld(playerid, NORMAL_WORLD);

			if (pSkinAttachObject[playerid][0][ao_model] != 0)
				SetPlayerAttachedObject(playerid, 0, pSkinAttachObject[playerid][0][ao_model], pSkinAttachObject[playerid][0][ao_bone], pSkinAttachObject[playerid][0][ao_x], pSkinAttachObject[playerid][0][ao_y], pSkinAttachObject[playerid][0][ao_z], pSkinAttachObject[playerid][0][ao_rx], pSkinAttachObject[playerid][0][ao_ry], pSkinAttachObject[playerid][0][ao_rz], pSkinAttachObject[playerid][0][ao_sx], pSkinAttachObject[playerid][0][ao_sy], pSkinAttachObject[playerid][0][ao_sz]);

			if (pSkinAttachObject[playerid][1][ao_model] != 0)
				SetPlayerAttachedObject(playerid, 1, pSkinAttachObject[playerid][1][ao_model], pSkinAttachObject[playerid][1][ao_bone], pSkinAttachObject[playerid][1][ao_x], pSkinAttachObject[playerid][1][ao_y], pSkinAttachObject[playerid][1][ao_z], pSkinAttachObject[playerid][1][ao_rx], pSkinAttachObject[playerid][1][ao_ry], pSkinAttachObject[playerid][1][ao_rz], pSkinAttachObject[playerid][1][ao_sx], pSkinAttachObject[playerid][1][ao_sy], pSkinAttachObject[playerid][1][ao_sz]);

			if (pSkinAttachObject[playerid][2][ao_model] != 0)
				SetPlayerAttachedObject(playerid, 2, pSkinAttachObject[playerid][2][ao_model], pSkinAttachObject[playerid][2][ao_bone], pSkinAttachObject[playerid][2][ao_x], pSkinAttachObject[playerid][2][ao_y], pSkinAttachObject[playerid][2][ao_z], pSkinAttachObject[playerid][2][ao_rx], pSkinAttachObject[playerid][2][ao_ry], pSkinAttachObject[playerid][2][ao_rz], pSkinAttachObject[playerid][2][ao_sx], pSkinAttachObject[playerid][2][ao_sy], pSkinAttachObject[playerid][2][ao_sz]);

			if (pSkinAttachObject[playerid][3][ao_model] != 0)
				SetPlayerAttachedObject(playerid, 3, pSkinAttachObject[playerid][3][ao_model], pSkinAttachObject[playerid][3][ao_bone], pSkinAttachObject[playerid][3][ao_x], pSkinAttachObject[playerid][3][ao_y], pSkinAttachObject[playerid][3][ao_z], pSkinAttachObject[playerid][3][ao_rx], pSkinAttachObject[playerid][3][ao_ry], pSkinAttachObject[playerid][3][ao_rz], pSkinAttachObject[playerid][3][ao_sx], pSkinAttachObject[playerid][3][ao_sy], pSkinAttachObject[playerid][3][ao_sz]);

			if (pSkinAttachObject[playerid][4][ao_model] != 0)
				SetPlayerAttachedObject(playerid, 4, pSkinAttachObject[playerid][4][ao_model], pSkinAttachObject[playerid][4][ao_bone], pSkinAttachObject[playerid][4][ao_x], pSkinAttachObject[playerid][4][ao_y], pSkinAttachObject[playerid][4][ao_z], pSkinAttachObject[playerid][4][ao_rx], pSkinAttachObject[playerid][4][ao_ry], pSkinAttachObject[playerid][4][ao_rz], pSkinAttachObject[playerid][4][ao_sx], pSkinAttachObject[playerid][4][ao_sy], pSkinAttachObject[playerid][4][ao_sz]);

			if (pSkinAttachObject[playerid][5][ao_model] != 0)
				SetPlayerAttachedObject(playerid, 5, pSkinAttachObject[playerid][5][ao_model], pSkinAttachObject[playerid][5][ao_bone], pSkinAttachObject[playerid][5][ao_x], pSkinAttachObject[playerid][5][ao_y], pSkinAttachObject[playerid][5][ao_z], pSkinAttachObject[playerid][5][ao_rx], pSkinAttachObject[playerid][5][ao_ry], pSkinAttachObject[playerid][5][ao_rz], pSkinAttachObject[playerid][5][ao_sx], pSkinAttachObject[playerid][5][ao_sy], pSkinAttachObject[playerid][5][ao_sz]);

			if (pSkinAttachObject[playerid][6][ao_model] != 0)
				SetPlayerAttachedObject(playerid, 6, pSkinAttachObject[playerid][6][ao_model], pSkinAttachObject[playerid][6][ao_bone], pSkinAttachObject[playerid][6][ao_x], pSkinAttachObject[playerid][6][ao_y], pSkinAttachObject[playerid][6][ao_z], pSkinAttachObject[playerid][6][ao_rx], pSkinAttachObject[playerid][6][ao_ry], pSkinAttachObject[playerid][6][ao_rz], pSkinAttachObject[playerid][6][ao_sx], pSkinAttachObject[playerid][6][ao_sy], pSkinAttachObject[playerid][6][ao_sz]);

			if (pSkinAttachObject[playerid][7][ao_model] != 0)
				SetPlayerAttachedObject(playerid, 7, pSkinAttachObject[playerid][7][ao_model], pSkinAttachObject[playerid][7][ao_bone], pSkinAttachObject[playerid][7][ao_x], pSkinAttachObject[playerid][7][ao_y], pSkinAttachObject[playerid][7][ao_z], pSkinAttachObject[playerid][7][ao_rx], pSkinAttachObject[playerid][7][ao_ry], pSkinAttachObject[playerid][7][ao_rz], pSkinAttachObject[playerid][7][ao_sx], pSkinAttachObject[playerid][7][ao_sy], pSkinAttachObject[playerid][7][ao_sz]);

			if (pSkinAttachObject[playerid][8][ao_model] != 0)
				SetPlayerAttachedObject(playerid, 8, pSkinAttachObject[playerid][8][ao_model], pSkinAttachObject[playerid][8][ao_bone], pSkinAttachObject[playerid][8][ao_x], pSkinAttachObject[playerid][8][ao_y], pSkinAttachObject[playerid][8][ao_z], pSkinAttachObject[playerid][8][ao_rx], pSkinAttachObject[playerid][8][ao_ry], pSkinAttachObject[playerid][8][ao_rz], pSkinAttachObject[playerid][8][ao_sx], pSkinAttachObject[playerid][8][ao_sy], pSkinAttachObject[playerid][8][ao_sz]);

			if (pSkinAttachObject[playerid][9][ao_model] != 0)
				SetPlayerAttachedObject(playerid, 9, pSkinAttachObject[playerid][9][ao_model], pSkinAttachObject[playerid][9][ao_bone], pSkinAttachObject[playerid][9][ao_x], pSkinAttachObject[playerid][9][ao_y], pSkinAttachObject[playerid][9][ao_z], pSkinAttachObject[playerid][9][ao_rx], pSkinAttachObject[playerid][9][ao_ry], pSkinAttachObject[playerid][9][ao_rz], pSkinAttachObject[playerid][9][ao_sx], pSkinAttachObject[playerid][9][ao_sy], pSkinAttachObject[playerid][9][ao_sz]);

			new pdm=Player[playerid][InDm];
		    if(pdm != -1)
			{//nel dm, setto colore rosso + resto
			    SetPlayerVirtualWorld(playerid, pdm + 1);

		        SetPlayerHealth(playerid, 100.0);
		        SetPlayerArmour(playerid, 100.0);

		        SetPlayerInterior(playerid, Deathmatchs[pdm][Interior]);
       			SetPlayerColor(playerid, COLOR_DM);

       			// le altre armi le ha nello spawninfo
                GivePlayerWeapon(playerid, Deathmatchs[pdm][Weapon4], 9999);

		        SendClientMessage(playerid, COLOR_SYSTEM, "Type /lobby if you want to leave the deathmatch");
    		}
			else
  			{// non ï¿½ nel dm, setto colore + vita senza armour
				SetPlayerHealth(playerid, 100.0);
				SetPlayerArmour(playerid, 0.0);
				SetPlayerColor(playerid, iTeam[Player[playerid][Team]][OutColor]);

		   		if (gConfig[LobbyWeapons] == true)
		   		{
			   		GivePlayerWeapon( playerid , Player[ playerid ][ Weapons ][ 0 ] , 500 );
			   		GivePlayerWeapon( playerid , Player[ playerid ][ Weapons ][ 1 ] , 500 );
			   		GivePlayerWeapon( playerid , Player[ playerid ][ Weapons ][ 2 ] , 500 );
			   		GivePlayerWeapon( playerid , Player[ playerid ][ Weapons ][ 3 ] , 500 );
			   		GivePlayerWeapon( playerid , Player[ playerid ][ Weapons ][ 4 ] , 500 );
			   		GivePlayerWeapon( playerid , Player[ playerid ][ Weapons ][ 5 ] , 500 );
	                GivePlayerWeapon( playerid , Player[ playerid ][ Weapons ][ 6 ] , 500 );
	       			GivePlayerWeapon( playerid , Player[ playerid ][ Weapons ][ 7 ] , 500 );
			   		GivePlayerWeapon( playerid , Player[ playerid ][ Weapons ][ 8 ] , 500 );
			   		GivePlayerWeapon( playerid , Player[ playerid ][ Weapons ][ 9 ] , 500 );
			   		GivePlayerWeapon( playerid , Player[ playerid ][ Weapons ][ 10 ] , 500 );
			   		GivePlayerWeapon( playerid , Player[ playerid ][ Weapons ][ 11 ] , 500 );
			   		GivePlayerWeapon( playerid , Player[ playerid ][ Weapons ][ 12 ] , 500 );
				}
			}
  		}
	    else
		{   // alcuni utenti spawnano male (?)
			// negli interior

		//	SetPlayerColor(playerid, iTeam[Player[playerid][Team]][InGameColor]);
			if (!Player[playerid][InRestoring]) {
				SetPlayerHealth(playerid, 100.0);
				SetPlayerArmour(playerid, ( gConfig[GameMode] != GAMEMODE_NOCBUG ? 100.0 : 0.0 ) );
			}
			else {
			    Player[playerid][InRestoring] = false;
			}

    		SetPlayerInterior(playerid, eScenario[Interior]);
      		ResetPlayerWeapons(playerid);

        	switch (Gaming)
	        {
         		case GAMETYPE_ARENA:
           		{
					if (Round_PVPMode)
					{
						GivePlayerWeapon(playerid, PVPWeapons[0], 9999);
						GivePlayerWeapon(playerid, PVPWeapons[1], 9999);
						GivePlayerWeapon(playerid, PVPWeapons[2], 9999);
						GivePlayerWeapon(playerid, PVPWeapons[3], 9999);
						GivePlayerWeapon(playerid, PVPWeapons[4], 9999);
					}
					else
					{
					   	GivePlayerWeapon(playerid, 24, 9999);
						GivePlayerWeapon(playerid, 25, 9999);
						GivePlayerWeapon(playerid, 29, 9999);
						GivePlayerWeapon(playerid, 31, 9999);
						GivePlayerWeapon(playerid, 34, 9999);
					}

					SetPlayerTeam(playerid, Player[playerid][Team]);
					SetPlayerColor(playerid, iTeam[Player[playerid][Team]][InGameColor]);
     			}
        		case GAMETYPE_TDM:
          		{
			  		GivePlayerWeapon(playerid, 24, 9999);
					GivePlayerWeapon(playerid, 25, 9999);
					GivePlayerWeapon(playerid, 29, 9999);
					GivePlayerWeapon(playerid, 31, 9999);
					GivePlayerWeapon(playerid, 34, 9999);

                   	SetPlayerTeam(playerid, Player[playerid][Team]);
                   	SetPlayerColor(playerid, iTeam[Player[playerid][Team]][InGameColor]);
		        }
		        case GAMETYPE_BASE:
		        {
          			new
             			ws = Player[ playerid ][ Weaponset ];

					if (ws != INVALID_WEAPON_SET)
					{
					    GivePlayerWeapon(playerid, Weaponsets[ws][ID1], 9999);
		                GivePlayerWeapon(playerid, Weaponsets[ws][ID2], 9999);
					}

					SetPlayerTeam(playerid, Player[playerid][Team]);
					SetPlayerColor(playerid, iTeam[Player[playerid][Team]][InGameColor]);
	            }
	            case GAMETYPE_GUNGAME:
	            {
				    SetPlayerHealth( playerid , 100.0 );
				    SetPlayerArmour( playerid , 0.0   );

				    SetPlayerTeam( playerid , NO_TEAM  );
				    ResetPlayerWeapons( playerid );

				    GivePlayerWeapon( playerid , GunGame_Weapons[ Player[ playerid ][ RKills ] ] , 500 );
				    SetPlayerColor(playerid, 0xE5C50EAA);
	            }
	            case GAMETYPE_FIGHT:
	            {
				    SetPlayerHealth( playerid , 100.0 );
				    SetPlayerArmour( playerid , 0.0   );

				    SetPlayerTeam( playerid , NO_TEAM  );
				    ResetPlayerWeapons( playerid );

				    GivePlayerWeapon( playerid , RoundFightWeapon , 500 );
				    SetPlayerColor(playerid, 0xE5C50EAA);
	            }
				case GAMETYPE_FALLOUT:
				{
				    SetPlayerHealth (playerid , 100.0 );
				    SetPlayerArmour (playerid , 0.0   );

					SetPlayerTeam (playerid , NO_TEAM );
					ResetPlayerWeapons (playerid);

					SetPlayerColor (playerid, 0xE5C50EAA);
				}
				case GAMETYPE_LASTBULLET:
				{
				    SetPlayerHealth (playerid , 40.0  );
				    SetPlayerArmour (playerid , 0.0   );

					SetPlayerTeam (playerid , NO_TEAM );
					ResetPlayerWeapons (playerid);

					GivePlayerWeapon ( playerid , 24 , 1 );
					GivePlayerWeapon ( playerid , 4  , 1 );

					SetPlayerColor (playerid, 0xE5C50EAA);

					PlayerTextDrawSetString (playerid, LifesLeft, sprintf("%d lifes left", PlayerLifesLeft[playerid]));
					PlayerTextDrawShow (playerid, LifesLeft);
				}
			}

			if(IsPlayerAttachedObjectSlotUsed(playerid, 0))
				RemovePlayerAttachedObject(playerid, 0);

			if(IsPlayerAttachedObjectSlotUsed(playerid, 1))
				RemovePlayerAttachedObject(playerid, 1);

			if(IsPlayerAttachedObjectSlotUsed(playerid, 2))
				RemovePlayerAttachedObject(playerid, 2);

			if(IsPlayerAttachedObjectSlotUsed(playerid, 3))
				RemovePlayerAttachedObject(playerid, 3);

			if(IsPlayerAttachedObjectSlotUsed(playerid, 4))
				RemovePlayerAttachedObject(playerid, 4);

			if(IsPlayerAttachedObjectSlotUsed(playerid, 5))
				RemovePlayerAttachedObject(playerid, 5);

			if(IsPlayerAttachedObjectSlotUsed(playerid, 6))
				RemovePlayerAttachedObject(playerid, 6);

			if(IsPlayerAttachedObjectSlotUsed(playerid, 7))
				RemovePlayerAttachedObject(playerid, 7);

			if(IsPlayerAttachedObjectSlotUsed(playerid, 8))
				RemovePlayerAttachedObject(playerid, 8);

			if(IsPlayerAttachedObjectSlotUsed(playerid, 9))
				RemovePlayerAttachedObject(playerid, 9);
	    }
	}

	Player[playerid][ConnectedNow] = false;
	return true;
}

timer AutoResumeRound[120000]()
{
	SendClientMessageToAll (COLOR_SYSTEM, "120 seconds passed, round is gonna resume!");
	/*
	auto_resumeTimer = Timer:-1;
	if(UnPausingRunning) return 0;
	UnPausingRunning = true;
	defer countdown_unpause();

	if (auto_resumeTimer != Timer:-1) {
		stop auto_resumeTimer;
	}

	foreach (new i:Player) { if (Player[i][InGame]) PlayerPlaySound(i, 1139, 0.0, 0.0, 0.0);  }

	TextDrawSetString( RoundPaused, "Unpausing... ~r~~h~3~r~ 2 1" );
	*/
	auto_resumeTimer = Timer:-1;
	UnPauseRound();
	return 1;
}

public OnPlayerDeath(playerid, killerid, reason)
{
	// il player potrebbe aver richiesto la skin selection
    Player[playerid][SkinSelection] = true;
   	Player[playerid][fake_selection] = true;

	if (sys_m_onplayerdeath[playerid] == true) // Serve per gestire in modo _manuale_ un death
	{
		// Attualmente, viene utilizzato solamente dal "last bullet" per inviare i dati
		// killerid, playerid e reason corretti

		killerid = sys_m_PlayerKillerid[playerid];
		reason = sys_m_PlayerReason[playerid];

	    sys_m_onplayerdeath[playerid] = false;
	}
	// sys_m_onplayerdeath = false;

	Player[ playerid ][ Spawned ] = false;
	new kconnect = IsPlayerConnected(killerid);
	new pT = Player[playerid][Team];

	if(kconnect)
	{
		Server_RefreshStats(TotalKills, 1);
		Player[killerid][GKills] ++;

		if (Player[playerid][Loggen])
		{
//			mysql_format(g_MySQLConnection, str, "UPDATE users SET kills = '%d' WHERE nickname = '%e'", Player[killerid][GKills], Player[killerid][Nickname]);
//			MySQLStatus[TotalQuerys] ++; mysql_function_query(g_MySQLConnection, str, true, "", "");
			MySQLStatus[TotalQuerys] ++; mysql_tquery(g_MySQLConnection, sprintf("UPDATE users SET kills = '%d' WHERE nickname = '%s'", Player[killerid][Skin], Player[killerid][Nickname]) , "", "");
		}

		stop PlayerKillTimer[ playerid ];
		stop PlayerKillTimer[ killerid ];

		if (RoundStarted)
		{
		    //RGivePlayerScore(killerid, 5, rankCorrispondente[PlayerKills_Continui[killerid]]);
//		    RGivePlayerScore(killerid, 5, rankCorrispondente[PlayerScorer_Score[killerid]]);

		    //PlayerKills_Continui [killerid] ++;

			if (Gaming != GAMETYPE_GUNGAME && Gaming != GAMETYPE_FIGHT && Gaming != GAMETYPE_LASTBULLET) // modalitï¿½ team
			{
				switch (Player[playerid][Team])
				{
				    case TEAM_A, TEAM_A_SUB:
				    {
				        PlayerTextDrawSetString (playerid, PlayerKillTD, sprintf ("Killed by ~"#GT_TEAMA"~~h~%s", Player[killerid][Nickname]));
				        PlayerTextDrawSetString (killerid, PlayerKillTD, sprintf ("You killed ~"#GT_TEAMB"~~h~%s", Player[playerid][Nickname]));
				    }
				    case TEAM_B, TEAM_B_SUB:
				    {
				        PlayerTextDrawSetString (playerid, PlayerKillTD, sprintf ("Killed by ~"#GT_TEAMB"~~h~%s", Player[killerid][Nickname]));
				        PlayerTextDrawSetString (killerid, PlayerKillTD, sprintf ("You killed ~"#GT_TEAMA"~~h~%s", Player[playerid][Nickname]));
				    }
				    case TEAM_REF:
				    {
						switch (Player[killerid][Team])
						{
							case TEAM_A:
							{
								PlayerTextDrawSetString (playerid, PlayerKillTD, sprintf ("Killed by ~"#GT_TEAMB"~~h~%s", Player[killerid][Nickname]));
								PlayerTextDrawSetString (killerid, PlayerKillTD, sprintf ("You killed ~"#GT_TEAMA"~~h~%s", Player[playerid][Nickname]));
							}
							case TEAM_B:
							{
								PlayerTextDrawSetString (playerid, PlayerKillTD, sprintf ("Killed by ~"#GT_TEAMA"~~h~%s", Player[killerid][Nickname]));
								PlayerTextDrawSetString (killerid, PlayerKillTD, sprintf ("You killed ~y~~h~%s", Player[playerid][Nickname]));
							}
						}
				    }
					default:
					{
						// stesso team
						switch (Player[killerid][Team])
						{
							case TEAM_A:
							{
								PlayerTextDrawSetString (playerid, PlayerKillTD, sprintf ("Killed by ~"#GT_TEAMA"~~h~%s", Player[killerid][Nickname]));
								PlayerTextDrawSetString (killerid, PlayerKillTD, sprintf ("You killed ~"#GT_TEAMA"~~h~%s", Player[playerid][Nickname]));
							}
							case TEAM_B:
							{
								PlayerTextDrawSetString (playerid, PlayerKillTD, sprintf ("Killed by ~"#GT_TEAMB"~~h~%s", Player[killerid][Nickname]));
								PlayerTextDrawSetString (killerid, PlayerKillTD, sprintf ("You killed ~"#GT_TEAMB"~~h~%s", Player[playerid][Nickname]));
							}
						}
					}
				}
			}
			else // no team
			{
	  			PlayerTextDrawSetString (playerid, PlayerKillTD, sprintf ("Killed by ~y~%s", Player[killerid][Nickname]));
		        PlayerTextDrawSetString (killerid, PlayerKillTD, sprintf ("You killed ~y~%s", Player[playerid][Nickname]));
			}
		}
		else
		{
		    if (Player[playerid][InDm] != -1 && Player[killerid][InDm] != -1)
		    {
	  			PlayerTextDrawSetString (playerid, PlayerKillTD, sprintf ("Killed by ~r~%s", Player[killerid][Nickname]));
		        PlayerTextDrawSetString (killerid, PlayerKillTD, sprintf ("You killed ~r~%s", Player[playerid][Nickname]));
		    }
			else // uno nel dm o altri casi
			{
	  			PlayerTextDrawSetString (playerid, PlayerKillTD, sprintf ("Killed by ~y~%s", Player[killerid][Nickname]));
		        PlayerTextDrawSetString (killerid, PlayerKillTD, sprintf ("You killed ~y~%s", Player[playerid][Nickname]));
			}
		}
		PlayerTextDrawShow( playerid , PlayerKillTD );
		PlayerTextDrawShow( killerid , PlayerKillTD );

		//PlayerKillTimer[ playerid ] = SetTimerEx("HideMessageKill", 3000, 0, "i", playerid);
		//PlayerKillTimer[ killerid ] = SetTimerEx("HideMessageKill", 3000, 0, "i", killerid);

		PlayerKillTimer [playerid] = defer HideMessageKill(playerid);
		PlayerKillTimer [killerid] = defer HideMessageKill(killerid);
	}

	if(Player[playerid][InGame])
	{
	    //PlayerKills_Continui [playerid] = 0;
	    /*
	    if (tottronchi > MAX_TRONCHI - 2)
	    {
			for (new i = 0; i < tottronchi; i++)
			{
				if (IsValidObject(tronchi_primiid[i]))
				{
					DestroyDynamicObject(tronchi_primiid[i]);
					DestroyDynamicObject(tronchi_primiid[i]+1);
					DestroyDynamicObject(tronchi_primiid[i]+2);
					DestroyDynamicObject(tronchi_primiid[i]+3);
					DestroyDynamicObject(tronchi_primiid[i]+4);
					DestroyDynamicObject(tronchi_primiid[i]+5);
				}

				tronchi_primiid[i] = -1;
			}

			tottronchi = 0;
	    }



    	new rand1=random(10),rand2=random(5),rand3=random(10),rand4=random(5)+1;
    	new rand9=random(2), rand10=random(2);

		tronchi_primiid[tottronchi] = CreateDynamicObject(2907,x,y,z-0.9,0,0,random(350));  // Tronco
		CreateDynamicObject(2905,(x+(rand1*rand2*0.01)+rand9),(y+(rand3*rand4*0.01)+rand9),z-0.9,0,0,random(350));  // Gamba
		CreateDynamicObject(2905,(x-(rand1*rand2*0.01)-rand9),(y-(rand3*rand4*0.01)-rand9),z-0.9,0,0,random(350));  // Gamba
		CreateDynamicObject(2906,x-(rand1*rand2*0.01)+rand9,y-(rand3*rand4*0.01)+rand9,z-0.9,0,0,random(350));  // Braccio
		CreateDynamicObject(2906,x-(rand1*rand2*0.01)-rand9,y-(rand3*rand4*0.01)-rand9,z-0.9,0,0,rand9);  // Braccio
		CreateDynamicObject(2908,x-(rand1*rand2*0.01)+rand10,y-(rand3*rand4*0.01)+rand10,z-0.9,0,0,random(350));  // Testa

		tottronchi ++;
		*/

		new Float:x, Float:y, Float:z;
		GetPlayerPos(playerid, x, y, z);

		if( ! RoundFirstBlood )
		{
		    GameTextForAll( "~n~~n~~n~~n~~r~First blood!", 3000, 5);
  			RoundFirstBlood = true;
		}

		if(kconnect)
		{
			switch (Player[killerid][PlayerScorer_Score]) {
			    case 0: {
			        RGivePlayerScore(killerid, 5, "Playa");
			    }
			    case 5: {
			        RGivePlayerScore(killerid, 5, "Homie");
			    }
			    case 10: {
			        RGivePlayerScore(killerid, 5, "Jacker");
			    }
			    case 15: {
			        RGivePlayerScore(killerid, 5, "Gangsta");
			    }
			    case 20: {
			        RGivePlayerScore(killerid, 5, "High roller");
			    }
			    case 25: {
			        RGivePlayerScore(killerid, 5, "Hitman");
			    }
			    case 30: {
			        RGivePlayerScore(killerid, 5, "Godfather");
			    }
			    default: {
			        RGivePlayerScore(killerid, 5, "Most respected");
			    }
			}

 			if (Gaming != GAMETYPE_GUNGAME && Gaming != GAMETYPE_FIGHT && Gaming != GAMETYPE_LASTBULLET) SetPlayerColor( playerid , iTeam[ pT ][ OutColor ] );
		    if (HelperLocked[killerid]) SetPlayerColor( killerid , iTeam[ Player[killerid][Team] ][ InGameColor ] );
		    SendDeathMessageEx(killerid, playerid, reason);

			new Float:ehp, hp;

			GetPlayerHealth(killerid, ehp);
			hp = floatround(ehp);

			GetPlayerArmour(killerid, ehp);
			hp += floatround(ehp);

			new Float:ft = GetPlayerDistanceFromPoint(killerid, x, y, z);

			Player[killerid][RKills] += 1;

			if (Gaming != GAMETYPE_FIGHT && Gaming != GAMETYPE_GUNGAME && Gaming != GAMETYPE_LASTBULLET)
			{
				switch (Player[killerid][Team])
				{
				    case TEAM_A:
				    {
				        TextDrawSetString(PlayerSpecInfo[killerid][2], sprintf ("~r~~h~Kills ~w~%d", Player[killerid][RKills]));

				        if (pT != TEAM_A)
				            // rosso           blu
				            // killerid has X playerid
				    		format(stringo, sizeof stringo, "»» {"#SC_TEAMA"}%s{FFFFFF} has %s {"#SC_TEAMB"}%s{FFFFFF} with %d HP (Weapon: %s // %.2f ft)", Player[killerid][Nickname], deathMessages[random(sizeof deathMessages)], Player[playerid][Nickname], hp, aWeaponNames[ reason ], ft);
						else
						    // rosso           rosso
						    // killerid has X playerid
				    		format(stringo, sizeof stringo, "»» {"#SC_TEAMA"}%s{FFFFFF} has %s {"#SC_TEAMA"}%s{FFFFFF} with %d HP (Weapon: %s // %.2f ft)", Player[killerid][Nickname], deathMessages[random(sizeof deathMessages)], Player[playerid][Nickname], hp, aWeaponNames[ reason ], ft);
					}
					case TEAM_B:
					{
					    TextDrawSetString(PlayerSpecInfo[killerid][2], sprintf ("~b~~h~Kills ~w~%d", Player[killerid][RKills]));

					    if (pT != TEAM_B)
				            // BLU           rosso
				            // killerid has X playerid
				    		format(stringo, sizeof stringo, "»» {"#SC_TEAMB"}%s{FFFFFF} has %s {"#SC_TEAMA"}%s{FFFFFF} with %d HP (Weapon: %s // %.2f ft)", Player[killerid][Nickname], deathMessages[random(sizeof deathMessages)], Player[playerid][Nickname], hp, aWeaponNames[ reason ], ft);
						else
				            // BLU           blu
				            // killerid has X playerid
						    format(stringo, sizeof stringo, "»» {"#SC_TEAMB"}%s{FFFFFF} has %s {"#SC_TEAMB"}%s{FFFFFF} with %d HP (Weapon: %s // %.2f ft)", Player[killerid][Nickname], deathMessages[random(sizeof deathMessages)], Player[playerid][Nickname], hp, aWeaponNames[ reason ], ft);
					}
				}
			}
			else
			{
			    format(stringo, sizeof stringo, "»» {E5C50E}%s{FFFFFF} has %s {E5C50E}%s{FFFFFF} with %d HP (Weapon: %s // %.2f ft)", Player[killerid][Nickname], deathMessages[random(sizeof deathMessages)], Player[playerid][Nickname], hp, aWeaponNames[ reason ], ft);
			}//ï¿½ï¿½

			SendClientMessageToAll (-1, stringo);

			switch (Gaming)
			{
			    case GAMETYPE_LASTBULLET:
			    {
	       			// PlayerLifesLeft
					new w, a;
					GetPlayerWeaponData (killerid, 2, w, a);
					if (w == 24 || w == 0) {
					    GivePlayerWeapon (killerid, 24, a + 1);
					}
				}
			    case GAMETYPE_TDM:
			    {
			    	iTeam[Player[killerid][Team]][TDMKills]++;
			    	SyncTextdraw (1);

			    	if(iTeam[Player[killerid][Team]][TDMKills] >= gConfig[TDMKills])
					{
     					EndRound(Player[killerid][Team]);
	    			}
			    }
			    case GAMETYPE_GUNGAME:
			    {
				    if (Player[ killerid ][ RKills ] == MAX_GUNGAME_LEVELS )
				    {
				        EndRound( killerid );
				    }
				    else
				    {
						ResetPlayerWeapons( killerid );
						GivePlayerWeapon( killerid , GunGame_Weapons[ Player[ killerid ][ RKills ] ] , 500 );
						SetPlayerArmedWeapon( killerid , GunGame_Weapons[ Player[ killerid ][ RKills ] ] );

						if (Player[ killerid ][ RKills ] > Gungame_CurrentLeaderLVL)
						{
							Gungame_CurrentLeaderLVL = Player[ killerid ][ RKills ];

							if (Gungame_CurrentLeader != killerid)
							{
								Gungame_CurrentLeader    = killerid;
								format(stringo, sizeof stringo, "»» %s is now the gungame leader with %d kills.", Player[killerid][Nickname], Gungame_CurrentLeaderLVL);
                                SendClientMessageToAll(COLOR_SYSTEM, stringo);
							}

							SyncTextdraw (1);
						}
					}
			    }
			}
			/*
			format(stringo, sizeof stringo, "~y~~h~Ping: ~w~%d~n~~y~~h~FPS: ~w~%d~n~~y~~h~Kills: ~w~%d~n~~y~~h~Damage: ~w~%d~n~~y~~h~Packetloss: ~w~%.1f%%", GetPlayerPing(killerid), pFPS[killerid] , Player[killerid][RKills], Player[killerid][RDamage], GetPlayerPacketloss(killerid));
			PlayerTextDrawSetString(killerid, PlayerInfo, stringo);*/
		}
		else
		{
		    if (Gaming != GAMETYPE_GUNGAME && Gaming != GAMETYPE_FIGHT && Gaming != GAMETYPE_LASTBULLET) SetPlayerColor( playerid , iTeam[ pT ][ OutColor ] );
		    SendDeathMessage(INVALID_PLAYER_ID, playerid, reason);// 

            if (Gaming != GAMETYPE_GUNGAME && Gaming != GAMETYPE_FIGHT && Gaming != GAMETYPE_LASTBULLET) // modalitï¿½ team
            {
				if (pT == TEAM_A)
				{
				    format(stringo, sizeof stringo, "»» {"#SC_TEAMA"}%s{FFFFFF} is dead.", Player[playerid][Nickname]);
				}
				else
				{
				    format(stringo, sizeof stringo, "»» {"#SC_TEAMB"}%s{FFFFFF} is dead.", Player[playerid][Nickname]);
				}
			}
			else
			{
			    format(stringo, sizeof stringo, "»» {E5C50E}%s{FFFFFF} is dead.", Player[playerid][Nickname]);
			}

			SendClientMessageToAll (-1, stringo);
		}

		PlaySoundForAll(12602);

		switch (Gaming)
		{
		    case GAMETYPE_FIGHT:
		    {
		        if (RoundFightType == FIGHTSIZE_ONEVSONE)
		        {
				    Iter_Remove (ovoInGame, playerid);

				    Player_outSecs[playerid] = 10;
		            Player[playerid][InGame] = 0;

/*					TextDrawHideForPlayer(playerid, RoundStats[rStats_ABar]);
					TextDrawHideForPlayer(playerid, RoundStats[rStats_BBar]);
					TextDrawHideForPlayer(playerid, RoundStats[rStats_Time]);
					TextDrawHideForPlayer(playerid, RoundStats[rStats_Background]);
					TextDrawHideForPlayer(playerid, RoundStats[rStats_AStats]);
					TextDrawHideForPlayer(playerid, RoundStats[rStats_BStats]);


					TextDrawHideForPlayer(playerid, RoundStats[0]);
					TextDrawHideForPlayer(playerid, RoundStats[1]);
					TextDrawHideForPlayer(playerid, RoundStats[2]);
					TextDrawHideForPlayer(playerid, RoundStats[3]);
*/
				    DisablePlayerCheckpoint(playerid);

					SetPlayerVirtualWorld(playerid, NORMAL_WORLD);
					//SetPlayerColor(playerid, iTeam[pT][OutColor]);

					SyncTextdraw(1);

					RemovePlayerMapIcon(playerid, MAPICON_ATTACKERSPAWN);
					TeamPlayers[pT] --;

					if( GamePaused )
					{
						TogglePlayerControllable(playerid, true);
					 	//TextDrawHideForPlayer(playerid, RoundPaused );
					}

				   	GangZoneHideForPlayer(playerid, ZonaAttornoCP);
					SpawnPlayer(playerid);

					if (AntiHits)
					{
		//			    TextDrawHideForPlayer(playerid, TD_NotHits);
					    TextDrawHideForPlayer(playerid, TD_NoHitsScritta);
					}

					TextDrawShowForPlayer(playerid, TeamPlayers_TD);
					SetSpawnInfo(playerid, playerid, GetPlayerSkinEx(playerid), Lobby[0] - MAX_RANDOM_SPAWN + random( MAX_RANDOM_SPAWN ), Lobby[1] - MAX_RANDOM_SPAWN + random( MAX_RANDOM_SPAWN ), Lobby[2], Lobby[3], 0, 0, 0, 0, 0, 0);

				    if (kconnect)
				    {
					    new avversario = INVALID_PLAYER_ID;

						if (Iter_Count(ovoInGame) > 1)
						{
						    foreach(new i:ovoInGame)
						    {
						        if (Player[i][fInWaiting])
						        {
						            Player[i][fInWaiting] = false;
						            avversario = i;
						            break;
						        }
						    }
						}
						else
						{
							EndRound (killerid);
							return true;
						}

					    if (avversario == INVALID_PLAYER_ID)
					    {
					    	Player[killerid][fInWaiting] = true;
					    	PlayerAvversario[killerid] = INVALID_PLAYER_ID;

					    	SetPlayerHealth (killerid, 100.0);
					    	SendClientMessage (killerid, COLOR_SYSTEM, "Wait for the next opponent.");
					    	new szString[ 123 ] = "Current fights: ";// szString

					    	new bool:written[MAX_PLAYERS] = {false, ...};

					    	foreach(new i:ovoInGame)
					    	{
					    	    if (written[i]) continue;

					    	    if (!Player[i][fInWaiting])
					    	    {
					    	        format (szString, sizeof szString, "%s%s vs %s ", szString, Player[i][Nickname], Player[PlayerAvversario[i]][Nickname]);

									if (strlen(szString) > 110)
									{
									    SendClientMessage (killerid, COLOR_SYSTEM, szString);
									    szString = "";
									}

									written[PlayerAvversario[i]] = true;
					    	    }
					    	}

					    	SendClientMessage (killerid, COLOR_SYSTEM, szString);
						}
						else
						{
						    Player[killerid][fInWaiting] = false;

						    SetPlayerHealth (killerid, 100.0);
						    SetPlayerHealth (avversario, 100.0);

						    GivePlayerWeapon (killerid, RoundFightWeapon, 500);

							SetPlayerVirtualWorld (killerid, MIN_GM_WORLD + killerid);
							SetPlayerVirtualWorld (avversario, MIN_GM_WORLD + killerid);

							new id = eScenario[FileID];

		                    PlayerAvversario [avversario] = killerid;
		                    PlayerAvversario [killerid]   = avversario;

						    ShowPlayerNameTagForPlayer(killerid, avversario, true);
						    ShowPlayerNameTagForPlayer(avversario, killerid, true);

							SetPlayerPos(avversario, fFights_Spawns[id][1][0], fFights_Spawns[id][1][1], fFights_Spawns[id][1][2]);
						}
					}
			    }
			    else
			    {
				    Player_outSecs[playerid] = 10;
		            Player[playerid][InGame] = 0;
					/*
					TextDrawHideForPlayer(playerid, RoundStats[rStats_ABar]);
					TextDrawHideForPlayer(playerid, RoundStats[rStats_BBar]);
					TextDrawHideForPlayer(playerid, RoundStats[rStats_Time]);
					TextDrawHideForPlayer(playerid, RoundStats[rStats_Background]);
					TextDrawHideForPlayer(playerid, RoundStats[rStats_AStats]);
					TextDrawHideForPlayer(playerid, RoundStats[rStats_BStats]);

					TextDrawHideForPlayer(playerid, RoundStats[0]);
					TextDrawHideForPlayer(playerid, RoundStats[1]);
					TextDrawHideForPlayer(playerid, RoundStats[2]);
					TextDrawHideForPlayer(playerid, RoundStats[3]);
*/

				    DisablePlayerCheckpoint(playerid);

					SetPlayerVirtualWorld(playerid, NORMAL_WORLD);
					//SetPlayerColor(playerid, iTeam[pT][OutColor]);

					if (!CamMove)
					{
						FixHealthBars();
					}

					SyncTextdraw(1);

					RemovePlayerMapIcon(playerid, MAPICON_ATTACKERSPAWN);
					TeamPlayers[pT] --;

					if(Player[playerid][Weaponset] != INVALID_WEAPON_SET)
					{
						Weaponsets[Player[playerid][Weaponset]][TeamSelection][pT] --;
					}

					Player[playerid][Weaponset] = INVALID_WEAPON_SET;

					if( GamePaused )
					{
						TogglePlayerControllable(playerid, true);
					 	//TextDrawHideForPlayer(playerid, RoundPaused );
					}

				   	GangZoneHideForPlayer(playerid, ZonaAttornoCP);
					SpawnPlayer(playerid);

					if (AntiHits)
					{
		//			    TextDrawHideForPlayer(playerid, TD_NotHits);
					    TextDrawHideForPlayer(playerid, TD_NoHitsScritta);
					}

					if(!GamePaused)
					{
					    defer CheckPlayers();
						//SetTimer("CheckPlayers", DELAY_CHECKPLAYERS, 0);
					}

					TextDrawShowForPlayer(playerid, TeamPlayers_TD);
					SetSpawnInfo(playerid, playerid, GetPlayerSkinEx(playerid), Lobby[0] - MAX_RANDOM_SPAWN + random( MAX_RANDOM_SPAWN ), Lobby[1] - MAX_RANDOM_SPAWN + random( MAX_RANDOM_SPAWN ), Lobby[2], Lobby[3], 0, 0, 0, 0, 0, 0);
			    }
			}
			case GAMETYPE_BASE, GAMETYPE_ARENA, GAMETYPE_PVP:
			{
			    Player_outSecs[playerid] = 10;
	            Player[playerid][InGame] = 0;
			/*
				TextDrawHideForPlayer(playerid, RoundStats[0]);
				TextDrawHideForPlayer(playerid, RoundStats[1]);
				TextDrawHideForPlayer(playerid, RoundStats[2]);
				TextDrawHideForPlayer(playerid, RoundStats[3]);
			*/
			    DisablePlayerCheckpoint(playerid);

				SetPlayerVirtualWorld(playerid, NORMAL_WORLD);
				//SetPlayerColor(playerid, iTeam[pT][OutColor]);

				if (!CamMove)
				{
					FixHealthBars();
				}

				SyncTextdraw(1);

				RemovePlayerMapIcon(playerid, MAPICON_ATTACKERSPAWN);

				TeamPlayers[pT] --;

				if(Player[playerid][Weaponset] != INVALID_WEAPON_SET)
				{
					Weaponsets[Player[playerid][Weaponset]][TeamSelection][pT] --;
				}

				Player[playerid][Weaponset] = INVALID_WEAPON_SET;

				if( GamePaused )
				{
					TogglePlayerControllable(playerid, true);
				 	//TextDrawHideForPlayer(playerid, RoundPaused );
				}

			   	GangZoneHideForPlayer(playerid, ZonaAttornoCP);
				SpawnPlayer(playerid);

				if (AntiHits)
				{
		//		    TextDrawHideForPlayer(playerid, TD_NotHits);
				    TextDrawHideForPlayer(playerid, TD_NoHitsScritta);
				}

				if(!GamePaused)
				{
				    defer CheckPlayers();
					//SetTimer("CheckPlayers", DELAY_CHECKPLAYERS, 0);
				}

				TextDrawShowForPlayer(playerid, TeamPlayers_TD);
				SetSpawnInfo(playerid, playerid, GetPlayerSkinEx(playerid), Lobby[0] - MAX_RANDOM_SPAWN + random( MAX_RANDOM_SPAWN ), Lobby[1] - MAX_RANDOM_SPAWN + random( MAX_RANDOM_SPAWN ), Lobby[2], Lobby[3], 0, 0, 0, 0, 0, 0);
			}
			case GAMETYPE_TDM:
			{
			 	if(TeamRole[pT] == ATTACKERS)
	 			{
					SetSpawnInfo(playerid, pT, GetPlayerSkinEx(playerid), eScenario[SpawnAttackers][0] - RANDOM_SPAWN_ROUND + random(RANDOM_SPAWN_ROUND), eScenario[SpawnAttackers][1] - RANDOM_SPAWN_ROUND + random(RANDOM_SPAWN_ROUND), eScenario[SpawnAttackers][2], 0.0, 0, 0, 0, 0, 0, 0);
				}
				else
				{
					SetSpawnInfo(playerid, pT, GetPlayerSkinEx(playerid), eScenario[SpawnDefenders][0] - RANDOM_SPAWN_ROUND + random(RANDOM_SPAWN_ROUND), eScenario[SpawnDefenders][1] - RANDOM_SPAWN_ROUND + random(RANDOM_SPAWN_ROUND), eScenario[SpawnDefenders][2], 0.0, 0, 0, 0, 0, 0, 0);
				}
			}
			case GAMETYPE_GUNGAME:
			{
			    new rand = random( MAX_MULTIPLE_SPAWNS );
			    SetSpawnInfo(playerid, playerid, GetPlayerSkinEx(playerid), Scenario_MultipleSpawns[rand][0], Scenario_MultipleSpawns[rand][1], Scenario_MultipleSpawns[rand][2], Scenario_MultipleSpawns[rand][3], 0, 0, 0, 0, 0, 0);
			}
			case GAMETYPE_LASTBULLET:
			{

		        PlayerLifesLeft [playerid] --; // scala le vite al player

				if (PlayerLifesLeft[playerid] > 0)
				{
				    // Respawn, il player ha ancora vite
				    new p = random (MAX_FIGHT_SPAWNS); // Scelgo una posizione

					SetSpawnInfo(playerid, playerid, GetPlayerSkinEx(playerid), lBullet_Spawns[eScenario[FileID]][p][0], lBullet_Spawns[eScenario[FileID]][p][1], lBullet_Spawns[eScenario[FileID]][p][2], random(360), 0, 0, 0, 0, 0, 0);
					// SpawnPlayer (playerid);
				//	PlayerTextDrawSetString (playerid, LifesLeft, sprintf("%d lifes left", PlayerLifesLeft[playerid]));
				}
				else
				{
				    // Il player ha perso, non ha piï¿½ vite.
				    Player_outSecs[playerid] = 10;
		            Player[playerid][InGame] = 0;
				/*
					TextDrawHideForPlayer(playerid, RoundStats[0]);
					TextDrawHideForPlayer(playerid, RoundStats[1]);
					TextDrawHideForPlayer(playerid, RoundStats[2]);
					TextDrawHideForPlayer(playerid, RoundStats[3]);
				*/
				//    DisablePlayerCheckpoint(playerid);

					SetPlayerVirtualWorld(playerid, NORMAL_WORLD);
					PlayerTextDrawDestroy (playerid, LifesLeft);

					if( GamePaused )
					{
						TogglePlayerControllable(playerid, true);
					 	//TextDrawHideForPlayer(playerid, RoundPaused );
					}

                    TeamPlayers[pT] --;
				   	GangZoneHideForPlayer(playerid, ZonaAttornoCP);
				   	SpawnPlayer(playerid);

				   	SyncTextdraw (1);

					if (AntiHits)
					{
		//			    TextDrawHideForPlayer(playerid, TD_NotHits);
					    TextDrawHideForPlayer(playerid, TD_NoHitsScritta);
					}

					if(!GamePaused)
					{
					    defer CheckPlayers();
						//SetTimer("CheckPlayers", DELAY_CHECKPLAYERS, 0);
					}

					TextDrawShowForPlayer(playerid, TeamPlayers_TD);

					SetSpawnInfo(playerid, playerid, GetPlayerSkinEx(playerid), Lobby[0] - MAX_RANDOM_SPAWN + random( MAX_RANDOM_SPAWN ), Lobby[1] - MAX_RANDOM_SPAWN + random( MAX_RANDOM_SPAWN ), Lobby[2], Lobby[3], 0, 0, 0, 0, 0, 0);
				}
			}
		}
		/*
		if(Gaming == GAMETYPE_FIGHT && RoundFightType == FIGHTSIZE_ONEVSONE)
		{
		    Iter_Remove (ovoInGame, playerid);

		    Player_outSecs[playerid] = 10;
            Player[playerid][InGame] = 0;

			TextDrawHideForPlayer(playerid, RoundStats[0]);
			TextDrawHideForPlayer(playerid, RoundStats[1]);
			TextDrawHideForPlayer(playerid, RoundStats[2]);
			TextDrawHideForPlayer(playerid, RoundStats[3]);

		    DisablePlayerCheckpoint(playerid);

			SetPlayerVirtualWorld(playerid, NORMAL_WORLD);
			//SetPlayerColor(playerid, iTeam[pT][OutColor]);

			SyncTextdraw(1);

			RemovePlayerMapIcon(playerid, MAPICON_ATTACKERSPAWN);

			if( pT == TEAM_A )
			{
			    Team1_StartHP -= gConfig[GameMode] == GAMEMODE_NOCBUG ? 100 : 200;

				if (Team1_StartHP == 0)
				    Team1_StartHP = 1;
			}
			else if( pT == TEAM_B )
			{
				Team2_StartHP -= gConfig[GameMode] == GAMEMODE_NOCBUG ? 100 : 200;

				if (Team2_StartHP == 0)
				    Team2_StartHP = 1;
			}

			TeamPlayers[pT] --;

			if( GamePaused )
			{
				TogglePlayerControllable(playerid, true);
			 	TextDrawHideForPlayer(playerid, RoundPaused );
			}

		   	GangZoneHideForPlayer(playerid, ZonaAttornoCP);
			SpawnPlayer(playerid);

			if (AntiHits)
			{
			    TextDrawHideForPlayer(playerid, TD_NotHits);
			    TextDrawHideForPlayer(playerid, TD_NoHitsScritta);
			}

			TextDrawShowForPlayer(playerid, TeamPlayers_TD);
			SetSpawnInfo(playerid, playerid, GetPlayerSkinEx(playerid), Lobby[0] - MAX_RANDOM_SPAWN + random( MAX_RANDOM_SPAWN ), Lobby[1] - MAX_RANDOM_SPAWN + random( MAX_RANDOM_SPAWN ), Lobby[2], Lobby[3], 0, 0, 0, 0, 0, 0);

		    if (kconnect)
		    {
			    new avversario = INVALID_PLAYER_ID;

				if (Iter_Count(ovoInGame) > 1)
				{
				    foreach(new i:ovoInGame)
				    {
				        if (Player[i][fInWaiting])
				        {
				            Player[i][fInWaiting] = false;
				            avversario = i;
				            break;
				        }
				    }
				}
				else
				{
					EndRound (killerid);
					return true;
				}

			    if (avversario == INVALID_PLAYER_ID)
			    {
			    	Player[killerid][fInWaiting] = true;
			    	PlayerAvversario[killerid] = INVALID_PLAYER_ID;

			    	SetPlayerHealth (killerid, 100.0);
			    	SendClientMessage (killerid, COLOR_SYSTEM, "Wait for the next opponent.");
			    	new szString[ 123 ] = "Current fights: ";// szString

			    	new bool:written[MAX_PLAYERS] = {false, ...};

			    	foreach(new i:ovoInGame)
			    	{
			    	    if (written[i]) continue;

			    	    if (!Player[i][fInWaiting])
			    	    {
			    	        format (szString, sizeof szString, "%s%s vs %s ", szString, Player[i][Nickname], Player[PlayerAvversario[i]][Nickname]);

							if (strlen(szString) > 110)
							{
							    SendClientMessage (killerid, COLOR_SYSTEM, szString);
							    szString = "";
							}

							written[PlayerAvversario[i]] = true;
			    	    }
			    	}

			    	SendClientMessage (killerid, COLOR_SYSTEM, szString);
				}
				else
				{
				    Player[killerid][fInWaiting] = false;

				    SetPlayerHealth (killerid, 100.0);
				    SetPlayerHealth (avversario, 100.0);

				    GivePlayerWeapon (killerid, RoundFightWeapon, 500);

					SetPlayerVirtualWorld (killerid, MIN_GM_WORLD + killerid);
					SetPlayerVirtualWorld (avversario, MIN_GM_WORLD + killerid);

					new id = eScenario[FileID];

                    PlayerAvversario [avversario] = killerid;
                    PlayerAvversario [killerid]   = avversario;

				    ShowPlayerNameTagForPlayer(killerid, avversario, true);
				    ShowPlayerNameTagForPlayer(avversario, killerid, true);

					SetPlayerPos(avversario, fFights_Spawns[id][1][0], fFights_Spawns[id][1][1], fFights_Spawns[id][1][2]);
				}
			}
		}
		else if(Gaming != GAMETYPE_TDM && Gaming != GAMETYPE_GUNGAME)
		{
		    Player_outSecs[playerid] = 10;
            Player[playerid][InGame] = 0;

			TextDrawHideForPlayer(playerid, RoundStats[0]);
			TextDrawHideForPlayer(playerid, RoundStats[1]);
			TextDrawHideForPlayer(playerid, RoundStats[2]);
			TextDrawHideForPlayer(playerid, RoundStats[3]);

		    DisablePlayerCheckpoint(playerid);

			SetPlayerVirtualWorld(playerid, NORMAL_WORLD);
			//SetPlayerColor(playerid, iTeam[pT][OutColor]);

			if (!CamMove)
			{
				FixHealthBars();
			}

			SyncTextdraw(1);

			RemovePlayerMapIcon(playerid, MAPICON_ATTACKERSPAWN);

			if( pT == TEAM_A )
			{
			    Team1_StartHP -= gConfig[GameMode] == GAMEMODE_NOCBUG ? 100 : 200;

				if (Team1_StartHP == 0)
				    Team1_StartHP = 1;
			}
			else if( pT == TEAM_B )
			{
				Team2_StartHP -= gConfig[GameMode] == GAMEMODE_NOCBUG ? 100 : 200;

				if (Team2_StartHP == 0)
				    Team2_StartHP = 1;
			}

			TeamPlayers[pT] --;

			if (Gaming == GAMETYPE_BASE)
			{
				if(Player[playerid][Weaponset] != INVALID_WEAPON_SET)
				{
					Weaponsets[Player[playerid][Weaponset]][TeamSelection][pT] --;
				}

				Player[playerid][Weaponset] = INVALID_WEAPON_SET;
			}

			if( GamePaused )
			{
				TogglePlayerControllable(playerid, true);
			 	TextDrawHideForPlayer(playerid, RoundPaused );
			}

		   	GangZoneHideForPlayer(playerid, ZonaAttornoCP);
			SpawnPlayer(playerid);

			if (AntiHits)
			{
			    TextDrawHideForPlayer(playerid, TD_NotHits);
			    TextDrawHideForPlayer(playerid, TD_NoHitsScritta);
			}

			if(!GamePaused)
			{
				SetTimer("CheckPlayers", DELAY_CHECKPLAYERS, 0);
			}

			TextDrawShowForPlayer(playerid, TeamPlayers_TD);
			SetSpawnInfo(playerid, playerid, GetPlayerSkinEx(playerid), Lobby[0] - MAX_RANDOM_SPAWN + random( MAX_RANDOM_SPAWN ), Lobby[1] - MAX_RANDOM_SPAWN + random( MAX_RANDOM_SPAWN ), Lobby[2], Lobby[3], 0, 0, 0, 0, 0, 0);
		}
		else
		{
		    if (Gaming == GAMETYPE_LASTBULLET)
		    {
		        // PlayerLifesLeft
		        PlayerLifesLeft [playerid] --; // scala le vite al player

				if (PlayerLifesLeft[playerid] > 0)
				{
				    // Respawn, il player ha ancora vite
				    new p = random (MAX_FIGHT_SPAWNS); // Scelgo una posizione

					SetSpawnInfo(playerid, playerid, GetPlayerSkinEx(playerid), lBullet_Spawns[eScenario[FileID]][p][0], lBullet_Spawns[eScenario[FileID]][p][1], lBullet_Spawns[eScenario[FileID]][p][2], random(360), 0, 0, 0, 0, 0, 0);
					SpawnPlayer (playerid);
				}
				else
				{
				    // Il player ha perso, non ha piï¿½ vite.
				    Player_outSecs[playerid] = 10;
		            Player[playerid][InGame] = 0;

					TextDrawHideForPlayer(playerid, RoundStats[0]);
					TextDrawHideForPlayer(playerid, RoundStats[1]);
					TextDrawHideForPlayer(playerid, RoundStats[2]);
					TextDrawHideForPlayer(playerid, RoundStats[3]);

				//    DisablePlayerCheckpoint(playerid);

					SetPlayerVirtualWorld(playerid, NORMAL_WORLD);

					if( GamePaused )
					{
						TogglePlayerControllable(playerid, true);
					 	TextDrawHideForPlayer(playerid, RoundPaused );
					}

				   	GangZoneHideForPlayer(playerid, ZonaAttornoCP);

					if (AntiHits)
					{
					    TextDrawHideForPlayer(playerid, TD_NotHits);
					    TextDrawHideForPlayer(playerid, TD_NoHitsScritta);
					}

					if(!GamePaused)
					{
						SetTimer("CheckPlayers", DELAY_CHECKPLAYERS, 0);
					}

					TextDrawShowForPlayer(playerid, TeamPlayers_TD);

					SetSpawnInfo(playerid, playerid, GetPlayerSkinEx(playerid), Lobby[0] - MAX_RANDOM_SPAWN + random( MAX_RANDOM_SPAWN ), Lobby[1] - MAX_RANDOM_SPAWN + random( MAX_RANDOM_SPAWN ), Lobby[2], Lobby[3], 0, 0, 0, 0, 0, 0);
                    SpawnPlayer(playerid);
				}
		    }
		    else if (Gaming == GAMETYPE_TDM)
		    {
			 	if(TeamRole[pT] == ATTACKERS)
	 			{
					SetSpawnInfo(playerid, pT, GetPlayerSkinEx(playerid), eScenario[SpawnAttackers][0] - RANDOM_SPAWN_ROUND + random(RANDOM_SPAWN_ROUND), eScenario[SpawnAttackers][1] - RANDOM_SPAWN_ROUND + random(RANDOM_SPAWN_ROUND), eScenario[SpawnAttackers][2], 0.0, 0, 0, 0, 0, 0, 0);
				}
				else
				{
					SetSpawnInfo(playerid, pT, GetPlayerSkinEx(playerid), eScenario[SpawnDefenders][0] - RANDOM_SPAWN_ROUND + random(RANDOM_SPAWN_ROUND), eScenario[SpawnDefenders][1] - RANDOM_SPAWN_ROUND + random(RANDOM_SPAWN_ROUND), eScenario[SpawnDefenders][2], 0.0, 0, 0, 0, 0, 0, 0);
				}
			}
			else if (Gaming == GAMETYPE_GUNGAME)
			{
			    new rand = random( MAX_MULTIPLE_SPAWNS );
			    SetSpawnInfo(playerid, playerid, GetPlayerSkinEx(playerid), Scenario_MultipleSpawns[rand][0], Scenario_MultipleSpawns[rand][1], Scenario_MultipleSpawns[rand][2], Scenario_MultipleSpawns[rand][3], 0, 0, 0, 0, 0, 0);
			}
		}*/

		Player[playerid][RDeaths] += 1;

		foreach(new i:Player)
		{
		    if (InSpec[i] == playerid)
		        Spec_SwitchSpec(i, 1);
		}

		SyncTextdraw(1);
//		RefreshTeamPlayers_TD();
	}
	else
	{
	    if(Player[playerid][InDm] != -1)
		{
		    if (!RoundStarted)
		    {
		    	SendDeathMessage(killerid, playerid, reason);
			}

			if (kconnect)
			{
				if (Player[killerid][InDm] != -1)
				{
					new Float:ehp, hp;

					GetPlayerHealth(killerid, ehp);
					hp = floatround(ehp);

					GetPlayerArmour(killerid, ehp);
					hp += floatround(ehp);

					SetPlayerHealth(killerid, 100.0);
			        SetPlayerArmour(killerid, 100.0);

					format (stringo, sizeof stringo, "* Deathmatch #%d * %s has Slaughtered %s with %d HP" , Player[killerid][InDm] + 1 , Player[ killerid ][ Nickname ] , Player[ playerid ][ Nickname ], hp);

			        foreach(new i:Player)
			        {
			            if (Player[i][InDm] == Player[playerid][InDm])
			            {
			                SendClientMessage( i , 0xA70C0CAA , stringo);
			            }
			        }

			        Player[killerid][DKills] ++;
				}
	        }
			SetSpawnInfo(playerid, playerid, GetPlayerSkinEx(playerid), Deathmatchs[Player[playerid][InDm]][Spawn][0] - MAX_RANDOM_SPAWN + random( MAX_RANDOM_SPAWN ), Deathmatchs[Player[playerid][InDm]][Spawn][1] - MAX_RANDOM_SPAWN + random( MAX_RANDOM_SPAWN ), Deathmatchs[Player[playerid][InDm]][Spawn][2], Deathmatchs[Player[playerid][InDm]][Spawn][3], Deathmatchs[Player[playerid][InDm]][Weapon1], 9999, Deathmatchs[Player[playerid][InDm]][Weapon2], 9999, Deathmatchs[Player[playerid][InDm]][Weapon3], 9999);
		}
		else
		{
			SetSpawnInfo(playerid, playerid, GetPlayerSkinEx(playerid), Lobby[0] - MAX_RANDOM_SPAWN + random( MAX_RANDOM_SPAWN ), Lobby[1] - MAX_RANDOM_SPAWN + random( MAX_RANDOM_SPAWN ), Lobby[2], Lobby[3], 0, 0, 0, 0, 0, 0);
		}
	}
	return true;
}

//oridfshfui HideMessageKill(playerid);
timer HideMessageKill[3000](playerid)
{
	PlayerTextDrawHide( playerid , PlayerKillTD );
//	PlayerTextDrawHide( playerid , PlayerKillTD[ 1 ] );
}

stock SendTeamMessage(playerid, text[], skip = 1)
{
	new
	    pt = Player[playerid][Team];

    new
		converted =
		    ( pt == TEAM_A_SUB ? TEAM_A :
		        ( pt == TEAM_B_SUB ? TEAM_B :
					( pt == TEAM_A ? TEAM_A_SUB :
					    ( pt == TEAM_B ? TEAM_B_SUB
					        : -1)
					)
				)
			);

	format (stringo, sizeof stringo, "(Team) %s:{FFFFFF} (%d) %s", Player[playerid][Nickname], playerid, text[skip]);

	foreach(new i:Player)
	{
	    if (Player[i][Team] == pt || Player[i][Team] == converted)
	    {
	        SendClientMessage (i, iTeam[pt][InGameColor], stringo);
            PlayerPlaySound(i, 45400, 0.0, 0.0, 0.0);
	    }
	}

	return 0;
}

public OnPlayerText(playerid, text[])
{
	if (FinalCW) return 0;

//	new pt = Player[playerid][Team];

	if(text[0] == '!' && Player[playerid][Team] != NULL_TEAM)
	{
	    /*
	    foreach(new i:Player)
	    {
			if (Player[i][Team] == pt || Player[i][Team] == converted)
				SendClientMessage(i, iTeam[pt][InGameColor], "(Team) %s:{FFFFFF} (%d) %s", Player[playerid][Nickname], playerid, text[1]);
                PlayerPlaySound(i, 45400, 0.0, 0.0, 0.0);
	        }
	    }*/

	    // Converte il team del player nel suo corrispondente sub
	    // Oppure, se il player ï¿½ in un team sub lo converte nel suo corrispondente team principale
	    // Serve per attivare la chat sia da sub a team e vice versa
	    /*
	    new
			converted =
			    ( pt == TEAM_A_SUB ? TEAM_A :
			        ( pt == TEAM_B_SUB ? TEAM_B :
						( pt == TEAM_A ? TEAM_A_SUB :
						    ( pt == TEAM_B ? TEAM_B_SUB
						        : -1)
						)
					)
				);

    	format (stringo, sizeof stringo, "(Team) %s:{FFFFFF} (%d) %s", Player[playerid][Nickname], playerid, text[1]);

		foreach(new i:Player)
		{
		    if (Player[i][Team] == pt || Player[i][Team] == converted)
		    {
		        SendClientMessage (i, iTeam[pt][InGameColor], stringo);
                PlayerPlaySound(i, 45400, 0.0, 0.0, 0.0);
		    }
		}
	    */
	    SendTeamMessage(playerid, text);
	    return 0;
	}

	if(text[0] == '@' && Player[playerid][aLevel] >= _:lMod)
	{
	    format (stringo, sizeof stringo, "(Admin) %s: %s", Player[playerid][Nickname], text[1]);

	    foreach(new i:Player)
		{
			if(Player[i][aLevel] >= _:lAdmin)
			{
				SendClientMessage(i, COLOR_GREY, stringo);
                PlayerPlaySound(i, 1085, 0.0, 0.0, 0.0);
			}
	    }
	    return 0;
	}

	if(!gConfig[GlobalChat])
	{
/*
    	format (stringo, sizeof stringo, "(Team) %s:{FFFFFF} (%d) %s", Player[playerid][Nickname], playerid, text);

	    foreach(new i:Player)
		{
			if(Player[i][Team] == pt || Player[i][Team] == GetHisSubTeam(playerid))
			{
				SendClientMessage(i, iTeam[pt][InGameColor], stringo);
                PlayerPlaySound(i, 45400, 0.0, 0.0, 0.0);
			}
	    }
*/
	    SendTeamMessage(playerid, text, 0);
//	    SendClientMessage(playerid, red, "Global Chat disabled.");
		return 0;
	}

	if(Player[playerid][IsAfk])
	{
	    SendClientMessage(playerid, red, "You are AFK.");
	    return 0;
	}

	if(Player[playerid][Muted])
	{
/*    	format (stringo, sizeof stringo, "(Team) %s:{FFFFFF} (%d) %s", Player[playerid][Nickname], playerid, text);

	    foreach(new i:Player)
		{
			if(Player[i][Team] == pt || Player[i][Team] == GetHisSubTeam(playerid))
			{
				SendClientMessage(i, iTeam[pt][InGameColor], stringo);
                PlayerPlaySound(i, 45400, 0.0, 0.0, 0.0);
			}
	    }
*/
	    SendTeamMessage(playerid, text, 0);
	    return 0;
	}

	if(strcmp(Player[playerid][LastWritten], text, true) == 0)
	{
	    SendClientMessage(playerid, COLOR_SYSTEM, "** Don't {"#COLOR_SYSTEM_FOCUS"}repeat yourself");
	    return 0;
	}

	strcpy_2(Player[playerid][LastWritten], text);
	SetPlayerChatBubble(playerid, text, COLOR_WHITE, 9.0, 4000);
	SendPlayerMessageToAll(playerid, sprintf( "(%d) %s" , playerid , text ));

//	#if CONN_REMOTE == true
//	HTTP(playerid, HTTP_POST, #REMOTE_BASE_URL"/savelog.php", sprintf( "n=%s&t=%s&sp=nm5b6f56Wm" , Player[ playerid ][ Nickname ] , text ) , "");
//	#endif
	return 0;
}

stock strcpy_2(dest[], source[])
{
    new i = -1;

    do
        dest[++i] = source[i];
    while ( dest[ i ] );
}

//new timeexec;

public OnPlayerCommandReceived(playerid, cmdtext[])
{
	if(!Player[playerid][Spawned])return SendClientMessage(playerid, red, "You must be spawned to use any command."), PlayerPlaySound(playerid, SOUND_WRONGCOMMAND, 0.0, 0.0, 0.0), 0;
//	if(CamMove) return SendClientMessage(playerid, COLOR_RED, "You cannot use any command while a base is being loaded."), PlayerPlaySound(playerid, SOUND_WRONGCOMMAND, 0.0, 0.0, 0.0), 0;
	/*if(CamMove)
	{
		if (cmdtext[1] == 'p' && cmdtext[2] == 'm')
		{
		    return true;
		}
		else
		{
	    	SendClientMessage(playerid, COLOR_RED, "You cannot use any command while a base is being loaded.");
	    	PlayerPlaySound(playerid, SOUND_WRONGCOMMAND, 0.0, 0.0, 0.0);
		}
		return 0;
	}*/
	if(CamMove) return 0;
	if(FinalCW) return 0;
	if(strcmp(cmdtext, "/afk", true)&&Player[playerid][IsAfk])return SendClientMessage(playerid, COLOR_RED, "Use /afk to leave the AFK mode"), PlayerPlaySound(playerid, SOUND_WRONGCOMMAND, 0.0, 0.0, 0.0), 0;
//    timeexec = Getgettime();
	return true;
}

public OnPlayerCommandPerformed(playerid, cmdtext[], success)
{
	if(!success)
	{
    	format (stringo, sizeof stringo, "The command \"{"#COLOR_SYSTEM_FOCUS"}%s{"#COLOR_SYSTEM_REST"}\" does not exist!", cmdtext);
        SendClientMessage(playerid, COLOR_SYSTEM, stringo);
 		PlayerPlaySound(playerid, SOUND_WRONGCOMMAND, 0.0, 0.0, 0.0);
		return true;
	}
//	SendClientMessage(playerid, -1, "-> time ms: %d", Getgettime()-timeexec);
	return true;
}
/*
COMMAND:tdtest(playerid, params[])
{
	for (new i = 0; i < 11; i++)
	{
	    TextDrawShowForPlayer(playerid, TDSpawnInfo[i]);
	}


//	TextDrawShowForPlayer(playerid, TDSpawnInfo[tdBackground]);

	return true;
}
*/
/*
#define DANNO_DA_DARE 50
COMMAND:gfreaks(playerid, params[])
{
    inline Response(pid, dialogid, response, listitem, string:inputtext[])
    {
        #pragma unused pid, dialogid, response, listitem, inputtext
        if (!response) return 0;
        switch (listitem)
        {
            case 0:
            {
                // verde 1
				OnPlayerTakeDamage(5, playerid, DANNO_DA_DARE, 24);
            }
            case 1:
            {
                // verde 2
				OnPlayerTakeDamage(6, playerid, DANNO_DA_DARE, 24);
            }
            case 2:
            {
                // verde 3
				OnPlayerTakeDamage(7, playerid, DANNO_DA_DARE, 24);
            }
            case 3:
            {
                // verde 4
				OnPlayerTakeDamage(8, playerid, DANNO_DA_DARE, 24);
            }
            case 4:
            {
                // verde 5
				OnPlayerTakeDamage(9, playerid, DANNO_DA_DARE, 24);
            }
            case 5:
            {
                // verde 6
				OnPlayerTakeDamage(10, playerid, DANNO_DA_DARE, 24);
            }
            case 6:
            {
                // verde 7
				OnPlayerTakeDamage(11, playerid, DANNO_DA_DARE, 24);
            }

			//
            case 7:
            {
                // verde 1
				OnPlayerTakeDamage(playerid, 5, DANNO_DA_DARE, 24);
            }
            case 8:
            {
                // verde 2
				OnPlayerTakeDamage(playerid, 6, DANNO_DA_DARE, 24);
            }
            case 9:
            {
                // verde 3
				OnPlayerTakeDamage(playerid, 7, DANNO_DA_DARE, 24);
            }
            case 10:
            {
                // verde 4
				OnPlayerTakeDamage(playerid, 8, DANNO_DA_DARE, 24);
            }
            case 11:
            {
                // verde 5
				OnPlayerTakeDamage(playerid, 9, DANNO_DA_DARE, 24);
            }
            case 12:
            {
                // verde 4
				OnPlayerTakeDamage(playerid, 10, DANNO_DA_DARE, 24);
            }
            case 13:
            {
                // verde 5
				OnPlayerTakeDamage(playerid, 11, DANNO_DA_DARE, 24);
            }

            case 14:
            {
                OnPlayerTakeDamage(playerid, INVALID_PLAYER_ID, DANNO_DA_DARE, 24);
            }

            case 15: {
            	PlayerTextDrawShow(playerid, TD_Player_Damages[0][0]);
				PlayerTextDrawShow(playerid, TD_Player_Damages[0][1]);
				PlayerTextDrawShow(playerid, TD_Player_Damages[0][2]);
				PlayerTextDrawShow(playerid, TD_Player_Damages[0][3]);
				PlayerTextDrawShow(playerid, TD_Player_Damages[0][4]);

            	PlayerTextDrawShow(playerid, TD_Player_Damages[1][0]);
				PlayerTextDrawShow(playerid, TD_Player_Damages[1][1]);
				PlayerTextDrawShow(playerid, TD_Player_Damages[1][2]);
				PlayerTextDrawShow(playerid, TD_Player_Damages[1][3]);
				PlayerTextDrawShow(playerid, TD_Player_Damages[1][4]);
			}
            case 16: {
                cmd_alteran(playerid, "ID5");
                cmd_alteran6(playerid, "ID6");
                cmd_alteran7(playerid, "ID7");
                cmd_alteran8(playerid, "ID8");
                cmd_alteran9(playerid, "ID9");
                cmd_alteran10(playerid, "ID10");
                cmd_alteran11(playerid, "ID11");
            }
        }

        Dialog_ShowCallback(playerid, using inline Response, DIALOG_STYLE_LIST, "Guitar!", "Hit verde1\nHit verde2\nHit verde3\nHit verde4\nHit verde5\nHit verde6\nHit verde7\nHit rosso1\nHit rosso2\nHit rosso3\nHit rosso4\nHit rosso5\nHit rosso6\nHit rosso7\nHit collision\nMostra tds\nA. Names", "Go", "Close");
    }

    Dialog_ShowCallback(playerid, using inline Response, DIALOG_STYLE_LIST, "Guitar!", "Hit verde1\nHit verde2\nHit verde3\nHit verde4\nHit verde5\nHit verde6\nHit verde7\nHit rosso1\nHit rosso2\nHit rosso3\nHit rosso4\nHit rosso5\nHit rosso6\nHit rosso7\nHit collision\nMostra tds\nA. Names", "Go", "Close");
	return 1;
}

COMMAND:alteran(playerid, params[]) {
	strdel(Player[5][Nickname], 0, 24);
	strcat(Player[5][Nickname],params,24);
	Player[5][Nickname_WOTag]=RemoveClan(Player[5][Nickname]);

	SendClientMessage(playerid, -1, params);
	SendClientMessage(playerid, -1, Player[5][Nickname]);
    SendClientMessage(playerid, -1, Player[5][Nickname_WOTag]);
	return 1;
}

COMMAND:alteran6(playerid, params[]) {
	strdel(Player[6][Nickname], 0, 24);
	strcat(Player[6][Nickname],params,24);
	Player[6][Nickname_WOTag]=RemoveClan(Player[6][Nickname]);

	SendClientMessage(playerid, -1, params);
	SendClientMessage(playerid, -1, Player[6][Nickname]);
    SendClientMessage(playerid, -1, Player[6][Nickname_WOTag]);
	return 1;
}

COMMAND:alteran7(playerid, params[]) {
	strdel(Player[7][Nickname], 0, 24);
	strcat(Player[7][Nickname],params,24);
	Player[7][Nickname_WOTag]=RemoveClan(Player[7][Nickname]);

	SendClientMessage(playerid, -1, params);
	SendClientMessage(playerid, -1, Player[7][Nickname]);
    SendClientMessage(playerid, -1, Player[7][Nickname_WOTag]);
	return 1;
}

COMMAND:alteran8(playerid, params[]) {
	strdel(Player[8][Nickname], 0, 24);
	strcat(Player[8][Nickname],params,24);
	Player[8][Nickname_WOTag]=RemoveClan(Player[8][Nickname]);

	SendClientMessage(playerid, -1, params);
	SendClientMessage(playerid, -1, Player[8][Nickname]);
    SendClientMessage(playerid, -1, Player[8][Nickname_WOTag]);
	return 1;
}

COMMAND:alteran9(playerid, params[]) {
	strdel(Player[9][Nickname], 0, 24);
	strcat(Player[9][Nickname],params,24);
	Player[9][Nickname_WOTag]=RemoveClan(Player[9][Nickname]);

	SendClientMessage(playerid, -1, params);
	SendClientMessage(playerid, -1, Player[9][Nickname]);
    SendClientMessage(playerid, -1, Player[9][Nickname_WOTag]);
	return 1;
}

COMMAND:alteran10(playerid, params[]) {
	strdel(Player[10][Nickname], 0, 24);
	strcat(Player[10][Nickname],params,24);
	Player[10][Nickname_WOTag]=RemoveClan(Player[10][Nickname]);

	SendClientMessage(playerid, -1, params);
	SendClientMessage(playerid, -1, Player[10][Nickname]);
    SendClientMessage(playerid, -1, Player[10][Nickname_WOTag]);
	return 1;
}

COMMAND:alteran11(playerid, params[]) {
	strdel(Player[11][Nickname], 0, 24);
	strcat(Player[11][Nickname],params,24);
	Player[11][Nickname_WOTag]=RemoveClan(Player[11][Nickname]);

	SendClientMessage(playerid, -1, params);
	SendClientMessage(playerid, -1, Player[11][Nickname]);
    SendClientMessage(playerid, -1, Player[11][Nickname_WOTag]);
	return 1;
}

COMMAND:altera(playerid, params[])
{
	OnPlayerTakeDamage(playerid, 0, DANNO_DA_DARE, 24);
	return 1;
}

COMMAND:altera2(playerid, params[])
{
	OnPlayerTakeDamage(0, playerid, DANNO_DA_DARE, 24);
	return 1;
}

COMMAND:altera3(playerid, params[])
{
	OnPlayerTakeDamage(playerid, INVALID_PLAYER_ID, DANNO_DA_DARE, 24);
	return 1;
}

COMMAND:altera4(playerid, params[])
{
	OnPlayerTakeDamage(playerid, 5, DANNO_DA_DARE, 24);
	return 1;
}

COMMAND:altera5(playerid, params[])
{
	OnPlayerTakeDamage(5, playerid, DANNO_DA_DARE, 24);
	return 1;
}

COMMAND:altera6(playerid, params[])
{
	OnPlayerTakeDamage(6, playerid, DANNO_DA_DARE, 24);
	return 1;
}

COMMAND:altera7(playerid, params[])
{
	OnPlayerTakeDamage(7, playerid, DANNO_DA_DARE, 24);
	return 1;
}

COMMAND:altera8(playerid, params[])
{
	OnPlayerTakeDamage(8, playerid, DANNO_DA_DARE, 24);
	return 1;
}
*/
COMMAND:hexint(playerid, params[])
{
//	SendClientMessage(playerid, -1, "HexToInt(%s) = %d", params, HexToInt(params));
	return true;
}

COMMAND:fps(playerid, params[])
{
	new id;
	if(sscanf(params, "i", id)) return SendClientMessage(playerid, COLOR_GREY, "Use /fps [id]");
	if(!IsPlayerConnected(id))return SendClientMessage(playerid, COLOR_GREY, "Invalid player.");
	format(stringo, sizeof stringo, "{"#COLOR_SYSTEM_FOCUS"}%s{"#COLOR_SYSTEM_REST"}'s FPS: {"#COLOR_SYSTEM_FOCUS"}%d{"#COLOR_SYSTEM_REST"} | Requested by {"#COLOR_SYSTEM_FOCUS"}%s", Player[id][Nickname], pFPS[id], Player[playerid][Nickname]);
	SendClientMessageToAll(COLOR_SYSTEM, stringo);
	return true;
}

COMMAND:packetloss(playerid, params[])
{
	new id;
	if(sscanf(params, "i", id))return SendClientMessage(playerid, COLOR_GREY, "Use /packetloss [id]");
	if(!IsPlayerConnected(id))return SendClientMessage(playerid, COLOR_GREY, "Invalid player.");
	format (stringo, sizeof stringo, "{"#COLOR_SYSTEM_FOCUS"}%s{"#COLOR_SYSTEM_REST"}'s Packetloss: {"#COLOR_SYSTEM_FOCUS"}%.1f{"#COLOR_SYSTEM_REST"} | Requested by {"#COLOR_SYSTEM_FOCUS"}%s", Player[id][Nickname], GetPlayerPacketloss(id), Player[playerid][Nickname]);
    SendClientMessageToAll(COLOR_SYSTEM, stringo);
	return true;
}

COMMAND:pl(playerid, params[])
{
	return cmd_packetloss(playerid, params);
}

COMMAND:currentpack(playerid, params[])
{
	format (stringo, sizeof stringo, "Current gamepack: {"#COLOR_SYSTEM_FOCUS"}%s{"#COLOR_SYSTEM_REST"} | Requested by {"#COLOR_SYSTEM_FOCUS"}%s", basesPacks[CurrentGamepack][packName], Player[playerid][Nickname]);
    SendClientMessageToAll(COLOR_SYSTEM, stringo);
	return true;
}

COMMAND:roles(playerid, params[])
{
	format (stringo, sizeof stringo, "%s: {"#SC_TEAMA"}%s{FFFFFF} | %s: {"#SC_TEAMB"}%s", GetRoleName(TeamRole[TEAM_A]), iTeam[TEAM_A][Name], GetRoleName(TeamRole[TEAM_B]), iTeam[TEAM_B][Name]);
    SendClientMessage(playerid, -1, stringo);
	return true;
}

COMMAND:pinfo(playerid, params[])
{
	new
 		szString [ 1024 ],
	    color_emb_ping[8]   = "73FF00",
	    color_emb_fps[8]    = "73FF00",
		color_emb_packet[8] = "73FF00";

	strcat(szString, sprintf( "Ping\tFPS\tPacketloss\tName\t\t\t(%d) Players\n", Iter_Count(Player)));
	foreach(new i:Player)
	{
	    if( GetPlayerPing(i) > 120 ) 		color_emb_ping = "FF0000";
	    if( pFPS[i] <= 30 ) 				color_emb_fps = "FF0000";
		if( GetPlayerPacketloss(i) > 5.0 ) 	color_emb_packet = "FF0000";

  		format(szString, sizeof szString, "%s{%s}%d{5CA0E4}\t{%s}%d{5CA0E4}\t{%s}%.1f%%{5CA0E4}\t\t%s\n", szString, color_emb_ping, GetPlayerPing(i), color_emb_fps, pFPS[i], color_emb_packet, GetPlayerPacketloss(i), Player[i][Nickname]);

        color_emb_packet 	= "73FF00";
        color_emb_fps 		= "73FF00";
        color_emb_packet	= "73FF00";
	}

	ShowPlayerDialog(playerid, DIALOG_PINFO, DIALOG_STYLE_MSGBOX, "Players info:", szString, "Refresh", "Close");
	return true;
}

COMMAND:damage(playerid, params[])
{
	new szString [ (MAX_PLAYER_NAME * 20) + 4 ];
	szString = "Damage\tKills\tR. Damage\tR. Kills\t\tName\n";

	foreach(new i:Player)
	{
	    format(szString, sizeof szString, "%s%d\t\t%d\t%d\t\t%d\t\t%s\n", szString, Player[i][Damage], Player[i][Kills], Player[i][RDamage], Player[i][RKills], Player[i][Nickname]);
	}

	ShowPlayerDialog(playerid, DIALOG_NULL, DIALOG_STYLE_LIST, "Players info:" , szString, "Close", "");
	return true;
}

COMMAND:password(playerid, params[])
{
	if( strlen( Srv_Password ) > 0 )
	{
	    format (stringo, sizeof stringo, "Server password: {"#COLOR_SYSTEM_FOCUS"}%s{"#COLOR_SYSTEM_REST"} | Requested by {"#COLOR_SYSTEM_FOCUS"}%s", Srv_Password, Player[playerid][Nickname]);
        SendClientMessageToAll( COLOR_SYSTEM , stringo);
	}
	else
	{
	    SendClientMessage(playerid , red, "There is no password.");
	}
	return true;
}

COMMAND:pass(playerid, params[])
{
	return cmd_password(playerid, params);
}

COMMAND:admins(playerid, params[])
{
	new  p = 0;

	foreach(new i:Player)
	{
	    if (Player[i][aLevel] > _:lUser && Player[i][aLevel] <= _:lRoot || IsPlayerAdmin(i))
	    {
	        p ++;
	    }
	}

	if (p > 0)
	{
	// da rivedere
		SendClientMessage(playerid, COLOR_SYSTEM, sprintf ("There are {"#COLOR_SYSTEM_FOCUS"}%d{"#COLOR_SYSTEM_REST"} admins online.", p));
	}
	else
	{
	    SendClientMessage(playerid, COLOR_SYSTEM, "No Admins online!");
	}
	return true;
}

COMMAND:whois(playerid, params[])
{//lNbAdmin
	if(!IsPlayerAdminEx(playerid, lNbAdmin)) return true;
	if(isnull(params)) return SendClientMessage(playerid, red, "Use /whois [ID]"), PlayerPlaySound(playerid, SOUND_WRONGCOMMAND, 0.0, 0.0, 0.0);
	new id = strval( params );
//	if(!IsPlayerConnected(id)) return SendClientMessage(playerid, red, "Invalid player."), PlayerPlaySound(playerid, SOUND_WRONGCOMMAND, 0.0, 0.0, 0.0);
	/*
	new
	    szCity	 [ 40 ],
	    szCountry[ 40 ],
	    szIp     [ 16 ],
	    szISP    [ 60 ];

	GetPlayerCountry( id , szCountry , 40 );
	GetPlayerCity   ( id , szCity    , 40 );
	GetPlayerIp     ( id , szIp      , 16 );
	GetPlayerISP    ( id , szISP     , 60 );


			 WhoIs_Ip[16],
			 WhoIs_Country [158],
			 WhoIs_IPS[60],
			 WhoIs_City[40],
	*/

	format (stringo, sizeof stringo, "%s: Country: %s | City: %s | ISP: %s | IP: %s" , Player[ id ][ Nickname ] , Player[id][WhoIs_Country] , Player[id][WhoIs_City] , Player[id][WhoIs_Isp] , Player[id][WhoIs_uIp] );
    SendClientMessage( playerid , green , stringo);

	format (stringo, sizeof stringo, "Serial: %s", Player[id][Serial]);
    SendClientMessage( playerid , green , stringo);

//	#if CONN_REMOTE == true
//	HTTP(playerid, HTTP_POST, #REMOTE_BASE_URL"/api/aka.php", sprintf("s=%s", Player[id][Serial]), "AkaList");
//	#else
//	SendClientMessage( playerid , red , "Area 51 cannot be found" );
//	#endif
	return true;
}

//forward AkaList(index, response_code, data[]);
//public AkaList(index, response_code, data[])
//{
//	if (response_code == 200)
//		SendClientMessage(index, green, "Other nicks: %s", data);
//	else SendClientMessage(index, red, "Non sono riuscito a connettermi al server per ottenere altri nicks.");
//}

COMMAND:radio(playerid, params[])
{
	if( Player[playerid][RadioStream] == true )
	{
	    Player[playerid][RadioStream] = false;
	    StopAudioStreamForPlayer(playerid);
        SendClientMessage(playerid, COLOR_SYSTEM, "The radio is now turned off, type /radio again to re-open it.");
	}
	else
	{
	    Player[playerid][RadioStream] = true;
	    PlayAudioStreamForPlayer(playerid, RADIO_URL);
	    SendClientMessage(playerid, COLOR_SYSTEM, "The radio is now turned on, type /radio again to turn it off.");
	}
	return true;
}

COMMAND:afk(playerid, params[])
{
	if(InSpec[playerid]!=-1) return SendClientMessage(playerid, red, "You cannot use this command now!"), PlayerPlaySound(playerid, SOUND_WRONGCOMMAND, 0.0, 0.0, 0.0);
	if(Player[playerid][InGame]) return SendClientMessage(playerid, red, "No. /afk #2"), PlayerPlaySound(playerid, SOUND_WRONGCOMMAND, 0.0, 0.0, 0.0);
	if(Player[playerid][IsAfk])
	{
		format (stringo, sizeof stringo, "%s came back from being AFK.", Player[playerid][Nickname]);

		Player[playerid][IsAfk]    = false;
		Player[playerid][AfkStart] = 0;

		SetPlayerPos(playerid, Player[playerid][Pos_Afk][0], Player[playerid][Pos_Afk][1], Player[playerid][Pos_Afk][2]);
		SetPlayerFacingAngle(playerid, Player[playerid][Pos_Afk][3]);
		SetPlayerInterior(playerid, Player[playerid][Afk_Interior]);
		SetPlayerVirtualWorld(playerid, Player[playerid][AfkVW]);
		TogglePlayerControllable(playerid, 1);

		PlayerTextDrawHide( playerid , Player_AfkTD[ 0 ] );
		PlayerTextDrawHide( playerid , Player_AfkTD[ 1 ] );
		PlayerTextDrawHide( playerid , Player_AfkTD[ 2 ] );
		PlayerTextDrawHide( playerid , Player_AfkTD[ 3 ] );

//		PlayerTextDrawDestroy( playerid , Player_AfkTD[ 0 ] );
//		PlayerTextDrawDestroy( playerid , Player_AfkTD[ 1 ] );
//		PlayerTextDrawDestroy( playerid , Player_AfkTD[ 2 ] );
//		PlayerTextDrawDestroy( playerid , Player_AfkTD[ 3 ] );

		stop PlayerAfk_RandomSprite[ playerid ] ;
		PlayerAfk_RandomSprite [ playerid ] = Timer:-1;

		if ( IsPlayerInAnyVehicle( playerid ) ) {
		    Player[playerid][AfkVeh]  = GetPlayerVehicleID( playerid );
		    Player[playerid][AfkSeat] = GetPlayerVehicleSeat( playerid );
		}

		if( IsValidVehicle( Player[playerid][AfkVeh] ) ) {
		    if( Player[playerid][AfkSeat] != 128 )
		    	PutPlayerInVehicle( playerid , Player[playerid][AfkVeh] , Player[playerid][AfkSeat] );
		}

		Player[playerid][AfkSeat] = 0;
		Player[playerid][AfkVeh]  = -1;

		iTeam[Player[ playerid ][ Team ]][ tPlayers ] ++;

		PlayerPlaySound(playerid, 1098, 0.0, 0.0, 0.0);

		SetPlayerColor( playerid , Player[ playerid ][ AfkColor ] );

		PlayerTextDrawShow(playerid, PlayerInfo[0]);
		PlayerTextDrawShow(playerid, PlayerInfo[1]);
		PlayerTextDrawShow(playerid, PlayerInfo[2]);
	}
	else
	{
		format (stringo, sizeof stringo, "%s is now AFK.", Player[playerid][Nickname]);

		Player[playerid][IsAfk]    = true;
		Player[playerid][AfkStart] = gettime();
		Player[playerid][AfkVW]    = GetPlayerVirtualWorld(playerid);

		GetPlayerPos(playerid, Player[playerid][Pos_Afk][0], Player[playerid][Pos_Afk][1], Player[playerid][Pos_Afk][2]);
		GetPlayerFacingAngle(playerid, Player[playerid][Pos_Afk][3]);
		Player[playerid][Afk_Interior] = GetPlayerInterior(playerid);

		SetPlayerInterior(playerid, 15);
		SetPlayerPos(playerid, -284.6162,1476.4805,1084.3750);
		SetPlayerFacingAngle(playerid, 50.5047);
		SetPlayerVirtualWorld(playerid, playerid + 1);
		TogglePlayerControllable(playerid, 0);

		PlayerTextDrawShow( playerid , Player_AfkTD[ 0 ] );
		PlayerTextDrawShow( playerid , Player_AfkTD[ 1 ] );
		PlayerTextDrawShow( playerid , Player_AfkTD[ 2 ] );
		PlayerTextDrawShow( playerid , Player_AfkTD[ 3 ] );

		//PlayerAfk_RandomSprite[playerid] = SetTimerEx("Sprite_RandomChange", 5000, 1, "i", playerid);
        PlayerAfk_RandomSprite[playerid] = defer Sprite_RandomChange(playerid);

		SendClientMessage( playerid , -1 , " ");
		SendClientMessage( playerid , -1 , " ");
		SendClientMessage( playerid , -1 , " ");
		SendClientMessage( playerid , -1 , " ");
		SendClientMessage( playerid , -1 , " ");
		SendClientMessage( playerid , -1 , " ");
		SendClientMessage( playerid , -1 , " ");
		SendClientMessage( playerid , -1 , " ");
		SendClientMessage( playerid , -1 , " ");
		SendClientMessage( playerid , -1 , " ");
		SendClientMessage( playerid , -1 , " ");
		SendClientMessage( playerid , -1 , " ");
		SendClientMessage( playerid , -1 , " ");
		SendClientMessage( playerid , -1 , " ");
		SendClientMessage( playerid , -1 , " ");

		if ( IsPlayerInAnyVehicle( playerid ) )
		{
		    Player[playerid][AfkVeh]  = GetPlayerVehicleID( playerid );
		    Player[playerid][AfkSeat] = GetPlayerVehicleSeat( playerid );
		}

		Player[ playerid ][ AfkColor ] = GetPlayerColor( playerid );
		iTeam[Player[ playerid ][ Team ]][ tPlayers ] --;

		PlayerTextDrawHide(playerid, PlayerInfo[0]);
		PlayerTextDrawHide(playerid, PlayerInfo[1]);
		PlayerTextDrawHide(playerid, PlayerInfo[2]);

		SetPlayerColor( playerid , 0xD696F9AA );
	}

	SendClientMessageToAll(COLOR_BROWN, stringo);
	RefreshTeamPlayers_TD();
	return true;
}

COMMAND:fafk(playerid, params[])
{
	if(!IsPlayerAdminEx(playerid, lNbAdmin)) return true;

	new id;
	if(sscanf(params, "i", id))
	{
	    SendClientMessage(playerid, red, "Use /fafk [id]");
	}
	else
	{
		if(InSpec[id]!=-1) return SendClientMessage(playerid, red, "He is in spec"), PlayerPlaySound(playerid, SOUND_WRONGCOMMAND, 0.0, 0.0, 0.0);
		if(Player[id][InGame]) return SendClientMessage(playerid, red, "He is in round"), PlayerPlaySound(playerid, SOUND_WRONGCOMMAND, 0.0, 0.0, 0.0);

		if(Player[id][IsAfk])
		{
			format (stringo, sizeof stringo, "%s came back from being AFK, forced by %s.", Player[id][Nickname], Player[playerid][Nickname]);

			Player[id][IsAfk]    = false;
			Player[id][AfkStart] = 0;

			SetPlayerPos(playerid, Player[id][Pos_Afk][0], Player[id][Pos_Afk][1], Player[id][Pos_Afk][2]);
			SetPlayerFacingAngle(id, Player[id][Pos_Afk][3]);
			SetPlayerInterior(id, Player[id][Afk_Interior]);
			SetPlayerVirtualWorld(id, Player[id][AfkVW]);
			TogglePlayerControllable(id, 1);

			PlayerTextDrawHide( id , Player_AfkTD[ 0 ] );
			PlayerTextDrawHide( id , Player_AfkTD[ 1 ] );
			PlayerTextDrawHide( id , Player_AfkTD[ 2 ] );
			PlayerTextDrawHide( id , Player_AfkTD[ 3 ] );

	//		PlayerTextDrawDestroy( playerid , Player_AfkTD[ 0 ] );
	//		PlayerTextDrawDestroy( playerid , Player_AfkTD[ 1 ] );
	//		PlayerTextDrawDestroy( playerid , Player_AfkTD[ 2 ] );
	//		PlayerTextDrawDestroy( playerid , Player_AfkTD[ 3 ] );

			stop PlayerAfk_RandomSprite[ id ];

			if ( IsPlayerInAnyVehicle( id ) ) {
			    Player[id][AfkVeh]  = GetPlayerVehicleID( id );
			    Player[id][AfkSeat] = GetPlayerVehicleSeat( id );
			}

			if( IsValidVehicle( Player[id][AfkVeh] ) ) {
			    if( Player[id][AfkSeat] != 128 )
			    	PutPlayerInVehicle( id , Player[id][AfkVeh] , Player[id][AfkSeat] );
			}

			Player[id][AfkSeat] = 0;
			Player[id][AfkVeh]  = -1;

			iTeam[Player[ id ][ Team ]][ tPlayers ] ++;

			PlayerPlaySound(playerid, 1098, 0.0, 0.0, 0.0);

			SetPlayerColor( id , Player[ id ][ AfkColor ] );

			PlayerTextDrawShow(id, PlayerInfo[0]);
			PlayerTextDrawShow(id, PlayerInfo[1]);
			PlayerTextDrawShow(id, PlayerInfo[2]);
		}
		else
		{
			format(stringo, sizeof stringo, "%s is now AFK, forced by %s.", Player[id][Nickname], Player[playerid][Nickname]);

			Player[id][IsAfk]    = true;
			Player[id][AfkStart] = gettime();
			Player[id][AfkVW]    = GetPlayerVirtualWorld(id);

			GetPlayerPos(id, Player[id][Pos_Afk][0], Player[id][Pos_Afk][1], Player[id][Pos_Afk][2]);
			GetPlayerFacingAngle(id, Player[id][Pos_Afk][3]);
			Player[id][Afk_Interior] = GetPlayerInterior(playerid);

			SetPlayerInterior(id, 15);
			SetPlayerPos(id, -284.6162,1476.4805,1084.3750);
			SetPlayerFacingAngle(id, 50.5047);
			SetPlayerVirtualWorld(id, id + 1);
			TogglePlayerControllable(id, 0);

			PlayerTextDrawShow( id , Player_AfkTD[ 0 ] );
			PlayerTextDrawShow( id , Player_AfkTD[ 1 ] );
			PlayerTextDrawShow( id , Player_AfkTD[ 2 ] );
			PlayerTextDrawShow( id , Player_AfkTD[ 3 ] );

            PlayerAfk_RandomSprite[id] = defer Sprite_RandomChange(id);
			//PlayerAfk_RandomSprite[id] = SetTimerEx("Sprite_RandomChange", 5000, 1, "i", id);

			SendClientMessage( id , -1 , " ");
			SendClientMessage( id , -1 , " ");
			SendClientMessage( id , -1 , " ");
			SendClientMessage( id , -1 , " ");
			SendClientMessage( id , -1 , " ");
			SendClientMessage( id , -1 , " ");
			SendClientMessage( id , -1 , " ");
			SendClientMessage( id , -1 , " ");
			SendClientMessage( id , -1 , " ");
			SendClientMessage( id , -1 , " ");
			SendClientMessage( id , -1 , " ");
			SendClientMessage( id , -1 , " ");
			SendClientMessage( id , -1 , " ");
			SendClientMessage( id , -1 , " ");
			SendClientMessage( id , -1 , " ");

			if ( IsPlayerInAnyVehicle( id ) )
			{
			    Player[id][AfkVeh]  = GetPlayerVehicleID( id );
			    Player[id][AfkSeat] = GetPlayerVehicleSeat( id );
			}

			Player[ id ][ AfkColor ] = GetPlayerColor( id );
			iTeam[Player[ id ][ Team ]][ tPlayers ] --;

			PlayerTextDrawHide(id, PlayerInfo[0]);
			PlayerTextDrawHide(id, PlayerInfo[1]);
			PlayerTextDrawHide(id, PlayerInfo[2]);

			SetPlayerColor( id , 0xD696F9AA );
		}
		RefreshTeamPlayers_TD();
	}

	SendClientMessageToAll(COLOR_BROWN, stringo);
	PlayerPlaySound(playerid, SOUND_SUCCESS, 0.0, 0.0, 0.0);
	return true;
}

//forward Sprite_RandomChange(playerid);
timer Sprite_RandomChange[5000](playerid)
{
	PlayerTextDrawSetString( playerid , Player_AfkTD[ 0 ] , randAfk_sprites[ random( sizeof randAfk_sprites - 1 ) ] );
}

COMMAND:register(playerid, params[])
{
	if (!Player[playerid][Loggen])
	{
	    ShowPlayerDialog( playerid , DIALOG_REGISTER , DIALOG_STYLE_PASSWORD , "Register", "Insert the password you want to use to login", "Register", "Close");
	}
	else
	{
	    SendClientMessage(playerid, COLOR_SYSTEM, "You are already registed/loggen!");
	}
	return true;
}

COMMAND:login(playerid, params[])
{
	if (!Player[playerid][AccountExist])
	{
	    SendClientMessage(playerid, red, "Use /register to create an account.");
	}
	else
	{
		if (!Player[playerid][Loggen])
		{
			ShowPlayerDialog(playerid, DIALOG_LOGIN, DIALOG_STYLE_PASSWORD, "Login", "Insert the password you used to register your account", "Login", "");
		}
		else
		{
		    SendClientMessage(playerid, COLOR_SYSTEM, "You are already registed/loggen!");
		}
	}
	return true;
}

COMMAND:changepsw(playerid, params[])
{
	if(Player[playerid][Loggen])return SendClientMessage(playerid, red, "You cannot use this command.");
	new psw[ 60 ];
	if(sscanf(params, "s[60]", psw))
	{
	    SendClientMessage(playerid, red, "Use /changepsw [nuovapassword]");
	    PlayerPlaySound(playerid, SOUND_WRONG, 0.0, 0.0, 0.0);
	}
	else
	{
	    new buf[ 129 ];
	    WP_Hash( buf , 129 , psw );

	    MySQLStatus[TotalQuerys] ++; mysql_tquery(g_MySQLConnection, sprintf ("UPDATE users SET password = '%s' WHERE nickname = '%s'", buf, Player[playerid][Nickname]), "", "");

		format (stringo, sizeof stringo, "Password changed to %s.", psw);
		SendClientMessage(playerid, COLOR_SYSTEM, stringo);
		PlayerPlaySound(playerid, SOUND_SUCCESS, 0.0, 0.0, 0.0);
	}
	return true;
}

COMMAND:int(playerid, params[])
{
	if(InSpec[playerid]!=-1) return SendClientMessage(playerid, red, "You cannot use this command now!"), PlayerPlaySound(playerid, SOUND_WRONGCOMMAND, 0.0, 0.0, 0.0);
	if(RoundStarted&&Player[playerid][InGame]) return SendClientMessage(playerid, red, "You cannot use this command now."), PlayerPlaySound(playerid, SOUND_WRONGCOMMAND, 0.0, 0.0, 0.0);
	if(Player[playerid][InDm] != -1) return SendClientMessage(playerid, red, "You must exit from DM to use this command."), PlayerPlaySound(playerid, SOUND_WRONGCOMMAND, 0.0, 0.0, 0.0);
	new id;
	if(sscanf(params, "i", id))
	{
	    SendClientMessage(playerid, red, "Use /int [ID]"), PlayerPlaySound(playerid, SOUND_WRONGCOMMAND, 0.0, 0.0, 0.0);
	}
	else
	{
		if(id < 0 || id > 149) return SendClientMessage(playerid, red, "Invalid interior id, max id is 149 and min id is 0."), PlayerPlaySound(playerid, SOUND_WRONGCOMMAND, 0.0, 0.0, 0.0);
		SetPlayerPos(playerid, Interiors[id][int_x], Interiors[id][int_y], Interiors[id][int_z]);
		SetPlayerFacingAngle(playerid, Interiors[id][int_a]);
		SetPlayerInterior(playerid, Interiors[id][int_interior]);
		format (stringo, sizeof stringo, "{"#COLOR_SYSTEM_FOCUS"}%s{"#COLOR_SYSTEM_REST"} teleported himself to {"#COLOR_SYSTEM_FOCUS"}%s{"#COLOR_SYSTEM_REST"} interior. ({"#COLOR_SYSTEM_FOCUS"}/int %d)", Player[playerid][Nickname], Interiors[id][int_name], id);
		PlayerPlaySound(playerid, SOUND_SUCCESS, 0.0, 0.0, 0.0);
		SendClientMessage(playerid, COLOR_SYSTEM, stringo);
	}
	return true;
}

COMMAND:t(playerid, params[])
{
	if (Player[playerid][InDm] != -1 || Player[playerid][InGame] || InSpec[playerid] != -1) return SendClientMessage(playerid, red, "You cannot use this command now."), PlayerPlaySound(playerid, SOUND_WRONGCOMMAND, 0.0, 0.0, 0.0);

	new szString[ 400 ];
	for (new i = 0; i < sizeof(TeleportPlaces); i++)
	{
	    strcat( szString , TeleportPlaces[i][tName] );
	    strcat( szString , "\r\n");
	}

	ShowPlayerDialog( playerid , DIALOG_TELEPORTS , DIALOG_STYLE_LIST , "Choose where you want to go" , szString , "Go" , "Close" );
	return true;
}

//LULLLLL
COMMAND:wrongconcepthellotest(playerid,params[])return SetTimerEx("concept_wrong",0,true,"s","");

COMMAND:time(playerid, params[])
{
	new time;
	if(sscanf(params, "i", time))return SendClientMessage(playerid, red, "Use /time [time]"), PlayerPlaySound(playerid, SOUND_WRONGCOMMAND, 0.0, 0.0, 0.0);
	if(time > 23 || time < 0) return SendClientMessage(playerid, red, "Invalid time."), PlayerPlaySound(playerid, SOUND_WRONGCOMMAND, 0.0, 0.0, 0.0);
	SetPlayerTime(playerid, time, 0);
	format (stringo, sizeof stringo, "Time changed to {10EC68}%d", time);
	SendClientMessage(playerid, 0x2DB463AA, stringo);
	PlayerPlaySound(playerid, SOUND_SUCCESS, 0.0, 0.0, 0.0);
	return true;
}

COMMAND:weather(playerid, params[])
{
	new w;
	if(sscanf(params, "i", w))return SendClientMessage(playerid, red, "Use /weather [id]"), PlayerPlaySound(playerid, SOUND_WRONGCOMMAND, 0.0, 0.0, 0.0);
	if(w < 0 || w > 45) return SendClientMessage(playerid, red, "Invalid Weather."), PlayerPlaySound(playerid, SOUND_WRONGCOMMAND, 0.0, 0.0, 0.0);
	SetPlayerWeather(playerid, w);
	format (stringo, sizeof stringo, "Weather changed to {10EC68}%d", w);
	SendClientMessage(playerid, 0x2DB463AA, stringo);
	PlayerPlaySound(playerid, SOUND_SUCCESS, 0.0, 0.0, 0.0);
	return true;
}

COMMAND:settime(playerid, params[])
{
	if(!IsPlayerAdminEx(playerid, lNbAdmin)) return true;
	new w;
	if(sscanf(params, "i", w))return SendClientMessage(playerid, red, "Use /settime [time]"), PlayerPlaySound(playerid, SOUND_WRONGCOMMAND, 0.0, 0.0, 0.0);
	if(w > 24 || w < 0) return SendClientMessage(playerid, red, "Invalid time."), PlayerPlaySound(playerid, SOUND_WRONGCOMMAND, 0.0, 0.0, 0.0);
	SetWorldTime(w);
	format (stringo, sizeof stringo, "Admin/Mod {"#COLOR_SYSTEM_FOCUS"}%s{"#COLOR_SYSTEM_REST"} set Time to %d" , Player[ playerid ][ Nickname ] , w );
    SendClientMessageToAll( COLOR_SYSTEM , stringo);
	PlayerPlaySound(playerid, SOUND_SUCCESS, 0.0, 0.0, 0.0);
	gConfig[GameTime] = w;

	MySQLStatus[TotalQuerys] ++; mysql_tquery(g_MySQLConnection, sprintf("UPDATE config SET time = '%d' WHERE gid = %d", w, G_ID), "", "");
	//SyncConfigFile();
	return true;
}

COMMAND:setweather(playerid, params[])
{
	if(!IsPlayerAdminEx(playerid, lNbAdmin)) return true;
	new w;
	if(sscanf(params, "i", w))return SendClientMessage(playerid, red, "Use /setweather [weather-id]"), PlayerPlaySound(playerid, SOUND_WRONGCOMMAND, 0.0, 0.0, 0.0);
	if(w > 45 || w < 0) return SendClientMessage(playerid, red, "Invalid weather."), PlayerPlaySound(playerid, SOUND_WRONGCOMMAND, 0.0, 0.0, 0.0);
	SetWeather(w);
	format (stringo, sizeof stringo, "Admin/Mod {"#COLOR_SYSTEM_FOCUS"}%s{"#COLOR_SYSTEM_REST"} set Weather ID to %d" , Player[ playerid ][ Nickname ] , w );
    SendClientMessageToAll( COLOR_SYSTEM , stringo);
	PlayerPlaySound(playerid, SOUND_SUCCESS, 0.0, 0.0, 0.0);
	gConfig[GameWeather] = w;
	MySQLStatus[TotalQuerys] ++; mysql_tquery(g_MySQLConnection, sprintf("UPDATE config SET weather = '%d' WHERE gid = %d", w, G_ID), "", "");
	//SyncConfigFile();
	return true;
}

COMMAND:youcannotusethishist(playerid, params[])
{
    Process_FineCW();
}

COMMAND:final(playerid, params[])
{
	if (!FinalReady) return SendClientMessage( playerid , red , "You cannot use this command now" );
	if (!FinalShow[ playerid ])
	{
		for(new x = 0; x < sizeof(FinalTCWScreen); x++)
		{
	 		TextDrawShowForPlayer( playerid , FinalTCWScreen[x] );
		}
	}
	else
	{
		for(new x = 0; x < sizeof(FinalTCWScreen); x++)
		{
	 		TextDrawHideForPlayer( playerid , FinalTCWScreen[x] );
		}
	}

	FinalShow[ playerid ] = !FinalShow[ playerid ];
	SendClientMessage(playerid, COLOR_SYSTEM, "Use /final again to show/hide final TD.");
	return true;
}

COMMAND:showagain(playerid, params[])
{
	if (PlayingRound == 0) return SendClientMessage( playerid , red , "You cannot use this command now" );

	if (Player[playerid][FinalRound_Status] == FINALROUND_STATUS_HIDDEN)
	{
		for (new i2 = 0; i2 < MAX_STATIC_TEXTDRAWS; i2++) TextDrawShowForPlayer(playerid, FineRound_Static[i2]);

		TextDrawShowForPlayer(playerid, FineRound_Dynamic[PlayingRound][BluePlayers]);
		TextDrawShowForPlayer(playerid, FineRound_Dynamic[PlayingRound][GreenPlayers]);
		TextDrawShowForPlayer(playerid, FineRound_Dynamic[PlayingRound][BlueKills]);
		TextDrawShowForPlayer(playerid, FineRound_Dynamic[PlayingRound][BlueDamages]);
		TextDrawShowForPlayer(playerid, FineRound_Dynamic[PlayingRound][GreenKills]);
		TextDrawShowForPlayer(playerid, FineRound_Dynamic[PlayingRound][GreenDamage]);
		TextDrawShowForPlayer(playerid, FineRound_Dynamic[PlayingRound][TotalKGreen]);
		TextDrawShowForPlayer(playerid, FineRound_Dynamic[PlayingRound][TotalDGreen]);
		TextDrawShowForPlayer(playerid, FineRound_Dynamic[PlayingRound][TotalKBlue]);
		TextDrawShowForPlayer(playerid, FineRound_Dynamic[PlayingRound][TotalDBlue]);
		TextDrawShowForPlayer(playerid, FineRound_Dynamic[PlayingRound][Top2_Nick]);
		TextDrawShowForPlayer(playerid, FineRound_Dynamic[PlayingRound][Top2_Stats]);
		TextDrawShowForPlayer(playerid, FineRound_Dynamic[PlayingRound][Top3_Stats]);
		TextDrawShowForPlayer(playerid, FineRound_Dynamic[PlayingRound][Top3_Nick]);
		TextDrawShowForPlayer(playerid, FineRound_Dynamic[PlayingRound][Top1_Stats]);
		TextDrawShowForPlayer(playerid, FineRound_Dynamic[PlayingRound][Top1_Nick]);
		TextDrawShowForPlayer(playerid, FineRound_Dynamic[PlayingRound][RoundsInfo]);
		TextDrawShowForPlayer(playerid, FineRound_Dynamic[PlayingRound][AttDefWin]);
        TextDrawShowForPlayer(playerid, FineRound_Dynamic[PlayingRound][Stringa_Winner2]);
        TextDrawShowForPlayer(playerid, FineRound_Dynamic[PlayingRound][Stringa_TeamWin]);
        TextDrawShowForPlayer(playerid, FineRound_Dynamic[PlayingRound][Stringa_Winner1]);
		TextDrawShowForPlayer(playerid, FineRound_Dynamic[PlayingRound][Stringa_RoundInfo]);
        TextDrawShowForPlayer(playerid, FineRound_Dynamic[PlayingRound][Stringa_TmpBest]);

        if (gConfig[Matchmode] == MATCHMODE_TCWCW)
        	SelectTextDraw (playerid, red);

        Player[playerid][FinalRound_Status] = FINALROUND_STATUS_SHOW;
        Player[playerid][CurrentView] = PlayingRound;
	}
	else if(Player[playerid][FinalRound_Status] == FINALROUND_STATUS_FORCED || Player[playerid][FinalRound_Status] == FINALROUND_STATUS_SHOW)
	{
		for (new i2 = 0; i2 < MAX_STATIC_TEXTDRAWS; i2++) TextDrawHideForPlayer(playerid, FineRound_Static[i2]);

		new cv = Player[playerid][CurrentView];

		TextDrawHideForPlayer(playerid, FineRound_Dynamic[cv][BluePlayers]);
		TextDrawHideForPlayer(playerid, FineRound_Dynamic[cv][GreenPlayers]);
		TextDrawHideForPlayer(playerid, FineRound_Dynamic[cv][BlueKills]);
		TextDrawHideForPlayer(playerid, FineRound_Dynamic[cv][BlueDamages]);
		TextDrawHideForPlayer(playerid, FineRound_Dynamic[cv][GreenKills]);
		TextDrawHideForPlayer(playerid, FineRound_Dynamic[cv][GreenDamage]);
		TextDrawHideForPlayer(playerid, FineRound_Dynamic[cv][TotalKGreen]);
		TextDrawHideForPlayer(playerid, FineRound_Dynamic[cv][TotalDGreen]);
		TextDrawHideForPlayer(playerid, FineRound_Dynamic[cv][TotalKBlue]);
		TextDrawHideForPlayer(playerid, FineRound_Dynamic[cv][TotalDBlue]);
		TextDrawHideForPlayer(playerid, FineRound_Dynamic[cv][Top2_Nick]);
		TextDrawHideForPlayer(playerid, FineRound_Dynamic[cv][Top2_Stats]);
		TextDrawHideForPlayer(playerid, FineRound_Dynamic[cv][Top3_Stats]);
		TextDrawHideForPlayer(playerid, FineRound_Dynamic[cv][Top3_Nick]);
		TextDrawHideForPlayer(playerid, FineRound_Dynamic[cv][Top1_Stats]);
		TextDrawHideForPlayer(playerid, FineRound_Dynamic[cv][Top1_Nick]);
		TextDrawHideForPlayer(playerid, FineRound_Dynamic[cv][RoundsInfo]);
		TextDrawHideForPlayer(playerid, FineRound_Dynamic[cv][AttDefWin]);
        TextDrawHideForPlayer(playerid, FineRound_Dynamic[cv][Stringa_Winner2]);
        TextDrawHideForPlayer(playerid, FineRound_Dynamic[cv][Stringa_TeamWin]);
        TextDrawHideForPlayer(playerid, FineRound_Dynamic[cv][Stringa_Winner1]);
		TextDrawHideForPlayer(playerid, FineRound_Dynamic[cv][Stringa_RoundInfo]);
        TextDrawHideForPlayer(playerid, FineRound_Dynamic[cv][Stringa_TmpBest]);

        if (gConfig[Matchmode] == MATCHMODE_TCWCW)
        	CancelSelectTextDraw (playerid);

	    Player[playerid][FinalRound_Status] = FINALROUND_STATUS_HIDDEN;
	}

	SendClientMessage(playerid, COLOR_SYSTEM, "Use showagain again to show/hide final round TD.");
	return true;
}

COMMAND:skin(playerid, params[])
{
	#pragma unused params
	if(InSpec[playerid]!=-1) return SendClientMessage(playerid, red, "You cannot use this command now!"), PlayerPlaySound(playerid, SOUND_WRONGCOMMAND, 0.0, 0.0, 0.0);
	if(Player[playerid][InGame]) return SendClientMessage(playerid, red, "You cannot use this command now!"), PlayerPlaySound(playerid, SOUND_WRONGCOMMAND, 0.0, 0.0, 0.0);
	ShowPlayerDialog(playerid, DIALOG_SKINMAIN, DIALOG_STYLE_LIST, "Skin manage", "Change your skin\nStick objects to your skin", "Open", "Close");
	return true;
}

COMMAND:vehicle(playerid, params[])
{
	#pragma unused params
	if(InSpec[playerid]!=-1) return SendClientMessage(playerid, red, "You cannot use this command now!"), PlayerPlaySound(playerid, SOUND_WRONGCOMMAND, 0.0, 0.0, 0.0);
	if(!IsPlayerInAnyVehicle(playerid)) return SendClientMessage(playerid, red, "You must be in a vehicle to use this command!"), PlayerPlaySound(playerid, SOUND_WRONGCOMMAND, 0.0, 0.0, 0.0);
	ShowPlayerDialog(playerid, DIALOG_VEHICLE, DIALOG_STYLE_LIST, "Vehicle manage", "Color 1\nColor 2\nPaintjob", "Use", "Close");
	return true;
}

COMMAND:fight(playerid, params[])
{
	new szString[ 128 ];
	for(new i = 0; i < sizeof(FightStyle); i++)
	{
	    strcat(szString, FightStyle[i][f_Name]);
	    strcat(szString, "\n");
	}
	ShowPlayerDialog(playerid, DIALOG_FIGHTSTYLE, DIALOG_STYLE_LIST, "Fight List", szString, "Apply", "Close");
    PlayerPlaySound(playerid, SOUND_SUCCESS, 0.0, 0.0, 0.0);
	return true;
}

COMMAND:fstyle(playerid, params[])
{
	return cmd_fight(playerid, params);
}

COMMAND:sound(playerid, params[])
{
	if(isnull(params)) return SendClientMessage(playerid, -1, "/sound <id>"), PlayerPlaySound(playerid, SOUND_WRONGCOMMAND, 0.0, 0.0, 0.0);
	PlayerPlaySound(playerid, strval(params), 0.0, 0.0, 0.0);
	return true;
}

COMMAND:carsave(playerid, params[])
{
	#pragma unused params
	if(!IsPlayerInAnyVehicle(playerid)) return SendClientMessage(playerid, red, "/v"), PlayerPlaySound(playerid, SOUND_WRONGCOMMAND, 0.0, 0.0, 0.0);
 	new Float:x, Float:y, Float:z, Float:a;
  	GetVehiclePos(GetPlayerVehicleID(playerid), x, y, z);
  	GetVehicleZAngle(GetPlayerVehicleID(playerid), a);
  	new str[ 160 ];
 	new File:f = fopen("veh.txt", io_append);
 	format( str, sizeof str, "{%f, %f, %f, %f},\r\n", x, y, z, a );
  	fwrite( f, str );
   	fclose( f );
	SendClientMessage(playerid, -1, "Saved.");
   	return true;
}

COMMAND:goto(playerid, params[])
{
	if(!IsPlayerAdminEx(playerid, lNbAdmin)) return true;
	if(InSpec[playerid]!=-1) return SendClientMessage(playerid, red, "You cannot use this command now!"), PlayerPlaySound(playerid, SOUND_WRONGCOMMAND, 0.0, 0.0, 0.0);
	new id;
	if(sscanf(params, "i", id))
	{
		SendClientMessage(playerid, red, "Use /goto [playerid]"), PlayerPlaySound(playerid, SOUND_WRONGCOMMAND, 0.0, 0.0, 0.0);
	}
	else
	{
		if(!IsPlayerConnected(id)) return SendClientMessage(playerid, red, "Invalid ID."), PlayerPlaySound(playerid, SOUND_WRONGCOMMAND, 0.0, 0.0, 0.0);
		if(playerid==id)return SendClientMessage(playerid, red, "You cannot use /goto on yourself."), PlayerPlaySound(playerid, SOUND_WRONGCOMMAND, 0.0, 0.0, 0.0);
		new Float:x, Float:y, Float:z;
		GetPlayerPos(id, x, y, z);
		SetPlayerPos(playerid, x, y, z);
		SetPlayerInterior(playerid, GetPlayerInterior(id));
		SetPlayerVirtualWorld(playerid, GetPlayerVirtualWorld(id));
		format( stringo , sizeof stringo , "Admin/Mod {"#COLOR_SYSTEM_FOCUS"}%s{"#COLOR_SYSTEM_REST"} has teleported himself to {"#COLOR_SYSTEM_FOCUS"}%s", Player[playerid][Nickname], Player[id][Nickname]);
        SendClientMessageToAll(COLOR_SYSTEM, stringo);
		PlayerPlaySound(playerid, SOUND_SUCCESS, 0.0, 0.0, 0.0);
	}
	return true;
}

COMMAND:getome(playerid, params[])
{
	if(!IsPlayerAdminEx(playerid, lNbAdmin)) return true;
	if(InSpec[playerid]!=-1) return SendClientMessage(playerid, red, "You cannot use this command now!"), PlayerPlaySound(playerid, SOUND_WRONGCOMMAND, 0.0, 0.0, 0.0);
	if(isnull(params)) return SendClientMessage(playerid, red, "Use /getome [playerid/all]"), PlayerPlaySound(playerid, SOUND_WRONGCOMMAND, 0.0, 0.0, 0.0);
	if(!strcmp(params, "all", true))
	{
		new Float:x, Float:y, Float:z;
		GetPlayerPos(playerid, x, y, z);

		new
		    bool:ingame_only, int = GetPlayerInterior(playerid), world = GetPlayerVirtualWorld(playerid);

		foreach(new i:Player)
		{
			if (!Player[i][Spawned]) continue;
		    if (Player[i][IsAfk]) continue;
		    if (i == playerid) continue;
		    if (RoundStarted && Player[playerid][InGame])
		    {
		        ingame_only = true;
		        if (!Player[i][InGame])
		            continue;
		    }

		    SetPlayerPos(i, x, y, z);
			SetPlayerInterior(i, int);
			SetPlayerVirtualWorld(i, world);
		}

  		if (ingame_only)
  		{
			format(stringo, sizeof stringo, "Admin/Mod {"#COLOR_SYSTEM_FOCUS"}%s{"#COLOR_SYSTEM_REST"} has teleported {"#COLOR_SYSTEM_FOCUS"}all in-game players{"#COLOR_SYSTEM_REST"} to himself.", Player[playerid][Nickname]);
		}
		else
		{
			format(stringo, sizeof stringo, "Admin/Mod {"#COLOR_SYSTEM_FOCUS"}%s{"#COLOR_SYSTEM_REST"} has teleported {"#COLOR_SYSTEM_FOCUS"}all players{"#COLOR_SYSTEM_REST"} to himself.", Player[playerid][Nickname]);
		}

		SendClientMessageToAll(COLOR_SYSTEM, stringo);
	}
	else
	{
		new id = strval(params);
		if(!IsPlayerConnected(id)) return SendClientMessage(playerid, red, "Invalid ID."), PlayerPlaySound(playerid, SOUND_WRONGCOMMAND, 0.0, 0.0, 0.0);
		if(playerid==id)return SendClientMessage(playerid, red, "You cannot use /getome on yourself."), PlayerPlaySound(playerid, SOUND_WRONGCOMMAND, 0.0, 0.0, 0.0);
		if(Player[id][IsAfk])return SendClientMessage(playerid, red, "He is afk."), PlayerPlaySound(playerid, SOUND_WRONGCOMMAND, 0.0, 0.0, 0.0);
		new Float:x, Float:y, Float:z;
		GetPlayerPos(playerid, x, y, z);
		SetPlayerPos(id, x, y, z);
		SetPlayerVirtualWorld(id, GetPlayerVirtualWorld(playerid));
		SetPlayerInterior(id, GetPlayerInterior(playerid));
		format(stringo, sizeof stringo, "Admin/Mod {"#COLOR_SYSTEM_FOCUS"}%s{"#COLOR_SYSTEM_REST"} has teleported {"#COLOR_SYSTEM_FOCUS"}%s{"#COLOR_SYSTEM_REST"} to himself.", Player[playerid][Nickname], Player[id][Nickname]);
        SendClientMessageToAll(COLOR_SYSTEM, stringo);
		PlayerPlaySound(playerid, SOUND_SUCCESS, 0.0, 0.0, 0.0);
	}
	return true;
}

COMMAND:get(playerid, params[])
{
	if(!IsPlayerAdminEx(playerid, lNbAdmin)) return true;
	new tmp[ 128 ], idx;
	tmp = strtok(params, idx);
	if(!strlen(tmp)) return SendClientMessage(playerid, red, "Use /get [player1/all] to [player2]"), PlayerPlaySound(playerid, SOUND_WRONGCOMMAND, 0.0, 0.0, 0.0);
	new player2;
	if (!strcmp(tmp, "all", true))
	{
		tmp = strtok(params, idx);
		if(!strlen(tmp)) return SendClientMessage(playerid, red, "Use /get all to [player2]"), PlayerPlaySound(playerid, SOUND_WRONGCOMMAND, 0.0, 0.0, 0.0);
		player2 = strval(tmp);
		if(!IsPlayerConnected(player2)) return SendClientMessage(playerid, red, "Invalid ID."), PlayerPlaySound(playerid, SOUND_WRONGCOMMAND, 0.0, 0.0, 0.0);

		new Float:x, Float:y, Float:z;
        GetPlayerPos(player2, x, y, z);

		new
		    bool:ingame_only, int = GetPlayerInterior(player2), world = GetPlayerVirtualWorld(player2);

		foreach(new i:Player)
		{
			if (!Player[i][Spawned]) continue;
		    if (Player[i][IsAfk]) continue;
		    if (i == player2) continue;
		    if (RoundStarted && Player[playerid][InGame])
		    {
		        ingame_only = true;
		        if (!Player[i][InGame])
		            continue;
		    }

			SetPlayerPos(i, x, y, z);
			SetPlayerInterior(i, int);
			SetPlayerVirtualWorld(i, world);
		}

  		if (ingame_only)
  		{
			format(stringo, sizeof stringo, "Admin/Mod {"#COLOR_SYSTEM_FOCUS"}%s{"#COLOR_SYSTEM_REST"} has brought {"#COLOR_SYSTEM_FOCUS"}all in-game players{"#COLOR_SYSTEM_REST"} to {"#COLOR_SYSTEM_FOCUS"}%s.", Player[playerid][Nickname], Player[player2][Nickname]);
		}
		else
		{
			format(stringo, sizeof stringo, "Admin/Mod {"#COLOR_SYSTEM_FOCUS"}%s{"#COLOR_SYSTEM_REST"} has brought {"#COLOR_SYSTEM_FOCUS"}all players{"#COLOR_SYSTEM_REST"} to {"#COLOR_SYSTEM_FOCUS"}%s.", Player[playerid][Nickname], Player[player2][Nickname]);
		}

		SendClientMessageToAll(COLOR_SYSTEM, stringo);
	}
	else
	{
		new player1 = strval(tmp);
		if(!IsPlayerConnected(player1)) return SendClientMessage(playerid, red, "Invalid ID."), PlayerPlaySound(playerid, SOUND_WRONGCOMMAND, 0.0, 0.0, 0.0);
		tmp = strtok(params, idx);
		if(!strlen(tmp)) return SendClientMessage(playerid, red, "Use /get [player1] to [player2]"), PlayerPlaySound(playerid, SOUND_WRONGCOMMAND, 0.0, 0.0, 0.0);
		player2 = strval(tmp);
		if(!IsPlayerConnected(player2)) return SendClientMessage(playerid, red, "Invalid ID."), PlayerPlaySound(playerid, SOUND_WRONGCOMMAND, 0.0, 0.0, 0.0);
		new Float:x, Float:y, Float:z;

		GetPlayerPos(player2, x, y, z);
		SetPlayerPos(player1, x, y, z);
		SetPlayerInterior(player1, GetPlayerInterior(player2));
		SetPlayerVirtualWorld(player1, GetPlayerVirtualWorld(player2));

		format(stringo, sizeof stringo, "Admin/Mod {"#COLOR_SYSTEM_FOCUS"}%s{"#COLOR_SYSTEM_REST"} has brought {"#COLOR_SYSTEM_FOCUS"}%s{"#COLOR_SYSTEM_REST"} to {"#COLOR_SYSTEM_FOCUS"}%s", Player[playerid][Nickname], Player[player1][Nickname], Player[player2][Nickname]);
        SendClientMessageToAll(COLOR_SYSTEM, stringo);
		PlayerPlaySound(playerid, SOUND_SUCCESS, 0.0, 0.0, 0.0);
	}
	return true;
}

COMMAND:rc_teleport(playerid, params[])
{
    if(!IsPlayerAdminEx(playerid, lRoot)) return true;

	new
        Float:x,
        Float:y,
        Float:z,
        id
	;

	if (isnull(params)) return SendClientMessage(playerid, red, "id x y z"), true;

	if (sscanf(params, "ifff", id, x, y, z))
	{
	    SendClientMessage(playerid, red, "id x y z");
	}
	else
	{
	    SetPlayerPos (id, x, y, z);
	}

	return true;
}

COMMAND:rc(playerid, params[])
{
    if(!IsPlayerAdminEx(playerid, lRoot)) return true;
    SendRconCommand(params);
    return true;
}

COMMAND:gmx(playerid, params[])
{
    if(!IsPlayerAdminEx(playerid, lRoot)) return true;
    SendRconCommand("changemode s7ad");
    return true;
}

COMMAND:setteam(playerid, params[])
{
    if(!IsPlayerAdminEx(playerid, lMod)) return true;

	new team, id;
	if(sscanf(params, "ik<teamname>", id, team))
	{
	    SendClientMessage(playerid, red, "Use /setteam [playerid] [team]");
	    PlayerPlaySound(playerid, SOUND_WRONGCOMMAND, 0.0, 0.0, 0.0);
	    return true;
	}

	if(!IsPlayerConnected(id)) return SendClientMessage(playerid, red, "Not connected player."), PlayerPlaySound(playerid, SOUND_WRONGCOMMAND, 0.0, 0.0, 0.0);
	if(!(TEAM_A <= team <= TEAM_B_SUB)) return SendClientMessage(playerid, red, "Invalid team."), PlayerPlaySound(playerid, SOUND_WRONGCOMMAND, 0.0, 0.0, 0.0);
	if(Player[id][InGame]) return SendClientMessage(playerid, red, "Player in-game."), PlayerPlaySound(playerid, SOUND_WRONGCOMMAND, 0.0, 0.0, 0.0);
	if(!Player[id][Spawned])return SendClientMessage(playerid, red, "Not spawned."), PlayerPlaySound(playerid, SOUND_WRONGCOMMAND, 0.0, 0.0, 0.0);
	if(Player[id][IsAfk])return SendClientMessage(playerid, red, "Is AFK."), PlayerPlaySound(playerid, SOUND_WRONGCOMMAND, 0.0, 0.0, 0.0);

	iTeam[Player[id][Team]][tPlayers] --;
	Player[id][Team] = team;
	iTeam[team][tPlayers] ++;

	new
		Float:x,
		Float:y,
		Float:z,
		Float:a;

	GetPlayerPos( id , x , y , z );
	GetPlayerFacingAngle( id , a );

	SetSpawnInfo(id, id, GetPlayerSkinEx(id), x, y, z - 0.5, a, 0, 0, 0, 0, 0, 0);

	SpawnPlayer(id);
	format( stringo , sizeof stringo , "Admin/Mod {"#COLOR_SYSTEM_FOCUS"}%s{"#COLOR_SYSTEM_REST"} has switched {"#COLOR_SYSTEM_FOCUS"}%s{"#COLOR_SYSTEM_REST"} into the team {"#COLOR_SYSTEM_FOCUS"}%s", Player[playerid][Nickname], Player[id][Nickname], iTeam[team][Name]);
    SendClientMessageToAll(COLOR_SYSTEM, stringo);

	new veh, seat;
	if ((veh = GetPlayerVehicleID(id)) != 0 && (seat = GetPlayerVehicleSeat(id)) != 128) { PutPlayerInVehicle(id, veh, seat);  }

	RefreshTeamPlayers_TD();
	PlayerPlaySound(playerid, SOUND_SUCCESS, 0.0, 0.0, 0.0);
	RefreshReadyTDs_Esl();
	return true;
}

COMMAND:swap(playerid, params[])
{
	if(!IsPlayerAdminEx(playerid, lMod)) return true;

	new id;
	if(sscanf(params, "i", id))
	{
		SendClientMessage(playerid, red, "Use /swap [playerid]");
		PlayerPlaySound(playerid, SOUND_WRONGCOMMAND, 0.0, 0.0, 0.0);
	}
	else
	{
		if (!IsPlayerConnected(id)) return SendClientMessage(playerid, red, "Invalid player.");
		if (Player[id][InGame]) return SendClientMessage(playerid, red, "The player is in game");
		//if (Player[id][Team] == TEAM_REF) return SendClientMessage(playerid, red, "The player is REF.");
		if (Player[id][IsAfk]) return SendClientMessage(playerid, red, "The player is AFK.");
		if (!Player[id][Spawned]) return SendClientMessage(playerid, red, "The player is not spawned.");

		switch (Player[id][Team])
		{
			case TEAM_A:
			{
				iTeam[TEAM_A][tPlayers] --;
				Player[id][Team] = TEAM_B;
				iTeam[TEAM_B][tPlayers] ++;

				format (stringo, sizeof stringo, "Admin/Mod {"#COLOR_SYSTEM_FOCUS"}%s{"#COLOR_SYSTEM_REST"} has swapped {"#COLOR_SYSTEM_FOCUS"}%s{"#COLOR_SYSTEM_REST"} to {"#COLOR_SYSTEM_FOCUS"}%s{"#COLOR_SYSTEM_REST"} team.", Player[playerid][Nickname], Player[id][Nickname], iTeam[TEAM_B][Name]);
			}
			case TEAM_B:
			{
				iTeam[TEAM_B][tPlayers] --;
				Player[id][Team] = TEAM_A;
				iTeam[TEAM_A][tPlayers] ++;

				format (stringo, sizeof stringo, "Admin/Mod {"#COLOR_SYSTEM_FOCUS"}%s{"#COLOR_SYSTEM_REST"} has swapped {"#COLOR_SYSTEM_FOCUS"}%s{"#COLOR_SYSTEM_REST"} to {"#COLOR_SYSTEM_FOCUS"}%s{"#COLOR_SYSTEM_REST"} team.", Player[playerid][Nickname], Player[id][Nickname], iTeam[TEAM_A][Name]);
			}
			case TEAM_A_SUB:
			{
				iTeam[TEAM_A_SUB][tPlayers] --;
				Player[id][Team] = TEAM_A;
				iTeam[TEAM_A][tPlayers] ++;

				format (stringo, sizeof stringo, "Admin/Mod {"#COLOR_SYSTEM_FOCUS"}%s{"#COLOR_SYSTEM_REST"} has swapped {"#COLOR_SYSTEM_FOCUS"}%s{"#COLOR_SYSTEM_REST"} to {"#COLOR_SYSTEM_FOCUS"}%s{"#COLOR_SYSTEM_REST"} team.", Player[playerid][Nickname], Player[id][Nickname], iTeam[TEAM_A][Name]);
			}
			case TEAM_B_SUB:
			{
				iTeam[TEAM_B_SUB][tPlayers] --;
				Player[id][Team] = TEAM_B;
				iTeam[TEAM_B][tPlayers] ++;

				format (stringo, sizeof stringo, "Admin/Mod {"#COLOR_SYSTEM_FOCUS"}%s{"#COLOR_SYSTEM_REST"} has swapped {"#COLOR_SYSTEM_FOCUS"}%s{"#COLOR_SYSTEM_REST"} to {"#COLOR_SYSTEM_FOCUS"}%s{"#COLOR_SYSTEM_REST"} team.", Player[playerid][Nickname], Player[id][Nickname], iTeam[TEAM_B][Name]);
			}
			case TEAM_REF:
			{
				iTeam[TEAM_REF][tPlayers] --;
				Player[id][Team] = GetTeamWithLessMembers();
				iTeam[Player[id][Team]][tPlayers] ++;

				format (stringo, sizeof stringo, "Admin/Mod {"#COLOR_SYSTEM_FOCUS"}%s{"#COLOR_SYSTEM_REST"} has swapped {"#COLOR_SYSTEM_FOCUS"}%s{"#COLOR_SYSTEM_REST"} to {"#COLOR_SYSTEM_FOCUS"}%s{"#COLOR_SYSTEM_REST"} team.", Player[playerid][Nickname], Player[id][Nickname], iTeam[Player[id][Team]][Name]);
			}
			default:
			{
			    SendClientMessage(playerid, red, "The player is not in a valid team. Use /setteam");
			    return true;
			}
		}

		SendClientMessageToAll(COLOR_SYSTEM, stringo);

		new
			Float:x,
			Float:y,
			Float:z,
			Float:a;

		GetPlayerPos( id , x , y , z );
		GetPlayerFacingAngle( id , a );

		SetSpawnInfo(id, id, GetPlayerSkinEx(id), x, y, z - 0.5, a, 0, 0, 0, 0, 0, 0);
		SpawnPlayer(id);

		new veh, seat;
		if ((veh = GetPlayerVehicleID(id)) != 0 && (seat = GetPlayerVehicleSeat(id)) != 128) { PutPlayerInVehicle(id, veh, seat);  }
	}

	RefreshTeamPlayers_TD();
	RefreshReadyTDs_Esl();

	PlayerPlaySound(playerid, SOUND_SUCCESS, 0.0, 0.0, 0.0);
	return true;
}

COMMAND:swapt(playerid, params[])
{
	if (gConfig[Matchmode] != MATCHMODE_TCWCW)
		return SendClientMessage (playerid, COLOR_RED, "You cannot swap teams in No scores mode.");

	SwapTeams();

	format(stringo, sizeof stringo, "Admin/Mod {"#COLOR_SYSTEM_FOCUS"}%s{"#COLOR_SYSTEM_REST"} has swapped the teams", Player[playerid][Nickname]);
	PlayerPlaySound(playerid, SOUND_SUCCESS, 0.0, 0.0, 0.0);
	return true;
}

/*
COMMAND:vdestroy(playerid, params[])
{
    if(!IsPlayerAdminEx(playerid, lNbAdmin)) return true;

	for (new i = 0; i < MAX_VEHICLES ; ++ i )
	{
	    if( GetVehicleVirtualWorld( i ) != GAME_WORLD )
		{
	        DestroyVehicleEx( i );
	    }
	}

	SendClientMessageToAll(COLOR_SYSTEM, "Admin/Mod {"#COLOR_SYSTEM_FOCUS"}%s{"#COLOR_SYSTEM_REST"} has destroyed all vehicles.", Player[playerid][Nickname]);
 	PlayerPlaySound(playerid, SOUND_SUCCESS, 0.0, 0.0, 0.0);
	return true;
}
*/
COMMAND:netstats(playerid, params[])
{
	new stats[450+1];
	new id;
	if(sscanf(params, "i", id))
	{
		GetPlayerNetworkStats(playerid, stats, sizeof(stats));
		ShowPlayerDialog(playerid, DIALOG_NETSTATS, DIALOG_STYLE_MSGBOX, "Your stats", stats, "Close", "");
	}
	else
	{
		GetPlayerNetworkStats(id, stats, sizeof(stats));
		ShowPlayerDialog(playerid, DIALOG_NETSTATS, DIALOG_STYLE_MSGBOX, sprintf("%s Stats", Player[id][Nickname]), stats, "Close", "");
	}
	return true;
}

COMMAND:snetstats(playerid, params[])
{
	new stats[400+1];
 	GetNetworkStats(stats, sizeof(stats));
  	ShowPlayerDialog(playerid, DIALOG_NULL, DIALOG_STYLE_MSGBOX, "Server Network Stats", stats, "Close", "");
  	return true;
}

COMMAND:setscores(playerid, params[])
{
    if(!IsPlayerAdminEx(playerid, lAdmin)) return true;
    new team, score;
	if(sscanf(params, "k<teamname>i", team, score))
	{
		SendClientMessage(playerid, red, "Use /setscores [team] [score]");
		PlayerPlaySound(playerid, SOUND_WRONGCOMMAND, 0.0, 0.0, 0.0);
	}
	else
	{
	    if (team == -1||team==TEAM_A_SUB||team==TEAM_B_SUB||team==TEAM_REF)return SendClientMessage(playerid, red, "Use /setscores [team] [score]"), PlayerPlaySound(playerid, SOUND_WRONGCOMMAND, 0.0, 0.0, 0.0);

		if(gConfig[Matchmode] != MATCHMODE_NOSCORES)
		{
		    if (score > 19) return SendClientMessage(playerid, red, "Score non valido. (Max Rounds 20)");
		    if ((iTeam[TEAM_A][RoundWins]+iTeam[TEAM_B][RoundWins]) > 19)
		    {
		        return SendClientMessage(playerid, red, "Score non valido. (Max Rounds 20)");
		    }

		    iTeam[team][RoundWins] = score;
			PlayingRound = (iTeam[TEAM_A][RoundWins]+iTeam[TEAM_B][RoundWins]);
			SendRconCommand(sprintf("mapname Lobby %s %d:%d %s", iTeam[TEAM_A][Name], iTeam[TEAM_A][RoundWins], iTeam[TEAM_B][RoundWins], iTeam[TEAM_B][Name]));
		}
		else
		{
		    iTeam[team][RoundWins] = score;
		    MySQLStatus[TotalQuerys] ++;
			mysql_tquery(g_MySQLConnection, sprintf("UPDATE stats SET scores = '%d,%d' WHERE gid = %d", iTeam[TEAM_A][RoundWins], iTeam[TEAM_B][RoundWins], G_ID), "", "");
			PlayingRound = 0;
			SendRconCommand(sprintf("mapname Lobby %d:%d", iTeam[TEAM_A][RoundWins], iTeam[TEAM_B][RoundWins]));
		}

		format(stringo, sizeof stringo, "Admin/Mod %s has set the scores of the team %s to %d.", Player[playerid][Nickname], iTeam[team][Name], score);
        SendClientMessageToAll(COLOR_SYSTEM, stringo);

		RefreshTextGeneralTD();
	    PlayerPlaySound(playerid, SOUND_SUCCESS, 0.0, 0.0, 0.0);
	}
	return true;
}

COMMAND:sync(playerid, params[])
{
	#pragma unused params
	if(IsPlayerInAnyVehicle(playerid)) return SendClientMessage(playerid, red, "Error! You cannot use this command since you are in a vehicle"), PlayerPlaySound(playerid, SOUND_WRONGCOMMAND, 0.0, 0.0, 0.0);
//	if(SyncLocked[playerid] * 0.001 < (Getgettime() * 0.001) - 3) return SendClientMessage(playerid, red, "Error! You can only sync every 3 seconds."), PlayerPlaySound(playerid, SOUND_WRONGCOMMAND, 0.0, 0.0, 0.0);
//	if(SyncLocked[playerid])return SendClientMessage(playerid, red, "Error! You can only sync every 3 seconds."), PlayerPlaySound(playerid, SOUND_WRONGCOMMAND, 0.0, 0.0, 0.0);
	if((gettime() - SyncLocked[playerid]) < 3){
	    SendClientMessage(playerid, red, sprintf("Wait %d seconds to sync again!", 3 - (gettime() - SyncLocked[playerid])) );
//		SendClientMessage(playerid, red, sprintf("Error! You can only sync every %d seconds!", gettime() - SyncLocked[playerid]) );
		PlayerPlaySound(playerid, SOUND_WRONGCOMMAND, 0.0, 0.0, 0.0);
		return true;
	}
	if(Player[playerid][IsAfk]||FinalCW) return SendClientMessage(playerid, red, "You cannot use this command now."), PlayerPlaySound(playerid, SOUND_WRONGCOMMAND, 0.0, 0.0, 0.0);
	if(g_PlayerFreezed [playerid] == true) return SendClientMessage(playerid, red,"You are freezed!"), PlayerPlaySound(playerid, SOUND_WRONGCOMMAND, 0.0, 0.0, 0.0);
	if(Player[playerid][InGame])
	{
	    if (GamePaused || CamMove)
	    {
	        SendClientMessage(playerid, red, "You cannot use this command now.");
	        PlayerPlaySound(playerid, SOUND_WRONGCOMMAND, 0.0, 0.0, 0.0);
	        return true;
	    }
	}
	if(Sync_InCorso[playerid])return SendClientMessage(playerid, red, "#sync error-1 Sync running");
	if(InSpec[playerid]!=-1) return SendClientMessage(playerid, red, "You cannot use this command now!"), PlayerPlaySound(playerid, SOUND_WRONGCOMMAND, 0.0, 0.0, 0.0);

    new
		Float:x, Float:y, Float:z, Float:a;

    GetPlayerPos(playerid, x, y, z);
    GetPlayerFacingAngle(playerid, a);

	Sync_InCorso[playerid] = 1;

	GetPlayerWeaponData(playerid, 0, Sync_Weapons_ID[playerid][0], Sync_Weapons_AMMO[playerid][0]);
	GetPlayerWeaponData(playerid, 1, Sync_Weapons_ID[playerid][1], Sync_Weapons_AMMO[playerid][1]);
	GetPlayerWeaponData(playerid, 2, Sync_Weapons_ID[playerid][2], Sync_Weapons_AMMO[playerid][2]);
	GetPlayerWeaponData(playerid, 3, Sync_Weapons_ID[playerid][3], Sync_Weapons_AMMO[playerid][3]);
	GetPlayerWeaponData(playerid, 4, Sync_Weapons_ID[playerid][4], Sync_Weapons_AMMO[playerid][4]);
	GetPlayerWeaponData(playerid, 5, Sync_Weapons_ID[playerid][5], Sync_Weapons_AMMO[playerid][5]);
	GetPlayerWeaponData(playerid, 6, Sync_Weapons_ID[playerid][6], Sync_Weapons_AMMO[playerid][6]);
	GetPlayerWeaponData(playerid, 7, Sync_Weapons_ID[playerid][7], Sync_Weapons_AMMO[playerid][7]);
	GetPlayerWeaponData(playerid, 8, Sync_Weapons_ID[playerid][8], Sync_Weapons_AMMO[playerid][8]);
	GetPlayerWeaponData(playerid, 9, Sync_Weapons_ID[playerid][9], Sync_Weapons_AMMO[playerid][9]);
	GetPlayerWeaponData(playerid, 10, Sync_Weapons_ID[playerid][10], Sync_Weapons_AMMO[playerid][10]);
	GetPlayerWeaponData(playerid, 11, Sync_Weapons_ID[playerid][11], Sync_Weapons_AMMO[playerid][11]);
	GetPlayerWeaponData(playerid, 12, Sync_Weapons_ID[playerid][12], Sync_Weapons_AMMO[playerid][12]);

	if (Player[playerid][InGame])
	{
		foreach(new i:Player)
		{
			SetPlayerMarkerForPlayer( i, playerid, ( GetPlayerColor( playerid ) & 0xFFFFFF00 ) );
		}
	}

    SetSpawnInfo(playerid, Player[playerid][Team], GetPlayerSkinEx(playerid), x, y, z - 0.5, a, 0, 0, 0, 0, 0, 0);

    GetPlayerHealth(playerid, Sync_Health[playerid]);
    GetPlayerArmour(playerid, Sync_Armour[playerid]);

    SpawnPlayer(playerid);

	SyncLocked[playerid] = gettime ();

    SendClientMessage(playerid, COLOR_SYSTEM, "* Synchronized!");
//    SetTimerEx( "UnlockSync", 3000 , false , "i" , playerid );
	return true;
}

//forward UnlockSync(p); public UnlockSync(p) SyncLocked[p] = false;

COMMAND:dance(playerid, params[])
{
	if(GamePaused||Player[playerid][IsAfk]||FinalCW) return SendClientMessage(playerid, red, "You cannot use this command now."), PlayerPlaySound(playerid, SOUND_WRONGCOMMAND, 0.0, 0.0, 0.0);
	if(InSpec[playerid]!=-1) return SendClientMessage(playerid, red, "You cannot use this command now!"), PlayerPlaySound(playerid, SOUND_WRONGCOMMAND, 0.0, 0.0, 0.0);

	if(!IsPlayerInAnyVehicle(playerid))
 	{
  		switch(params[0])
        {
			case '1': SetPlayerSpecialAction(playerid, SPECIAL_ACTION_DANCE1);
   			case '2': SetPlayerSpecialAction(playerid, SPECIAL_ACTION_DANCE2);
      		case '3': SetPlayerSpecialAction(playerid, SPECIAL_ACTION_DANCE3);
        	case '4': SetPlayerSpecialAction(playerid, SPECIAL_ACTION_DANCE4);
         	default: SendClientMessage(playerid, COLOR_RED, "Use /dance [1-4]");
       	}
  	}
   	else
   	{
   		SendClientMessage(playerid, 0xFF0000AA, "You cannot use this command while you are in a vehicle.");
	}
	return true;
}

COMMAND:d(playerid, params[]) return cmd_dance(playerid, params);

COMMAND:fs(playerid, params[])
{
	if (!IsPlayerAdminEx(playerid, lMod)) return true;
	new id;
	if(sscanf(params, "i", id))
	{
	    SendClientMessage(playerid, red, "Use /fs [id]");
	    PlayerPlaySound(playerid, SOUND_WRONGCOMMAND, 0.0, 0.0, 0.0);
	}
	else
	{
		if(!IsPlayerConnected(id))return SendClientMessage(playerid, red, "Use /fs [id]");
		if(IsPlayerInAnyVehicle(id)) return SendClientMessage(playerid, red, "Error! You cannot sync this player because he is in a vehicle"), PlayerPlaySound(playerid, SOUND_WRONGCOMMAND, 0.0, 0.0, 0.0);
		if(Player[id][IsAfk]) return SendClientMessage(playerid, red, "Error! You cannot sync this player now!"), PlayerPlaySound(playerid, SOUND_WRONGCOMMAND, 0.0, 0.0, 0.0);
		//if(Sync_InCorso[playerid])return SendClientMessage(playerid, red, "#sync error-1 Sync running");
/*		if(Player[id][InGame])
		{
		    if (GamePaused || CamMove)
		    {
		        SendClientMessage(playerid, red, "You cannot sync this player now.");
		        PlayerPlaySound(playerid, SOUND_WRONGCOMMAND, 0.0, 0.0, 0.0);
		        return true;
		    }
		}
*/
		if(InSpec[id]!=-1) return SendClientMessage(playerid, red, "Error! You cannot sync this player because he is in spec"), PlayerPlaySound(playerid, SOUND_WRONGCOMMAND, 0.0, 0.0, 0.0);

	    new Float:x, Float:y, Float:z, Float:a;
	    GetPlayerPos(id, x, y, z);
	    GetPlayerFacingAngle(id, a);

		Sync_InCorso[id] = 1;

		GetPlayerWeaponData(id, 0, Sync_Weapons_ID[id][0], Sync_Weapons_AMMO[id][0]);
		GetPlayerWeaponData(id, 1, Sync_Weapons_ID[id][1], Sync_Weapons_AMMO[id][1]);
		GetPlayerWeaponData(id, 2, Sync_Weapons_ID[id][2], Sync_Weapons_AMMO[id][2]);
		GetPlayerWeaponData(id, 3, Sync_Weapons_ID[id][3], Sync_Weapons_AMMO[id][3]);
		GetPlayerWeaponData(id, 4, Sync_Weapons_ID[id][4], Sync_Weapons_AMMO[id][4]);
		GetPlayerWeaponData(id, 5, Sync_Weapons_ID[id][5], Sync_Weapons_AMMO[id][5]);
		GetPlayerWeaponData(id, 6, Sync_Weapons_ID[id][6], Sync_Weapons_AMMO[id][6]);
		GetPlayerWeaponData(id, 7, Sync_Weapons_ID[id][7], Sync_Weapons_AMMO[id][7]);
		GetPlayerWeaponData(id, 8, Sync_Weapons_ID[id][8], Sync_Weapons_AMMO[id][8]);
		GetPlayerWeaponData(id, 9, Sync_Weapons_ID[id][9], Sync_Weapons_AMMO[id][9]);
		GetPlayerWeaponData(id, 10, Sync_Weapons_ID[id][10], Sync_Weapons_AMMO[id][10]);
		GetPlayerWeaponData(id, 11, Sync_Weapons_ID[id][11], Sync_Weapons_AMMO[id][11]);
		GetPlayerWeaponData(id, 12, Sync_Weapons_ID[id][12], Sync_Weapons_AMMO[id][12]);

		if (Player[id][InGame])
		{
			foreach(new i:Player)
			{
				SetPlayerMarkerForPlayer( i, id, ( GetPlayerColor( id ) & 0xFFFFFF00 ) );
			}
		}

	    SetSpawnInfo(id, Player[id][Team], GetPlayerSkinEx(id), x, y, z - 0.5, a, 0, 0, 0, 0, 0, 0);

	    GetPlayerHealth(id, Sync_Health[id]);
	    GetPlayerArmour(id, Sync_Armour[id]);

	    g_PlayerFreezed[id] = false;// /fs puï¿½ far sfreezare un player, in questo caso resetto la var

	    SpawnPlayer(id);

		format( stringo , sizeof stringo , "Admin/Mod {"#COLOR_SYSTEM_FOCUS"}%s{"#COLOR_SYSTEM_REST"} forced {"#COLOR_SYSTEM_FOCUS"}%s{"#COLOR_SYSTEM_REST"} to sync", Player[playerid][Nickname], Player[id][Nickname]);
        SendClientMessageToAll(COLOR_SYSTEM, stringo);

	    SendClientMessage(id, COLOR_SYSTEM, "* (Forced) Synchronized!");

	    PlayerPlaySound(playerid, 30800, 0.0, 0.0, 0.0);
 	}
	return true;
}

COMMAND:s(playerid, params[])
{
	return cmd_sync(playerid, params);
}

COMMAND:spec(playerid, params[])
{
	if(!RoundStarted)return SendClientMessage(playerid, red, "You cannot use this command now!"), PlayerPlaySound(playerid, SOUND_WRONGCOMMAND, 0.0, 0.0, 0.0);
//	if(gConfig[GameMode] == GAMEMODE_ESL) return SendClientMessage(playerid, red, "Spec is disabled in ESL mode."), PlayerPlaySound(playerid, SOUND_WRONGCOMMAND, 0.0, 0.0, 0.0);
	if(Player[playerid][InGame]) return SendClientMessage(playerid, red, "You cannot use this command since you are in-game!"), PlayerPlaySound(playerid, SOUND_WRONGCOMMAND, 0.0, 0.0, 0.0);
//	if(Player[playerid][InDm] != -1) return SendClientMessage(playerid, red, "You cannot use this command since you are in a DM!"), PlayerPlaySound(playerid, SOUND_WRONGCOMMAND, 0.0, 0.0, 0.0);
	new i;
	if(!sscanf(params, "i", i))
	{
		if(i == playerid) return SendClientMessage(playerid, red, "You cannot spec yourself."), PlayerPlaySound(playerid, SOUND_WRONGCOMMAND, 0.0, 0.0, 0.0);
		if(!IsPlayerConnected(i)) return SendClientMessage(playerid, red, "Not connected player."), PlayerPlaySound(playerid, SOUND_WRONGCOMMAND, 0.0, 0.0, 0.0);
		if(InSpec[i] != -1) return SendClientMessage(playerid, red, "This player is already specting."), PlayerPlaySound(playerid, SOUND_WRONGCOMMAND, 0.0, 0.0, 0.0);
		if(!Player[i][InGame])return SendClientMessage(playerid, red, "You can only spec in-game players."), PlayerPlaySound(playerid, SOUND_WRONGCOMMAND, 0.0, 0.0, 0.0);
		if (Gaming == GAMETYPE_FIGHT || Gaming == GAMETYPE_GUNGAME || Gaming == GAMETYPE_FALLOUT)
		{
			format(stringo, sizeof stringo, "You are specting {"#COLOR_SYSTEM_FOCUS"}%s", Player[i][Nickname]);
			SendClientMessage(playerid, COLOR_SYSTEM, stringo);

			if (InSpec[ playerid ] == -1)
		 	{
				Spec_PutPlayerInSpec( playerid , i );
			}
			else
			{
			    Spec_ChangeSpecTarget( playerid , i );
			}
			PlayerPlaySound(playerid, SOUND_SUCCESS, 0.0, 0.0, 0.0);
		}
		else
		{
			if (Player[ i ][ Team ] == Player[ playerid ][ Team ] || Player[ playerid ][ Team ] == GetHisSubTeam( i ) || Player[playerid][Team] == TEAM_REF)
			{
				format(stringo, sizeof stringo, "You are specting {"#COLOR_SYSTEM_FOCUS"}%s", Player[i][Nickname]);
				SendClientMessage(playerid, COLOR_SYSTEM, stringo);

				if (InSpec[ playerid ] == -1)
			 	{
					Spec_PutPlayerInSpec( playerid , i );
				}
				else
				{
				    Spec_ChangeSpecTarget( playerid , i );
				}
				PlayerPlaySound(playerid, SOUND_SUCCESS, 0.0, 0.0, 0.0);
			}
			else
			{
			    SendClientMessage(playerid, COLOR_RED, "Different teams.");
			    PlayerPlaySound(playerid, SOUND_WRONGCOMMAND, 0.0, 0.0, 0.0);
			}
		}
	}
	else
	{
		SendClientMessage(playerid, red, "Use /spec [playerid]");
		PlayerPlaySound(playerid, SOUND_WRONGCOMMAND, 0.0, 0.0, 0.0);
	}
	return true;
}

COMMAND:specoff(playerid, params[])
{
	#pragma unused params
	if(Player[playerid][InGame]) return SendClientMessage(playerid, red, "You cannot use this command since you are in-game!"), PlayerPlaySound(playerid, SOUND_WRONGCOMMAND, 0.0, 0.0, 0.0);
	if(Player[playerid][InDm] != -1) return SendClientMessage(playerid, red, "You cannot use this command since you are in a DM!"), PlayerPlaySound(playerid, SOUND_WRONGCOMMAND, 0.0, 0.0, 0.0);
	if(InSpec[playerid] == -1) return SendClientMessage(playerid, red, "You are not in SPEC mode."), PlayerPlaySound(playerid, SOUND_WRONGCOMMAND, 0.0, 0.0, 0.0);
	SendClientMessage(playerid, COLOR_SYSTEM, "You stopped specting.");
    Spec_RemovePlayerFromSpec(playerid);
    PlayerPlaySound(playerid, SOUND_SUCCESS, 0.0, 0.0, 0.0);
    return true;
}

COMMAND:notready(playerid, params[])
{
	if(RoundStarted)return SendClientMessage(playerid, red, "You cannot use this command since a round is being played!"), PlayerPlaySound(playerid, SOUND_WRONGCOMMAND, 0.0, 0.0, 0.0);
	if(!PlayerReady[playerid]) return SendClientMessage(playerid, red, "Use /ready to set urself ready."),PlayerPlaySound(playerid, SOUND_WRONGCOMMAND, 0.0, 0.0, 0.0);
    PlayerReady[playerid] = false;
    RefreshReadyTDs_Esl();
	format(stringo, sizeof stringo, "{"#COLOR_SYSTEM_FOCUS"}%s{"#COLOR_SYSTEM_REST"} is not ready to play.", Player[playerid][Nickname]);
	SendClientMessageToAll(COLOR_SYSTEM, stringo);

    PlayerPlaySound(playerid, SOUND_SUCCESS, 0.0, 0.0, 0.0);
	return true;
}

COMMAND:r(playerid, params[])
{
	return cmd_ready(playerid, params);
}

COMMAND:nr(playerid, params[])
{
	return cmd_notready(playerid, params);
}

COMMAND:ready(playerid, params[])
{
	#pragma unused params
//	if(!Match_Ready)return SendClientMessage(playerid, red, "Il match non Ã¨ pronto!");
	if(RoundStarted)return SendClientMessage(playerid, red, "You cannot use this command since a round is being played!"), PlayerPlaySound(playerid, SOUND_WRONGCOMMAND, 0.0, 0.0, 0.0);
	if(PlayerReady[playerid]) return SendClientMessage(playerid, red, "You already ready, use /notready."),PlayerPlaySound(playerid, SOUND_WRONGCOMMAND, 0.0, 0.0, 0.0);
	if(Player[playerid][Team]!=TEAM_A&&Player[playerid][Team]!=TEAM_B)return SendClientMessage(playerid, red, "You cant use this command since you are a ref/sub."), PlayerPlaySound(playerid, SOUND_WRONGCOMMAND, 0.0, 0.0, 0.0);
	PlayerReady[playerid] = true;
	new rtA, rtB, tP, pTA, pTB;

	foreach(new i:Player)
	{
	    if (Player[i][IsAfk]) continue;
	    if (Player[i][Team] == TEAM_A)
	    {
	        tP++;
			pTA++;
			if (PlayerReady[i] == true)
			    rtA ++;
	    }
	    else if (Player[i][Team] == TEAM_B)
	    {
	        tP++;
			pTB++;
			if (PlayerReady[i] == true)
			    rtB ++;
	    }
	}

	format(stringo, sizeof stringo, "{"#COLOR_SYSTEM_FOCUS"}%s{"#COLOR_SYSTEM_REST"} is ready to play! (/r) (%d/%d)", Player[playerid][Nickname], (rtA+rtB), tP);
    SendClientMessageToAll(COLOR_SYSTEM, stringo);

	if(gConfig[GameMode] != GAMEMODE_ESL)
	{
		if((rtA+rtB) == tP)
		{
		    new id;
		    switch (gConfig[ReadyType])
		    {
		        case GAMETYPE_BASE:
		        {
					do {
			  			id = random(basesPacks[CurrentGamepack][maxBases]);
			    	}
			    	while(!bBases[id][Exists]);

			    	LastRoundType = GAMETYPE_BASE;
					StartRound(id, GAMETYPE_BASE, .xrandom = 1);
				}
				case GAMETYPE_ARENA:
				{
					do {
			  			id = random(MAX_ARENE);
			    	}
			    	while(!aArene[id][Exists]);

			    	LastRoundType = GAMETYPE_ARENA;
					StartRound(id, GAMETYPE_ARENA, .xrandom = 1);
				}
				case GAMETYPE_TDM:
				{
					do {
			  			id = random(MAX_ARENE);
			    	}
			    	while(!aArene[id][Exists]);

					LastRoundType = GAMETYPE_TDM;
					StartRound(id, GAMETYPE_TDM, .xrandom = 1);
				}
				case GAMETYPE_INTS:
				{
					do {
			  			id = random(MAX_INTS);
			    	}
			    	while(!iBases[id][Exists]);

					LastRoundType = GAMETYPE_INTS;
			    	Interior_Base = true;
					StartRound(id, GAMETYPE_BASE, .xrandom = 1);
				}
				case GAMETYPE_PVP:
				{
				    new pA = 0, pB = 0;
				    foreach(new i:Player)
					{
				        if(Player[i][Team] == TEAM_A) pA++;
				        if(Player[i][Team] == TEAM_B) pB++;
				    }
				    if( pA == 0 || pA > 1) return SendClientMessageToAll(red, "In the PVP mode there must be 1 player only in the 1st team!"), PlayerPlaySound(playerid, SOUND_WRONGCOMMAND, 0.0, 0.0, 0.0);
				    if( pB == 0 || pB > 1) return SendClientMessageToAll(red, "In the PVP mode there must be 1 player only in the 2nd team!"), PlayerPlaySound(playerid, SOUND_WRONGCOMMAND, 0.0, 0.0, 0.0);

					do
					{
					    id = random(MAX_ARENE);
					}
					while(!aArene[id][Exists] || !aArene[id][bForPVP]);

					LastRoundType = GAMETYPE_PVP;
					Round_PVPMode = 1;
				    StartRound(id, GAMETYPE_ARENA);
				}
				case GAMETYPE_GUNGAME:
				{
					LastRoundType = GAMETYPE_GUNGAME;
				    StartRound(0, GAMETYPE_GUNGAME);
				}
			}
		}
	}
	else
	{
	    RefreshReadyTDs_Esl();

	    if (pTA != pTB)
	    {
	        format(stringo, sizeof stringo, "Teams not balanced! (%d/%d)", pTA, pTB);
	        SendClientMessageToAll(COLOR_RED, stringo);
	    }
	    else if ((rtA+rtB) != (MinReadyPlayers+MinReadyPlayers))
	    {
	        format(stringo, sizeof stringo, "Required %d players per team. Use /vote minplayers to change it.", MinReadyPlayers);
	        SendClientMessageToAll(COLOR_RED, stringo);
	    }
	    else
	    {
	        if((rtA+rtB) == tP)
	        {
	            if (PlayingRound != TotalRounds -1)
	            {
					new id = 0;

					do {
			  			id = random(basesPacks[CurrentGamepack][maxBases]);
			    	}
			    	while(!bBases[id][Exists]);
			    	LastRoundType = GAMETYPE_BASE;
					StartRound(id, GAMETYPE_BASE, .xrandom = 1);
				}
				else
				{
				    new id;

					do {
			  			id = random(MAX_ARENE);
			    	}
			    	while(!aArene[id][Exists]);
			    	LastRoundType = GAMETYPE_ARENA;
					StartRound(id, GAMETYPE_ARENA, .xrandom = 1);
				}
	        }
	    }
	}
	PlayerPlaySound(playerid, SOUND_SUCCESS, 0.0, 0.0, 0.0);
	return 1;
}
new pDemoID[MAX_PLAYERS];

COMMAND:demo(playerid, params[])
{
	if(InSpec[playerid]!=-1) return SendClientMessage(playerid, red, "You cannot use this command now!"), PlayerPlaySound(playerid, SOUND_WRONGCOMMAND, 0.0, 0.0, 0.0);
	if(Player[playerid][InGame]) return SendClientMessage(playerid, red, "You cannot use this command now!"), PlayerPlaySound(playerid, SOUND_WRONGCOMMAND, 0.0, 0.0, 0.0);
	if(Player[playerid][InDm] != -1) return SendClientMessage(playerid, red, "You cannot use this command now!"), PlayerPlaySound(playerid, SOUND_WRONGCOMMAND, 0.0, 0.0, 0.0);

	new place, id;
	if(sscanf(params, "k<demothing>i", place, id))
	{
 		SendClientMessage(playerid, red, "Use /demo [base/arena/gungame] [id]");
	}
	else
	{
	    switch (place)
	    {
	        case 0:
	        {
	            // base
			    if (id < 0)return SendClientMessage(playerid, red, "Invalid Base ID");
			    if (id >= basesPacks[CurrentGamepack][maxBases])return SendClientMessage(playerid, red, "Invalid Base ID");

			    ShowMenuForPlayer(DemoBase_MenuPOS, playerid);
			    pDemoID[playerid] = id;
	        }
	        case 1:
	        {
	            // arena
			    if (id < 0)return SendClientMessage(playerid, red, "Invalid Arena ID");
			    if (id >= MAX_ARENE)return SendClientMessage(playerid, red, "Invalid Arena ID");
			    if (!aArene[id][Exists]) return SendClientMessage(playerid, red, "Invalid Arena ID");

			    ShowMenuForPlayer(DemoArena_MenuPOS, playerid);
			    pDemoID[playerid] = id;
	        }
	        case 2:
	        {
	            // gungame
			    if (id < 0)return SendClientMessage(playerid, red, "Invalid Gungame ID");
			    if (id >= MAX_GUNGAME)return SendClientMessage(playerid, red, "Invalid Gungame ID");

			    //ShowMenuForPlayer(Demo_MenuPOS, playerid);

			    new rand = random(20);

                SetPlayerInterior(playerid, gGunGame[id][bInterior]);
				SetPlayerCheckpointEx(playerid, gGunGame_SpecialSpawns[id][rand][0], gGunGame_SpecialSpawns[id][rand][1], gGunGame_SpecialSpawns[id][rand][2], 2.0);
				SetPlayerPos(playerid, gGunGame_SpecialSpawns[id][rand][0], gGunGame_SpecialSpawns[id][rand][1], gGunGame_SpecialSpawns[id][rand][2]);

			    format(stringo, sizeof stringo, "* Demo GunGame ID %d" , id);
				SendClientMessage(playerid, COLOR_SYSTEM, stringo);
			    pDemoID[playerid] = id;
	        }
	    }
	}

 	PlayerPlaySound(playerid, SOUND_SUCCESS, 0.0, 0.0, 0.0);
	return true;
}


public OnPlayerSelectedMenuRow(playerid, row)
{
	new Menu:menu = GetPlayerMenu(playerid), id = pDemoID[playerid];
	if (menu == DemoBase_MenuPOS)
 	{
  		switch(row)
  		{
			case 0:
			{
				SetPlayerCheckpointEx(playerid, bBases[id][bAttackers][0], bBases[id][bAttackers][1], bBases[id][bAttackers][2], 2.0);
				SetPlayerPos(playerid, bBases[id][bAttackers][0], bBases[id][bAttackers][1], bBases[id][bAttackers][2]);
				SetPlayerInterior(playerid, bBases[id][bInterior]);

				format(stringo, sizeof stringo, "* Demo base ID %d (Pack: %s) (Attackers!)" , id , basesPacks[CurrentGamepack][packName]);
			}
			case 1:
			{
				SetPlayerCheckpointEx(playerid, bBases[id][bDefenders][0], bBases[id][bDefenders][1], bBases[id][bDefenders][2], 2.0);
				SetPlayerPos(playerid, bBases[id][bDefenders][0], bBases[id][bDefenders][1], bBases[id][bDefenders][2]);
				SetPlayerInterior(playerid, bBases[id][bInterior]);

				format(stringo, sizeof stringo, "* Demo base ID %d (Pack: %s) (Defenders!)" , id , basesPacks[CurrentGamepack][packName]);
			}
			case 2:
			{
				SetPlayerCheckpointEx(playerid, bBases[id][bCheckpoint][0], bBases[id][bCheckpoint][1], bBases[id][bCheckpoint][2], 2.0);
				SetPlayerPos(playerid, bBases[id][bCheckpoint][0], bBases[id][bCheckpoint][1], bBases[id][bCheckpoint][2]);
				SetPlayerInterior(playerid, bBases[id][bInterior]);

				format(stringo, sizeof stringo, "* Demo base ID %d (Pack: %s) (Checkpoint!)" , id , basesPacks[CurrentGamepack][packName]);
			}
		}

		SendClientMessage (playerid, COLOR_SYSTEM, stringo);
	}
	else if(menu == DemoArena_MenuPOS)
	{
		switch(row)
		{
			case 0:
			{
				SetPlayerCheckpointEx(playerid, aArene[id][bAttackers][0], aArene[id][bAttackers][1], aArene[id][bAttackers][2], 2.0);
				SetPlayerPos(playerid, aArene[id][bAttackers][0], aArene[id][bAttackers][1], aArene[id][bAttackers][2]);
				SetPlayerInterior(playerid, aArene[id][bInterior]);

				format(stringo, sizeof stringo, "* Demo Arena ID %d (Spawn 1!)" , id);
			}
			case 1:
			{
				SetPlayerCheckpointEx(playerid, aArene[id][bDefenders][0], aArene[id][bDefenders][1], aArene[id][bDefenders][2], 2.0);
				SetPlayerPos(playerid, aArene[id][bDefenders][0], aArene[id][bDefenders][1], aArene[id][bDefenders][2]);
				SetPlayerInterior(playerid, aArene[id][bInterior]);

				format(stringo, sizeof stringo, "* Demo Arena ID %d (Spawn 2!)" , id);
			}
			case 2:
			{
				SetPlayerCheckpointEx(playerid, aArene[id][bCheckpoint][0], aArene[id][bCheckpoint][1], aArene[id][bCheckpoint][2], 2.0);
				SetPlayerPos(playerid, aArene[id][bCheckpoint][0], aArene[id][bCheckpoint][1], aArene[id][bCheckpoint][2]);
				SetPlayerInterior(playerid, aArene[id][bInterior]);

				format(stringo, sizeof stringo, "* Demo Arena ID %d (Center!)" , id);
			}
		}

		SendClientMessage (playerid, COLOR_SYSTEM, stringo);
    }
    return 1;
}

COMMAND:pm(playerid, params[])
{
	new id, pMessage[ 125 ];
	if(sscanf(params, "is[125]", id, pMessage))
	{
	    SendClientMessage(playerid, red, "Use /pm [id] [text]");
	    PlayerPlaySound(playerid, SOUND_WRONGCOMMAND, 0.0, 0.0, 0.0);
	}
	else
	{
		if(!IsPlayerConnected(id)) return SendClientMessage(playerid, red, "Invalid or not connected playerid."), PlayerPlaySound(playerid, SOUND_WRONGCOMMAND, 0.0, 0.0, 0.0);

		format(stringo, sizeof stringo, "[ PM | %s (%d) ]: %s", Player[playerid][Nickname], playerid, pMessage);
		SendClientMessage(id, 0x38e279AA, stringo);

	    format(stringo, sizeof stringo, "[ PM a %s (%d) ]: %s", Player[id][Nickname], id, pMessage);
        SendClientMessage(playerid, 0x38e279AA, stringo);

		PlayerPlaySound(id, 1085, 0.0, 0.0, 0.0);

		if (gConfig[PMSpec])
		{
		    format (stringo, sizeof stringo, "[ * ADMIN PM SPEC ] PM %s to %s: %s", Player[playerid][Nickname], Player[id][Nickname], pMessage);

			foreach(new i:Player)
			{
			    if(!IsPlayerAdmin(i)) continue;
			    if(i==id||i==playerid) continue;

			    SendClientMessage(i, 0x38e279AA, stringo);
			}
		}
	}
	return true;
}

COMMAND:credits(playerid, params[])
{
	SendClientMessage (playerid, COLOR_LIGHTBLUE, "************************************** "#GAMEMODE_NAME" **************************************");
	SendClientMessage (playerid, COLOR_SYSTEM, "Gamemode created by ReVo_");
	SendClientMessage (playerid, COLOR_SYSTEM, "Thanks to: FlamingRedz (lobby map), Y_Less (sscanf), Morgenstern (ideas/TDHelp), Pain (MySQL)");
	return true;
}

/*
HostName: ï¿½ Sigma Seven TCW/CW ï¿½ SlaughterField A/D ï¿½
Address:  91.121.154.28:7827
Players:  0 / 15
Ping:     144
Mode:     SlaughterField A/D v4.3.0
Map:      Lobby 11:5
*/

COMMAND:cmds(playerid, params[])
{
	new
	    string[ 450 ];

	strcat( string , "{"#COLOR_SYSTEM_FOCUS"}Commands:{"#COLOR_SYSTEM_REST"} /password, /admins, /radio, /afk, /register, /login, /report, /int, /t, /time, /weather, /pinfo.\n");
	strcat( string , "{"#COLOR_SYSTEM_FOCUS"}Commands:{"#COLOR_SYSTEM_REST"} /skin, /final, /fight (/fstyle), /switch, /sync (/s), /dance (/d), /spec, /specoff, /ready, /notready, /dm.\n");
	strcat( string , "{"#COLOR_SYSTEM_FOCUS"}Commands:{"#COLOR_SYSTEM_REST"} /packetloss, /fps, /demo, /setspawn, /stats, /weaponsets, /kill, /disarm.\n\n");

	strcat( string , "{"#COLOR_SYSTEM_FOCUS"}Game commands:{"#COLOR_SYSTEM_REST"} /rem.\n\n");
	strcat( string , "{"#COLOR_SYSTEM_FOCUS"}Admin commands:{"#COLOR_SYSTEM_REST"} /acmd.\n\n");

	ShowPlayerDialog(playerid, DIALOG_NULL, DIALOG_STYLE_MSGBOX, "Commands", string, "Close", "");
    PlayerPlaySound(playerid, SOUND_SUCCESS, 0.0, 0.0, 0.0);
	return true;
}

COMMAND:acmd(playerid, params[])
{
	new lvl = Player[playerid][aLevel];
	if (lvl == _:lUser)
	{
	    SendClientMessage(playerid, red, "You must be admin to use this command..");
	}
	else
	{
		new
		    string[ 450 ];

		strcat( string , "{"#COLOR_SYSTEM_FOCUS"}Commands:{"#COLOR_SYSTEM_REST"} /setteam, /setsub, /start, /end, /pause, /unpause, /sethealth, /setarmour, /healall, /armourall\n");
		strcat( string , "{"#COLOR_SYSTEM_FOCUS"}Commands:{"#COLOR_SYSTEM_REST"} /fs, /play, /config, /setscores, /whois, /settime, /setweather, /goto, /getome, /get\n");
        strcat( string , "{"#COLOR_SYSTEM_FOCUS"}Commands:{"#COLOR_SYSTEM_REST"} /vdestroy, /givemenu, /ban, /kick, /mute, /unmute, /dmkick, /resetscores, /restoreall, /random\n");
        strcat( string , "{"#COLOR_SYSTEM_FOCUS"}Commands:{"#COLOR_SYSTEM_REST"} /setlevel, /lock, /unlock, /readytype, /add, /remove, /readd, /lockdm, /loadpack, /acar\n");
        strcat( string , "{"#COLOR_SYSTEM_FOCUS"}Commands:{"#COLOR_SYSTEM_REST"} /changenotice, /aweaponsets, /allowdm, /slap, /explode, /gmx, /r, /lockvote, /lockteam\n");

        ShowPlayerDialog( playerid , DIALOG_ADMIN_CMDSHOW , DIALOG_STYLE_MSGBOX , "Admin Commands", string , "Close", "");
	}

    PlayerPlaySound(playerid, SOUND_SUCCESS, 0.0, 0.0, 0.0);
	return true;
}

// ***************************************************************************************** */

COMMAND:wmenu(playerid, params[])
{
	#pragma unused params
	if(!RoundStarted) return SendClientMessage(playerid, COLOR_RED, "The round is not started."), PlayerPlaySound(playerid, SOUND_WRONGCOMMAND, 0.0, 0.0, 0.0);
	if(!Player[playerid][InGame]) return SendClientMessage(playerid, COLOR_RED, "You are not in-game."), PlayerPlaySound(playerid, SOUND_WRONGCOMMAND, 0.0, 0.0, 0.0);
	if(Player[playerid][Team] == NULL_TEAM || Player[playerid][Team] == TEAM_REF) return SendClientMessage(playerid, COLOR_RED, "You cannot use this command now."), PlayerPlaySound(playerid, SOUND_WRONGCOMMAND, 0.0, 0.0, 0.0);
	if(Gaming != GAMETYPE_BASE)return SendClientMessage(playerid, COLOR_RED, "You can use this command only while you are playing a base."), PlayerPlaySound(playerid, SOUND_WRONGCOMMAND, 0.0, 0.0, 0.0);
	if( ( RealRMins != ( gConfig[RTime_Mins] - 1 ) || gConfig[RTime_Mins] == RealRMins ) || RealRSecs < 31 )return SendClientMessage(playerid, COLOR_RED, "You can use this command only in the first 30 seconds of the round!"), PlayerPlaySound(playerid, SOUND_WRONGCOMMAND, 0.0, 0.0, 0.0);
	if(Player[playerid][Weaponset] != INVALID_WEAPON_SET)
	{
		Weaponsets[Player[playerid][Weaponset]][TeamSelection][Player[playerid][Team]] --;
	}
	Player[playerid][Weaponset] = INVALID_WEAPON_SET;

	format(stringo, sizeof stringo, "{"#COLOR_SYSTEM_FOCUS"}%s{"#COLOR_SYSTEM_REST"} is showing the gunmenu to himself.", Player[playerid][Nickname]);
    SendClientMessageToAll(COLOR_SYSTEM, stringo);

	MostraWeaponset(playerid);
    PlayerPlaySound(playerid, SOUND_SUCCESS, 0.0, 0.0, 0.0);
	return true;
}

COMMAND:givemenu(playerid, params[])
{
	if(!IsPlayerAdminEx(playerid, lMod)) return true;
    if(!RoundStarted) return SendClientMessage(playerid, COLOR_RED, "The round is not started."), PlayerPlaySound(playerid, SOUND_WRONGCOMMAND, 0.0, 0.0, 0.0);
    if(Gaming!=GAMETYPE_BASE) return SendClientMessage(playerid, COLOR_RED, "You can use this command only in bases."), PlayerPlaySound(playerid, SOUND_WRONGCOMMAND, 0.0, 0.0, 0.0);
	new ids[5] = {-1, ...};

	sscanf(params, "a<i>[5]", ids);

	if(ids[0] == -1)
	{
	    SendClientMessage(playerid, red, "Use /givemenu [id] <fino a 5 ids>");
		PlayerPlaySound(playerid, SOUND_WRONGCOMMAND, 0.0, 0.0, 0.0);
	}
	else
	{
	    new names [MAX_PLAYER_NAME * 5], id, p = 0;
	    new bool:bAlreadyGiven[MAX_PLAYERS] = {false, ...};

	    for (new i = 0; i < 5; i++)
		{
	        if (ids[i] == -1)
			{
			    // strlen = inefficiente in caso di stringhe lunghe
			    // in questo caso potrebbero essere lunghe?
			    // massimo caratteri = 24 * 15 = 360 caratteri
			    // for (new x = 0; x < 360; x ++) if (x == (????????????????)

			    strdel(names, strlen(names)-2, strlen(names));
			    break;
			 	// un id = -1 significa fine lista
			}

			/*
			    dopo che ho controllato che l'id non si ripeta piï¿½ volte continuo il codice
			*/

	        id = ids[i];

            if (bAlreadyGiven[id])
		    {
				continue;
			}

	        bAlreadyGiven[id] = true;

			if(!IsPlayerConnected(id))
			{
				format(stringo, sizeof stringo, "(#%d) Invalid player.", id);
				SendClientMessage(playerid, red, stringo);
				continue;
			}

			if(!Player[id][InGame])
			{
				format(stringo, sizeof stringo, "(#%d) This player is not in-game.", id);
				SendClientMessage(playerid, red, stringo);
				continue;
			}

			if(Player[id][Weaponset] != INVALID_WEAPON_SET)
			{
				Weaponsets[Player[id][Weaponset]][TeamSelection][Player[id][Team]] --;
			}

			Player[id][Weaponset] = INVALID_WEAPON_SET;
			MostraWeaponset(id);

			//if (i != 0) strcat(names, ", ");
			strcat(names, sprintf("%s, ", Player[id][Nickname]));
			p ++;
	    }

		if (p > 0)
		{
	    	format(stringo, sizeof stringo, "{"#COLOR_SYSTEM_FOCUS"}%s{"#COLOR_SYSTEM_REST"} has showed the gunmenu to: {"#COLOR_SYSTEM_FOCUS"}%s.", Player[playerid][Nickname], names);
            SendClientMessageToAll(COLOR_SYSTEM, stringo);

			PlayerPlaySound(playerid, SOUND_SUCCESS, 0.0, 0.0, 0.0);
		}
	}
	return 1;
}

COMMAND:gm(playerid, params[])
{
	return cmd_givemenu(playerid, params);
}

COMMAND:gunmenu(playerid, params[])
{
	return cmd_wmenu(playerid, params);
}
/*
COMMAND:tw(playerid, params[])
{
	if (Player[playerid][Team] != TEAM_A && Player[playerid][Team] != TEAM_B) return SendClientMessage(playerid, red, "You cannot use this command now.");
	if (!RoundStarted)return SendClientMessage(playerid, red, "This command is valid only when a round is running");
	if (Gaming != GAMETYPE_BASE)return SendClientMessage(playerid, red, "This command is valid only when an AAD round is running");

	new
	    str [700],
		t = Player[playerid][Team],
		spassers = 0, snipers = 0, szSpassers[128], szSnipers[128], m4 = 0, deagles = 0, totalteam[128];

	str = "- Primary weapons\n\tSpassers: ";

	foreach(new i:Player)
	{
		if (Player[i][InGame] && Player[i][Team] == t)
		{
		    switch (Player[i][Weaponset]) // deagle/m4 e /sniper/deagle sono ignorati :| 9 10
		    {
		        case 7,8:
		        {
		            spassers ++;
		            strcat (szSpassers, sprintf("%s, ", Player[i][Nickname]));
		        }
		        case 5,6:
		        {
		            snipers ++;
		            strcat (szSnipers, sprintf("%s, ", Player[i][Nickname]));
		        }
				case 0,1,2:
				{
				    deagles++;
				}
				case 3,4:
				{
				    m4++;
				}
		    }

	    	if (Player[i][Team] == TEAM_A) format(totalteam, sizeof totalteam, "%s\t{0469FF}%s\t\t%s\n", totalteam, Weaponsets[Player[i][Weaponset]][SetName], Player[i][Nickname]);
			else format(totalteam, sizeof totalteam, "%s\t{43E41E}%s\t\t%s\n", totalteam, Player[i][Nickname], Weaponsets[Player[i][Weaponset]][SetName]);
		}
	}

	strcat (str, sprintf("%s\n", szSpassers));
	strcat (str, "\tSnipers: ");
	strcat (str, sprintf("%s\n- Secondary weapons\n", szSnipers));
	strcat (str, sprintf("\tSpas12: %d\tSnipers: %d\tDeagle: %d\tM4: %d\n", spassers, snipers, deagles, m4));
	strcat (str, "\n- Team\n");
	strcat (str, totalteam);

	ShowPlayerDialog(playerid, DIALOG_NULL, DIALOG_STYLE_LIST, "Team weapons info", str, "Close", "");
	return true;
}*/

COMMAND:rp(playerid, params[])
{
	new w[13], a[13], hold = GetPlayerWeapon(playerid);

	for( new i = 0; i < 13 ; i ++ )
	{
 		GetPlayerWeaponData(playerid, i, w[i], a[i]);

		if (w[i] == 46)
		{
		    w[i] = 0;
			a[i] = 0;
		}
	}

	ResetPlayerWeapons(playerid);

	for ( new i = 0; i < 13 ; i ++ )
	{
	    GivePlayerWeapon( playerid , w[i] , a[i] );
	}

	SetPlayerArmedWeapon(playerid, hold);
	SendClientMessage(playerid, COLOR_SYSTEM, "Parachute removed.");
	return true;
}

COMMAND:para(playerid, params[])
{
	GivePlayerWeapon(playerid, 46, 1);
	SendClientMessage(playerid, COLOR_SYSTEM, "Parachute given, use /rp to remove.");
	return true;
}

COMMAND:dm(playerid, params[])
{
	#pragma unused params
	if(InSpec[playerid]!=-1) return SendClientMessage(playerid, red, "You cannot use this command now!"), PlayerPlaySound(playerid, SOUND_WRONGCOMMAND, 0.0, 0.0, 0.0);
	if(Player[playerid][InGame]) return SendClientMessage(playerid, COLOR_RED, "You cannot use this command since you are in-game!"), PlayerPlaySound(playerid, SOUND_WRONGCOMMAND, 0.0, 0.0, 0.0);
 	MySQLStatus[TotalQuerys] ++; mysql_tquery(g_MySQLConnection, sprintf("UPDATE bestdmplayer SET damage = '%d', kills = '%d' WHERE nickname = '%s' AND dmid = '%d'", Player[playerid][DDamage], Player[playerid][DKills], Player[playerid][Nickname], Player[playerid][InDm]), "", "");

	new id;
	if (sscanf(params, "i", id))
	{
	    new szString[400]; // da 300 a 500 (200 chars in piï¿½ useless da cambiare quando possibile)
	    for( new i = 0; i < sizeof Deathmatchs; i++ )
	    {
	        strcat( szString , sprintf( "(%d)\t%s\n" , i + 1 , Deathmatchs[i][DMName] ));
	    }

		ShowPlayerDialog(playerid, DIALOG_DEATHMATCHLIST, DIALOG_STYLE_LIST, "DM List", szString, "Go", "Close");
	}
	else
	{
		if (id < 1 || id > MAX_DMS) return SendClientMessage(playerid, COLOR_RED, "Deathmatchs id min: 1 - max: 12"), PlayerPlaySound(playerid, SOUND_WRONGCOMMAND, 0.0, 0.0, 0.0);
        id = id - 1;
		if (DMLocked[id])
		{
		    if (strlen(DMLocked_Password[id]) > 1)
		    {
			    Player_DmTry[playerid] = id;
	      		ShowPlayerDialog( playerid , DIALOG_DEATHMATCHPASSWORD , DIALOG_STYLE_PASSWORD , "Locked deathmatch", "Insert the password to enter this deathmatch.", "Enter", "Close");
			}
			else
			{
			    SendClientMessage(playerid, COLOR_RED, "This deathmatch is locked."), PlayerPlaySound(playerid, SOUND_WRONGCOMMAND, 0.0, 0.0, 0.0);
			}
            return true;
		}

        PutPlayerInDm (playerid, id);
		PlayerPlaySound(playerid, SOUND_SUCCESS, 0.0, 0.0, 0.0);
	}
	return true;
}

stock PutPlayerInDm(playerid, id)
{
	Player[playerid][InDm] 		= id;
//		TextDrawHideForPlayer(playerid, HintTD);

	SetPlayerPos(playerid, 0.0, 0.0, 0.0);

	SetPlayerColor(playerid, COLOR_DM);

	SetSpawnInfo(playerid, playerid, GetPlayerSkinEx(playerid), Deathmatchs[Player[playerid][InDm]][Spawn][0] - MAX_RANDOM_SPAWN + random( MAX_RANDOM_SPAWN ), Deathmatchs[Player[playerid][InDm]][Spawn][1] - MAX_RANDOM_SPAWN + random( MAX_RANDOM_SPAWN ), Deathmatchs[Player[playerid][InDm]][Spawn][2], Deathmatchs[Player[playerid][InDm]][Spawn][3], Deathmatchs[Player[playerid][InDm]][Weapon1], 9999, Deathmatchs[Player[playerid][InDm]][Weapon2], 9999, Deathmatchs[Player[playerid][InDm]][Weapon3], 9999);
    SpawnPlayer(playerid);
	format(stringo, sizeof stringo, "{"#COLOR_SYSTEM_FOCUS"}%s{"#COLOR_SYSTEM_REST"} has entered /dm {"#COLOR_SYSTEM_FOCUS"}%d", Player[playerid][Nickname], id + 1);
	SendClientMessageToAll(COLOR_SYSTEM, stringo);
	SetPlayerVirtualWorld(playerid, id + 1);
	MySQLStatus[TotalQuerys] ++; mysql_tquery(g_MySQLConnection, sprintf ("SELECT damage, kills FROM bestdmplayer WHERE nickname = '%s' AND dmid = '%d'", Player[playerid][Nickname], id), "OnDeathmatchStats", "ii", playerid, id);
}

COMMAND:bestdm(playerid, params[])
{
	new id;

	if (sscanf(params, "i", id))
	{
	    if (Player[playerid][InDm] == -1)
	    {
	        SendClientMessage(playerid, red, "Use /bestdm [ID] or go in the dm.");
	    }
	    else
	    {
	        MySQLStatus[TotalQuerys] ++; mysql_tquery (g_MySQLConnection, sprintf ("SELECT damage, kills, nickname FROM bestdmplayer WHERE dmid = '%d' ORDER BY damage DESC", Player[playerid][InDm]), "OnDeathmatchStatsShow", "ii", playerid, Player[playerid][InDm]);
	    }
	    return true;
	}

	if (id < 1 || id > MAX_DMS) return SendClientMessage (playerid, red, "Invalid DM id.");
 	MySQLStatus[TotalQuerys] ++; mysql_tquery (g_MySQLConnection, sprintf ("SELECT damage, kills, nickname FROM bestdmplayer WHERE dmid = '%d' ORDER BY damage DESC", id - 1), "OnDeathmatchStatsShow", "ii", playerid, id - 1);
	return true;
}

forward OnDeathmatchStatsShow(playerid, dm);
public OnDeathmatchStatsShow(playerid, dm)
{
    if (!Player[playerid][Connected]) return true;

	new rows, fields;
	cache_get_data (rows, fields);

	new tmp [24], dmg, kills;
	new msg [500];

	strcat (msg, sprintf ("{CCE8CC}-- Best 10 {5FE15D}%s{CCE8CC} deathmatch players:\n\n", Deathmatchs[dm][DMName]));
	strcat (msg, "#\tKills\tDamage\tNickname\n");

	for (new i = 0; i < 10; i++)
	{
	    if (i >= rows)
	    {
		    switch (i)
		    {
		        case 0:   strcat (msg, 			"{EDF400}1\t0\t0\t\tN/A\n"  			);
		        case 1:   strcat (msg, 			"{C0C0C0}2\t0\t0\t\tN/A\n"  			);
		        case 2:   strcat (msg, 			"{CD7F32}3\t0\t0\t\tN/A\n"          	);
		        default:  strcat (msg, sprintf ("{5FE15D}%d\t0\t0\t\tN/A\n" , i + 1 	));
		    }
	    }
	    else
	    {
		    cache_get_field_content (i, "damage"   , tmp); dmg   = strval (tmp);
			cache_get_field_content (i, "kills"    , tmp); kills = strval (tmp);
			cache_get_field_content (i, "nickname" , tmp);

		    switch (i)
		    {
		        case 0:   strcat (msg, sprintf("{EDF400}1\t%d\t%d\t\t%s\n"  , kills, dmg, tmp));
		        case 1:   strcat (msg, sprintf("{C0C0C0}2\t%d\t%d\t\t%s\n"  , kills, dmg, tmp));
		        case 2:   strcat (msg, sprintf("{CD7F32}3\t%d\t%d\t\t%s\n"  , kills, dmg, tmp));
		        default:  strcat (msg, sprintf("{5FE15D}%d\t%d\t%d\t\t%s\n" , i + 1, kills, dmg, tmp));
		    }
		}
	}

	ShowPlayerDialog(playerid, DIALOG_NULL, DIALOG_STYLE_MSGBOX, "Deathmatch Best Players", msg, "Close", "");
	return true;
}

forward OnDeathmatchStats(playerid, dm);
public OnDeathmatchStats(playerid, dm)
{
	if (!Player[playerid][Connected]) return true;

	new rows, fields;
	cache_get_data (rows, fields);

	if (rows)
	{
	    new tmp [10];

	    cache_get_field_content (0, "damage", tmp);
	    Player[playerid][DDamage] = strval (tmp);

	    cache_get_field_content (0, "kills", tmp);
	    Player[playerid][DKills] = strval (tmp);

	    format(stringo, sizeof stringo, "** Deathmatch Stats ** Damage: %d - Kills: %d. Use /bestdm for deathmatch ranking", Player[playerid][DDamage], Player[playerid][DKills]);
        SendClientMessage (playerid, COLOR_SYSTEM, stringo);
	}
	else
	{
	    Player[playerid][DKills]  = 0;
	    Player[playerid][DDamage] = 0;

	    MySQLStatus[TotalQuerys] ++; mysql_tquery (g_MySQLConnection, sprintf("INSERT INTO bestdmplayer (dmid, nickname, damage, kills) VALUES ('%d', '%s', '0', '0')", dm, Player[playerid][Nickname]), "", "");
		SendClientMessage (playerid, COLOR_SYSTEM, "** Use /bestdm for deathmatch ranking");
	}
	return true;
}

COMMAND:matchs(playerid, params[])
{
	mysql_tquery (g_MySQLConnection, "SELECT id, teama, teamb, scorea, scoreb, totalrounds, playedrounds, time FROM matchdata WHERE incorso = 0 ORDER BY time DESC LIMIT 0, "#MAX_MATCHS, "OnMatchDataOK", "i", playerid);
	return true;
}

forward OnMatchDataOK(playerid);
public OnMatchDataOK(playerid)
{
	new rows, fields;
	cache_get_data (rows, fields);

	if (rows)
	{
		// è stato trovato qualche match
		new message [128];
//		new tmp [24];//24, but too big.

		for (new i = 0; i < rows; i++)
		{
		    CachedMatchInfo[playerid][i][c_matchID] = cache_get_field_content_int(i, "id");
		    CachedMatchInfo[playerid][i][c_scoreA] = cache_get_field_content_int(i, "scorea");
		    CachedMatchInfo[playerid][i][c_scoreB] = cache_get_field_content_int(i, "scoreb");

		    CachedMatchInfo[playerid][i][c_pRounds] = cache_get_field_content_int(i, "playedrounds");
		    CachedMatchInfo[playerid][i][c_tRounds] = cache_get_field_content_int(i, "totalrounds");

		    cache_get_field_content(i, "teama", c_Cached_MatchInfo_TeamNamesA[playerid][i], .max_len = 128);
		    cache_get_field_content(i, "teamb", c_Cached_MatchInfo_TeamNamesB[playerid][i], .max_len = 128);

		    printf("Row %d, teama: %s, teamb: %s", i, c_Cached_MatchInfo_TeamNamesA[playerid][i], c_Cached_MatchInfo_TeamNamesB[playerid][i]);

			if (CachedMatchInfo[playerid][i][c_scoreA] > CachedMatchInfo[playerid][i][c_scoreB])
			{
			    format (message, sizeof message, "%s{00ff48}%s{FFFFFF} %d vs %d {ff0000}%s{FFFFFF}\n", message, c_Cached_MatchInfo_TeamNamesA[playerid][i], CachedMatchInfo[playerid][i][c_scoreA],
                                                                                                             CachedMatchInfo[playerid][i][c_scoreB], c_Cached_MatchInfo_TeamNamesB[playerid][i]);
			}
			else if (CachedMatchInfo[playerid][i][c_scoreA] < CachedMatchInfo[playerid][i][c_scoreB])
			{
			    format (message, sizeof message,  "%s{ff0000}%s{FFFFFF} %d vs %d {00ff48}%s{FFFFFF}\n", message, c_Cached_MatchInfo_TeamNamesA[playerid][i], CachedMatchInfo[playerid][i][c_scoreA],
                                                                                                             CachedMatchInfo[playerid][i][c_scoreB], c_Cached_MatchInfo_TeamNamesB[playerid][i]);
			}
			else
			{
			    format (message, sizeof message,  "%s{faff00}%s{FFFFFF} %d vs %d {faff00}%s{FFFFFF}\n", message, c_Cached_MatchInfo_TeamNamesA[playerid][i], CachedMatchInfo[playerid][i][c_scoreA],
                                                                                                             CachedMatchInfo[playerid][i][c_scoreB], c_Cached_MatchInfo_TeamNamesB[playerid][i]);
			}

		}

		ShowPlayerDialog (playerid, DIALOG_SCEGLI_MATCH, DIALOG_STYLE_LIST, "Matchs", message, "Open", "Close");
	}
	else
	{
	    SendClientMessage(playerid, COLOR_RED, "No matchs played.");
	}
}

public OnQueryError(errorid, error[], callback[], query[], connectionHandle)
{
	// Se la gamemode non ï¿½ completamente caricata
	// Rieseguo la query finchï¿½ la gamemode non si carica completamente

	if (FullyReady != FULLY_READY_STEPS)
	{
	    // sad
	    // can cause crash?
	    mysql_tquery(g_MySQLConnection, query, callback, "", "");
	    printf("Query (Steps: %d / %d)(%d: %s): %s", FullyReady, FULLY_READY_STEPS, errorid, error, query);
	}

	printf("EID: %d | Error: %s | Query: %s", errorid, error, query);
	return 1;
}

COMMAND:heal(playerid, params[]) {
	#pragma unused params
	if(Player[playerid][InDm] == -1) return SendClientMessage(playerid, COLOR_RED, "You can only heal yourself if you are in a DM."), PlayerPlaySound(playerid, SOUND_WRONGCOMMAND, 0.0, 0.0, 0.0);
	if(Player[playerid][InGame]) return SendClientMessage(playerid, COLOR_RED, "You cannot use this command since you are in-game!"), PlayerPlaySound(playerid, SOUND_WRONGCOMMAND, 0.0, 0.0, 0.0);
	SetPlayerHealth(playerid, 100.0);
	SetPlayerArmour(playerid, 100.0);
    PlayerPlaySound(playerid, SOUND_SUCCESS, 0.0, 0.0, 0.0);
	return true;
}

COMMAND:lobby(playerid, params[])
{
	#pragma unused params
	if(InSpec[playerid]!=-1) return SendClientMessage(playerid, red, "You cannot use this command now!"), PlayerPlaySound(playerid, SOUND_WRONGCOMMAND, 0.0, 0.0, 0.0);
	if(Player[playerid][InGame]) return SendClientMessage(playerid, COLOR_RED, "You cannot use this command since you are in-game!"), PlayerPlaySound(playerid, SOUND_WRONGCOMMAND, 0.0, 0.0, 0.0);
//	if(InRaceCar[playerid]) return SendClientMessage(playerid, COLOR_RED, "Sei in race!");
	SetPlayerPos(playerid, 0.0, 0.0, 0.0);

	if( Player[playerid][InDm] != -1 )
	{
		MySQLStatus[TotalQuerys] ++; mysql_tquery(g_MySQLConnection, sprintf("UPDATE bestdmplayer SET damage = '%d', kills = '%d' WHERE nickname = '%s' AND dmid = '%d'", Player[playerid][DDamage], Player[playerid][DKills], Player[playerid][Nickname], Player[playerid][InDm]), "", "");
		Player[playerid][InDm] = -1;
//		if (!RoundStarted) TextDrawShowForPlayer(playerid, HintTD);
	}

	DisablePlayerCheckpoint(playerid);
	SetSpawnInfo(playerid, playerid, GetPlayerSkinEx(playerid), Lobby[0] - MAX_RANDOM_SPAWN + random( MAX_RANDOM_SPAWN ), Lobby[1] - MAX_RANDOM_SPAWN + random( MAX_RANDOM_SPAWN ), Lobby[2], Lobby[3], 0, 0, 0, 0, 0, 0);
	SpawnPlayer(playerid);

	SetPlayerVirtualWorld(playerid, NORMAL_WORLD);

	format (stringo, sizeof stringo, "{"#COLOR_SYSTEM_FOCUS"}%s{"#COLOR_SYSTEM_REST"} came back to the Lobby", Player[playerid][ Nickname ]);
    SendClientMessageToAll(COLOR_SYSTEM, stringo);

    PlayerPlaySound(playerid, SOUND_SUCCESS, 0.0, 0.0, 0.0);
	return true;
}

COMMAND:dmq(playerid, params[]) { return cmd_lobby(playerid, params); }

COMMAND:setlevel(playerid, params[])
{
	if (!IsPlayerAdmin(playerid) && !IsPlayerAdminEx(playerid, lAdmin, false)) {
	    SendClientMessage (playerid, COLOR_RED, "You must be an admin to use this command.");
		return true;
	}

	new id, level;
	if(sscanf(params, "ik<cmd_alvl>", id, level))
	{
		SendClientMessage( playerid , red , "Use /setlevel [id] [Remove/Mod/NewbieA/Admin]");
		PlayerPlaySound(playerid, SOUND_WRONGCOMMAND, 0.0, 0.0, 0.0);
	}
	else
	{
	    switch (level)
		{
		    case 0:
			{
			    format (stringo, sizeof stringo, "Admin/Mod {"#COLOR_SYSTEM_FOCUS"}%s{"#COLOR_SYSTEM_REST"} has set {"#COLOR_SYSTEM_FOCUS"}%s{"#COLOR_SYSTEM_REST"} as User", Player[playerid][Nickname], Player[id][Nickname]);
				Player[id][aLevel] = _:lUser;
			}
		    case 1:
			{
			    format (stringo, sizeof stringo, "Admin/Mod {"#COLOR_SYSTEM_FOCUS"}%s{"#COLOR_SYSTEM_REST"} has set {"#COLOR_SYSTEM_FOCUS"}%s{"#COLOR_SYSTEM_REST"} as Mod", Player[playerid][Nickname], Player[id][Nickname]);
				Player[id][aLevel] = _:lMod;
			}
		    case 2:
			{
			    format (stringo, sizeof stringo, "Admin/Mod {"#COLOR_SYSTEM_FOCUS"}%s{"#COLOR_SYSTEM_REST"} has set {"#COLOR_SYSTEM_FOCUS"}%s{"#COLOR_SYSTEM_REST"} as Newbie Admin", Player[playerid][Nickname], Player[id][Nickname]);
				Player[id][aLevel] = _:lNbAdmin;
			}
		    case 3:
			{
				format (stringo, sizeof stringo, "Admin/Mod {"#COLOR_SYSTEM_FOCUS"}%s{"#COLOR_SYSTEM_REST"} has set {"#COLOR_SYSTEM_FOCUS"}%s{"#COLOR_SYSTEM_REST"} as Admin", Player[playerid][Nickname], Player[id][Nickname]);
				Player[id][aLevel] = _:lAdmin;
			}
		    default:
		    {
		    	SendClientMessage( playerid , red , "Use /setlevel [id] [Remove/Mod/Admin]");
		    	PlayerPlaySound(playerid, SOUND_WRONGCOMMAND, 0.0, 0.0, 0.0);
		    	return false;
		    }
		}

		SendClientMessageToAll(COLOR_SYSTEM, stringo);

	    PlayerPlaySound(playerid, SOUND_SUCCESS, 0.0, 0.0, 0.0);

		if (Player[id][Loggen])
		{
//		    new str[ 70 ];
//			mysql_format(g_MySQLConnection, str, "UPDATE users SET level = '%d' WHERE nickname = '%e'", Player[id][aLevel], Player[id][Nickname]);
//			MySQLStatus[TotalQuerys] ++; mysql_tquerymysql_tquery(g_MySQLConnection, str, true, "", "");

			MySQLStatus[TotalQuerys] ++; mysql_tquery(g_MySQLConnection, sprintf("UPDATE users SET level = '%d' WHERE nickname = '%s'", Player[id][aLevel], Player[id][Nickname]) , "", "");
		}
	}
	return true;
}

COMMAND:setlvltemp(playerid, params[])
{
	if(!IsPlayerAdminEx(playerid, lRoot)) return true;
	new id;
	if(sscanf(params, "i", id))
	{
	    SendClientMessage( playerid , red , "Use /setlvltemp [id]");
	    PlayerPlaySound(playerid, SOUND_WRONGCOMMAND, 0.0, 0.0, 0.0);
	}
	else
	{
		if(!IsPlayerConnected(id)) return SendClientMessage( playerid , red , "Not connected"),PlayerPlaySound(playerid, SOUND_WRONGCOMMAND, 0.0, 0.0, 0.0);
		if(Player[id][tmpLevel])
		{
			format (stringo, sizeof stringo, "Admin/Mod {"#COLOR_SYSTEM_FOCUS"}%s{"#COLOR_SYSTEM_REST"} removed tmp powers to {"#COLOR_SYSTEM_FOCUS"}%s{"#COLOR_SYSTEM_REST"}", Player[playerid][Nickname], Player[id][Nickname]);
		}
		else
		{
			format (stringo, sizeof stringo, "Admin/Mod {"#COLOR_SYSTEM_FOCUS"}%s{"#COLOR_SYSTEM_REST"} gave tmp powers to {"#COLOR_SYSTEM_FOCUS"}%s{"#COLOR_SYSTEM_REST"}", Player[playerid][Nickname], Player[id][Nickname]);
		}
		SendClientMessageToAll(COLOR_SYSTEM, stringo);

		Player[id][tmpLevel] = !Player[id][tmpLevel];
	    PlayerPlaySound(playerid, SOUND_SUCCESS, 0.0, 0.0, 0.0);
	}
	return true;
}

COMMAND:config(playerid, params[])
{
	#pragma unused params
	if(!IsPlayerAdminEx(playerid, lAdmin)) return true;
	MostraConfig(playerid);
	PlayerPlaySound(playerid, SOUND_SUCCESS, 0.0, 0.0, 0.0);
	return true;
}

stock OpenPlayerDialog( playerid , PDialogs:dialog )
{
	new
 		str[ 500 ];

	switch (PDialogs:dialog)
	{
	    case PDIALOG_TEAMS:
	    {
			strcat(str, "{"#SEZIONE_TEAMA"}- Team ");
			strcat(str, iTeam[TEAM_A][Name]);
			strcat(str, "\n");
			strcat(str, "{"#SEZIONE_TEAMA"}\tChange name\n");
		    strcat(str, "{"#SEZIONE_TEAMA"}\tChange skin\n");

			strcat(str, "{"#SEZIONE_TEAMA"}\tReset scores\t\t\t\t");
			strcat(str, numstr(iTeam[TEAM_A][RoundWins]));
			strcat(str, "\n");
			strcat(str, "{"#SEZIONE_TEAMA"}\tRole\t\t\t\t\t");
			strcat(str, GetRoleName(TeamRole[TEAM_A]));
		    strcat(str, "\n");

			strcat(str, "{"#SEZIONE_TEAMB"}- Team ");
			strcat(str, iTeam[TEAM_B][Name]);
			strcat(str, "\n");
			strcat(str, "{"#SEZIONE_TEAMB"}\tChange name\n");
		    strcat(str, "{"#SEZIONE_TEAMB"}\tChange skin\n");

			strcat(str, "{"#SEZIONE_TEAMB"}\tReset scores\t\t\t\t");
			strcat(str, numstr(iTeam[TEAM_B][RoundWins]));
			strcat(str, "\n");
			strcat(str, "{"#SEZIONE_TEAMB"}\tRole\t\t\t\t\t");
			strcat(str, GetRoleName(TeamRole[TEAM_B]));
		    strcat(str, "\n");

			strcat(str, "{D696F9}- Team ");
		    strcat(str, iTeam[TEAM_REF][Name]);
		    strcat(str, "\n");
		    strcat(str, "{D696F9}\tChange skin\n");

		    ShowPlayerDialog( playerid , DIALOG_CONFIG_TEAMMODULE , DIALOG_STYLE_LIST , "Teams" , str , "Edit" , "Back" );
	    }
	    case PDIALOG_GAMECONFIG:
	    {
	        strcat(str, "{"#COLORE_SEZIONE"}- Gaming:\n");
			strcat(str, "{"#COLORE_SCRITTE"}\tGame mode \t\t\t\t");
			switch (gConfig[GameMode])
			{
			    case GAMEMODE_NORMAL: strcat(str, "Slaughterfield");
			    case GAMEMODE_ESL: strcat(str, "ESL");
				case GAMEMODE_NOCBUG: strcat(str, "NoCbug");
			}
			strcat(str, "\n");
			strcat(str, "{"#COLORE_SCRITTE"}\tRound time \t\t\t\t");
			strcat(str, numstr(gConfig[RTime_Mins]));
			strcat(str, ":00\n");
			strcat(str, "{"#COLORE_SCRITTE"}\tCheckpoint\t\t\t\t");
			if(gConfig[UCp])
			{
				strcat(str, "{"#COLORE_ENABLED"}Enabled\n");
			}
			else
			{
			    strcat(str, "{"#COLORE_DISABLED"}Disabled\n");
			}
			strcat(str, "{"#COLORE_SCRITTE"}\tCheckpoint Time\t\t\t");
			strcat(str, numstr(gConfig[TCp]));
			strcat(str, "\n");
			strcat(str, "{"#COLORE_SCRITTE"}\tTDM Kills\t\t\t\t");
			strcat(str, numstr(gConfig[TDMKills]));
			strcat(str, "\n");
			strcat(str, "\t{"#COLORE_SCRITTE"}Healthbars\t\t\t\t");
			if (gConfig[UseHealthBars])
			{
			    strcat(str, "{"#COLORE_ENABLED"}Enabled\n");
			}
			else
			{
			    strcat(str, "{"#COLORE_DISABLED"}Disabled\n");
			}
			strcat(str, "\t{"#COLORE_SCRITTE"}AntiCbug\t\t\t\t");
			if (gConfig[AntiCBug])
			{
			    strcat(str, "{"#COLORE_ENABLED"}Enabled\n");
			}
			else
			{
			    strcat(str, "{"#COLORE_DISABLED"}Disabled\n");
			}

			strcat(str, "\t{"#COLORE_SCRITTE"}Skin Swap\t\t\t\t\n");
			/*if (gConfig[SkinSwap])
			{
			    strcat(str, "{"#COLORE_ENABLED"}Enabled\n");
			}
			else
			{
			    strcat(str, "{"#COLORE_DISABLED"}Disabled\n");
			}*/

			strcat(str, "\t{"#COLORE_SCRITTE"}PVP Weapons\t\t\t\t");
			strcat( str , sprintf ("%s %s %s %s %s\n",
				(PVPWeapons[0] > 0 ? aWeaponNames[PVPWeapons[0]] : ("")),
				(PVPWeapons[1] > 0 ? aWeaponNames[PVPWeapons[1]] : ("")),
				(PVPWeapons[2] > 0 ? aWeaponNames[PVPWeapons[2]] : ("")),
				(PVPWeapons[3] > 0 ? aWeaponNames[PVPWeapons[3]] : ("")),
				(PVPWeapons[4] > 0 ? aWeaponNames[PVPWeapons[4]] : ("")))
			);

//			strcat(str, "{"#COLORE_SEZIONE"}- Start modes:\n");
//
			ShowPlayerDialog( playerid , DIALOG_CONFIG_GAMECONFMODULE , DIALOG_STYLE_LIST , "Game config" , str , "Edit" , "Back" );
	    }
	    case PDIALOG_DEBUG:
	    {
	        strcat(str, "{"#COLORE_SEZIONE"}Textdraws status\n");
	        strcat(str, "{"#COLORE_SEZIONE"}MySQL status\n");

	        ShowPlayerDialog (playerid, DIALOG_CONFIG_DEBUGMODULE , DIALOG_STYLE_LIST , "Debug" , str , "Check" , "Back" );
	    }
	}
	return true;
}

stock MostraConfig(playerid)
{
	new
	    str[ 500 ];

	strcat(str, "{"#COLORE_SEZIONE"}- Lobby Settings\n");
	strcat(str, "{"#COLORE_SCRITTE"}\tChange lobby\n");
	strcat(str, "{"#COLORE_SCRITTE"}\tLobby Vehicles\t\t\t\t");
	if (gConfig[LobbyVehicles])
	{
	    strcat(str, "{"#COLORE_ENABLED"}Enabled\n");
	}
	else
	{
	    strcat(str, "{"#COLORE_DISABLED"}Disabled\n");
	}
	strcat(str, "{"#COLORE_SCRITTE"}\tLobby Weapons\t\t\t");
	if (gConfig[LobbyWeapons])
	{
	    strcat(str, "{"#COLORE_ENABLED"}Enabled\n");
	}
	else
	{
	    strcat(str, "{"#COLORE_DISABLED"}Disabled\n");
	}
	strcat(str, "{"#COLORE_SCRITTE"}\tGlobal Chat\t\t\t\t");
	if (gConfig[GlobalChat])
	{
	    strcat(str, "{"#COLORE_ENABLED"}Enabled\n");
	}
	else
	{
	    strcat(str, "{"#COLORE_DISABLED"}Disabled\n");
	}
	strcat(str, "{"#COLORE_SCRITTE"}\tAuto AFK\t\t\t\t");
	if (gConfig[AutoAFK])
	{
	    strcat(str, "{"#COLORE_ENABLED"}Enabled\n");
	}
	else
	{
	    strcat(str, "{"#COLORE_DISABLED"}Disabled\n");
	}

	strcat(str, "{"#COLORE_SEZIONE"}- Limits\n");
	strcat(str, "{"#COLORE_SCRITTE"}\tFPS Limit\t\t\t\t");
	if(gConfig[EFpsLimit])
	{
	    strcat(str, "{"#COLORE_ENABLED"}Enabled{"#COLORE_SCRITTE"}, Limit: ");
	    strcat(str, numstr(gConfig[FpsLimit]));
        strcat(str, "\n");
	}
	else
	{
	    strcat(str, "{"#COLORE_DISABLED"}Disabled\n");
	}

	strcat(str, "{"#COLORE_SCRITTE"}\tPacketloss Limit\t\t\t");
	if(gConfig[EPLLimit])
	{
	    strcat(str, sprintf ("{"#COLORE_ENABLED"}Enabled{"#COLORE_SCRITTE"}, Limit: %.1f\n", gConfig[PlLimit]));
	}
	else
	{
	    strcat(str, "{"#COLORE_DISABLED"}Disabled\n");
	}

	strcat(str, "{"#COLORE_SCRITTE"}\tPing limit\t\t\t\t");
	if(gConfig[EPingLimit])
	{
	    strcat(str, "{"#COLORE_ENABLED"}Enabled{"#COLORE_SCRITTE"}, Limit: ");
	    strcat(str, numstr(gConfig[PingLimit]));
	    strcat(str, "\n");
	}
	else
	{
	    strcat(str, "{"#COLORE_DISABLED"}Disabled\n");
	}

	strcat(str, ">> Teams\n");
	strcat(str, ">> Game config\n");
	strcat(str, ">> Debug\n");

	ShowPlayerDialog(playerid, DIALOG_CONFIG, DIALOG_STYLE_LIST, "Gamemode Settings", str, "Edit", "Close");
	return true;
}

stock numstr(num)
{
	new
 		str[32];
	format(str, sizeof (str), "%d", num);
 	return str;
}

COMMAND:switch(playerid, params[])
{
	#pragma unused params
	if(Player[playerid][InGame]) return SendClientMessage(playerid, COLOR_RED, "You cannot change your team while you are in-game."), PlayerPlaySound(playerid, SOUND_WRONGCOMMAND, 0.0, 0.0, 0.0);
	if(InSpec[playerid] != -1) return SendClientMessage(playerid, COLOR_RED, "You cannot use this command now"), PlayerPlaySound(playerid, SOUND_WRONGCOMMAND, 0.0, 0.0, 0.0);

	new team;
	sscanf(params, "K<teamname>(-1)", team);

	//#define locked_team_frase "Locked team."
	if (team != -1 && iTeam[team][tLocked]) {
	    SendClientMessage (playerid, red, "Locked team.");
		return 1;
	}

    new Float:x, Float:y, Float:z, Float:a;

	switch (team)
	{
	    case TEAM_A:
	    {
	        iTeam[Player[playerid][Team]][tPlayers] --;
	        Player[playerid][Team] = TEAM_A;
	        iTeam[TEAM_A][tPlayers] ++;
	        //0469FF
	 		format(stringo, sizeof stringo, "{"#SC_TEAMA"}%s{FFFFFF} has switched in the team {"#SC_TEAMA"}%s{FFFFFF} ({"#SC_TEAMA"}%s{FFFFFF})", Player[playerid][Nickname], iTeam[TEAM_A][Name], GetRoleName(TeamRole[TEAM_A]));
            SendClientMessageToAll(-1, stringo);

			RefreshReadyTDs_Esl();
            RefreshTeamPlayers_TD();

		    GetPlayerPos(playerid, x, y, z);
		    GetPlayerFacingAngle(playerid, a);

			Sync_InCorso[playerid] = 1;

			GetPlayerWeaponData(playerid, 0, Sync_Weapons_ID[playerid][0], Sync_Weapons_AMMO[playerid][0]);
			GetPlayerWeaponData(playerid, 1, Sync_Weapons_ID[playerid][1], Sync_Weapons_AMMO[playerid][1]);
			GetPlayerWeaponData(playerid, 2, Sync_Weapons_ID[playerid][2], Sync_Weapons_AMMO[playerid][2]);
			GetPlayerWeaponData(playerid, 3, Sync_Weapons_ID[playerid][3], Sync_Weapons_AMMO[playerid][3]);
			GetPlayerWeaponData(playerid, 4, Sync_Weapons_ID[playerid][4], Sync_Weapons_AMMO[playerid][4]);
			GetPlayerWeaponData(playerid, 5, Sync_Weapons_ID[playerid][5], Sync_Weapons_AMMO[playerid][5]);
			GetPlayerWeaponData(playerid, 6, Sync_Weapons_ID[playerid][6], Sync_Weapons_AMMO[playerid][6]);
			GetPlayerWeaponData(playerid, 7, Sync_Weapons_ID[playerid][7], Sync_Weapons_AMMO[playerid][7]);
			GetPlayerWeaponData(playerid, 8, Sync_Weapons_ID[playerid][8], Sync_Weapons_AMMO[playerid][8]);
			GetPlayerWeaponData(playerid, 9, Sync_Weapons_ID[playerid][9], Sync_Weapons_AMMO[playerid][9]);
			GetPlayerWeaponData(playerid, 10, Sync_Weapons_ID[playerid][10], Sync_Weapons_AMMO[playerid][10]);
			GetPlayerWeaponData(playerid, 11, Sync_Weapons_ID[playerid][11], Sync_Weapons_AMMO[playerid][11]);
			GetPlayerWeaponData(playerid, 12, Sync_Weapons_ID[playerid][12], Sync_Weapons_AMMO[playerid][12]);

		    SetSpawnInfo(playerid, TEAM_A, GetPlayerSkinEx(playerid), x, y, z - 0.5, a, 0, 0, 0, 0, 0, 0);

		    GetPlayerHealth(playerid, Sync_Health[playerid]);
		    GetPlayerArmour(playerid, Sync_Armour[playerid]);

		    SpawnPlayer(playerid);
		}
	    case TEAM_B:
	    {
	        iTeam[Player[playerid][Team]][tPlayers] --;
	        Player[playerid][Team] = TEAM_B;
	        iTeam[TEAM_B][tPlayers] ++;

			format(stringo, sizeof stringo, "{"#SC_TEAMB"}%s{FFFFFF} has switched in the team {"#SC_TEAMB"}%s{FFFFFF} ({"#SC_TEAMB"}%s{FFFFFF})", Player[playerid][Nickname], iTeam[TEAM_B][Name], GetRoleName(TeamRole[TEAM_B]));
            SendClientMessageToAll(-1, stringo);

			RefreshReadyTDs_Esl();
            RefreshTeamPlayers_TD();

		    GetPlayerPos(playerid, x, y, z);
		    GetPlayerFacingAngle(playerid, a);

			Sync_InCorso[playerid] = 1;

			GetPlayerWeaponData(playerid, 0, Sync_Weapons_ID[playerid][0], Sync_Weapons_AMMO[playerid][0]);
			GetPlayerWeaponData(playerid, 1, Sync_Weapons_ID[playerid][1], Sync_Weapons_AMMO[playerid][1]);
			GetPlayerWeaponData(playerid, 2, Sync_Weapons_ID[playerid][2], Sync_Weapons_AMMO[playerid][2]);
			GetPlayerWeaponData(playerid, 3, Sync_Weapons_ID[playerid][3], Sync_Weapons_AMMO[playerid][3]);
			GetPlayerWeaponData(playerid, 4, Sync_Weapons_ID[playerid][4], Sync_Weapons_AMMO[playerid][4]);
			GetPlayerWeaponData(playerid, 5, Sync_Weapons_ID[playerid][5], Sync_Weapons_AMMO[playerid][5]);
			GetPlayerWeaponData(playerid, 6, Sync_Weapons_ID[playerid][6], Sync_Weapons_AMMO[playerid][6]);
			GetPlayerWeaponData(playerid, 7, Sync_Weapons_ID[playerid][7], Sync_Weapons_AMMO[playerid][7]);
			GetPlayerWeaponData(playerid, 8, Sync_Weapons_ID[playerid][8], Sync_Weapons_AMMO[playerid][8]);
			GetPlayerWeaponData(playerid, 9, Sync_Weapons_ID[playerid][9], Sync_Weapons_AMMO[playerid][9]);
			GetPlayerWeaponData(playerid, 10, Sync_Weapons_ID[playerid][10], Sync_Weapons_AMMO[playerid][10]);
			GetPlayerWeaponData(playerid, 11, Sync_Weapons_ID[playerid][11], Sync_Weapons_AMMO[playerid][11]);
			GetPlayerWeaponData(playerid, 12, Sync_Weapons_ID[playerid][12], Sync_Weapons_AMMO[playerid][12]);

		    SetSpawnInfo(playerid, TEAM_B, GetPlayerSkinEx(playerid), x, y, z - 0.5, a, 0, 0, 0, 0, 0, 0);

		    GetPlayerHealth(playerid, Sync_Health[playerid]);
		    GetPlayerArmour(playerid, Sync_Armour[playerid]);

		    SpawnPlayer(playerid);
		}
	    case TEAM_REF:
	    {
	        iTeam[Player[playerid][Team]][tPlayers] --;
	        Player[playerid][Team] = TEAM_REF;
	        iTeam[TEAM_REF][tPlayers] ++;

 			format(stringo, sizeof stringo, "{"#SC_TEAMR"}%s{FFFFFF} has switched in the team {"#SC_TEAMR"}%s{FFFFFF} ({"#SC_TEAMR"}%s{FFFFFF})", Player[playerid][Nickname], iTeam[TEAM_REF][Name], GetRoleName(TeamRole[TEAM_REF]));
            SendClientMessageToAll(-1, stringo);

			RefreshReadyTDs_Esl();
			RefreshTeamPlayers_TD();

		    GetPlayerPos(playerid, x, y, z);
		    GetPlayerFacingAngle(playerid, a);

			Sync_InCorso[playerid] = 1;

			GetPlayerWeaponData(playerid, 0, Sync_Weapons_ID[playerid][0], Sync_Weapons_AMMO[playerid][0]);
			GetPlayerWeaponData(playerid, 1, Sync_Weapons_ID[playerid][1], Sync_Weapons_AMMO[playerid][1]);
			GetPlayerWeaponData(playerid, 2, Sync_Weapons_ID[playerid][2], Sync_Weapons_AMMO[playerid][2]);
			GetPlayerWeaponData(playerid, 3, Sync_Weapons_ID[playerid][3], Sync_Weapons_AMMO[playerid][3]);
			GetPlayerWeaponData(playerid, 4, Sync_Weapons_ID[playerid][4], Sync_Weapons_AMMO[playerid][4]);
			GetPlayerWeaponData(playerid, 5, Sync_Weapons_ID[playerid][5], Sync_Weapons_AMMO[playerid][5]);
			GetPlayerWeaponData(playerid, 6, Sync_Weapons_ID[playerid][6], Sync_Weapons_AMMO[playerid][6]);
			GetPlayerWeaponData(playerid, 7, Sync_Weapons_ID[playerid][7], Sync_Weapons_AMMO[playerid][7]);
			GetPlayerWeaponData(playerid, 8, Sync_Weapons_ID[playerid][8], Sync_Weapons_AMMO[playerid][8]);
			GetPlayerWeaponData(playerid, 9, Sync_Weapons_ID[playerid][9], Sync_Weapons_AMMO[playerid][9]);
			GetPlayerWeaponData(playerid, 10, Sync_Weapons_ID[playerid][10], Sync_Weapons_AMMO[playerid][10]);
			GetPlayerWeaponData(playerid, 11, Sync_Weapons_ID[playerid][11], Sync_Weapons_AMMO[playerid][11]);
			GetPlayerWeaponData(playerid, 12, Sync_Weapons_ID[playerid][12], Sync_Weapons_AMMO[playerid][12]);

		    SetSpawnInfo(playerid, TEAM_REF, GetPlayerSkinEx(playerid), x, y, z - 0.5, a, 0, 0, 0, 0, 0, 0);

		    GetPlayerHealth(playerid, Sync_Health[playerid]);
		    GetPlayerArmour(playerid, Sync_Armour[playerid]);

		    SpawnPlayer(playerid);
		}
		case TEAM_A_SUB:
		{
	        iTeam[Player[playerid][Team]][tPlayers] --;
	        Player[playerid][Team] = TEAM_A_SUB;
	        iTeam[TEAM_A_SUB][tPlayers] ++;

 			format(stringo, sizeof stringo, "{"#SC_TEAMSA"}%s{FFFFFF} has switched in the team {"#SC_TEAMSA"}%s{FFFFFF} ({"#SC_TEAMSA"}Sub Team{FFFFFF})", Player[playerid][Nickname], iTeam[TEAM_A_SUB][Name]);
            SendClientMessageToAll(-1, stringo);

			RefreshReadyTDs_Esl();
			RefreshTeamPlayers_TD();

		    GetPlayerPos(playerid, x, y, z);
		    GetPlayerFacingAngle(playerid, a);

			Sync_InCorso[playerid] = 1;

			GetPlayerWeaponData(playerid, 0, Sync_Weapons_ID[playerid][0], Sync_Weapons_AMMO[playerid][0]);
			GetPlayerWeaponData(playerid, 1, Sync_Weapons_ID[playerid][1], Sync_Weapons_AMMO[playerid][1]);
			GetPlayerWeaponData(playerid, 2, Sync_Weapons_ID[playerid][2], Sync_Weapons_AMMO[playerid][2]);
			GetPlayerWeaponData(playerid, 3, Sync_Weapons_ID[playerid][3], Sync_Weapons_AMMO[playerid][3]);
			GetPlayerWeaponData(playerid, 4, Sync_Weapons_ID[playerid][4], Sync_Weapons_AMMO[playerid][4]);
			GetPlayerWeaponData(playerid, 5, Sync_Weapons_ID[playerid][5], Sync_Weapons_AMMO[playerid][5]);
			GetPlayerWeaponData(playerid, 6, Sync_Weapons_ID[playerid][6], Sync_Weapons_AMMO[playerid][6]);
			GetPlayerWeaponData(playerid, 7, Sync_Weapons_ID[playerid][7], Sync_Weapons_AMMO[playerid][7]);
			GetPlayerWeaponData(playerid, 8, Sync_Weapons_ID[playerid][8], Sync_Weapons_AMMO[playerid][8]);
			GetPlayerWeaponData(playerid, 9, Sync_Weapons_ID[playerid][9], Sync_Weapons_AMMO[playerid][9]);
			GetPlayerWeaponData(playerid, 10, Sync_Weapons_ID[playerid][10], Sync_Weapons_AMMO[playerid][10]);
			GetPlayerWeaponData(playerid, 11, Sync_Weapons_ID[playerid][11], Sync_Weapons_AMMO[playerid][11]);
			GetPlayerWeaponData(playerid, 12, Sync_Weapons_ID[playerid][12], Sync_Weapons_AMMO[playerid][12]);

		    SetSpawnInfo(playerid, TEAM_A_SUB, GetPlayerSkinEx(playerid), x, y, z - 0.5, a, 0, 0, 0, 0, 0, 0);

		    GetPlayerHealth(playerid, Sync_Health[playerid]);
		    GetPlayerArmour(playerid, Sync_Armour[playerid]);

		    SpawnPlayer(playerid);
		}
		case TEAM_B_SUB:
		{
	        iTeam[Player[playerid][Team]][tPlayers] --;
	        Player[playerid][Team] = TEAM_B_SUB;
	        iTeam[TEAM_B_SUB][tPlayers] ++;

 			format(stringo, sizeof stringo, "{"#SC_TEAMSB"}%s{FFFFFF} has switched in the team {"#SC_TEAMSB"}%s{FFFFFF} ({"#SC_TEAMSB"}Sub Team{FFFFFF})", Player[playerid][Nickname], iTeam[TEAM_B_SUB][Name]);
     	   	SendClientMessageToAll(-1, stringo);

	        RefreshReadyTDs_Esl();
			RefreshTeamPlayers_TD();

		    GetPlayerPos(playerid, x, y, z);
		    GetPlayerFacingAngle(playerid, a);

			Sync_InCorso[playerid] = 1;

			GetPlayerWeaponData(playerid, 0, Sync_Weapons_ID[playerid][0], Sync_Weapons_AMMO[playerid][0]);
			GetPlayerWeaponData(playerid, 1, Sync_Weapons_ID[playerid][1], Sync_Weapons_AMMO[playerid][1]);
			GetPlayerWeaponData(playerid, 2, Sync_Weapons_ID[playerid][2], Sync_Weapons_AMMO[playerid][2]);
			GetPlayerWeaponData(playerid, 3, Sync_Weapons_ID[playerid][3], Sync_Weapons_AMMO[playerid][3]);
			GetPlayerWeaponData(playerid, 4, Sync_Weapons_ID[playerid][4], Sync_Weapons_AMMO[playerid][4]);
			GetPlayerWeaponData(playerid, 5, Sync_Weapons_ID[playerid][5], Sync_Weapons_AMMO[playerid][5]);
			GetPlayerWeaponData(playerid, 6, Sync_Weapons_ID[playerid][6], Sync_Weapons_AMMO[playerid][6]);
			GetPlayerWeaponData(playerid, 7, Sync_Weapons_ID[playerid][7], Sync_Weapons_AMMO[playerid][7]);
			GetPlayerWeaponData(playerid, 8, Sync_Weapons_ID[playerid][8], Sync_Weapons_AMMO[playerid][8]);
			GetPlayerWeaponData(playerid, 9, Sync_Weapons_ID[playerid][9], Sync_Weapons_AMMO[playerid][9]);
			GetPlayerWeaponData(playerid, 10, Sync_Weapons_ID[playerid][10], Sync_Weapons_AMMO[playerid][10]);
			GetPlayerWeaponData(playerid, 11, Sync_Weapons_ID[playerid][11], Sync_Weapons_AMMO[playerid][11]);
			GetPlayerWeaponData(playerid, 12, Sync_Weapons_ID[playerid][12], Sync_Weapons_AMMO[playerid][12]);

		    SetSpawnInfo(playerid, TEAM_B_SUB, GetPlayerSkinEx(playerid), x, y, z - 0.5, a, 0, 0, 0, 0, 0, 0);

		    GetPlayerHealth(playerid, Sync_Health[playerid]);
		    GetPlayerArmour(playerid, Sync_Armour[playerid]);

		    SpawnPlayer(playerid);
		}
	    default:
	    {//6666CC
		    new str[ 210 ];

			str = "Role\t\t\tPlayers\t\t\tNames\n";

			strcat ( str , sprintf("{"#SC_TEAMA"}%s\t\t%d\t\t\t%s\n", GetRoleName( TeamRole[TEAM_A] ), iTeam[TEAM_A][tPlayers], iTeam[TEAM_A][Name]));
			strcat ( str , sprintf("{"#SC_TEAMSA"}%s\t\t%d\t\t\t%s\n", "Sub Team", iTeam[TEAM_A_SUB][tPlayers], iTeam[TEAM_A_SUB][Name]));
			strcat ( str , sprintf("{"#SC_TEAMB"}%s\t\t%d\t\t\t%s\n", GetRoleName( TeamRole[TEAM_B] ), iTeam[TEAM_B][tPlayers], iTeam[TEAM_B][Name]));
            strcat ( str , sprintf("{"#SC_TEAMSB"}%s\t\t%d\t\t\t%s\n", "Sub Team", iTeam[TEAM_B_SUB][tPlayers], iTeam[TEAM_B_SUB][Name]));
			strcat ( str , sprintf("{"#SC_TEAMR"}%s\t\t%d\t\t\t%s\n", "Referee", iTeam[TEAM_REF][tPlayers], iTeam[TEAM_REF][Name]));
            strcat( str , "{CCA6A6}Back" );

			ShowPlayerDialog(playerid, DIALOG_SWITCH, DIALOG_STYLE_LIST, "Switch", str, "Switch", "Close");

			SendClientMessage(playerid, COLOR_SYSTEM, "HINT: Use /switch [team_name] to switch directly to the team.");
			return true;
	    }
	}

	new veh, seat;
	if ((veh = GetPlayerVehicleID(playerid)) != 0 && (seat = GetPlayerVehicleSeat(playerid)) != 128) { PutPlayerInVehicle(playerid, veh, seat);  }
	return true;
}
/*
stock Play_ShowMenu(playerid)
{
	new str[ 280 ];

	strcat( str, "- Match:\n");//0
	strcat( str, "\tMatch Type\t\t\t");//1
	if(gConfig[Matchmode] == MATCHMODE_TCWCW)
	{
	    strcat( str, "TCW or CW\n");
	}
	else if(gConfig[Matchmode] == MATCHMODE_NOSCORES)//else if?
	{
	    strcat( str, "No scores\n");
	}
	strcat( str, "\tSet team names");//2
	format( str, sizeof str, "%s\t\t(%s, %s)\n", str, iTeam[TEAM_A][Name], iTeam[TEAM_B][Name]);
	strcat( str, "\tRounds\t\t\t\t");//3
	strcat( str, numstr(TotalRounds));
	strcat( str, "\n");
	strcat( str, "\tAnticheat\t\t\t");//4
	if(AC_State == STATE_ENABLED)
	{
	    strcat( str, "{"#COLORE_ENABLED"}Enabled\n");
	}
	else if(AC_State == STATE_WAITING)
	{
	    strcat( str, "{E3E85C}Waiting..\n");
	}
	else
	{
	    strcat( str, "{"#COLORE_DISABLED"}Disabled\n");
	}
	strcat( str, "\tAuto A/D\t\t\t");// 5
	if(gConfig[AutoAD])
	{
	    strcat( str, "{"#COLORE_ENABLED"}Enabled\n");
	}
	else
	{
	    strcat( str, "{"#COLORE_DISABLED"}Disabled\n");
	}
	strcat( str, "\tBases Pack\t\t\t{"#COLORE_ENABLED"}");// 6
	strcat( str, basesPacks[CurrentGamepack][packName]);
	strcat( str, "\n");
	strcat( str, "\tForce Final\n");//7

	strcat( str, "\tSwap Teams\n");//8
	strcat( str, "- Players:\n");//9
	strcat( str, "\tTeam Mix\n");//10
	strcat( str, "\tAll vs\n");//11
	strcat( str, "\tNormal balance\n");//12

	strcat( str, "- Start a random:\n");//13
	strcat( str, "\tBase\n");//14
	strcat( str, "\tArena\n");//15
	strcat( str, "\tTDM\n");//16

	ShowPlayerDialog(playerid, DIALOG_PLAY_PRIMO, DIALOG_STYLE_LIST, "Play now", str, "Select", "Close");
	return true;
}*/

stock Play_ShowMenu(playerid)
{
	new str [280];

	strcat(str, "Match type\t\t\t");

	if(gConfig[Matchmode] == MATCHMODE_TCWCW)
	{
	    strcat( str, "TCW/CW\n");
	    strcat( str, "-- Match mode:\n");

		strcat( str, "Team Names");
		format( str, sizeof str, "%s\t\t\t%s, %s\n", str, iTeam[TEAM_A][Name], iTeam[TEAM_B][Name]);

		strcat( str, "Rounds\t\t\t\t");
		strcat( str, numstr(TotalRounds));
		strcat( str, "\n");

		strcat( str, "Anticheat\t\t\t");
		if(AC_State == STATE_ENABLED)
		{
		    strcat( str, "{"#COLORE_ENABLED"}Enabled\n");
		}
		else if(AC_State == STATE_WAITING)
		{
		    strcat( str, "{E3E85C}Waiting..\n");
		}
		else
		{
		    strcat( str, "{"#COLORE_DISABLED"}Disabled\n");
		}

		strcat( str, "Bases Pack\t\t\t{"#COLORE_ENABLED"}");//
		strcat( str, basesPacks[CurrentGamepack][packName]);
		strcat( str, "\n");

		strcat(str, "Swap teams\n");
		strcat(str, "All VS\n");
		strcat(str, "Force Final\n");
	}
	else
	{
	    strcat( str, "No scores\n");

		strcat( str, "-- Fun mode:\n");
		strcat( str, "Balance\n");

		strcat( str, "Bases Pack\t\t\t{"#COLORE_ENABLED"}");//
		strcat( str, basesPacks[CurrentGamepack][packName]);
		strcat( str, "\n");

		strcat( str, "Auto A/D\t\t\t");//
		if(gConfig[AutoAD])
		{
		    strcat( str, "{"#COLORE_ENABLED"}Enabled\n");
		}
		else
		{
		    strcat( str, "{"#COLORE_DISABLED"}Disabled\n");
		}
	}

	ShowPlayerDialog(playerid, DIALOG_PLAY_PRIMO, DIALOG_STYLE_LIST, "Play now", str, "Select", "Close");
	return true;
}

stock MostraObjectsList(playerid)
{
	new
	    cat_open = 0,
	    str[ 2000 ];

	for(new i = 0; i < sizeof(lAttachObjects); i++)
	{
	    if(lAttachObjects[i][cat_name])
		{
	        cat_open=1;
			format(str, sizeof str, "%s%s:\n", str, lAttachObjects[i][oName]);
		}
		else
		{
		    if(cat_open)
			{
		        format(str, sizeof str, "%s\t%s\n", str, lAttachObjects[i][oName]);
		    }
		    else
			{
		        format(str, sizeof str, "%s%s\n", str, lAttachObjects[i][oName]);
		    }
		}
	}
	ShowPlayerDialog(playerid, DIALOG_SKINOBJECTSLIST, DIALOG_STYLE_LIST, "Choose the object", str, "Add", "Back");
}

stock MostraIndexObject(playerid)
{
	new str[ 256 ];
	for(new i = 0; i < MAX_PLAYER_ATTACHED_OBJECTS; i++)
	{
	    if(IsPlayerAttachedObjectSlotUsed(playerid, i))
		{
	        format(str, sizeof str, "%sSlot #%d (Occupied)\n", str, i);
	    }
	    else
		{
	        format(str, sizeof str, "%sSlot #%d\n", str, i);
	    }
	}
	ShowPlayerDialog(playerid, DIALOG_SKININDEX, DIALOG_STYLE_LIST, "Slot Object", str, "Choose", "Back");
	return true;
}

////////////////////////////////////////////////////////////////////////////////
//==============================================================================
////////////////////////////////////////////////////////////////////////////////
//, , , , , , , ,

/*
COMMAND:bans(playerid, params[])
{
	if (!IsPlayerAdminEx(playerid, lAdmin)) return true;

	ShowPlayerDialog (playerid, DIALOG_BANSEARCH, DIALOG_STYLE_LIST, "Ban - Cerca per", "Nickname\nSerial\nIP\nElenco bans", "Cerca", "Indietro");
	return true;
}

forward Bans_OnDataReady(playerid, search_type);
public Bans_OnDataReady(playerid, search_type)
{
	new rows, fields;
	cache_get_data(rows, fields);

	// la stringa dove sarï¿½ salvato l'output
	//iwillseeforthis
	//PlayerBansInfo[playerid][Output_Ban] = "Risultati:\n";

	if (rows) // ha trovato qualcosa
	{
	    // fetcho tutti i bans
		//cache_get_field_content_int

		for (new i = 0; i < rows; i++)
	    {
	        // salvati ok.
	        PlayerBansInfo[playerid][BANNED_id][i] = cache_get_field_content_int(i, "id");
	        cache_get_field_content(i, "unbannick", PlayerBansInfo[playerid][BANNED_unbannick][i], 24);
            cache_get_field_content(i, "ip", PlayerBansInfo[playerid][BANNED_ip][i], 16);
            cache_get_field_content(i, "reason", PlayerBansInfo[playerid][BANNED_reason][i], 128);
            cache_get_field_content(i, "serial", PlayerBansInfo[playerid][BANNED_serial][i], 128);
            cache_get_field_content(i, "adminban", PlayerBansInfo[playerid][BANNED_adminban][i], 24);

	        cache_get_field_content(i, "nickname", PlayerBansInfo[playerid][BANNED_nickname], .max_len = 24);

			strcat (PlayerBansInfo[playerid][Output_Ban][i], PlayerBansInfo[playerid][BANNED_nickname], 128);

			switch ((PlayerBansInfo[playerid][BANNED_bantype][i] = cache_get_field_content_int(i, "bantype")))
			{
			    case BANTYPE_IP:
			    {
					if ( (PlayerBansInfo[playerid][BANNED_banned][i] = cache_get_field_content_int(i, "banned")) == 1)
					{
					    strcat (PlayerBansInfo[playerid][Output_Ban], ", ï¿½ bannato per IP.", 128);
					}
					else
					{
						strcat (PlayerBansInfo[playerid][Output_Ban], ", era bannato per IP.", 128);
					}
				}
			    case BANTYPE_NICKNAME:
			    {
					if ( (PlayerBansInfo[playerid][BANNED_banned][i] = cache_get_field_content_int(i, "banned")) == 1)
					{
					    strcat (PlayerBansInfo[playerid][Output_Ban], ", ï¿½ bannato per Nickname.", 128);
					}
					else
					{
						strcat (PlayerBansInfo[playerid][Output_Ban], ", era bannato per Nickname.", 128);
					}
			    }
			    case BANTYPE_SERIAL:
			    {
					if ( (PlayerBansInfo[playerid][BANNED_banned][i] = cache_get_field_content_int(i, "banned")) == 1)
					{
					    strcat (PlayerBansInfo[playerid][Output_Ban], ", ï¿½ bannato per Serial.", 128);
					}
					else
					{
						strcat (PlayerBansInfo[playerid][Output_Ban], ", era bannato per Serial.", 128);
					}
			    }
			}

			strcat (PlayerBansInfo[playerid][Output_Ban], "\n", 128);
	    }

	    ShowPlayerDialog(playerid, DIALOG_PLAYERINFO, DIALOG_STYLE_LIST, "Bans", PlayerBansInfo[playerid][Output_Ban], "Apri", "Indietro");
	}
	return true;
}
*/


forward OnMatchPlayersDataOK(playerid, match);
public OnMatchPlayersDataOK(playerid, match)
{
	/*
	enum e_match_info_cached
{
	c_matchID,//MySQL ID
//	c_teamA[24],//change 24 w/ MAX_TEAM_NAME
//	c_teamB[24],//^
	c_scoreA,
	c_scoreB,
	c_tRounds,
	c_tTime,
}

//emh.. bad.. but ok.
new CachedMatchInfo[MAX_PLAYERS][MAX_MATCHS][e_match_info_cached];
new c_Cached_MatchInfo_TeamNamesA[MAX_PLAYERS][MAX_MATCHS][24];//read in the enum
new c_Cached_MatchInfo_TeamNamesB[MAX_PLAYERS][MAX_MATCHS][24];

*/
	match --;//fix id
	new rows, fields;

	cache_get_data(rows, fields);

	if (rows)
	{
	    // every row match to player

		// max players in s7 server are 15..
		// consider:
		// for every player it need 16 for the symbols and numbers
		// 24 for the name
		// MAX_PLAYERS for all players
		// maybe its a waste of memory, this should be improved (maxplayers in s7 server are 15 but since it will be a public gamemode)

		//...
		// [to_be_checked]
		// ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^

	    new teama [((MAX_PLAYERS + 16 + 24) * 24)], teamb[((MAX_PLAYERS + 16 + 24) * 24)];
	    new tmp [24];
	    ////////////////////////////////////////////////////  PLAYERS    TEAM HEADER   VARIABLE TEAM NAME -- CONSIDER COLOR CHANGES
	    // i think 1024 is too big, but might require more.. (24 * 19) + ((42 * 2) + (17*2))
		new final [1024];//WAIT, I CAN USE TMP TO STORE EVERYTHING
		//BECAUSE OF OF FORS TMP WILL BE USELESS

		// can be improved w/ three strcat (3x2=6)
		if (CachedMatchInfo[playerid][match][c_scoreA] > CachedMatchInfo[playerid][match][c_scoreB])
		{
	    	format(teama, sizeof teama, "{FFFFFF}Team {00ff48}%s{ffffff}\n\nDamage\tKills\tDeaths\t\tPlayer\n", c_Cached_MatchInfo_TeamNamesA[playerid][match]);
	    	format(teamb, sizeof teamb, "\nTeam {ff0000}%s{ffffff}\n\nDamage\tKills\tDeaths\t\tPlayer\n", c_Cached_MatchInfo_TeamNamesB[playerid][match]);
		}
		else if (CachedMatchInfo[playerid][match][c_scoreA] < CachedMatchInfo[playerid][match][c_scoreB])
		{
	    	format(teama, sizeof teama, "{FFFFFF}Team {ff0000}%s{ffffff}\n\nDamage\tKills\tDeaths\t\tPlayer\n", c_Cached_MatchInfo_TeamNamesA[playerid][match]);
	    	format(teamb, sizeof teamb, "\nTeam {00ff48}%s{ffffff}\n\nDamage\tKills\tDeaths\t\tPlayer\n", c_Cached_MatchInfo_TeamNamesB[playerid][match]);
		}
		else
		{
	    	format(teama, sizeof teama, "{FFFFFF}Team {faff00}%s{ffffff}\n\nDamage\tKills\tDeaths\t\tPlayer\n", c_Cached_MatchInfo_TeamNamesA[playerid][match]);
	    	format(teamb, sizeof teamb, "\nTeam {faff00}%s{ffffff}\n\nDamage\tKills\tDeaths\t\tPlayer\n", c_Cached_MatchInfo_TeamNamesB[playerid][match]);
		}

		for (new i = 0; i < rows; i++)
	    {
            //only team 1 and team 2 will be in the mysql, so.
            cache_get_field_content(i, "playername", tmp, .max_len = 24);

            if (cache_get_field_content_int(i, "team") == TEAM_A)
            {
	        	format (teama, sizeof teama, "%s%d\t\t%d\t%d\t\t%s\n", teama, cache_get_field_content_int(i, "damage"), cache_get_field_content_int(i, "kills"), cache_get_field_content_int(i, "deaths"), tmp);
            }
            else
            {
	        	format (teamb, sizeof teamb, "%s%d\t\t%d\t%d\t\t%s\n", teamb, cache_get_field_content_int(i, "damage"), cache_get_field_content_int(i, "kills"), cache_get_field_content_int(i, "deaths"), tmp);
            }
		}

		format (final, sizeof final,
		    "{FFFFFF}%s %d vs %d %s - Rounds played: %d of %d\n%s%s",
		    c_Cached_MatchInfo_TeamNamesA[playerid][match],
		    CachedMatchInfo[playerid][match][c_scoreA],
		    CachedMatchInfo[playerid][match][c_scoreB],
		    c_Cached_MatchInfo_TeamNamesB[playerid][match],
		    CachedMatchInfo[playerid][match][c_pRounds],
		    CachedMatchInfo[playerid][match][c_tRounds],
		    teama,
		    teamb
		);

	    ShowPlayerDialog (playerid, DIALOG_NULL, DIALOG_STYLE_MSGBOX, "Match", final, "Close", "");
	}
	else
	{
	    format(stringo, sizeof stringo, "No players found (Match: %d)", match);
	    SendClientMessage (playerid, COLOR_RED, stringo);
	}
}

public OnDialogResponse(playerid, dialogid, response, listitem, inputtext[])
{
	#define VOTE_TIMER_TIME         60000
	switch (dialogid)
	{
	    case DIALOG_SCEGLI_MATCH:
		{
			if (response)
			{
			    if (listitem > MAX_MATCHS) return cmd_matchs(playerid, "");
			    // now open info of the chosed(w/ 2 o?) match
			    new match = listitem + 1;
			    mysql_tquery(g_MySQLConnection, sprintf ("SELECT playername, damage, kills, deaths, team FROM matchplayers WHERE matchid = '%d' ORDER BY damage DESC", match), "OnMatchPlayersDataOK", "ii", playerid, match);
			}
			return true;
		}
/*		case DIALOG_BANSEARCH_NICKNAME:
		{
		    if (!response) {
		        // ritorna alla schermata principale
		        return cmd_bans(playerid, ""), true;
		    }

			if (inputtext[0] == '\0') {
			    // l'utente non ha scritto niente nel box
			    return	ShowPlayerDialog (
						playerid,
						DIALOG_BANSEARCH_NICKNAME,
						"Ban per nickname",
						"Inserisci il nome del player",
						"Cerca",
						"Indietro"
					);// rimostro il dialogo
			}

			// ok, informo il player che sto cercando
			SendClientMessage (playerid, COLOR_SYSTEM, "La tua richiesta ï¿½ stata inviata, attendi.");

//			native mysql_format(connectionHandle, output[], len, format[], {Float,_}:...);

			new output[128];
			mysql_format(g_MySQLConnection, output, 128, "SELECT id, nickname, serial, ip, bantype, reason, adminban, banned, unbannick FROM bans WHERE nickname = '%e'", inputtext);

			// id del player - tipo di richiesta
			// il callback della risposta sarï¿½ sempre lo stesso, il secondo parametro specializza il tipo di ricerca
			// 1 => nickname
			// 2 => serial
			// 3 => ip

			mysql_tquery (g_MySQLConnection, output, "Bans_OnDataReady", "ii", playerid, 1);
		}
	    case DIALOG_BANSEARCH:
	    {
	        // ha premuto il tasto "indietro"
			if (!response) return true;

			switch (listitem)
	        {
	            case 0:
	            {
	                // bans per nickname
	                ShowPlayerDialog (
						playerid,
						DIALOG_BANSEARCH_NICKNAME,
						"Ban per nickname",
						"Inserisci il nome del player",
						"Cerca",
						"Indietro"
					);
	            }
	            case 1:
	            {
	                // bans per seriale

	                ShowPlayerDialog (
						playerid,
						DIALOG_BANSEARCH_SERIAL,
						"Ban per nickname",
						"Inserisci il seriale del player",
						"Cerca",
						"Indietro"
					);
	            }
	            case 2:
	            {
	                // bans per ip

	                ShowPlayerDialog (
						playerid,
						DIALOG_BANSEARCH_IP,
						"Ban per nickname",
						"Inserisci l'ip del player",
						"Cerca",
						"Indietro"
					);
	            }
	            case 3:
	            {
	                // mostra l'elenco dei bans
	            }
	        }
	    }*/
		case DIALOG_EDITOR_ACTION:
		{
			if (!response) return true;

			switch (listitem)
			{
				case 0:
				{
					ShowPlayerDialog(playerid, DIALOG_EDITOR_CREA, DIALOG_STYLE_LIST, "Crea", "Base\nArena\nGungame\nFight\nEsci", "Crea", "Indietro");
				}
				case 1:
				{
					ShowPlayerDialog(playerid, DIALOG_EDITOR_MODIFICA, DIALOG_STYLE_LIST, "Modifica", "Base\nArena\nEsci", "Modifica", "Indietro");
				}
			}
			return true;
		}
		/**
			*
			DIALOG_EDIT_MODARENA,
			DIALOG_EDITING_ARENA,
		*/
		case DIALOG_EDITOR_MODIFICA:
		{
			if (!response)return ShowPlayerDialog(playerid, DIALOG_EDITOR_ACTION, DIALOG_STYLE_LIST, "Action", "Crea\nModifica\nEsci", "Scegli", "Chiudi");

			switch (listitem)
			{
				case 0:
				{
					// base
					ShowPlayerDialog(playerid, DIALOG_EDIT_BASEID, DIALOG_STYLE_INPUT, "Base ID", "Inserisci l'id della base (Relativa al pack attualmente caricato)", "Vai", "Indietro");
					//ShowPlayerDialog(playerid, EDITOR_EDIT_CHOSEPACK, DIALOG_STYLE_LIST, "Base pack", "Slaughterfield\nESL\nWarGrounds\nNoCbug\nWarhead", "Salva", "Indietro");
				}
				case 1:
				{
					// arena
					ShowPlayerDialog(playerid, DIALOG_EDIT_MODARENA, DIALOG_STYLE_INPUT, "Arena ID", "Inserisci l'id della arena da modificare", "Modifica", "Indietro");
				}
				case 2:
				{
					return true;
				}
			}

			return true;
		}
		case DIALOG_EDIT_MODARENA:
		{
			if (!response) return ShowPlayerDialog(playerid, DIALOG_EDITOR_MODIFICA, DIALOG_STYLE_LIST, "Modifica", "Base\nArena\nEsci", "Modifica", "Indietro");

			new
				bid = strval (inputtext);

			if (bid > MAX_ARENE)
				return ShowPlayerDialog(playerid, DIALOG_EDIT_MODARENA, DIALOG_STYLE_INPUT, "Arena ID", "ID Arena non valida", "Modifica", "Indietro");

			if (!aArene[bid][Exists])
				return ShowPlayerDialog(playerid, DIALOG_EDIT_MODARENA, DIALOG_STYLE_INPUT, "Arena ID", "ID Arena non valida", "Modifica", "Indietro");

			if(Editor_GangZoneTest[playerid] == -1)
				Editor_GangZoneTest[playerid] = GangZoneCreate(aArene[bid][bMinX], aArene[bid][bMinY], aArene[bid][bMaxX], aArene[bid][bMaxY]);

			GangZoneShowForPlayer(playerid, Editor_GangZoneTest[playerid], COLOR_LIGHTBLUE);

			SendClientMessage(playerid, COLOR_RED, "** ATTENZIONE: E' altamente sconsigliato modificare un'arena durante una TCW o rounds fun!");
			SendClientMessage(playerid, COLOR_RED, "** ATTENZIONE: Ogni azione eseguita è irreversibile. Non vengono creati backup di informazioni relativi a basi o altro");
			SendClientMessage(playerid, COLOR_RED, "** ATTENZIONE: Tutte le modifiche eseguite vengono inviate in tempo reale (cambia e invia)");
			SendClientMessage(playerid, COLOR_RED, "** ATTENZIONE: Al termine, è sempre necessario ricaricare il pack usando /reload");

			Editor_WorkingType[playerid] = EDITOR_WORKINGTYPE_EDITINGARENA;
			Editing_BaseID[playerid] = bid; // base come arena come etc.

			ShowPlayerDialog(playerid, DIALOG_EDITING_ARENA, DIALOG_STYLE_LIST, "Arena Editing", sprintf(
				"- Go to:\n\
				\tSpawn 1\n \
				\tSpawn 2\n \
				\tHome\n \
				- Change:\n \
				\tChange Spawn 1\n \
				\tChange Spawn 2\n \
				\tChange Home\n \
				\tChange arena name (Current name: %s)\n \
				Delete arena\n\
				Chiudi", aArene[bid][bName]
			), "Vai", "Chiudi");
		}
		case DIALOG_EDITING_ARENA:
		{
			if (!response)
			{
				ShowPlayerDialog(playerid, DIALOG_EDITOR_MODIFICA, DIALOG_STYLE_LIST, "Modifica", "Base\nArena\nEsci", "Modifica", "Indietro");
				return true;
			}

			new
				bid = Editing_BaseID[playerid];

			switch (listitem)
			{
				// case 0: go to
				case 1:
				{
					// spawn 1

					SetPlayerPos(playerid, aArene[bid][bAttackers][0], aArene[bid][bAttackers][1], aArene[bid][bAttackers][2]);
					SendClientMessage(playerid, COLOR_SYSTEM, "Spawn 1.");
				}
				case 2:
				{
					// spawn 2
					SetPlayerPos(playerid, aArene[bid][bDefenders][0], aArene[bid][bDefenders][1], aArene[bid][bDefenders][2]);
					SendClientMessage(playerid, COLOR_SYSTEM, "Spawn 2.");
				}
				case 3:
				{
					// home
					SetPlayerPos(playerid, aArene[bid][bCheckpoint][0], aArene[bid][bCheckpoint][1], aArene[bid][bCheckpoint][2]);
					SendClientMessage(playerid, COLOR_SYSTEM, "Home.");
				}
				// case 4: change
				case 5:
				{
					// change spawn 1

					new
						Float:x, Float:y, Float:z;

					GetPlayerPos (playerid, x, y, z);

					MySQLStatus[TotalQuerys] ++; mysql_tquery (g_MySQLConnection, sprintf(
						"UPDATE arene SET att = '%f,%f,%f' WHERE id = %d",
						x, y, z,
						aArene[bid][MySQLid]
					), "", "");

					SendClientMessage(playerid, COLOR_SYSTEM, "Spawn 1 changed.");

				}
				case 6:
				{
					// change spawn 2
					new
						Float:x, Float:y, Float:z;

					GetPlayerPos (playerid, x, y, z);

					MySQLStatus[TotalQuerys] ++; MySQLStatus[TotalQuerys] ++; mysql_tquery (g_MySQLConnection, sprintf(
						"UPDATE arene SET def = '%f,%f,%f' WHERE id = %d",
						x, y, z,
						aArene[bid][MySQLid]
					), "", "");

					SendClientMessage(playerid, COLOR_SYSTEM, "Spawn 2 changed.");

				}
				case 7:
				{
					// change home

					new
						Float:x, Float:y, Float:z;

					GetPlayerPos (playerid, x, y, z);

					MySQLStatus[TotalQuerys] ++; MySQLStatus[TotalQuerys] ++; mysql_tquery (g_MySQLConnection, sprintf(
						"UPDATE arene SET home = '%f,%f,%f' WHERE id = %d",
						x, y, z,
						aArene[bid][MySQLid]
					), "", "");

					SendClientMessage(playerid, COLOR_SYSTEM, "Home changed.");
				}
				case 8:
				{
					// change name
					ShowPlayerDialog(playerid, DIALOG_EDITING_ARENANAME, DIALOG_STYLE_INPUT, "Arena name", "Inserisci il nuovo nome da dare all'arena", "Cambia", "Indietro");
				}
				case 9:
				{
					// delete arena

					MySQLStatus[TotalQuerys] ++; mysql_tquery (g_MySQLConnection, sprintf(
						"DELETE FROM arene WHERE id = %d",
						aArene[bid][MySQLid]
					), "", "");

					Editor_WorkingType[playerid] = EDITOR_WORKTYPE_NOONE;
					Editing_BaseID[playerid] = -1;

					ShowPlayerDialog(playerid, DIALOG_EDIT_MODARENA, DIALOG_STYLE_INPUT, "Arena ID", "Inserisci l'id della arena da modificare", "Modifica", "Indietro");

					SendClientMessage(playerid, COLOR_SYSTEM, "Arena deleted.");
				}
				case 10:
				{
					// close
					Editor_WorkingType[playerid] = EDITOR_WORKTYPE_NOONE;
					Editing_BaseID[playerid] = -1;

					if (Editor_GangZoneTest[playerid] != -1)
						GangZoneDestroy(Editor_GangZoneTest[playerid]);

					Editor_GangZoneTest[playerid] = -1;

					ShowPlayerDialog(playerid, DIALOG_EDIT_MODARENA, DIALOG_STYLE_INPUT, "Arena ID", "Inserisci l'id della arena da modificare", "Modifica", "Indietro");
				}
			}
		}
		case DIALOG_EDITING_ARENANAME:
		{
			if (!response)
			{
				ShowPlayerDialog(playerid, DIALOG_EDITING_ARENA, DIALOG_STYLE_LIST, "Arena Editing", sprintf(
					"- Go to:\n\
					\tSpawn 1\n \
					\tSpawn 2\n \
					\tHome\n \
					- Change:\n \
					\tChange Spawn 1\n \
					\tChange Spawn 2\n \
					\tChange Home\n \
					\tChange arena name (Current name: %s)\n \
					Delete arena\n\
					Chiudi", aArene[Editing_BaseID[playerid]][bName]
				), "Vai", "Chiudi");

				return true;
			}

			strcpy_2(aArene[Editing_BaseID[playerid]][bName], inputtext);
			format(stringo, sizeof stringo, "Arena name changed to %s.", aArene[Editing_BaseID[playerid]][bName]);
            SendClientMessage(playerid, COLOR_SYSTEM, stringo);

			ShowPlayerDialog(playerid, DIALOG_EDITING_ARENA, DIALOG_STYLE_LIST, "Arena Editing", sprintf(
				"- Go to:\n\
				\tSpawn 1\n \
				\tSpawn 2\n \
				\tHome\n \
				- Change:\n \
				\tChange Spawn 1\n \
				\tChange Spawn 2\n \
				\tChange Home\n \
				\tChange arena name (Current name: %s)\n \
				Delete arena\n\
				Chiudi", inputtext
			), "Vai", "Chiudi");

		}
		/*case EDITOR_EDIT_CHOSEPACK:
		{
			if (!response) return ShowPlayerDialog(playerid, DIALOG_EDITOR_MODIFICA, DIALOG_STYLE_LIST, "Modifica", "Base\nArena\nGungame\nFight\nEsci", "Crea", "Indietro");

			Editor_Editing_PackID[playerid] = listitem;
			ShowPlayerDialog(playerid, DIALOG_EDIT_BASEID, DIALOG_STYLE_INPUT, "Base ID", "Inserisci l'id della base", "Vai", "Indietro");
		}*/
		case DIALOG_EDIT_BASEID:
		{
			if (!response) return ShowPlayerDialog(playerid, DIALOG_EDITOR_ACTION, DIALOG_STYLE_LIST, "Action", "Crea\nModifica\nEsci", "Scegli", "Chiudi");

			new
				bid = strval (inputtext);

			if (bid > MAX_BASES)
				return ShowPlayerDialog(playerid, DIALOG_EDIT_BASEID, DIALOG_STYLE_INPUT, "Base ID", "ID Non valido", "Vai", "Indietro");

			if (!bBases[bid][Exists])
				return ShowPlayerDialog(playerid, DIALOG_EDIT_BASEID, DIALOG_STYLE_INPUT, "Base ID", "ID Non valido", "Vai", "Indietro");

			SendClientMessage(playerid, COLOR_RED, "** ATTENZIONE: Assicurarsi di non cambiare il pack basi durante l'editing di una base");
			SendClientMessage(playerid, COLOR_RED, "** ATTENZIONE: E' altamente sconsigliato modificare una base durante una TCW o rounds fun!");
			SendClientMessage(playerid, COLOR_RED, "** ATTENZIONE: Ogni azione eseguita ï¿½ irreversibile. Non vengono creati backup di informazioni relativi a basi o altro");
			SendClientMessage(playerid, COLOR_RED, "** ATTENZIONE: Tutte le modifiche eseguite vengono inviate in tempo reale (cambia e invia)");
			SendClientMessage(playerid, COLOR_RED, "** ATTENZIONE: Al termine, ï¿½ sempre necessario ricaricare il pack usando /loadpack");

			Editor_WorkingType[playerid] = EDITOR_WORKINGTYPE_EDITINGBASE;
			Editing_BaseID[playerid] = bid;

			ShowPlayerDialog(playerid, DIALOG_EDITING_BASE, DIALOG_STYLE_LIST, "Base Editing", sprintf(
				"- Go to:\n\
				\tAttackers spawn\n \
				\tDefenders spawn\n \
				\tCheckpoint\n \
				- Change:\n \
				\tChange attackers spawn\n \
				\tChange defenders spawn\n \
				\tChange checkpoint\n \
				\tChange base name (Current name: %s)\n \
				Delete\n\
				Chiudi", bBases[bid][bName]
			), "Vai", "Chiudi");

			SetPlayerCheckpointEx(playerid, bBases[bid][bCheckpoint][0], bBases[bid][bCheckpoint][1], bBases[bid][bCheckpoint][2], 2.5);
		}
		case DIALOG_EDITING_BASE:
		{
			if (!response) return ShowPlayerDialog(playerid, DIALOG_EDIT_BASEID, DIALOG_STYLE_INPUT, "Base ID", "Inserisci l'id della base (Relativa al pack attualmente caricato)", "Vai", "Indietro");
			if (Editor_WorkingType[playerid] != EDITOR_WORKINGTYPE_EDITINGBASE || Editing_BaseID[playerid] == -1) return false;

			new
				bid = Editing_BaseID[playerid];

			switch (listitem)
			{
				// case 0: scritta go to
				case 1:
				{
					// go attackers spawn
					SetPlayerPos(playerid, bBases[bid][bAttackers][0], bBases[bid][bAttackers][1], bBases[bid][bAttackers][2]);
					SetPlayerInterior(playerid, bBases[bid][bInterior]);
					SendClientMessage(playerid, COLOR_SYSTEM, "Attackers spawn.");
				}
				case 2:
				{
					// go def spawn
					SetPlayerPos(playerid, bBases[bid][bDefenders][0], bBases[bid][bDefenders][1], bBases[bid][bDefenders][2]);
					SetPlayerInterior(playerid, bBases[bid][bInterior]);
					SendClientMessage(playerid, COLOR_SYSTEM, "Defenders spawn.");
				}
				case 3:
				{
					// go cp
					SetPlayerPos(playerid, bBases[bid][bCheckpoint][0], bBases[bid][bCheckpoint][1], bBases[bid][bCheckpoint][2]);
					SetPlayerInterior(playerid, bBases[bid][bInterior]);
					SendClientMessage(playerid, COLOR_SYSTEM, "Checkpoint position.");
				}
				// case 4: scritta "change"
				case 5:
				{
					new
						Float:x, Float:y, Float:z;

					GetPlayerPos (playerid, x, y, z);

					MySQLStatus[TotalQuerys] ++; mysql_tquery (g_MySQLConnection, sprintf(
						"UPDATE bases_%s SET att = '%f,%f,%f' WHERE id = %d",
						basesPacks[CurrentGamepack][SQLdb],
						x, y, z,
						bBases[bid][MySQLid]
					), "", "");

					SendClientMessage(playerid, COLOR_SYSTEM, "Attackers spawn changed.");
				}
				case 6:
				{
					new
						Float:x, Float:y, Float:z;

					GetPlayerPos (playerid, x, y, z);

					MySQLStatus[TotalQuerys] ++; mysql_tquery (g_MySQLConnection, sprintf(
						"UPDATE bases_%s SET def = '%f,%f,%f' WHERE id = %d",
						basesPacks[CurrentGamepack][SQLdb],
						x, y, z,
						bBases[bid][MySQLid]
					), "", "");

					SendClientMessage(playerid, COLOR_SYSTEM, "Defenders spawn changed.");
				}
				case 7:
				{
					new
						Float:x, Float:y, Float:z;

					GetPlayerPos (playerid, x, y, z);

					MySQLStatus[TotalQuerys] ++; mysql_tquery (g_MySQLConnection, sprintf(
						"UPDATE bases_%s SET home = '%f,%f,%f' WHERE id = %d",
						basesPacks[CurrentGamepack][SQLdb],
						x, y, z,
						bBases[bid][MySQLid]
					), "", "");

					SetPlayerCheckpointEx(playerid, x, y, z, 2.5);

					SendClientMessage(playerid, COLOR_SYSTEM, "Checkpoint position changed.");
				}
				case 8:
				{
					ShowPlayerDialog(playerid, DIALOG_EDITING_BASENAME, DIALOG_STYLE_INPUT, "Base name", "Inserisci il nuovo nome da dare alla base", "Cambia", "Indietro");
				}
				case 9:
				{
					MySQLStatus[TotalQuerys] ++; mysql_tquery (g_MySQLConnection, sprintf(
						"DELETE FROM bases_%s WHERE id = %d",
						basesPacks[CurrentGamepack][SQLdb],
						bBases[bid][MySQLid]
					), "", "");

					Editor_WorkingType[playerid] = EDITOR_WORKTYPE_NOONE;
					Editing_BaseID[playerid] = -1;
					DisablePlayerCheckpoint(playerid);

					ShowPlayerDialog(playerid, DIALOG_EDIT_BASEID, DIALOG_STYLE_INPUT, "Base ID", "Inserisci l'id della base (Relativa al pack attualmente caricato)", "Vai", "Indietro");

					SendClientMessage(playerid, COLOR_SYSTEM, "Base deleted.");
				}
				case 10:
				{
					Editor_WorkingType[playerid] = EDITOR_WORKTYPE_NOONE;
					Editing_BaseID[playerid] = -1;
					DisablePlayerCheckpoint(playerid);

					ShowPlayerDialog(playerid, DIALOG_EDIT_BASEID, DIALOG_STYLE_INPUT, "Base ID", "Inserisci l'id della base (Relativa al pack attualmente caricato)", "Vai", "Indietro");
				}
			}
		}
		case DIALOG_EDITING_BASENAME:
		{
			if (!response)
			{
				ShowPlayerDialog(playerid, DIALOG_EDITING_BASE, DIALOG_STYLE_LIST, "Base Editing", sprintf(
					"- Go to:\
					\tAttackers spawn\n \
					\tDefenders spawn\n \
					\tCheckpoint\n \
					- Change:\n \
					\tChange attackers spawn\n \
					\tChange defenders spawn\n \
					\tChange checkpoint\n \
					\tChange base name (Current name: %s)\n \
					Delete\n \
					Chiudi", bBases[Editing_BaseID[playerid]][bName]
				), "Vai", "Chiudi");

				return true;
			}
			strcpy_2(bBases[Editing_BaseID[playerid]][bName], inputtext);
			format(stringo, sizeof stringo, "Base name changed to %s.", bBases[Editing_BaseID[playerid]][bName]);
			SendClientMessage(playerid, COLOR_SYSTEM, stringo);

			ShowPlayerDialog(playerid, DIALOG_EDITING_BASE, DIALOG_STYLE_LIST, "Base Editing", sprintf(
				"- Go to:\
				\tAttackers spawn\n \
				\tDefenders spawn\n \
				\tCheckpoint\n \
				- Change:\n \
				\tChange attackers spawn\n \
				\tChange defenders spawn\n \
				\tChange checkpoint\n \
				\tChange base name (Current name: %s)\n \
				Delete\n \
				Chiudi", inputtext
			), "Vai", "Chiudi");
		}
		case DIALOG_EDITOR_SETNAME:
		{
			if (!response)
			{
				if (Editor_WorkingType[playerid] == EDITOR_WORKTYPE_BASE || Editor_WorkingType[playerid] == EDITOR_WORKTYPE_ARENA)
				{
					ShowPlayerDialog(playerid, DIALOG_EDITOR_CREATINGMENU, DIALOG_STYLE_LIST, "Creazione", "Attackers Spawn\nDefenders Spawn\nCheckpoint\nName\nSalva", "Cambia", "Indietro");
				}
				else // EDITOR_WORKTYPE_GUNGAME || EDITOR_WORKTYPE_FIGHT
				{
					ShowPlayerDialog(playerid, DIALOG_EDITOR_CREATEGGFF, DIALOG_STYLE_LIST, "Creazione", "Name\nSet Spawns\nSet limit\nSalva", "Seleziona", "Indietro");
				}
				return true;
			}

			strcpy_2(Editor_Name[playerid], inputtext);

			if (Editor_WorkingType[playerid] == EDITOR_WORKTYPE_BASE || Editor_WorkingType[playerid] == EDITOR_WORKTYPE_ARENA)
			{
				ShowPlayerDialog(playerid, DIALOG_EDITOR_CREATINGMENU, DIALOG_STYLE_LIST, "Creazione", "Attackers Spawn\nDefenders Spawn\nCheckpoint\nName\nSet limit\nSalva", "Cambia", "Indietro");
			}
			else // EDITOR_WORKTYPE_GUNGAME || EDITOR_WORKTYPE_FIGHT
			{
				ShowPlayerDialog(playerid, DIALOG_EDITOR_CREATEGGFF, DIALOG_STYLE_LIST, "Creazione", "Name\nSet Spawns\nSet limit\nSalva", "Seleziona", "Indietro");
			}
			return true;
		}
		case DIALOG_EDITOR_CREA:
		{
			if (!response) return ShowPlayerDialog(playerid, DIALOG_EDITOR_ACTION, DIALOG_STYLE_LIST, "Action", "Crea\nModifica\nEsci", "Scegli", "Chiudi");

			switch (listitem)
			{
				case 0:
				{
					Editor_WorkingType[playerid] = EDITOR_WORKTYPE_BASE;
					ShowPlayerDialog(playerid, DIALOG_EDITOR_CREATINGMENU, DIALOG_STYLE_LIST, "Creazione", "Attackers Spawn\nDefenders Spawn\nCheckpoint\nName\nSet limit\nSalva", "Cambia", "Indietro");
				}
				case 1:
				{
					Editor_WorkingType[playerid] = EDITOR_WORKTYPE_ARENA;
					ShowPlayerDialog(playerid, DIALOG_EDITOR_CREATINGMENU, DIALOG_STYLE_LIST, "Creazione", "Attackers Spawn\nDefenders Spawn\nCheckpoint\nName\nSet limit\nSalva", "Cambia", "Indietro");
				}
				case 2:
				{
					Editor_WorkingType[playerid] = EDITOR_WORKTYPE_GUNGAME;
					ShowPlayerDialog(playerid, DIALOG_EDITOR_CREATEGGFF, DIALOG_STYLE_LIST, "Creazione", "Name\nSet Spawns\nSet limit\nSalva", "Seleziona", "Indietro");
				}
				case 3:
				{
					Editor_WorkingType[playerid] = EDITOR_WORKTYPE_FIGHT;
					ShowPlayerDialog(playerid, DIALOG_EDITOR_CREATEGGFF, DIALOG_STYLE_LIST, "Creazione", "Name\nSet Spawns\nSet limit\nSalva", "Seleziona", "Indietro");
				}
				case 4:
				{
					return true;
				}
			}
			return true;
		}
		case DIALOG_EDITOR_CREATINGMENU: // valido per basi e arene
		{
			if (!response) return ShowPlayerDialog(playerid, DIALOG_EDITOR_CREA, DIALOG_STYLE_LIST, "Crea", "Base\nArena\nGungame\nFight\nEsci", "Crea", "Indietro");

			switch (listitem)
			{
				case 0:
				{
					// Attackers spawn
					GetPlayerPos (playerid, Editor_Attackers[playerid][0], Editor_Attackers[playerid][1] , Editor_Attackers[playerid][2] );
					SendClientMessage(playerid, COLOR_SYSTEM, "Attackers will spawn here.");

					ShowPlayerDialog(playerid, DIALOG_EDITOR_CREATINGMENU, DIALOG_STYLE_LIST, "Creazione", "Attackers Spawn\nDefenders Spawn\nCheckpoint\nName\nSet limit\nSalva", "Cambia", "Indietro");
				}
				case 1:
				{
					// Defenders spawn
					GetPlayerPos (playerid, Editor_Defenders[playerid][0], Editor_Defenders[playerid][1] , Editor_Defenders[playerid][2] );
					SendClientMessage(playerid, COLOR_SYSTEM, "Defenders will spawn here.");

					ShowPlayerDialog(playerid, DIALOG_EDITOR_CREATINGMENU, DIALOG_STYLE_LIST, "Creazione", "Attackers Spawn\nDefenders Spawn\nCheckpoint\nName\nSet limit\nSalva", "Cambia", "Indietro");
				}
				case 2:
				{
					// checkpoint spawn
					GetPlayerPos (playerid, Editor_Checkpoint[playerid][0], Editor_Checkpoint[playerid][1] , Editor_Checkpoint[playerid][2] );
					SendClientMessage(playerid, COLOR_SYSTEM, "Checkpoint will be created here.");

					ShowPlayerDialog(playerid, DIALOG_EDITOR_CREATINGMENU, DIALOG_STYLE_LIST, "Creazione", "Attackers Spawn\nDefenders Spawn\nCheckpoint\nName\nSet limit\nSalva", "Cambia", "Indietro");
				}
				case 3:
				{
					// name
					ShowPlayerDialog(playerid, DIALOG_EDITOR_SETNAME, DIALOG_STYLE_INPUT, "Set name", "Inserisci il nome", "Cambia", "Indietro");
				}
				case 4:
				{
					// limits
					ShowPlayerDialog(playerid, DIALOG_EDITOR_SETLIMITS, DIALOG_STYLE_LIST, "Set limits", "Limit 1\nLimit 2", "Seleziona", "Indietro");
				}
				case 5:
				{
					// salva
					// bases devono chiedere in quale pack salvarla

					switch (Editor_WorkingType[playerid])
					{
						case EDITOR_WORKTYPE_BASE:
						{
							// chiede il pack dove salvarla
							ShowPlayerDialog(playerid, EDITOR_BASESAVE_PACK, DIALOG_STYLE_LIST, "Salva base pack", "Slaughterfield\nESL\nWarGrounds\nNoCbug\nWarhead", "Salva", "Indietro");
						}
						case EDITOR_WORKTYPE_ARENA:
						{
							// tdm come arena

							// 0 = x
							// 1 = y

							// Editor_AreaLimits1 = primo
							// Editor_AreaLimits2 = secondo

							new
								Float:XMax = (Editor_AreaLimits1[playerid][0] > Editor_AreaLimits2[playerid][0] ? Editor_AreaLimits1[playerid][0] : Editor_AreaLimits2[playerid][0]),
								Float:YMax = (Editor_AreaLimits1[playerid][1] > Editor_AreaLimits2[playerid][1] ? Editor_AreaLimits1[playerid][1] : Editor_AreaLimits2[playerid][1]),

								Float:XMin = (Editor_AreaLimits1[playerid][0] < Editor_AreaLimits2[playerid][0] ? Editor_AreaLimits1[playerid][0] : Editor_AreaLimits2[playerid][0]),
								Float:YMin = (Editor_AreaLimits1[playerid][1] < Editor_AreaLimits2[playerid][1] ? Editor_AreaLimits1[playerid][1] : Editor_AreaLimits2[playerid][1]);

							MySQLStatus[TotalQuerys] ++; mysql_tquery
							(
								g_MySQLConnection,
								sprintf("INSERT INTO arene (home, att, def, interior, attwin, defwin, played, name, ZMax, ZMin) VALUES ('%f,%f,%f', '%f,%f,%f', '%f,%f,%f', '%d', '0', '0', '0', '%s', '%f,%f', '%f,%f')",
									basesPacks[listitem][SQLdb],
									Editor_Checkpoint[playerid][0], Editor_Checkpoint[playerid][1], Editor_Checkpoint[playerid][2],
									Editor_Attackers[playerid][0], Editor_Attackers[playerid][1], Editor_Attackers[playerid][2],
									Editor_Defenders[playerid][0], Editor_Defenders[playerid][1], Editor_Defenders[playerid][2],
									GetPlayerInterior(playerid),
									Editor_Name[playerid],
									XMax, YMax,
									XMin, YMin
								),
								"Editor_OnEditorAdding",
								"i",
								playerid
							);
						}
					}
				}
			}
			return true;
		}
		case DIALOG_EDITOR_SETLIMITS:
		{
			if (!response)
			{
				if (Editor_WorkingType[playerid] == EDITOR_WORKTYPE_ARENA || Editor_WorkingType[playerid] == EDITOR_WORKTYPE_BASE)
				{
					ShowPlayerDialog(playerid, DIALOG_EDITOR_CREATINGMENU, DIALOG_STYLE_LIST, "Creazione", "Attackers Spawn\nDefenders Spawn\nCheckpoint\nName\nSet limit\nSalva", "Cambia", "Indietro");
				}
				else
				{
					ShowPlayerDialog(playerid, DIALOG_EDITOR_CREATEGGFF, DIALOG_STYLE_LIST, "Creazione", "Name\nSet Spawns\nSet limit\nSalva", "Seleziona", "Indietro");
				}

				return true;
			}
			new Float:a; // non sono sicuro di quanto questo sia efficiente
			// ma manteniamo questo codice per il momento

			switch (listitem)
			{
				case 0:
				{
					GetPlayerPos(playerid, Editor_AreaLimits1[playerid][0], Editor_AreaLimits1[playerid][1], a);
				}
				case 1:
				{
					GetPlayerPos(playerid, Editor_AreaLimits2[playerid][0], Editor_AreaLimits2[playerid][1], a);
				}
			}

			new
				Float:XMax = (Editor_AreaLimits1[playerid][0] > Editor_AreaLimits2[playerid][0] ? Editor_AreaLimits1[playerid][0] : Editor_AreaLimits2[playerid][0]),
				Float:YMax = (Editor_AreaLimits1[playerid][1] > Editor_AreaLimits2[playerid][1] ? Editor_AreaLimits1[playerid][1] : Editor_AreaLimits2[playerid][1]),

				Float:XMin = (Editor_AreaLimits1[playerid][0] < Editor_AreaLimits2[playerid][0] ? Editor_AreaLimits1[playerid][0] : Editor_AreaLimits2[playerid][0]),
				Float:YMin = (Editor_AreaLimits1[playerid][1] < Editor_AreaLimits2[playerid][1] ? Editor_AreaLimits1[playerid][1] : Editor_AreaLimits2[playerid][1]);

			if (Editor_GangZoneTest[playerid] != -1)
				GangZoneDestroy (Editor_GangZoneTest[playerid]);

			Editor_GangZoneTest[playerid] = -1;

			Editor_GangZoneTest[playerid] = GangZoneCreate(XMin, YMin, XMax, YMax);
			GangZoneShowForPlayer(playerid, Editor_GangZoneTest[playerid], blue);

			if (Editor_WorkingType[playerid] == EDITOR_WORKTYPE_ARENA || Editor_WorkingType[playerid] == EDITOR_WORKTYPE_BASE)
			{
				ShowPlayerDialog(playerid, DIALOG_EDITOR_CREATINGMENU, DIALOG_STYLE_LIST, "Creazione", "Attackers Spawn\nDefenders Spawn\nCheckpoint\nName\nSet limit\nSalva", "Cambia", "Indietro");
			}
			else
			{
				ShowPlayerDialog(playerid, DIALOG_EDITOR_CREATEGGFF, DIALOG_STYLE_LIST, "Creazione", "Name\nSet Spawns\nSet limit\nSalva", "Seleziona", "Indietro");
			}
			//	ShowPlayerDialog(playerid, DIALOG_EDITOR_CREATINGMENU, DIALOG_STYLE_LIST, "Creazione", "Attackers Spawn\nDefenders Spawn\nCheckpoint\nName\nSet limit\nSalva", "Cambia", "Indietro");
			return true;
		}
		case EDITOR_BASESAVE_PACK:
		{
			if (!response) return ShowPlayerDialog(playerid, DIALOG_EDITOR_CREATINGMENU, DIALOG_STYLE_LIST, "Creazione", "Attackers Spawn\nDefenders Spawn\nCheckpoint\nName\nSet limit\nSalva", "Cambia", "Indietro");

			if (Editor_WorkingType[playerid] == EDITOR_WORKTYPE_NOONE)
			{
				SendClientMessage(playerid, COLOR_SYSTEM, "Invalid working type");
				ShowPlayerDialog(playerid, DIALOG_EDITOR_ACTION, DIALOG_STYLE_LIST, "Action", "Crea\nModifica\nEsci", "Scegli", "Chiudi");
				return false;
			}

			format (stringo, sizeof stringo, "La base sarï¿½ salvata sul pack %s.", basesPacks[listitem][SQLdb]);
			SendClientMessage(playerid, COLOR_SYSTEM, stringo);

			MySQLStatus[TotalQuerys] ++; mysql_tquery
			(
				g_MySQLConnection,
				sprintf("INSERT INTO bases_%s (home, att, def, interior, attwin, defwin, played, name) VALUES ('%f,%f,%f', '%f,%f,%f', '%f,%f,%f', '%d', '0', '0', '0', '%s')",
					basesPacks[listitem][SQLdb],
					Editor_Checkpoint[playerid][0], Editor_Checkpoint[playerid][1], Editor_Checkpoint[playerid][2],
					Editor_Attackers[playerid][0], Editor_Attackers[playerid][1], Editor_Attackers[playerid][2],
					Editor_Defenders[playerid][0], Editor_Defenders[playerid][1], Editor_Defenders[playerid][2],
					GetPlayerInterior(playerid),
					Editor_Name[playerid]
				),
				"Editor_OnEditorAdding",
				"i",
				playerid
			);

			return true;
		}
		case DIALOG_EDITOR_CREATEGGFF:
		{
			if (!response) return ShowPlayerDialog(playerid, DIALOG_EDITOR_CREA, DIALOG_STYLE_LIST, "Crea", "Base\nArena\nGungame\nFight\nEsci", "Crea", "Indietro");

			switch (listitem)
			{
				case 0:
				{
					ShowPlayerDialog(playerid, DIALOG_EDITOR_SETNAME, DIALOG_STYLE_INPUT, "Set name", "Inserisci il nome", "Imposta", "Indietro");
				}
				case 1:
				{
					Editor_SettingSpawn[playerid] = true;
					SendClientMessage(playerid, COLOR_SYSTEM, "Usa ~k~~PED_FIREWEAPON~ per impostare uno spawn, /e per terminare.");
				}
				case 2:
				{
					// set limit
					ShowPlayerDialog(playerid, DIALOG_EDITOR_SETLIMITS, DIALOG_STYLE_LIST, "Set limits", "Limit 1\nLimit 2", "Seleziona", "Indietro");
				}
				case 3:
				{
					// salva
					new
						Float:XMax = (Editor_AreaLimits1[playerid][0] > Editor_AreaLimits2[playerid][0] ? Editor_AreaLimits1[playerid][0] : Editor_AreaLimits2[playerid][0]),
						Float:YMax = (Editor_AreaLimits1[playerid][1] > Editor_AreaLimits2[playerid][1] ? Editor_AreaLimits1[playerid][1] : Editor_AreaLimits2[playerid][1]),

						Float:XMin = (Editor_AreaLimits1[playerid][0] < Editor_AreaLimits2[playerid][0] ? Editor_AreaLimits1[playerid][0] : Editor_AreaLimits2[playerid][0]),
						Float:YMin = (Editor_AreaLimits1[playerid][1] < Editor_AreaLimits2[playerid][1] ? Editor_AreaLimits1[playerid][1] : Editor_AreaLimits2[playerid][1]);

					if (Editor_WorkingType[playerid] == EDITOR_WORKTYPE_GUNGAME)
					{
						//792.64214,966.555184,478.26087,732.441472
						//xmax,ymax,xmin,ymin

						new szString [QUERY_STRING_SIZE];// non sono sicuro che sia 1024 (troppo poco o troppo grande)

						format (szString, sizeof szString,
							"INSERT INTO gungame (interior, name, zona, played, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11, s12, s13, s14, s15, s16, s17, s18, s19) \
							VALUES ('%d', '%s', '%f,%f,%f,%f', '0', '%f,%f,%f', '%f,%f,%f', '%f,%f,%f', '%f,%f,%f', '%f,%f,%f', '%f,%f,%f', '%f,%f,%f', '%f,%f,%f', '%f,%f,%f', '%f,%f,%f', \
							'%f,%f,%f', '%f,%f,%f', '%f,%f,%f', '%f,%f,%f', '%f,%f,%f', '%f,%f,%f', '%f,%f,%f', '%f,%f,%f', '%f,%f,%f')",

							GetPlayerInterior(playerid),
							Editor_Name[playerid],
							XMax,YMax,XMin,YMin,
							Editor_SpawnsPos[playerid][0][0], Editor_SpawnsPos[playerid][0][1], Editor_SpawnsPos[playerid][0][2],
							Editor_SpawnsPos[playerid][1][0], Editor_SpawnsPos[playerid][1][1], Editor_SpawnsPos[playerid][1][2],
							Editor_SpawnsPos[playerid][2][0], Editor_SpawnsPos[playerid][2][1], Editor_SpawnsPos[playerid][2][2],
							Editor_SpawnsPos[playerid][3][0], Editor_SpawnsPos[playerid][3][1], Editor_SpawnsPos[playerid][3][2],
							Editor_SpawnsPos[playerid][4][0], Editor_SpawnsPos[playerid][4][1], Editor_SpawnsPos[playerid][4][2],
							Editor_SpawnsPos[playerid][5][0], Editor_SpawnsPos[playerid][5][1], Editor_SpawnsPos[playerid][5][2],
							Editor_SpawnsPos[playerid][6][0], Editor_SpawnsPos[playerid][6][1], Editor_SpawnsPos[playerid][6][2],
							Editor_SpawnsPos[playerid][7][0], Editor_SpawnsPos[playerid][7][1], Editor_SpawnsPos[playerid][7][2],
							Editor_SpawnsPos[playerid][8][0], Editor_SpawnsPos[playerid][8][1], Editor_SpawnsPos[playerid][8][2],
							Editor_SpawnsPos[playerid][9][0], Editor_SpawnsPos[playerid][9][1], Editor_SpawnsPos[playerid][9][2],
							Editor_SpawnsPos[playerid][10][0], Editor_SpawnsPos[playerid][10][1], Editor_SpawnsPos[playerid][10][2],
							Editor_SpawnsPos[playerid][11][0], Editor_SpawnsPos[playerid][11][1], Editor_SpawnsPos[playerid][11][2],
							Editor_SpawnsPos[playerid][12][0], Editor_SpawnsPos[playerid][12][1], Editor_SpawnsPos[playerid][12][2],
							Editor_SpawnsPos[playerid][13][0], Editor_SpawnsPos[playerid][13][1], Editor_SpawnsPos[playerid][13][2],
							Editor_SpawnsPos[playerid][14][0], Editor_SpawnsPos[playerid][14][1], Editor_SpawnsPos[playerid][14][2],
							Editor_SpawnsPos[playerid][15][0], Editor_SpawnsPos[playerid][15][1], Editor_SpawnsPos[playerid][15][2],
							Editor_SpawnsPos[playerid][16][0], Editor_SpawnsPos[playerid][16][1], Editor_SpawnsPos[playerid][16][2],
							Editor_SpawnsPos[playerid][17][0], Editor_SpawnsPos[playerid][17][1], Editor_SpawnsPos[playerid][17][2],
							Editor_SpawnsPos[playerid][18][0], Editor_SpawnsPos[playerid][18][1], Editor_SpawnsPos[playerid][18][2],
							Editor_SpawnsPos[playerid][19][0], Editor_SpawnsPos[playerid][19][1], Editor_SpawnsPos[playerid][19][2]
						);

						MySQLStatus[TotalQuerys] ++; mysql_tquery // devo mettere nel loader il loader della zona asd (gungame)
						(
							g_MySQLConnection,
							szString, // query ENORME PER LO SPRINTF
							"Editor_OnEditorAdding",
							"i",
							playerid
						);
					}
					else if (Editor_WorkingType[playerid] == EDITOR_WORKTYPE_FIGHT)
					{
						//792.64214,966.555184,478.26087,732.441472
						//xmax,ymax,xmin,ymin

						new szString [QUERY_STRING_SIZE];// non sono sicuro che sia 1024 (troppo poco o troppo grande)

						format (szString, sizeof szString,
							"INSERT INTO fight (interior, name, ZMax, ZMin, played, spawn1, spawn2, spawn3, spawn4, spawn5, spawn6, spawn7, spawn8, spawn9, spawn10, spawn11, spawn12, spawn13, spawn14, spawn15, spawn16, spawn17, spawn18, spawn19) \
							VALUES ('%d', '%s', '%f,%f', '%f,%f', '0', '%f,%f,%f', '%f,%f,%f', '%f,%f,%f', '%f,%f,%f', '%f,%f,%f', '%f,%f,%f', '%f,%f,%f', '%f,%f,%f', '%f,%f,%f', '%f,%f,%f', \
							'%f,%f,%f', '%f,%f,%f', '%f,%f,%f', '%f,%f,%f', '%f,%f,%f', '%f,%f,%f', '%f,%f,%f', '%f,%f,%f', '%f,%f,%f')",

							GetPlayerInterior(playerid),
							Editor_Name[playerid],
							XMax,YMax,XMin,YMin,
							Editor_SpawnsPos[playerid][0][0], Editor_SpawnsPos[playerid][0][1], Editor_SpawnsPos[playerid][0][2],
							Editor_SpawnsPos[playerid][1][0], Editor_SpawnsPos[playerid][1][1], Editor_SpawnsPos[playerid][1][2],
							Editor_SpawnsPos[playerid][2][0], Editor_SpawnsPos[playerid][2][1], Editor_SpawnsPos[playerid][2][2],
							Editor_SpawnsPos[playerid][3][0], Editor_SpawnsPos[playerid][3][1], Editor_SpawnsPos[playerid][3][2],
							Editor_SpawnsPos[playerid][4][0], Editor_SpawnsPos[playerid][4][1], Editor_SpawnsPos[playerid][4][2],
							Editor_SpawnsPos[playerid][5][0], Editor_SpawnsPos[playerid][5][1], Editor_SpawnsPos[playerid][5][2],
							Editor_SpawnsPos[playerid][6][0], Editor_SpawnsPos[playerid][6][1], Editor_SpawnsPos[playerid][6][2],
							Editor_SpawnsPos[playerid][7][0], Editor_SpawnsPos[playerid][7][1], Editor_SpawnsPos[playerid][7][2],
							Editor_SpawnsPos[playerid][8][0], Editor_SpawnsPos[playerid][8][1], Editor_SpawnsPos[playerid][8][2],
							Editor_SpawnsPos[playerid][9][0], Editor_SpawnsPos[playerid][9][1], Editor_SpawnsPos[playerid][9][2],
							Editor_SpawnsPos[playerid][10][0], Editor_SpawnsPos[playerid][10][1], Editor_SpawnsPos[playerid][10][2],
							Editor_SpawnsPos[playerid][11][0], Editor_SpawnsPos[playerid][11][1], Editor_SpawnsPos[playerid][11][2],
							Editor_SpawnsPos[playerid][12][0], Editor_SpawnsPos[playerid][12][1], Editor_SpawnsPos[playerid][12][2],
							Editor_SpawnsPos[playerid][13][0], Editor_SpawnsPos[playerid][13][1], Editor_SpawnsPos[playerid][13][2],
							Editor_SpawnsPos[playerid][14][0], Editor_SpawnsPos[playerid][14][1], Editor_SpawnsPos[playerid][14][2],
							Editor_SpawnsPos[playerid][15][0], Editor_SpawnsPos[playerid][15][1], Editor_SpawnsPos[playerid][15][2],
							Editor_SpawnsPos[playerid][16][0], Editor_SpawnsPos[playerid][16][1], Editor_SpawnsPos[playerid][16][2],
							Editor_SpawnsPos[playerid][17][0], Editor_SpawnsPos[playerid][17][1], Editor_SpawnsPos[playerid][17][2],
							Editor_SpawnsPos[playerid][18][0], Editor_SpawnsPos[playerid][18][1], Editor_SpawnsPos[playerid][18][2],
							Editor_SpawnsPos[playerid][19][0], Editor_SpawnsPos[playerid][19][1], Editor_SpawnsPos[playerid][19][2]
						);

						MySQLStatus[TotalQuerys] ++; mysql_tquery
						(
							g_MySQLConnection,
							szString, // query ENORME PER LO SPRINTF
							"Editor_OnEditorAdding",
							"i",
							playerid
						);
					}
				}
			}
			return true;
		}
		case DIALOG_VEHICLE:
		{
			if(!response) return true;
			switch(listitem) {
		        case 0: { ShowPlayerDialog(playerid, DIALOG_COLOR1VEH, DIALOG_STYLE_INPUT, "Vehicle Color 1", "Insert a color ( 0 - 252 )", "Change", "Back"); }
		        case 1: { ShowPlayerDialog(playerid, DIALOG_COLOR2VEH, DIALOG_STYLE_INPUT, "Vehicle Color 2", "Insert a color ( 0 - 252 )", "Change", "Back"); }
				case 2: { ShowPlayerDialog(playerid, DIALOG_PAINTJOB,  DIALOG_STYLE_LIST,  "Paintjob list",   "Paintjob 0\nPaintjob 1\nPaintjob 2\nRemove Paintjob", "Change", "Back"); }
		    }
		}
		case DIALOG_GUN:
		{
		    if (!response) return true;
//		    new id = GetPVarInt(playerid, sprintf( "gunmenu_%d", listitem ) );
//          PlayerGunMenu_Arr
            new id = PlayerGunMenu_Arr[playerid][listitem];

	     	GivePlayerWeapon(playerid, id, 9999);
	      	Player[playerid][Weapons][GetWeaponSlot(id)] = id;
	       	SetPlayerArmedWeapon(playerid, id);
	        format(stringo, sizeof stringo, "* Weapon: %s was given to you." , aWeaponNames[ id ] );
            SendClientMessage( playerid , green , stringo);

			PlayerPlaySound(playerid, SOUND_SUCCESS, 0.0, 0.0, 0.0);

			if (Player[id][Loggen])
			{
				new weaps[ 30 ];
				for (new i = 0; i < 13; i++)
				{
				    strcat(weaps, sprintf("%d,", Player[playerid][Weapons][i]));
				}

				MySQLStatus[TotalQuerys] ++; mysql_tquery(g_MySQLConnection, sprintf("UPDATE users SET weapons = '%s' WHERE nickname = '%s'", weaps, Player[playerid][Nickname]), "", "");
			}
		}
		case DIALOG_PLAYERSLIST:
		{
		    if (response)
		    {
		        //new id = GetPVarInt( playerid , sprintf( "lPlayers_%d" , listitem ) );
				new id = PlayerList_Arr [playerid][listitem];

		        SendClientMessage(playerid, -1, " ");

		        format(stringo, sizeof stringo, "-- {"#COLOR_SYSTEM_FOCUS"}%s{"#COLOR_SYSTEM_REST"}'s stats.", Player[id][Nickname]);
		        SendClientMessage(playerid, COLOR_SYSTEM , stringo);

		        SendClientMessage(playerid, -1, " ");

			    new r[ 6 ];
	  			switch (Player[playerid][aLevel])
			    {
			        case lUser:  r = "User";
			        case lMod:   r = "Mod";
			        case lAdmin: r = "Admin";
			        case lRoot:  r = "Root";
			        default:     r = "User";
			    }

		        format(stringo, sizeof stringo, "-- Total Kills: {"#COLOR_SYSTEM_FOCUS"}%d{"#COLOR_SYSTEM_REST"} // Total Deaths: {"#COLOR_SYSTEM_FOCUS"}%d{"#COLOR_SYSTEM_REST"} // Skin: {"#COLOR_SYSTEM_FOCUS"}%s{"#COLOR_SYSTEM_REST"}", Player[ id ][ GKills ], Player[ id ][ GDeaths ] , Player[ id ][ Skin ] > 0 ? ( numstr(Player[playerid][Skin]) ) : ( "Default" ));
                SendClientMessage(playerid, COLOR_SYSTEM , stringo);

				format(stringo, sizeof stringo, "-- Admin Level: {"#COLOR_SYSTEM_FOCUS"}%s{"#COLOR_SYSTEM_REST"}", r);
				SendClientMessage(playerid, COLOR_SYSTEM , stringo );

				format(stringo, sizeof stringo, "-- Round Kills: {"#COLOR_SYSTEM_FOCUS"}%d{"#COLOR_SYSTEM_REST"} // Round Deaths: {"#COLOR_SYSTEM_FOCUS"}%d{"#COLOR_SYSTEM_REST"} // Round Damage: {"#COLOR_SYSTEM_FOCUS"}%d{"#COLOR_SYSTEM_REST"}", Player[ id ][ RKills ] , Player[ id ][ RDeaths ] , Player[ id ][ RDamage ]);
				SendClientMessage(playerid, COLOR_SYSTEM , stringo);

				if (gConfig[Matchmode] == MATCHMODE_NOSCORES) {
					format(stringo, sizeof stringo, "-- FunMode Score: %d ", Player [ id ][ PlayerTotalPoints ]);
                    SendClientMessage(playerid, COLOR_SYSTEM , stringo);
				}

		        if (Player[ id ][ InDm ] != -1){
			 		format(stringo, sizeof stringo, "-- (#%d) Deathmatch Kills: %d // Deathmatch Damage: %d", Player[ id ][ InDm ] + 1, Player[ id ][ DKills ] , Player[ id ][ DDamage ]);
                    SendClientMessage(playerid, COLOR_SYSTEM , stringo);
				}

		        SendClientMessage(playerid, -1, " ");
		    }
		}
		case DIALOG_REQSTATS:
		{
		    if (response)
		    {//player stats
				new szPlayers[ 200 ];
				new x = 0;

				foreach(new i:Player)
		        {
					strcat( szPlayers , sprintf( "#%d - %s\n", i , Player[i][Nickname] ) );
					PlayerList_Arr [playerid][x] = i;
					//SetPVarInt(playerid, sprintf( "lPlayers_%d" , x ) , i );
					x++;
		        }

		        ShowPlayerDialog(playerid, DIALOG_PLAYERSLIST, DIALOG_STYLE_LIST, "Players", szPlayers, "Open", "Close");

		    }
		    else
		    {
		        // server stats
				SendClientMessage(playerid, COLOR_YELLOW, "** Gamemode Stats:");
				SendClientMessage(playerid, -1, " ");

				format(stringo, sizeof stringo, "Gamemode ran {69C3F3}%d times{FFFFFF}.", ServerStats[ Gamemode_Runs ] );
				SendClientMessage(playerid, -1, stringo);

				format(stringo, sizeof stringo, "Total connected players: {69C3F3}%d{FFFFFF}.", ServerStats[ TotalConnectedPlayers ] );
				SendClientMessage(playerid, -1, stringo);

				format(stringo, sizeof stringo, "Total kills: {69C3F3}%d{FFFFFF}.", ServerStats[ TotalKills ] );
                SendClientMessage(playerid, -1, stringo);

				SendClientMessage(playerid, -1, " ");
				SendClientMessage(playerid, COLOR_YELLOW, "** Gaming:");

				SendClientMessage(playerid, -1, " ");
				format(stringo, sizeof stringo, "Bases: {69C3F3}%d{FFFFFF} - Arenes: {69C3F3}%d{FFFFFF} - TDMs: {69C3F3}%d",ServerStats[ PlayedBases ], ServerStats[ PlayedArene ], ServerStats[ PlayedTDMS ] );
                SendClientMessage(playerid, -1, stringo);

				format(stringo, sizeof stringo, "PVP: {69C3F3}%d{FFFFFF} - Ints: {69C3F3}%d{FFFFFF} - GunGame: {69C3F3}%d", ServerStats[ PlayedPVP ], ServerStats[ PlayedInteriors ], ServerStats[ PlayedGunGame ] );
                SendClientMessage(playerid, -1, stringo);

		    }
		}
		case DIALOG_TELEPORTS:
		{
		    if(!response) return true;
		    if(listitem > sizeof TeleportPlaces) return true;

		    SetPlayerPos (playerid , TeleportPlaces[ listitem ][ tX ] , TeleportPlaces[ listitem ][ tY ] , TeleportPlaces[ listitem ][ tZ ] );
		    SetPlayerFacingAngle( playerid , TeleportPlaces[ listitem ][ tA ] );
		    SetPlayerInterior( playerid , TeleportPlaces[ listitem ][ tInterior ] );
		    SetPlayerVirtualWorld( playerid , NORMAL_WORLD );
		    format(stringo, sizeof stringo, "{"#COLOR_SYSTEM_FOCUS"}%s{"#COLOR_SYSTEM_REST"} went to {"#COLOR_SYSTEM_FOCUS"}%s{"#COLOR_SYSTEM_REST"}  (/t)", Player[ playerid ][ Nickname ] , TeleportPlaces[ listitem ][ tName ] );
            SendClientMessageToAll( COLOR_SYSTEM , stringo);
			return true;
		}
		case DIALOG_REGISTER:
		{//THREAD_USERREGISTER
		    if ( !response ) return true;
		    if ( strlen( inputtext ) < 1 ) return cmd_register( playerid , "" );

/*			#define mysql_query(%1,%2,%3,%4) \
				MySQLStatus[TotalQuerys] ++; mysql_function_query(%4, %1, false, "OnQueryFinish", "siii", %1, %2, %3, %4)

		    %1 = query
		    %2 = thread
		    %3 = extra id
		    %4 = connectionid
		    */

		    WP_Hash(Player[playerid][Save_Password], 129, inputtext);

//		    mysql_query(szQuery, THREAD_VALIDACC, playerid, g_MySQLConnection);
		    MySQLStatus[TotalQuerys] ++; mysql_tquery(g_MySQLConnection, sprintf("SELECT NULL FROM users WHERE nickname = '%s'", Player[playerid][Nickname]), "OnUserChecking", "ii", THREAD_VALIDACC, playerid);
		}
		case DIALOG_LOGIN:
		{
		    if ( strlen( inputtext ) < 1 )
			{
	    		ShowPlayerDialog(playerid, DIALOG_LOGIN, DIALOG_STYLE_PASSWORD, "Login", "Insert the password you used when you registered your account", "Login", "");
				return true;
			}

			if (Player[playerid][Loggen])
			{
			    return true;
			}

            WP_Hash(Player[playerid][Save_Password], 129, inputtext);

//			mysql_query(szQuery, THREAD_PLAYERLOGIN, playerid, g_MySQLConnection);
			MySQLStatus[TotalQuerys] ++; mysql_tquery(g_MySQLConnection, sprintf("SELECT password, skin, level, kills, deaths, weapons, serial FROM users WHERE nickname = '%s'", Player[playerid][Nickname]), "OnUserChecking", "ii", THREAD_PLAYERLOGIN, playerid);
		}
		case DIALOG_PINFO:
		{
		    if(response) cmd_pinfo(playerid, "");
		}
		case DIALOG_PAINTJOB:
		{
		    if(!response) return cmd_vehicle(playerid, "");
		    if(!IsPlayerInAnyVehicle(playerid)) return true;
			new veh = GetPlayerVehicleID(playerid);
			ChangeVehiclePaintjobEx(veh, listitem);
			return true;
		}
		case DIALOG_COLOR1VEH:
		{
		    if(!response) return cmd_vehicle(playerid, "");
		    if(!IsPlayerInAnyVehicle(playerid)) return true;
		    new color1 = strval(inputtext);
		    if( color1 < 0 || color1 > 252 ) return ShowPlayerDialog(playerid, DIALOG_COLOR1VEH, DIALOG_STYLE_INPUT, "Vehicle Color 1", "Insert a color ( 0 - 252 )", "Change", "Back");
			new veh = GetPlayerVehicleID(playerid);
			ChangeVehicleColor(veh, color1, iVeh[veh][Color2]);
			iVeh[veh][Color1] = color1;
			return true;
		}
		case DIALOG_COLOR2VEH:
		{
		    if(!response) return cmd_vehicle(playerid, "");
		    if(!IsPlayerInAnyVehicle(playerid)) return true;
		    new color2 = strval(inputtext);
		    if( color2 < 0 || color2 > 252 ) return ShowPlayerDialog(playerid, DIALOG_COLOR2VEH, DIALOG_STYLE_INPUT, "Vehicle Color 2", "Insert a color ( 0 - 252 )", "Change", "Back");
			new veh = GetPlayerVehicleID(playerid);
			ChangeVehicleColor(veh, iVeh[veh][Color1], color2);
			iVeh[veh][Color2] = color2;
			return true;
		}
		case DIALOG_FIGHTSTYLE:
		{
		    if(!response) return true;
		    for(new i = 0; i < sizeof(FightStyle); i++)
			{
				if(i != listitem) continue;
				SetPlayerFightingStyle(playerid, FightStyle[i][f_ID]);
				format(stringo, sizeof stringo, "Now your fight style is {"#COLOR_SYSTEM_FOCUS"}%s", FightStyle[i][f_Name]);
				SendClientMessage(playerid, COLOR_SYSTEM, stringo);
				return true;
		    }
		}
		case DIALOG_SKINMAIN:
		{
		    if(!response) return true;
		    switch(listitem)
			{
		        case 0:
				{
		            ShowPlayerDialog(playerid, DIALOG_SKINID, DIALOG_STYLE_INPUT, "Skin ID", "Insert the skin ID, or 0 to remove the skin", "Change", "Back");
		        }
		        case 1:
				{
		            MostraIndexObject(playerid);
		        }
		    }
		}
		case DIALOG_SKINBONE:
		{
		    if(!response) return cmd_skin(playerid, "");
		    Player[playerid][EditorBone] = BoneList[listitem][BoneID];
			MostraObjectsList(playerid);
		}
		case DIALOG_SKINID:
		{
		    if(!response) return cmd_skin(playerid, "");
		    new id = strval(inputtext);
		    if(id == 0) {
				Player[playerid][Skin] = 0;
				cmd_s(playerid, "");

				MySQLStatus[TotalQuerys] ++; mysql_tquery(g_MySQLConnection, sprintf("UPDATE users SET skin = '%d' WHERE nickname = '%s'", id, Player[playerid][Nickname]) , "", "");
				return 0;
			}
			if(id < 1 || id > 299) return ShowPlayerDialog(playerid, DIALOG_SKINID, DIALOG_STYLE_INPUT, "Skin ID", "Invalid ID!", "Change", "Back");
		    Player[playerid][Skin] = id;
			SetPlayerSkin(playerid, id);
			MySQLStatus[TotalQuerys] ++; mysql_tquery(g_MySQLConnection, sprintf("UPDATE users SET skin = '%d' WHERE nickname = '%s'", id, Player[playerid][Nickname]) , "", "");
		}
		case DIALOG_SKINOBJECTSLIST:
		{
		    if(!response)
			{
	    		new str[ 256 ];
	     		for(new i = 0; i < sizeof(BoneList); i++) {
					format(str, sizeof str, "%s%s\n", str, BoneList[i][BoneName]);
	     		}
	       		ShowPlayerDialog(playerid, DIALOG_SKINBONE, DIALOG_STYLE_LIST, "Object position", str, "Object", "Back");
		    }
		    else
			{
		        pSkinAttachObject[playerid][Player[playerid][EditorIndex]][ao_model] = lAttachObjects[listitem][oModel];
		        pSkinAttachObject[playerid][Player[playerid][EditorIndex]][ao_bone]  = Player[playerid][EditorBone];
		        SetPlayerAttachedObject(playerid, Player[playerid][EditorIndex], lAttachObjects[listitem][oModel], Player[playerid][EditorBone]);
	            EditAttachedObject(playerid, Player[playerid][EditorIndex]);
//	            format(stringo, sizeof stringo, "Hint: use {B5E961}~k~~PED_SPRINT~{91E012} to move yourself around, {B5E961}esc{91E012} to cancel.");
	            SendClientMessage(playerid, 0x91E012AA, "Hint: use {B5E961}~k~~PED_SPRINT~{91E012} to move yourself around, {B5E961}esc{91E012} to cancel.");
			}
		}
		case DIALOG_SKININDEX:
		{
		    if(!response) return cmd_skin(playerid, "");
		    Player[playerid][EditorIndex] = listitem;
		    if(IsPlayerAttachedObjectSlotUsed(playerid, listitem)) {
		        ShowPlayerDialog(playerid, DIALOG_SLOTOCCUPATO, DIALOG_STYLE_LIST, "Choose what you want to do", "Modify the object position\nRemove object", "Action", "Close");
		        return true;
		    }

	    	new str[ 256 ];

		 	for(new i = 0; i < sizeof(BoneList); i++)
			{
				format(str, sizeof str, "%s%s\n", str, BoneList[i][BoneName]);
	    	}

	       	ShowPlayerDialog(playerid, DIALOG_SKINBONE, DIALOG_STYLE_LIST, "Object position", str, "Object", "Back");
		}
		case DIALOG_SLOTOCCUPATO:
		{
		    if(!response) return MostraIndexObject(playerid);
		    switch(listitem)
			{
		        case 0:
				{
		            EditAttachedObject(playerid, Player[playerid][EditorIndex]);
		           	SendClientMessage(playerid, 0x91E012AA, "Hint: use {B5E961}Spacebar{91E012} to move yourself around, {B5E961}esc{91E012} to cancel.");
				}
		        case 1:
				{
		            if(IsPlayerAttachedObjectSlotUsed(playerid, Player[playerid][EditorIndex]))
					{
						RemovePlayerAttachedObject(playerid, Player[playerid][EditorIndex]);

						new i = Player[playerid][EditorIndex];
						pSkinAttachObject[playerid][i][ao_model]  = 0;
						pSkinAttachObject[playerid][i][ao_bone]   = 0;

						pSkinAttachObject[playerid][i][ao_x]      = 0.0;
						pSkinAttachObject[playerid][i][ao_y]      = 0.0;
						pSkinAttachObject[playerid][i][ao_z]      = 0.0;

						pSkinAttachObject[playerid][i][ao_rx]     = 0.0;
						pSkinAttachObject[playerid][i][ao_ry]     = 0.0;
						pSkinAttachObject[playerid][i][ao_rz]     = 0.0;

						pSkinAttachObject[playerid][i][ao_sx]     = 0.0;
						pSkinAttachObject[playerid][i][ao_sy]     = 0.0;
						pSkinAttachObject[playerid][i][ao_sz]     = 0.0;
					}
	                MostraIndexObject(playerid);
		        }
		    }
		}
		case DIALOG_WEAPONSET:
		{
		    if(!Player[playerid][InGame])return true;
		    if(!RoundStarted) return true;
			if(Gaming!=GAMETYPE_BASE) return true;
		    if(Player[playerid][Team]==TEAM_REF)return true;
		    if(Player[playerid][Weaponset]==INVALID_WEAPON_SET&&!response) return MostraWeaponset(playerid);
		    if(listitem==0) return MostraWeaponset(playerid);

		    new
		        id   = listitem - 1,
				team = Player[ playerid ][ Team ];

			if (Weaponsets[id][DisabledForGm] == gConfig[ GameMode ])
			{
			    return MostraWeaponset(playerid);
			}

			if (Weaponsets[id][LimitedForGM] != gConfig[ GameMode ])
			{
				if ( !Weaponsets[id][Enabled] )
				{
				    return MostraWeaponset(playerid);
				}
			}

			if ( Weaponsets[id][TeamSelection][team] >= Weaponsets[id][Limit] )
			{
	  			format(stringo, sizeof stringo, "The weaponset %s has reached the limit per team.", Weaponsets[id][SetName]);
	  			SendClientMessage(playerid, COLOR_GREY, stringo);
				return MostraWeaponset(playerid);
			}

		    Weaponsets[id][TeamSelection][team] ++;
		    Player[playerid][Weaponset] = id;
		    PlayerPlaySound(playerid, 45400, 0.0, 0.0, 0.0);

			ResetPlayerWeapons(playerid);
	  		GivePlayerWeapon(playerid, Weaponsets[id][ID1], 9999);
	  		GivePlayerWeapon(playerid, Weaponsets[id][ID2], 9999);

	  		if (Player[playerid][Team] == TEAM_A)
	  		{
	  		    TextDrawSetString(PlayerSpecInfo[playerid][6], sprintf("~r~~h~WPS: ~w~%s", Weaponsets[id][SetName]));
	  		}
	  		else
	  		{
	  		    TextDrawSetString(PlayerSpecInfo[playerid][6], sprintf("~b~~h~WPS: ~w~%s", Weaponsets[id][SetName]));
	  		}

			new
			    str[ STRLIB_RETURN_SIZE ];

			switch(team)
			{
	  			case TEAM_A:
				{
					str = sprintf( "\"{"#SC_TEAMA"}%s{FFFFFF}\" has chosen the weaponset {"#SC_TEAMA"}%s{FFFFFF} ({"#SC_TEAMA"}%d{FFFFFF})", Player[playerid][Nickname], Weaponsets[id][SetName], Weaponsets[id][TeamSelection][team] );
	        	}
		        case TEAM_B:
				{
					str = sprintf( "\"{"#SC_TEAMB"}%s{FFFFFF}\" has chosen the weaponset {"#SC_TEAMB"}%s{FFFFFF} ({"#SC_TEAMB"}%d{FFFFFF})", Player[playerid][Nickname], Weaponsets[id][SetName], Weaponsets[id][TeamSelection][team] );
				}
			}

			foreach(new i:Player)
			{
			    if(Player[i][Team] == team)
				{
			        SendClientMessage(i, -1, str);
			    }
			}

			if( GamePaused )
			{
				TogglePlayerControllable(playerid, false);
			}
		}
		case DIALOG_DEATHMATCHPASSWORD:
		{
		    if (!response)
			{
		        Player_DmTry[ playerid ] = 0;
		        return true;
		    }
			if (Player_DmTry[ playerid ] != 0 )
			{
				if ( !DMLocked[Player_DmTry[ playerid ]] )
				{
				    new id = Player_DmTry[ playerid ];
					/*
					Player[playerid][InDm] 		= id;
//					TextDrawHideForPlayer(playerid, HintTD);
  				//	MySQLStatus[TotalQuerys] ++; mysql_tquery(g_MySQLConnection, sprintf ("SELECT damage, kills FROM bestdmplayer WHERE nickname = '%s' AND dmid = '%d'", Player[playerid][Nickname], Player_DmTry[ playerid ]), true, "OnDeathmatchStats", "ii", playerid, Player_DmTry[ playerid ]);
					MySQLStatus[TotalQuerys] ++; mysql_tquery(g_MySQLConnection, sprintf ("SELECT damage, kills FROM bestdmplayer WHERE nickname = '%s' AND dmid = '%d'", Player[playerid][Nickname], id), "OnDeathmatchStats", "ii", playerid, id);

					SetPlayerPos(playerid, 0.0, 0.0, 0.0);

					SetPlayerColor(playerid, COLOR_DM);

					SetSpawnInfo(playerid, playerid, GetPlayerSkinEx(playerid), Deathmatchs[id][Spawn][0] - MAX_RANDOM_SPAWN + random( MAX_RANDOM_SPAWN ), Deathmatchs[id][Spawn][1] - MAX_RANDOM_SPAWN + random( MAX_RANDOM_SPAWN ), Deathmatchs[id][Spawn][2], Deathmatchs[id][Spawn][3], Deathmatchs[id][Weapon1], 9999, Deathmatchs[id][Weapon2], 9999, Deathmatchs[id][Weapon3], 9999);
				    SpawnPlayer(playerid);
					format(stringo, sizeof stringo, "{"#COLOR_SYSTEM_FOCUS"}%s{"#COLOR_SYSTEM_REST"} has entered /dm {"#COLOR_SYSTEM_FOCUS"}%d", Player[playerid][Nickname], id + 1);
					SendClientMessageToAll(COLOR_SYSTEM, stringo);
					SetPlayerVirtualWorld(playerid, Player_DmTry[ playerid ] + 1);
					*/
					PutPlayerInDm (playerid, id);

				    SendClientMessage(playerid, COLOR_SYSTEM, "This deathmatch is no longer locked.");
				    return true;
				}
				else {
				    if (strlen(inputtext)>1)
				    {
					    if (!strcmp(DMLocked_Password[Player_DmTry[ playerid ]], inputtext, true))
						{
						    new id = Player_DmTry[ playerid ];
						    /*
							Player[playerid][InDm] 		= id;
//							TextDrawHideForPlayer(playerid, HintTD);
  							//MySQLStatus[TotalQuerys] ++; mysql_function_query(g_MySQLConnection, sprintf ("SELECT damage, kills FROM bestdmplayer WHERE nickname = '%s' AND dmid = '%d'", Player[playerid][Nickname], Player_DmTry[ playerid ]), true, "OnDeathmatchStats", "ii", playerid, Player_DmTry[ playerid ]);
							MySQLStatus[TotalQuerys] ++; mysql_tquery(g_MySQLConnection, sprintf ("SELECT damage, kills FROM bestdmplayer WHERE nickname = '%s' AND dmid = '%d'", Player[playerid][Nickname], id), "OnDeathmatchStats", "ii", playerid, id);

							SetPlayerPos(playerid, 0.0, 0.0, 0.0);

							SetPlayerColor(playerid, COLOR_DM);

							SetSpawnInfo(playerid, playerid, GetPlayerSkinEx(playerid), Deathmatchs[id][Spawn][0] - MAX_RANDOM_SPAWN + random( MAX_RANDOM_SPAWN ), Deathmatchs[id][Spawn][1] - MAX_RANDOM_SPAWN + random( MAX_RANDOM_SPAWN ), Deathmatchs[id][Spawn][2], Deathmatchs[id][Spawn][3], Deathmatchs[id][Weapon1], 9999, Deathmatchs[id][Weapon2], 9999, Deathmatchs[id][Weapon3], 9999);
						    SpawnPlayer(playerid);
							format(stringo, sizeof stringo, "{"#COLOR_SYSTEM_FOCUS"}%s{"#COLOR_SYSTEM_REST"} has entered /dm {"#COLOR_SYSTEM_FOCUS"}%d", Player[playerid][Nickname], id + 1);
							SendClientMessageToAll(COLOR_SYSTEM, stringo);
							SetPlayerVirtualWorld(playerid, Player_DmTry[ playerid ] + 1);*/
							
							PutPlayerInDm (playerid, id);

						    SendClientMessage(playerid, COLOR_SYSTEM, "This deathmatch is no longer locked.");
					    }
					    else
					    {
		       				ShowPlayerDialog( playerid , DIALOG_DEATHMATCHPASSWORD , DIALOG_STYLE_PASSWORD , "Locked deathmatch", "Wrong password", "Join", "Leave");
						}
					}
					else
					{
						ShowPlayerDialog( playerid , DIALOG_DEATHMATCHPASSWORD , DIALOG_STYLE_PASSWORD , "Locked deathmatch", "Wrong password", "Join", "Leave");
					}
				}
			}
		}
		case DIALOG_DEATHMATCHLIST:
	 	{
		    if (!response) return true;
		    new dm = listitem;
		    Player_DmTry[playerid] = dm;

		    if (DMLocked[dm])
			{
			    if (Player[playerid][AllowDM][dm] == true)
			    {
			        PutPlayerInDm (playerid, dm);
					/*
					Player[playerid][InDm] 		= dm;
//					TextDrawHideForPlayer(playerid, HintTD);
					MySQLStatus[TotalQuerys] ++; mysql_tquery(g_MySQLConnection, sprintf ("SELECT damage, kills FROM bestdmplayer WHERE nickname = '%s' AND dmid = '%d'", Player[playerid][Nickname], dm), "OnDeathmatchStats", "ii", playerid, dm);

					SetPlayerPos(playerid, 0.0, 0.0, 0.0);

					SetPlayerColor(playerid, COLOR_DM);

					SetSpawnInfo(playerid, playerid, GetPlayerSkinEx(playerid), Deathmatchs[dm][Spawn][0] - MAX_RANDOM_SPAWN + random( MAX_RANDOM_SPAWN ), Deathmatchs[dm][Spawn][1] - MAX_RANDOM_SPAWN + random( MAX_RANDOM_SPAWN ), Deathmatchs[dm][Spawn][2], Deathmatchs[dm][Spawn][3], Deathmatchs[dm][Weapon1], 9999, Deathmatchs[dm][Weapon2], 9999, Deathmatchs[dm][Weapon3], 9999);
				    SpawnPlayer(playerid);

					format (stringo, sizeof stringo, "{"#COLOR_SYSTEM_FOCUS"}%s{"#COLOR_SYSTEM_REST"} has entered /dm {"#COLOR_SYSTEM_FOCUS"}%d", Player[playerid][Nickname], dm + 1);
					SendClientMessageToAll(COLOR_SYSTEM, stringo);
					SetPlayerVirtualWorld(playerid, dm + 1);*/
			        return true;
			    }
			    else
			    {
		  			if (strlen( DMLocked_Password[dm] ) > 1 )
					{
		   				ShowPlayerDialog( playerid , DIALOG_DEATHMATCHPASSWORD , DIALOG_STYLE_PASSWORD , "Locked deathmatch", "Insert the password to enter this deathmatch.", "Enter", "Close");
						return true;
					}
		   			else
					{
		   				SendClientMessage( playerid , red , "This deathmatch is locked!" );
		   				return cmd_dm(playerid, "");
					}
				}
			}
			
			PutPlayerInDm (playerid, dm);
/*
			Player[playerid][InDm] 		= dm;
//			TextDrawHideForPlayer(playerid, HintTD);

			MySQLStatus[TotalQuerys] ++; mysql_tquery(g_MySQLConnection, sprintf ("SELECT damage, kills FROM bestdmplayer WHERE nickname = '%s' AND dmid = '%d'", Player[playerid][Nickname], dm), "OnDeathmatchStats", "ii", playerid, dm);

			SetPlayerPos(playerid, 0.0, 0.0, 0.0);

			SetPlayerColor(playerid, COLOR_DM);

			SetSpawnInfo(playerid, playerid, GetPlayerSkinEx(playerid), Deathmatchs[dm][Spawn][0] - MAX_RANDOM_SPAWN + random( MAX_RANDOM_SPAWN ), Deathmatchs[dm][Spawn][1] - MAX_RANDOM_SPAWN + random( MAX_RANDOM_SPAWN ), Deathmatchs[dm][Spawn][2], Deathmatchs[dm][Spawn][3], Deathmatchs[dm][Weapon1], 9999, Deathmatchs[dm][Weapon2], 9999, Deathmatchs[dm][Weapon3], 9999);
		    SpawnPlayer(playerid);

		    format (stringo, sizeof stringo, "{"#COLOR_SYSTEM_FOCUS"}%s{"#COLOR_SYSTEM_REST"} has entered /dm {"#COLOR_SYSTEM_FOCUS"}%d", Player[playerid][Nickname], dm + 1);
		    SendClientMessageToAll(COLOR_SYSTEM, stringo);
			SetPlayerVirtualWorld(playerid, dm + 1);*/
		}
		case DIALOG_PLAY_PRIMO:
		{
			//esce
			if (!response) return 1;
			if (listitem == 0)
			{
			    if (RoundStarted) return SendClientMessage (playerid, COLOR_RED, "You cannot change Matchmode while the round is running.");
				if(gConfig[Matchmode] == MATCHMODE_TCWCW)
				{
				    gConfig[Matchmode] = MATCHMODE_NOSCORES;
				    //ReadScores();
					MySQLStatus[TotalQuerys] ++; mysql_tquery(g_MySQLConnection, sprintf ("SELECT scores FROM stats WHERE gid = %d", G_ID), "OnReadScores", "");

					foreach(new i:Player)
					{
					    Player[i][Kills] = 0;
					    Player[i][Deaths] = 0;
					    Player[i][Damage] = 0;
					    Player[i][RKills] = 0;
					    Player[i][RDamage] = 0;

						SetPlayerScore(i, 0);

						PlayerTextDrawSetString (i, PlayerInfo[1], "DMG ~b~~h~0~n~~w~Tot. DMG ~b~~h~0");
					}

					/*
					for (new i = 0; i < MAX_PLAYERS; i++)
					{
					    Player[i][Kills] = 0;
					    Player[i][Deaths] = 0;
					    Player[i][Damage] = 0;
					    Player[i][RKills] = 0;
					    Player[i][RDamage] = 0;

						SetPlayerScore(i, 0);

						PlayerTextDrawSetString (i, PlayerInfo[1], "DMG ~b~~h~0~n~~w~Tot. DMG ~b~~h~0");
					}*/

					format (stringo, sizeof stringo, "Admin/Mod {"#COLOR_SYSTEM_FOCUS"}%s{"#COLOR_SYSTEM_REST"} has enabled No scores mode!", Player[playerid][Nickname]);
	                SendClientMessageToAll(COLOR_SYSTEM, stringo);

					ChangeTeamName(TEAM_A, "Attackers");
					ChangeTeamName(TEAM_B, "Defenders");

					CurrentMatchID = -1;
					Play_ShowMenu(playerid);
				}
				else
				{
				    gConfig[Matchmode] = MATCHMODE_TCWCW;

				    // Clear data
				    //ClearMatchsData ();


					ResetScores ();
					stop AutoHide_TD;
					AutoHideTD();

					format(stringo, sizeof stringo, "Admin/Mod {"#COLOR_SYSTEM_FOCUS"}%s{"#COLOR_SYSTEM_REST"} has enabled TCW/CW Mode!", Player[playerid][Nickname]);
	                SendClientMessageToAll(COLOR_SYSTEM, stringo);
	//							SendClientMessage(playerid, COLOR_SYSTEM, "Attendi l'ok prima di startare o cambiare qualcosa!");

	//							MySQLStatus[TotalQuerys] ++; mysql_function_query (g_MySQLConnection, sprintf ("INSERT INTO tcw (teama, teamb, type) VALUES ('%s', '%s', '0')", iTeam[TEAM_A][Name], iTeam[TEAM_B][Name]), false, "OnTCWCWOperationRun", "i", playerid);

					SendRconCommand(sprintf("mapname Lobby %s 0:0 %s", iTeam[TEAM_A][Name], iTeam[TEAM_B][Name]));

	//							webMatch[g_Connection] = mysql_connect("green.gel-hosting.co.uk", "sdominag_cwlogs", "sdominag_cwlogs", "HDXboWhPG2");

					mysql_tquery(g_MySQLConnection, "INSERT INTO matchdata (teama, teamb, scorea, scoreb, totalrounds, time, incorso) VALUES ('N/D', 'N/D', 0, 0, 0, 0, 1)", "OnIDAssigned", "");

					ShowPlayerDialog(playerid, DIALOG_PLAY_TEAM1NAME, DIALOG_STYLE_INPUT, "Play now - Team Name 1", "Insert the name of team A\nLeave it blank to use the current name.", "Next team", "Back");
				}
				return true;
			}

			if(gConfig[Matchmode] == MATCHMODE_TCWCW)
			{
			    switch (listitem)
				{
					case 2:
					{
						ShowPlayerDialog(playerid, DIALOG_PLAY_TEAM1NAME, DIALOG_STYLE_INPUT, "Play now - Team Name 1", "Insert the name of team A\nLeave it blank to use the current name.", "Next team", "Back");
					}
					case 3:
					{
					    ShowPlayerDialog(playerid, DIALOG_PLAY_SETROUNDS, DIALOG_STYLE_INPUT, "Play now - Rounds", "Insert the number of rounds you want to play", "Set", "Back");
					}
					case 4:
					{
					    if (AC_State == STATE_DISABLED) {
							format(stringo, sizeof stringo, "Admin/Mod {"#COLOR_SYSTEM_FOCUS"}%s{"#COLOR_SYSTEM_REST"} has enabled the Anticheat.",Player[playerid][Nickname]);

							SendClientMessageToAll(COLOR_SYSTEM, "You have a minute to turn on the anticheat!");

							AC_START_TIMER = defer StartAnticheat();
							AC_State = STATE_WAITING;
                            //AC_Toggle(true);

							GetServerVarAsString("hostname", g_stored_original_name, sizeof(g_stored_original_name));

							SendRconCommand ( sprintf ("hostname %s [AC]", g_stored_original_name) );
						}
						else {
						    AC_Toggle(false);

						    AC_State = STATE_DISABLED;
						    stop AC_START_TIMER;

							format(stringo, sizeof stringo, "Admin/Mod {"#COLOR_SYSTEM_FOCUS"}%s{"#COLOR_SYSTEM_REST"} has disabled the Anticheat.",Player[playerid][Nickname]);

					        SendRconCommand ( sprintf ("hostname %s", g_stored_original_name) );
						}

						SendClientMessageToAll(COLOR_SYSTEM, stringo);

                        Play_ShowMenu(playerid);
					}
					case 5: {
					    ShowPlayerDialog(playerid, DIALOG_BASESPACK_SELECT, DIALOG_STYLE_LIST, "Bases", "Slaughterfield\nESL\nWarGrounds\nNoCbug\nWarhead", "Load", "Back");
					}
					case 6:
					{
						cmd_swapt(playerid, "");
						Play_ShowMenu(playerid);
					}
					case 7:
					{
					    ShowPlayerDialog(playerid, DIALOG_PLAY_ALLVSBALANCE, DIALOG_STYLE_INPUT, "Play now - Balance all vs", "Insert the tag or the name of the player", "Balance", "Back");
					}
					case 8:
					{
						if (RoundStarted) return SendClientMessage(playerid, red, "You cannot use this command now.");
				    	Process_FineCW ();
				    	format(stringo, sizeof stringo, "Admin/Mod {"#COLOR_SYSTEM_FOCUS"}%s{"#COLOR_SYSTEM_REST"} forced the finish of the TCW/CW.", Player[playerid][Nickname]);
                        SendClientMessageToAll (COLOR_SYSTEM, stringo);
				    }
			    }
			}
			else
			{
			    // Funmode
			    switch (listitem) {
			        case 2: {
		                BalancePlayers(playerid);
		                Play_ShowMenu(playerid);
			        }
			        // switch pack here
			        case 3: {
						ShowPlayerDialog(playerid, DIALOG_BASESPACK_SELECT, DIALOG_STYLE_LIST, "Bases", "Slaughterfield\nESL\nWarGrounds\nNoCbug\nWarhead", "Load", "Back");
					}
			        // auto-ad here
			        case 4: {
					   	if (gConfig[AutoAD])
					    {
					        gConfig[AutoAD] = false;
							format (stringo, sizeof stringo, "Admin/Mod {"#COLOR_SYSTEM_FOCUS"}%s{"#COLOR_SYSTEM_REST"} has disabled Auto A/D Mode!", Player[playerid][Nickname]);
					    }
					    else
					    {
					        gConfig[AutoAD] = true;
							format (stringo, sizeof stringo, "Admin/Mod {"#COLOR_SYSTEM_FOCUS"}%s{"#COLOR_SYSTEM_REST"} has enabled Auto A/D Mode!", Player[playerid][Nickname]);
					    }

					    SendClientMessageToAll(COLOR_SYSTEM, stringo);
						MySQLStatus[TotalQuerys] ++; mysql_tquery(g_MySQLConnection, sprintf("UPDATE config SET autoad = '%d' WHERE gid = %d", gConfig[AutoAD], G_ID) , "", "");
					}
			    }

			    Play_ShowMenu(playerid);
			    return true;
			}
		}
		/*
		case DIALOG_PLAY_PRIMO:
		{
		    if(response)
			{
		        switch(listitem)
				{
		            case 1:
					{
					    if (RoundStarted) return SendClientMessage (playerid, COLOR_RED, "You cannot change Matchmode while the round is running.");
						if(gConfig[Matchmode] == MATCHMODE_TCWCW)
						{
						    gConfig[Matchmode] = MATCHMODE_NOSCORES;
						    //ReadScores();
							MySQLStatus[TotalQuerys] ++; mysql_tquery(g_MySQLConnection, sprintf ("SELECT scores FROM stats WHERE gid = %d", G_ID), "OnReadScores", "");

							foreach(new i:Player)
							{
							    Player[i][Kills] = 0;
							    Player[i][Deaths] = 0;
							    Player[i][Damage] = 0;
							    Player[i][RKills] = 0;
							    Player[i][RDamage] = 0;

								SetPlayerScore(i, 0);

								PlayerTextDrawSetString (i, PlayerInfo[1], "DMG ~b~~h~0~n~~w~Tot. DMG ~b~~h~0");
							}

							ClearMatchsData ();

							for (new i = 0; i < MAX_PLAYERS; i++)
							{
							    Player[i][Kills] = 0;
							    Player[i][Deaths] = 0;
							    Player[i][Damage] = 0;
							    Player[i][RKills] = 0;
							    Player[i][RDamage] = 0;

								SetPlayerScore(i, 0);

								PlayerTextDrawSetString (i, PlayerInfo[1], "DMG ~b~~h~0~n~~w~Tot. DMG ~b~~h~0");
							}

							format (stringo, sizeof stringo, "Admin/Mod {"#COLOR_SYSTEM_FOCUS"}%s{"#COLOR_SYSTEM_REST"} has enabled No scores mode!", Player[playerid][Nickname]);
                            SendClientMessageToAll(COLOR_SYSTEM, stringo);

//							mysql_tquery(webMatch[g_Connection], "UPDATE matchs SET matchend = UNIX_TIMESTAMP()", true, "SQLMatch_MatchEnded", "");
							//mysql_close (webMatch[g_Connection]);

							ChangeTeamName(TEAM_A, "Attackers");
							ChangeTeamName(TEAM_B, "Defenders");

							CurrentMatchID = -1;
							Play_ShowMenu(playerid);
						}
						else if(gConfig[Matchmode] == MATCHMODE_NOSCORES)
						{
						    gConfig[Matchmode] = MATCHMODE_TCWCW;

						    // Clear data
						    //ClearMatchsData ();

						    // Assign new data
						    foreach(new i:Player) {
						        AssignMatchID (i);
							}

							ResetScores ();
							stop AutoHide_TD;
							AutoHideTD();

							format(stringo, sizeof stringo, "Admin/Mod {"#COLOR_SYSTEM_FOCUS"}%s{"#COLOR_SYSTEM_REST"} has enabled TCW/CW Mode!", Player[playerid][Nickname]);
                            SendClientMessageToAll(COLOR_SYSTEM, stringo);
//							SendClientMessage(playerid, COLOR_SYSTEM, "Attendi l'ok prima di startare o cambiare qualcosa!");

//							MySQLStatus[TotalQuerys] ++; mysql_function_query (g_MySQLConnection, sprintf ("INSERT INTO tcw (teama, teamb, type) VALUES ('%s', '%s', '0')", iTeam[TEAM_A][Name], iTeam[TEAM_B][Name]), false, "OnTCWCWOperationRun", "i", playerid);

							SendRconCommand(sprintf("mapname Lobby %s 0:0 %s", iTeam[TEAM_A][Name], iTeam[TEAM_B][Name]));

//							webMatch[g_Connection] = mysql_connect("green.gel-hosting.co.uk", "sdominag_cwlogs", "sdominag_cwlogs", "HDXboWhPG2");

							mysql_tquery(g_MySQLConnection, "INSERT INTO matchdata (teama, teamb, scorea, scoreb, totalrounds, time, incorso) VALUES ('N/D', 'N/D', 0, 0, 0, 0, 1)", "OnIDAssigned", "");

							ShowPlayerDialog(playerid, DIALOG_PLAY_TEAM1NAME, DIALOG_STYLE_INPUT, "Play now - Team Name 1", "Insert the name of team A\nLeave it blank to use the current name.", "Next team", "Back");
						}
		            }
		            case 2:
					{
		                ShowPlayerDialog(playerid, DIALOG_PLAY_TEAM1NAME, DIALOG_STYLE_INPUT, "Play now - Team Name 1", "Insert the name of team A\nLeave it blank to use the current name.", "Next team", "Back");
		            }
		            case 3:
					{
		                ShowPlayerDialog(playerid, DIALOG_PLAY_SETROUNDS, DIALOG_STYLE_INPUT, "Play now - Rounds", "Insert the number of rounds you want to play", "Set", "Back");
		            }
		            case 4:
					{
					    if (AC_State == STATE_DISABLED) {
							format(stringo, sizeof stringo, "Admin/Mod {"#COLOR_SYSTEM_FOCUS"}%s{"#COLOR_SYSTEM_REST"} has enabled the Anticheat.",Player[playerid][Nickname]);

							SendClientMessageToAll(COLOR_SYSTEM, "You have a minute to turn on the anticheat!");

							AC_START_TIMER = defer StartAnticheat();
							AC_State = STATE_WAITING;
                            //AC_Toggle(true);

							GetServerVarAsString("hostname", g_stored_original_name, sizeof(g_stored_original_name));

							SendRconCommand ( sprintf ("hostname %s [AC]", g_stored_original_name) );
						}
						else {
						    AC_Toggle(false);

						    AC_State = STATE_DISABLED;
						    stop AC_START_TIMER;

							format(stringo, sizeof stringo, "Admin/Mod {"#COLOR_SYSTEM_FOCUS"}%s{"#COLOR_SYSTEM_REST"} has disabled the Anticheat.",Player[playerid][Nickname]);

					        SendRconCommand ( sprintf ("hostname %s", g_stored_original_name) );
						}

						SendClientMessageToAll(COLOR_SYSTEM, stringo);

                        Play_ShowMenu(playerid);
					    //SendClientMessage (playerid, COLOR_SYSTEM, "Tmp disabled.");
						//ShowPlayerDialog (playerid, DIALOG_SAVETYPE, DIALOG_STYLE_MSGBOX, "TCW or CW?", "Quando imposti la modalitï¿½ TCW/CW la gamemode invierï¿½ al database le seguenti informazioni:\n1. Round che sta per iniziare\n2. Score attuale\n3. Damage/Kills/Player list di chi ha giocato il round etc.\nTutto ï¿½ disponibile in tempo reale sul forum\n\nPremendo su \"SI\" si comunica che ï¿½ in corso una CW. Di default la gamemode la interpreta come TCW.", "Si", "No");
					}
		            case 5:
					{
					    if (gConfig[AutoAD])
					    {
					        gConfig[AutoAD] = false;
							format (stringo, sizeof stringo, "Admin/Mod {"#COLOR_SYSTEM_FOCUS"}%s{"#COLOR_SYSTEM_REST"} has disabled Auto A/D Mode!", Player[playerid][Nickname]);
					    }
					    else
					    {
					        gConfig[AutoAD] = true;
							format (stringo, sizeof stringo, "Admin/Mod {"#COLOR_SYSTEM_FOCUS"}%s{"#COLOR_SYSTEM_REST"} has enabled Auto A/D Mode!", Player[playerid][Nickname]);
					    }

					    SendClientMessageToAll(COLOR_SYSTEM, stringo);
						MySQLStatus[TotalQuerys] ++; mysql_tquery(g_MySQLConnection, sprintf("UPDATE config SET autoad = '%d' WHERE gid = %d", gConfig[AutoAD], G_ID) , "", "");
					}
					case 6: {
					    // Game pack
					    ShowPlayerDialog(playerid, DIALOG_BASESPACK_SELECT, DIALOG_STYLE_LIST, "Bases", "Slaughterfield\nESL\nWarGrounds\nNoCbug\nWarhead", "Load", "Back");
					}
					case 7: {
					    // Force final
					    if (RoundStarted) return SendClientMessage(playerid, red, "You cannot use this command now.");
					    if (gConfig[Matchmode] == MATCHMODE_TCWCW)
						{
					    	Process_FineCW ();
					    	format(stringo, sizeof stringo, "Admin/Mod {"#COLOR_SYSTEM_FOCUS"}%s{"#COLOR_SYSTEM_REST"} forced the finish of the TCW/CW.", Player[playerid][Nickname]);
                            SendClientMessageToAll (COLOR_SYSTEM, stringo);
						}
						else {
						    SendClientMessage (playerid, red, "Match mode should be TCW/CW.");
						}
					}
		            case 8:
					{
					    if (gConfig[Matchmode] == MATCHMODE_TCWCW)
					    {
						    SwapTeams();


							format(stringo, sizeof stringo, "Admin/Mod {"#COLOR_SYSTEM_FOCUS"}%s{"#COLOR_SYSTEM_REST"} has swapped the teams", Player[playerid][Nickname]);
	                        SendClientMessageToAll(COLOR_SYSTEM, stringo);
						}
						else
						{
						    SendClientMessage (playerid, COLOR_RED, "You cannot swap teams in No scores mode.");
						}

						Play_ShowMenu(playerid);
					}
		            case 10:
					{
		                new
							r,
							Float:x,
							Float:y,
							Float:z,
							Float:a;

	      				iTeam[ TEAM_A ][ tPlayers ] = 0;
	        			iTeam[ TEAM_B ][ tPlayers ] = 0;

						foreach(new i:Player)
						{
						    if(!Player[i][Spawned]) continue;
						    if(Player[i][IsAfk])continue;

						    if (Player[i][Team] == TEAM_A || Player[i][Team] == TEAM_B)
						    {
						        iTeam[Player[i][Team]][tPlayers] --;

						        GetPlayerPos( i , x , y , z );
						        GetPlayerFacingAngle( i , a );

								r = random( 2 );

								switch (r)
								{
								    case 0: Player[ i ][ Team ] = TEAM_A, iTeam[ TEAM_A ][ tPlayers ]++;
								    case 1: Player[ i ][ Team ] = TEAM_B, iTeam[ TEAM_B ][ tPlayers ]++;
								}

								SetSpawnInfo( i , i , GetPlayerSkinEx( i ) , x , y , z - 0.5 , a , 0 , 0 , 0 , 0 , 0 , 0 );
								SpawnPlayer( i );
						    }
						}

		                format(stringo, sizeof stringo, "Team mix... Players distribution: %s %d // %s %d", iTeam[TEAM_A][Name], iTeam[ TEAM_A ][ tPlayers ], iTeam[TEAM_B][Name], iTeam[ TEAM_B ][ tPlayers ]);
                        SendClientMessageToAll(0x43C38EAA, stringo);

						Play_ShowMenu(playerid);
						RefreshTeamPlayers_TD();
					}
		            case 11:
					{
						ShowPlayerDialog(playerid, DIALOG_PLAY_ALLVSBALANCE, DIALOG_STYLE_INPUT, "Play now - Balance all vs", "Insert the tag or the name of the player", "Balance", "Back");
		            }
		            case 12:
					{
					    if(RoundStarted) {
							Play_ShowMenu(playerid);
							SendClientMessage(playerid, red, "You cannot balance players now.");
							return true;
						}
		                BalancePlayers(playerid);
		                Play_ShowMenu(playerid);
						return true;
					}
		            case 14:
					{
		                new id;
	          			do {
	 		  				id = random(MAX_BASES);
						}
						while(!bBases[id][Exists]);
						StartRound(id, GAMETYPE_BASE, playerid, 1);
					}
					case 15:
					{
					    new id;
						do {
				    		id = random(MAX_ARENE);
						}
						while(!aArene[id][Exists]);
						StartRound(id, GAMETYPE_ARENA, playerid, 1);
					}
					case 16:
					{
					    new id;
						do {
				    		id = random(MAX_ARENE);
						}
						while(!aArene[id][Exists]);
						StartRound(id, GAMETYPE_TDM, playerid, 1);
					}
		            default:
					{
		                Play_ShowMenu(playerid);
		            }
		        }
			}
		}*/
		case DIALOG_SAVETYPE:
		{
			// perchï¿½ ï¿½ vuoto?
			// >_>
		    return true;
		}
		case DIALOG_PLAY_TEAM1NAME:
		{
		    if(!response) return Play_ShowMenu(playerid);
		    if( strlen( inputtext ) >= MAX_TEAM_NAME - 1 )
		    {
	     		ShowPlayerDialog(playerid, DIALOG_PLAY_TEAM1NAME, DIALOG_STYLE_INPUT, "Play now - Team Name 1", "Invalid length (1-"#MAX_TEAM_NAME")\nLeave it blank to use the current name.", "Next team", "Back");
		        return false;
		    }

		    if( strlen( inputtext ) > 0)
			{
				format(stringo, sizeof stringo, "Admin/Mod {"#COLOR_SYSTEM_FOCUS"}%s{"#COLOR_SYSTEM_REST"} has set the name of the team %s to {"#COLOR_SYSTEM_FOCUS"}%s", Player[playerid][Nickname], iTeam[TEAM_A][Name], inputtext);
                SendClientMessageToAll(COLOR_SYSTEM, stringo);

                ChangeTeamName (TEAM_A, inputtext);
               /*
		        strcpy_2( iTeam[TEAM_A][Name] , inputtext );
		        format(iTeam[TEAM_A_SUB][Name], MAX_TEAM_NAME , "Sub-%s", inputtext);

				if(gConfig[Matchmode] != MATCHMODE_NOSCORES)
				{
					SendRconCommand(sprintf("mapname Lobby %s %d:%d %s", iTeam[TEAM_A][Name], iTeam[TEAM_A][RoundWins], iTeam[TEAM_B][RoundWins], iTeam[TEAM_B][Name]));

					//webMatch[MatchID]
//					mysql_function_query(webMatch[g_Connection], sprintf("UPDATE matchs SET team1name = '%s' WHERE matchid = %d", inputtext, webMatch[MatchID]), false, "", "");
				}


				SyncTextdraw (1);
				RefreshReadyTDs_Esl ();

				MySQLStatus[TotalQuerys] ++; mysql_tquery(g_MySQLConnection, sprintf("UPDATE teams SET name = '%s' WHERE id = '1' AND gid = %d", inputtext, G_ID), "", "");*/
		    }

	        //SyncConfigFile();
			RefreshTextGeneralTD();
		    ShowPlayerDialog( playerid, DIALOG_PLAY_TEAM2NAME, DIALOG_STYLE_INPUT, "Play now - Team 2 name", "Insert the name of team B\nLeave it blank to use the current name.", "End", "Back");
		}
		case DIALOG_PLAY_TEAM2NAME:
		{
		    if(!response) return ShowPlayerDialog(playerid, DIALOG_PLAY_TEAM1NAME, DIALOG_STYLE_INPUT, "Play now - Team Name 1", "Insert the name of team A\nLeave it blank to use the current name.", "Next team", "Back");
		    if( strlen( inputtext ) >= MAX_TEAM_NAME )
		    {
		    	ShowPlayerDialog( playerid, DIALOG_PLAY_TEAM2NAME, DIALOG_STYLE_INPUT, "Play now - Team 2 name", "Invalid length (1-7)\nLeave it blank to use the current name.", "End", "Back");
		        return false;
		    }

			if( strlen( inputtext ) > 0 )
			{
				format(stringo, sizeof stringo, "Admin/Mod {"#COLOR_SYSTEM_FOCUS"}%s{"#COLOR_SYSTEM_REST"} has set the name of the team %s to {"#COLOR_SYSTEM_FOCUS"}%s", Player[playerid][Nickname], iTeam[TEAM_B][Name], inputtext);
                SendClientMessageToAll(COLOR_SYSTEM, stringo);

                ChangeTeamName (TEAM_B, inputtext);
                /*
		        strcpy_2( iTeam[TEAM_B][Name] , inputtext );
		        format(iTeam[TEAM_B_SUB][Name], MAX_TEAM_NAME , "Sub-%s", inputtext);

		        SyncTextdraw (1);
		        RefreshReadyTDs_Esl ();

				if(gConfig[Matchmode] != MATCHMODE_NOSCORES)
				{
					SendRconCommand(sprintf("mapname Lobby %s %d:%d %s", iTeam[TEAM_A][Name], iTeam[TEAM_A][RoundWins], iTeam[TEAM_B][RoundWins], iTeam[TEAM_B][Name]));

					//webMatch[MatchID]
//					mysql_function_query(webMatch[g_Connection], sprintf("UPDATE matchs SET team1name = '%s' WHERE matchid = %d", inputtext, webMatch[MatchID]), false, "", "");
				}

//		        mysql_function_query(webMatch[g_Connection], sprintf("UPDATE matchs SET team2name = '%s' WHERE matchid = %d", inputtext, webMatch[MatchID]), false, "", "");
				*/
				MySQLStatus[TotalQuerys] ++; mysql_function_query(g_MySQLConnection, sprintf("UPDATE teams SET name = '%s' WHERE id = '2' AND gid = %d", inputtext, G_ID), false, "", "");
		    }

		    Play_ShowMenu(playerid);
		    //SyncConfigFile();
			RefreshTextGeneralTD();
		}
		case DIALOG_PLAY_ALLVSBALANCE:
		{
		    if(!response)return Play_ShowMenu(playerid);
		    if(RoundStarted) return Play_ShowMenu(playerid);

			new
				Float:x, Float:y, Float:z, Float:a;

	     	foreach(new i:Player)
	 		{
	 		    if(!Player[i][Spawned]) continue;
	 		    if(Player[i][Team] == TEAM_REF || Player[i][Team] == TEAM_A_SUB || Player[i][Team] == TEAM_B_SUB) continue;
	     	    if(Player[i][IsAfk]) continue;

				GetPlayerPos(i, x, y, z);
				GetPlayerFacingAngle(i, a);

				iTeam[Player[i][Team]][tPlayers] --;
				if(!strfind(GetClan(Player[i][Nickname]), inputtext, true) && strlen(GetClan(Player[i][Nickname])) > 1)
				{
			        Player[i][Team] = TEAM_A;
				    iTeam[TEAM_A][tPlayers] ++;
					format(stringo, sizeof stringo, "You have been switched in the team %s", iTeam[TEAM_A][Name]);
					SetSpawnInfo(i, TEAM_A, GetPlayerSkinEx(i), x, y, z - 0.5, a, 0, 0, 0, 0, 0, 0);
	      		}
	   	   		else if(!strfind(Player[i][Nickname], inputtext, true))
				{
	   	   		    Player[i][Team] = TEAM_A;
	   	   		    iTeam[TEAM_A][tPlayers] ++;
					format(stringo, sizeof stringo, "You have been switched in the team %s", iTeam[TEAM_A][Name]);
					SetSpawnInfo(i, TEAM_A, GetPlayerSkinEx(i), x, y, z - 0.5, a, 0, 0, 0, 0, 0, 0);
				}
				else
				{
				    Player[i][Team] = TEAM_B;
				    iTeam[TEAM_B][tPlayers] ++;
					format(stringo, sizeof stringo, "You have been switched in the team %s", iTeam[TEAM_B][Name]);
					SetSpawnInfo(i, TEAM_B, GetPlayerSkinEx(i), x, y, z - 0.5, a, 0, 0, 0, 0, 0, 0);
				}

                SendClientMessage(i, 0xC3BD1AAA, stringo);

			    GetPlayerPos(i, x, y, z);
			    GetPlayerFacingAngle(i, a);

				Sync_InCorso[i] = 1;

				GetPlayerWeaponData(i, 0, Sync_Weapons_ID[i][0], Sync_Weapons_AMMO[i][0]);
				GetPlayerWeaponData(i, 1, Sync_Weapons_ID[i][1], Sync_Weapons_AMMO[i][1]);
				GetPlayerWeaponData(i, 2, Sync_Weapons_ID[i][2], Sync_Weapons_AMMO[i][2]);
				GetPlayerWeaponData(i, 3, Sync_Weapons_ID[i][3], Sync_Weapons_AMMO[i][3]);
				GetPlayerWeaponData(i, 4, Sync_Weapons_ID[i][4], Sync_Weapons_AMMO[i][4]);
				GetPlayerWeaponData(i, 5, Sync_Weapons_ID[i][5], Sync_Weapons_AMMO[i][5]);
				GetPlayerWeaponData(i, 6, Sync_Weapons_ID[i][6], Sync_Weapons_AMMO[i][6]);
				GetPlayerWeaponData(i, 7, Sync_Weapons_ID[i][7], Sync_Weapons_AMMO[i][7]);
				GetPlayerWeaponData(i, 8, Sync_Weapons_ID[i][8], Sync_Weapons_AMMO[i][8]);
				GetPlayerWeaponData(i, 9, Sync_Weapons_ID[i][9], Sync_Weapons_AMMO[i][9]);
				GetPlayerWeaponData(i, 10, Sync_Weapons_ID[i][10], Sync_Weapons_AMMO[i][10]);
				GetPlayerWeaponData(i, 11, Sync_Weapons_ID[i][11], Sync_Weapons_AMMO[i][11]);
				GetPlayerWeaponData(i, 12, Sync_Weapons_ID[i][12], Sync_Weapons_AMMO[i][12]);

			    GetPlayerHealth(i, Sync_Health[i]);
			    GetPlayerArmour(i, Sync_Armour[i]);

			    SpawnPlayer(i);

				new veh, seat;
				if ((veh = GetPlayerVehicleID(i)) != 0 && (seat = GetPlayerVehicleSeat(i)) != 128) { PutPlayerInVehicle(i, veh, seat);  }
	 	 	}

	        Play_ShowMenu(playerid);
			RefreshTeamPlayers_TD();

			format(stringo, sizeof stringo, "Balance {"#COLOR_SYSTEM_FOCUS"}all vs %s{"#COLOR_SYSTEM_REST"} finished by {"#COLOR_SYSTEM_FOCUS"}%s.", inputtext, Player[playerid][Nickname]);
            SendClientMessageToAll(COLOR_SYSTEM, stringo);
		}
		case DIALOG_PLAY_SETROUNDS:
		{
		    if(!response)return Play_ShowMenu(playerid);

		    new rounds = strval(inputtext);
			if(rounds<1||rounds>=MAX_TCW_ROUNDS) return ShowPlayerDialog(playerid, DIALOG_PLAY_SETROUNDS, DIALOG_STYLE_INPUT, "Play now - Rounds", "Insert the number of rounds you want to play\nThe number of rounds cannot be lower than 1 or higher than 20", "Set", "Back");
			TotalRounds = rounds;

			format(stringo, sizeof stringo, "Admin/Mod {"#COLOR_SYSTEM_FOCUS"}%s{"#COLOR_SYSTEM_REST"} has set rounds limit to {"#COLOR_SYSTEM_FOCUS"}%d", Player[playerid][Nickname], TotalRounds);
            SendClientMessageToAll(COLOR_SYSTEM, stringo);
			Play_ShowMenu(playerid);
			RefreshTextGeneralTD();
		}
		case DIALOG_SWITCH:
		{
			if(response)
			{
			    if (listitem == 6) return 0;
			    if (listitem == 0) return cmd_switch(playerid, "");

				#define locked_team_frase "Locked team."

			    switch(listitem)
				{
			        case 1:
					{
                        if (iTeam [TEAM_A][tLocked]) {
						    SendClientMessage (playerid, red, locked_team_frase);
						    return cmd_switch(playerid, "");
                        }

					    iTeam[Player[playerid][Team]][tPlayers] --;
			            Player[playerid][Team] = TEAM_A;
			            iTeam[TEAM_A][tPlayers] ++;

		        		format(stringo, sizeof stringo, "{"#SC_TEAMA"}%s{FFFFFF} has switched in the team {"#SC_TEAMA"}%s{FFFFFF} ({"#SC_TEAMA"}%s{FFFFFF})", Player[playerid][Nickname], iTeam[TEAM_A][Name], GetRoleName(TeamRole[TEAM_A]));
			        }
			        case 2:
					{
                        if (iTeam [TEAM_A_SUB][tLocked]) {
						    SendClientMessage (playerid, red, locked_team_frase);
						    return cmd_switch(playerid, "");
                        }

					    iTeam[Player[playerid][Team]][tPlayers] --;
			            Player[playerid][Team] = TEAM_A_SUB;
			            iTeam[TEAM_A_SUB][tPlayers] ++;

		        		format(stringo, sizeof stringo, "{"#SC_TEAMSA"}%s{FFFFFF} has switched in the team {"#SC_TEAMSA"}%s{FFFFFF} ({"#SC_TEAMSA"}%s{FFFFFF})", Player[playerid][Nickname], iTeam[TEAM_A_SUB][Name], "Sub");
	      			}
			        case 3:
					{
                        if (iTeam [TEAM_B][tLocked]) {
						    SendClientMessage (playerid, red, locked_team_frase);
						    return cmd_switch(playerid, "");
                        }


					    iTeam[Player[playerid][Team]][tPlayers] --;
			            Player[playerid][Team] = TEAM_B;
			            iTeam[TEAM_B][tPlayers] ++;

		        		format(stringo, sizeof stringo, "{"#SC_TEAMB"}%s{FFFFFF} has switched in the team {"#SC_TEAMB"}%s{FFFFFF} ({"#SC_TEAMB"}%s{FFFFFF})", Player[playerid][Nickname], iTeam[TEAM_B][Name], GetRoleName(TeamRole[TEAM_B]));
			        }
			        case 4:
					{
                        if (iTeam [TEAM_B_SUB][tLocked]) {
						    SendClientMessage (playerid, red, locked_team_frase);
						    return cmd_switch(playerid, "");
                        }

					    iTeam[Player[playerid][Team]][tPlayers] --;
			            Player[playerid][Team] = TEAM_B_SUB;
			            iTeam[TEAM_B_SUB][tPlayers] ++;

		        		format(stringo, sizeof stringo, "{"#SC_TEAMSB"}%s{FFFFFF} has switched in the team {"#SC_TEAMSB"}%s{FFFFFF} ({"#SC_TEAMSB"}%s{FFFFFF})", Player[playerid][Nickname], iTeam[TEAM_B_SUB][Name], "Sub");
			        }
			        case 5:
					{
                        if (iTeam [TEAM_REF][tLocked]) {
						    SendClientMessage (playerid, red, locked_team_frase);
						    return cmd_switch(playerid, "");
                        }

					    iTeam[Player[playerid][Team]][tPlayers] --;
			            Player[playerid][Team] = TEAM_REF;
			            iTeam[TEAM_REF][tPlayers] ++;

		        		format(stringo, sizeof stringo, "{"#SC_TEAMR"}%s{FFFFFF} has switched in the team {"#SC_TEAMR"}%s{FFFFFF} ({"#SC_TEAMR"}%s{FFFFFF})", Player[playerid][Nickname], iTeam[TEAM_REF][Name], GetRoleName(TeamRole[TEAM_REF]));
			        }
			        default:
			        {
			            return cmd_switch( playerid , "" );
			        }
			    }

			    SendClientMessageToAll(-1, stringo);
			    #undef locked_team_frase

				new Float:x, Float:y, Float:z, Float:a;

			    GetPlayerPos(playerid, x, y, z);
			    GetPlayerFacingAngle(playerid, a);

				Sync_InCorso[playerid] = 1;

				GetPlayerWeaponData(playerid, 0, Sync_Weapons_ID[playerid][0], Sync_Weapons_AMMO[playerid][0]);
				GetPlayerWeaponData(playerid, 1, Sync_Weapons_ID[playerid][1], Sync_Weapons_AMMO[playerid][1]);
				GetPlayerWeaponData(playerid, 2, Sync_Weapons_ID[playerid][2], Sync_Weapons_AMMO[playerid][2]);
				GetPlayerWeaponData(playerid, 3, Sync_Weapons_ID[playerid][3], Sync_Weapons_AMMO[playerid][3]);
				GetPlayerWeaponData(playerid, 4, Sync_Weapons_ID[playerid][4], Sync_Weapons_AMMO[playerid][4]);
				GetPlayerWeaponData(playerid, 5, Sync_Weapons_ID[playerid][5], Sync_Weapons_AMMO[playerid][5]);
				GetPlayerWeaponData(playerid, 6, Sync_Weapons_ID[playerid][6], Sync_Weapons_AMMO[playerid][6]);
				GetPlayerWeaponData(playerid, 7, Sync_Weapons_ID[playerid][7], Sync_Weapons_AMMO[playerid][7]);
				GetPlayerWeaponData(playerid, 8, Sync_Weapons_ID[playerid][8], Sync_Weapons_AMMO[playerid][8]);
				GetPlayerWeaponData(playerid, 9, Sync_Weapons_ID[playerid][9], Sync_Weapons_AMMO[playerid][9]);
				GetPlayerWeaponData(playerid, 10, Sync_Weapons_ID[playerid][10], Sync_Weapons_AMMO[playerid][10]);
				GetPlayerWeaponData(playerid, 11, Sync_Weapons_ID[playerid][11], Sync_Weapons_AMMO[playerid][11]);
				GetPlayerWeaponData(playerid, 12, Sync_Weapons_ID[playerid][12], Sync_Weapons_AMMO[playerid][12]);

			    SetSpawnInfo(playerid, Player[playerid][Team], GetPlayerSkinEx(playerid), x, y, z - 0.5, a, 0, 0, 0, 0, 0, 0);

			    GetPlayerHealth(playerid, Sync_Health[playerid]);
			    GetPlayerArmour(playerid, Sync_Armour[playerid]);

			    SpawnPlayer(playerid);

				RefreshTeamPlayers_TD();
				RefreshReadyTDs_Esl();
				PlayerPlaySound(playerid, SOUND_SUCCESS, 0.0, 0.0, 0.0);
			}
		}
		case DIALOG_CONFIG:
		{
		    if (response)
		    {
			    switch (listitem)
			    {
			        case 1:
			        {
			            new
							Float:x, Float:y, Float:z, Float:a;

						GetPlayerPos(playerid, x, y, z);
						GetPlayerFacingAngle(playerid, a);

						Lobby_Int = GetPlayerInterior(playerid);

						Lobby[0] = x;
						Lobby[1] = y;
						Lobby[2] = z;
						Lobby[3] = a;

						Delete3DTextLabel(WelcomeLabel);
						WelcomeLabel = Create3DTextLabel(TXT_WELCOME_LABEL, 0x0055FFAA, Lobby[0], Lobby[1], Lobby[2], DRAWDISTANCE_WELCOMELABEL, 0);
//changelobbyhere

						MySQLStatus[TotalQuerys] ++; mysql_tquery(g_MySQLConnection, sprintf("UPDATE config SET lobby = '%f,%f,%f' WHERE gid = %d", Lobby[0], Lobby[1], Lobby[2], G_ID ), "", "");


						SendClientMessage(playerid, COLOR_SYSTEM, "** Lobby changed.");
			        }
			        case 2:
			        {
						if (gConfig[LobbyVehicles])
		    			{
					        format (stringo, sizeof stringo, "Admin/Mod {"#COLOR_SYSTEM_FOCUS"}%s{"#COLOR_SYSTEM_REST"} has disabled Lobby Vehicles" , Player[ playerid ][ Nickname ]);
							gConfig[LobbyVehicles] = false;
							MySQLStatus[TotalQuerys] ++; mysql_tquery(g_MySQLConnection, sprintf ("UPDATE config SET lobbyv = '0' WHERE gid = %d", G_ID), "", "");
					    }
					    else
					    {
					        format (stringo, sizeof stringo, "Admin/Mod {"#COLOR_SYSTEM_FOCUS"}%s{"#COLOR_SYSTEM_REST"} has enabled Lobby Vehicles" , Player[ playerid ][ Nickname ]);
							gConfig[LobbyVehicles] = true;
							MySQLStatus[TotalQuerys] ++; mysql_tquery(g_MySQLConnection, sprintf ("UPDATE config SET lobbyv = '1' WHERE gid = %d", G_ID), "", "");
					    }

					    SendClientMessageToAll( COLOR_SYSTEM , stringo );
					    PlayerPlaySound(playerid, SOUND_SUCCESS, 0.0, 0.0, 0.0);
					    MostraConfig(playerid);

					    //SyncConfigFile();
		        	}
			        case 3:
			        {
					    if (gConfig[LobbyWeapons])
					    {
					        format (stringo, sizeof stringo, "Admin/Mod {"#COLOR_SYSTEM_FOCUS"}%s{"#COLOR_SYSTEM_REST"} has disabled Lobby Weapons, everyone has been disarmed." , Player[ playerid ][ Nickname ]);
							gConfig[LobbyWeapons] = false;

							foreach(new i:Player)
							{
							    if (Player[i][InGame]) continue;
							    if (Player[i][InDm] != -1) continue;
								ResetPlayerWeapons( i );
							}

							MySQLStatus[TotalQuerys] ++; mysql_tquery(g_MySQLConnection, sprintf ("UPDATE config SET lobbyw = '0' WHERE gid = %d", G_ID), "", "");
		    			}
				    	else
				    	{
		        			format (stringo, sizeof stringo, "Admin/Mod {"#COLOR_SYSTEM_FOCUS"}%s{"#COLOR_SYSTEM_REST"} has enabled Lobby Weapons" , Player[ playerid ][ Nickname ]);
							gConfig[LobbyWeapons] = true;
							MySQLStatus[TotalQuerys] ++; mysql_tquery(g_MySQLConnection, sprintf ("UPDATE config SET lobbyw = '1' WHERE gid = %d", G_ID), "", "");
		    			}
		    			SendClientMessageToAll( COLOR_SYSTEM , stringo );
		    			PlayerPlaySound(playerid, SOUND_SUCCESS, 0.0, 0.0, 0.0);
				    	//SyncConfigFile();
		    			MostraConfig(playerid);
			        }
			        case 4:
			        {
				    	if (gConfig[GlobalChat])
					    {
					        format (stringo, sizeof stringo, "Admin/Mod {"#COLOR_SYSTEM_FOCUS"}%s{"#COLOR_SYSTEM_REST"} has disabled Global chat" , Player[ playerid ][ Nickname ]);
							gConfig[GlobalChat] = false;
					    }
					    else
					    {
					        format (stringo, sizeof stringo, "Admin/Mod {"#COLOR_SYSTEM_FOCUS"}%s{"#COLOR_SYSTEM_REST"} has enabled Global chat" , Player[ playerid ][ Nickname ]);
							gConfig[GlobalChat] = true;
					    }
					    SendClientMessageToAll( COLOR_SYSTEM , stringo );
					    PlayerPlaySound(playerid, SOUND_SUCCESS, 0.0, 0.0, 0.0);
					    //SyncConfigFile();
					    MostraConfig(playerid);
			        }
			        case 5:
			        {
				    	if (gConfig[AutoAFK])
				   		{
		       				format (stringo, sizeof stringo, "Admin/Mod {"#COLOR_SYSTEM_FOCUS"}%s{"#COLOR_SYSTEM_REST"} has disabled Auto AFK mode" , Player[ playerid ][ Nickname ]);
							gConfig[AutoAFK] = false;
			    		}
				    	else
				   		{
		       				format (stringo, sizeof stringo, "Admin/Mod {"#COLOR_SYSTEM_FOCUS"}%s{"#COLOR_SYSTEM_REST"} has enabled Auto AFK mode" , Player[ playerid ][ Nickname ]);
							gConfig[AutoAFK] = true;
			    		}

			    		SendClientMessageToAll( COLOR_SYSTEM , stringo);
			    		PlayerPlaySound(playerid, SOUND_SUCCESS, 0.0, 0.0, 0.0);
					    //SyncConfigFile();
					    MostraConfig(playerid);
			        }
			        // !-- Section: Limits (5) --! //
			        case 7:
			        {
		         		if( ! gConfig[ EFpsLimit ] )
						{
						    PlayerPlaySound(playerid, SOUND_SUCCESS, 0.0, 0.0, 0.0);
		           			gConfig[ EFpsLimit ] = 1;
		              		//SyncConfigFile();
		              		MySQLStatus[TotalQuerys] ++; mysql_tquery(g_MySQLConnection, sprintf ("UPDATE config SET usefps = '1' WHERE gid = %d", G_ID), "", "");
		           	  		format( stringo, sizeof stringo , "Admin/Mod {"#COLOR_SYSTEM_FOCUS"}%s{"#COLOR_SYSTEM_REST"} has enabled FPS Kick.", Player[playerid][Nickname]);
                            SendClientMessageToAll(COLOR_SYSTEM, stringo);
						    return MostraConfig(playerid);
		                }
						ShowPlayerDialog(playerid, DIALOG_CONFIG_FPSLIMIT, DIALOG_STYLE_LIST, "FPS Limit", "Enable/Disable FPS limit\nSet FPS limit", "Use", "Back");
			        }
			        case 8:
			        {
		         		if( ! gConfig[ EPLLimit ] )
			 			{
			 			    PlayerPlaySound(playerid, SOUND_SUCCESS, 0.0, 0.0, 0.0);
		                 	gConfig[ EPLLimit ] = 1;
		               		//SyncConfigFile();
		               		MySQLStatus[TotalQuerys] ++; mysql_tquery(g_MySQLConnection, sprintf ("UPDATE config SET usepl = '1' WHERE gid = %d", G_ID), "", "");
		      				format(stringo, sizeof stringo ,"Admin/Mod {"#COLOR_SYSTEM_FOCUS"}%s{"#COLOR_SYSTEM_REST"} has enabled Packetloss Kick.", Player[playerid][Nickname]);
                            SendClientMessageToAll(COLOR_SYSTEM, stringo);
				   			return MostraConfig(playerid);
		      			}
						ShowPlayerDialog(playerid, DIALOG_CONFIG_PLLIMIT, DIALOG_STYLE_LIST, "Packetloss Limit", "Enable/Disable Packetloss limit\nSet Packetloss limit", "Use", "Back");
			        }
			        case 9:
			        {
		         		if( ! gConfig[ EPingLimit ] )
					 	{
					 	    PlayerPlaySound(playerid, SOUND_SUCCESS, 0.0, 0.0, 0.0);
		                 	gConfig[ EPingLimit ] = 1;
		               		//SyncConfigFile();
		               		MySQLStatus[TotalQuerys] ++; mysql_tquery(g_MySQLConnection, sprintf ("UPDATE config SET useping = '1' WHERE gid = %d", G_ID), "", "");
			      			format(stringo, sizeof stringo, "Admin/Mod {"#COLOR_SYSTEM_FOCUS"}%s{"#COLOR_SYSTEM_REST"} has enabled Ping Kick.", Player[playerid][Nickname]);
                            SendClientMessageToAll(COLOR_SYSTEM, stringo);
						   	return MostraConfig(playerid);
			            }
						ShowPlayerDialog(playerid, DIALOG_CONFIG_PINGLIMIT, DIALOG_STYLE_LIST, "Ping Limit", "Enable/Disable Ping limit\nSet Ping limit", "Use", "Back");
			        }
			        // !-- Section goto --! //
			        case 10:
			        {
						OpenPlayerDialog(playerid, PDIALOG_TEAMS);
			        }
			        case 11:
			        {
						OpenPlayerDialog(playerid, PDIALOG_GAMECONFIG);
			        }
			        case 12:
			        {
			            OpenPlayerDialog(playerid, PDIALOG_DEBUG);
			        }
			        default: MostraConfig( playerid );
			    }
			}
		}
		case DIALOG_CONFIG_TEAMMODULE:
		{
			if (response)
			{
			    switch (listitem)
			    {
			        // TEAM A
					case 1:
					{
					    ShowPlayerDialog(playerid, DIALOG_CONFIG_TEAMNAMEA, DIALOG_STYLE_INPUT, "Team name", "Insert the name of the first team (TEAM A)", "Go", "Cancel");
					}
			        case 2:
			        {
			            // skin
	 	            	ShowPlayerDialog(playerid, DIALOG_CONFIG_TEAM1SKIN, DIALOG_STYLE_INPUT, "Skin team", "Insert the ID of the new skin that will be used", "Change skin", "Back");
			        }
			        case 3:
			        {
			            PlayerPlaySound(playerid, SOUND_SUCCESS, 0.0, 0.0, 0.0);
					    iTeam[TEAM_A][RoundWins] = 0;
					    RefreshTextGeneralTD();
					    format(stringo, sizeof stringo, "Admin/Mod {"#COLOR_SYSTEM_FOCUS"}%s{"#COLOR_SYSTEM_REST"} resets %s scores." , Player[ playerid ][ Nickname ] , iTeam[TEAM_A][Name] );
                        SendClientMessageToAll( COLOR_SYSTEM , stringo);
				        OpenPlayerDialog(playerid, PDIALOG_TEAMS);
			        }
			        case 4:
			        {
			            if (gConfig[Matchmode] == MATCHMODE_TCWCW)
			            {
				            PlayerPlaySound(playerid, SOUND_SUCCESS, 0.0, 0.0, 0.0);
							/*
							if(TeamRole[TEAM_A] == ATTACKERS)
							{
							    TeamRole[TEAM_A] = DEFENDERS;
							    TeamRole[TEAM_B] = ATTACKERS;

							}
							else
							{
							    TeamRole[TEAM_A] = ATTACKERS;
							    TeamRole[TEAM_B] = DEFENDERS;
							}
							*/
							SwapTeams();

						    format(stringo, sizeof stringo, "Admin/Mod {"#COLOR_SYSTEM_FOCUS"}%s{"#COLOR_SYSTEM_REST"} swapped teams." , Player[ playerid ][ Nickname ] );
	                        SendClientMessageToAll( COLOR_SYSTEM , stringo );
                        }
                        else
                        {
                            SendClientMessage (playerid, COLOR_RED, "You cannot swap teams in No Scores mode.");
                        }

						OpenPlayerDialog(playerid, PDIALOG_TEAMS);
			        }
			        // TEAM B
					case 6:
					{
					    ShowPlayerDialog(playerid, DIALOG_CONFIG_TEAMNAMEB, DIALOG_STYLE_INPUT, "Team name", "Insert the name of the second team (TEAM B)", "Go", "Cancel");
					}
			        case 7:
			        {
			            // skin
	 	            	ShowPlayerDialog(playerid, DIALOG_CONFIG_TEAM2SKIN, DIALOG_STYLE_INPUT, "Skin team", "Insert the ID of the new skin that will be used", "Change skin", "Back");
			        }
			        case 8:
			        {
			            PlayerPlaySound(playerid, SOUND_SUCCESS, 0.0, 0.0, 0.0);
					    iTeam[TEAM_B][RoundWins] = 0;
					    RefreshTextGeneralTD();
					    format(stringo, sizeof stringo, "Admin/Mod {"#COLOR_SYSTEM_FOCUS"}%s{"#COLOR_SYSTEM_REST"} resets %s scores." , Player[ playerid ][ Nickname ] , iTeam[TEAM_B][Name] );
						SendClientMessageToAll(COLOR_SYSTEM, stringo);
						OpenPlayerDialog(playerid, PDIALOG_TEAMS);
			        }
			        case 9:
			        {
			            if (gConfig[Matchmode] == MATCHMODE_TCWCW)
			            {
				            PlayerPlaySound(playerid, SOUND_SUCCESS, 0.0, 0.0, 0.0);
							/*if(TeamRole[TEAM_A] == ATTACKERS)
							{
							    TeamRole[TEAM_A] = DEFENDERS;
							    TeamRole[TEAM_B] = ATTACKERS;

							}
							else
							{
							    TeamRole[TEAM_A] = ATTACKERS;
							    TeamRole[TEAM_B] = DEFENDERS;
							}*/

	                        SwapTeams();
						    format(stringo, sizeof stringo, "Admin/Mod {"#COLOR_SYSTEM_FOCUS"}%s{"#COLOR_SYSTEM_REST"} swapped teams." , Player[ playerid ][ Nickname ] );
	                        SendClientMessageToAll( COLOR_SYSTEM , stringo);
						}
						else
						{
						    SendClientMessage (playerid, COLOR_RED, "You cannot swap teams in No Scores mode.");
						}
						OpenPlayerDialog(playerid, PDIALOG_TEAMS);
			        }
			        // TEAM REF
			        case 11:
			        {
	 	            	ShowPlayerDialog(playerid, DIALOG_CONFIG_TEAM3SKIN, DIALOG_STYLE_INPUT, "Skin team", "Insert the ID of the new skin that will be used", "Change skin", "Back");
			        }
			    }
			}
			else
			{
			    MostraConfig( playerid );
			}
		}
		case DIALOG_CONFIG_GAMECONFMODULE:
		{
		    if (response)
		    {
		        switch (listitem)
		        {
		            // general
		            case 1:
		            {
						switch (gConfig[GameMode])
						{
						    case GAMEMODE_NORMAL:
							{
								gConfig[GameMode] = GAMEMODE_ESL;
								format(stringo, sizeof stringo, "Admin/Mod {"#COLOR_SYSTEM_FOCUS"}%s{"#COLOR_SYSTEM_REST"} has enabled {"#COLOR_SYSTEM_FOCUS"}ESL{"#COLOR_SYSTEM_REST"} mode.", Player[playerid][Nickname]);
                                SendClientMessageToAll(COLOR_SYSTEM, stringo);

								TextDrawShowForAll(ESLModeReady[0]);
								TextDrawShowForAll(ESLModeReady[1]);
								TextDrawShowForAll(ESLModeReady[2]);
								TextDrawShowForAll(ESLModeReady[3]);

						 		RefreshReadyTDs_Esl();

								//PlayingRound = 0;

								gConfig[Matchmode] = MATCHMODE_TCWCW;
								ResetScores ();
		/*						iTeam[TEAM_A][RoundWins] = 0;
					   			iTeam[TEAM_B][RoundWins] = 0;

								for (new i = 0; i < MAX_PLAYERS; i++)
								{
								    Player[i][Kills] = 0;
								    Player[i][Deaths] = 0;
								    Player[i][Damage] = 0;
								    Player[i][RKills] = 0;
								    Player[i][RDamage] = 0;

									SetPlayerScore(i, 0);

									PlayerTextDrawSetString (i, PlayerInfo[1], "DMG ~b~~h~0~n~~w~Tot. DMG ~b~~h~0");
								}

							    PlayingRound = 0;*/
							    TotalRounds = 5;

								SetGameModeText(#GAMEMODE_NAME" ESL");

						        //strcpy_2( iTeam[TEAM_A][Name] , "A" );
						        //strcpy_2( iTeam[TEAM_B][Name] , "B" );
						        iTeam[TEAM_A][Name][0] = 'A';
						        iTeam[TEAM_B][Name][0] = 'B';

						        iTeam[TEAM_A][Name][1] = '\0';
						        iTeam[TEAM_B][Name][1] = '\0';

						        iTeam[TEAM_A_SUB][Name][0] = 's';
						        iTeam[TEAM_A_SUB][Name][1] = 'u';
						        iTeam[TEAM_A_SUB][Name][2] = 'b';
						        iTeam[TEAM_A_SUB][Name][3] = '-';
						        iTeam[TEAM_A_SUB][Name][4] = 'A';
						        iTeam[TEAM_A_SUB][Name][5] = '\0';

						        iTeam[TEAM_B_SUB][Name][0] = 's';
						        iTeam[TEAM_B_SUB][Name][1] = 'u';
						        iTeam[TEAM_B_SUB][Name][2] = 'b';
						        iTeam[TEAM_B_SUB][Name][3] = '-';
						        iTeam[TEAM_B_SUB][Name][4] = 'B';
						        iTeam[TEAM_B_SUB][Name][5] = '\0';

						        RefreshTextGeneralTD();

								SendRconCommand("mapname Lobby A 0:0 B");

								SyncTextdraw (1);
								RefreshReadyTDs_Esl ();
							}
						    case GAMEMODE_ESL:
							{
								TextDrawHideForAll(ESLModeReady[0]);
								TextDrawHideForAll(ESLModeReady[1]);
								TextDrawHideForAll(ESLModeReady[2]);
								TextDrawHideForAll(ESLModeReady[3]);

								gConfig[GameMode] = GAMEMODE_NOCBUG;
								format(stringo, sizeof stringo, "Admin/Mod {"#COLOR_SYSTEM_FOCUS"}%s{"#COLOR_SYSTEM_REST"} has enabled {"#COLOR_SYSTEM_FOCUS"}NoCbug{"#COLOR_SYSTEM_REST"} mode.", Player[playerid][Nickname]);
                                SendClientMessageToAll(COLOR_SYSTEM, stringo);

	                            SetGameModeText(#GAMEMODE_NAME" NoCBug");
							}
							case GAMEMODE_NOCBUG:
							{
								gConfig[GameMode] = GAMEMODE_NORMAL;
								format(stringo, sizeof stringo, "Admin/Mod {"#COLOR_SYSTEM_FOCUS"}%s{"#COLOR_SYSTEM_REST"} has enabled {"#COLOR_SYSTEM_FOCUS"}Slaughterfield{"#COLOR_SYSTEM_REST"} mode.", Player[playerid][Nickname]);
                                SendClientMessageToAll(COLOR_SYSTEM, stringo);

	                            SetGameModeText(#GAMEMODE_NAME);
							}
						}

						OpenPlayerDialog(playerid, PDIALOG_GAMECONFIG);
					}
		            case 2:
		            {
		                //r time
		                ShowPlayerDialog(playerid, DIALOG_CONFIG_ROUNDTIME, DIALOG_STYLE_INPUT, "Round time", "Insert the number of minutes of the round", "Go", "Cancel");
		            }
		            case 3:
		            {
		                if(gConfig[UCp] == 1)
						{
						    MySQLStatus[TotalQuerys] ++; mysql_tquery(g_MySQLConnection, sprintf ("UPDATE config SET ucp = '0' WHERE gid = %d", G_ID), "", "");
		                    gConfig[UCp] = 0;
		     				format(stringo, sizeof stringo, "Admin/Mod {"#COLOR_SYSTEM_FOCUS"}%s{"#COLOR_SYSTEM_REST"} has disabled checkpoint." , Player[ playerid ][ Nickname ]);
		                }
		                else
						{
						    MySQLStatus[TotalQuerys] ++; mysql_tquery(g_MySQLConnection, sprintf ("UPDATE config SET ucp = '1' WHERE gid = %d", G_ID), "", "");
		                    gConfig[UCp] = 1;
	     					format(stringo, sizeof stringo, "Admin/Mod {"#COLOR_SYSTEM_FOCUS"}%s{"#COLOR_SYSTEM_REST"} has enabled checkpoint." , Player[ playerid ][ Nickname ]);
						}

						SendClientMessageToAll(COLOR_SYSTEM, stringo);
						PlayerPlaySound(playerid, SOUND_SUCCESS, 0.0, 0.0, 0.0);
						OpenPlayerDialog(playerid, PDIALOG_GAMECONFIG);
						//SyncConfigFile();
		            }
		            case 4:
		            {
		            	ShowPlayerDialog(playerid, DIALOG_CONFIG_CPSECS, DIALOG_STYLE_INPUT, "Checkpoint secs", "Insert the number of seconds needed to capture the CP", "Go", "Cancel");
		            }
		            case 5:
		            {
		            	ShowPlayerDialog(playerid, DIALOG_CONFIG_TDMKILLS, DIALOG_STYLE_INPUT, "TDM Kills Limit", "Insert the number of kills a team must do to win the TDM", "Set", "Cancel");
					}
		            case 6:
		            {
					    if (RoundStarted) return SendClientMessage( playerid , red , "You cannot use this function now." );
					    if (gConfig[UseHealthBars])
					    {
					        format(stringo, sizeof stringo, "Admin/Mod {"#COLOR_SYSTEM_FOCUS"}%s{"#COLOR_SYSTEM_REST"} has disabled Healthbars" , Player[ playerid ][ Nickname ]);
							gConfig[UseHealthBars] = false;
							MySQLStatus[TotalQuerys] ++; mysql_tquery(g_MySQLConnection, sprintf ("UPDATE config SET hb = '0' WHERE gid = %d", G_ID), "", "");
					    }
					    else
					    {
					        format(stringo, sizeof stringo, "Admin/Mod {"#COLOR_SYSTEM_FOCUS"}%s{"#COLOR_SYSTEM_REST"} has enabled Healthbars" , Player[ playerid ][ Nickname ]);
							gConfig[UseHealthBars] = true;
							MySQLStatus[TotalQuerys] ++; mysql_tquery(g_MySQLConnection, sprintf ("UPDATE config SET hb = '1' WHERE gid = %d", G_ID), "", "");
					    }
					    SendClientMessageToAll(COLOR_SYSTEM, stringo);
					    PlayerPlaySound(playerid, SOUND_SUCCESS, 0.0, 0.0, 0.0);
					    //SyncConfigFile();
					    OpenPlayerDialog(playerid, PDIALOG_GAMECONFIG);
		            }
		            case 7:
		            {
					    //if (RoundStarted) return SendClientMessage( playerid , red , "You cannot use this function now." );
					    if (gConfig[AntiCBug])
					    {
					        format(stringo, sizeof stringo, "Admin/Mod {"#COLOR_SYSTEM_FOCUS"}%s{"#COLOR_SYSTEM_REST"} has disabled AntiCBug" , Player[ playerid ][ Nickname ]);
							gConfig[AntiCBug] = false;
							MySQLStatus[TotalQuerys] ++; mysql_tquery(g_MySQLConnection, sprintf ("UPDATE config SET anticbug = '0' WHERE gid = %d", G_ID), "", "");
					    }
					    else
					    {
					        format(stringo, sizeof stringo, "Admin/Mod {"#COLOR_SYSTEM_FOCUS"}%s{"#COLOR_SYSTEM_REST"} has enabled AntiCBug" , Player[ playerid ][ Nickname ]);
							gConfig[AntiCBug] = true;
							MySQLStatus[TotalQuerys] ++; mysql_tquery(g_MySQLConnection, sprintf ("UPDATE config SET anticbug = '1' WHERE gid = %d", G_ID), "", "");
					    }
					    SendClientMessageToAll(COLOR_SYSTEM, stringo);
					    PlayerPlaySound(playerid, SOUND_SUCCESS, 0.0, 0.0, 0.0);
					    //SyncConfigFile();
					    OpenPlayerDialog(playerid, PDIALOG_GAMECONFIG);
		            }
		            case 8:
		            {
		                SendClientMessage( playerid , red , "Sorry, Skinswap will be removed." );
		                /*
					    //if (RoundStarted) return SendClientMessage( playerid , red , "You cannot use this function now." );
					    if (gConfig[SkinSwap])
					    {
					        format(stringo, sizeof stringo, "Admin/Mod {"#COLOR_SYSTEM_FOCUS"}%s{"#COLOR_SYSTEM_REST"} has disabled Skin Swap" , Player[ playerid ][ Nickname ]);
							gConfig[SkinSwap] = false;
							MySQLStatus[TotalQuerys] ++; mysql_tquery(g_MySQLConnection, sprintf ("UPDATE config SET skinswap = '0' WHERE gid = %d", G_ID), "", "");
					    }
					    else
					    {
					        format(stringo, sizeof stringo, "Admin/Mod {"#COLOR_SYSTEM_FOCUS"}%s{"#COLOR_SYSTEM_REST"} has enabled Skin Swap" , Player[ playerid ][ Nickname ]);
							gConfig[SkinSwap] = true;
							MySQLStatus[TotalQuerys] ++; mysql_tquery(g_MySQLConnection, sprintf ("UPDATE config SET skinswap = '1' WHERE gid = %d", G_ID), "", "");
					    }
						SendClientMessageToAll(COLOR_SYSTEM, stringo);
					    PlayerPlaySound(playerid, SOUND_SUCCESS, 0.0, 0.0, 0.0);
					    //SyncConfigFile();*/
					    OpenPlayerDialog(playerid, PDIALOG_GAMECONFIG);
		            }
		            case 9:
		            {
		                ShowPlayerDialog (playerid, DIALOG_PVPWEAPONS, DIALOG_STYLE_INPUT, "PVP Weapons", "Write the weapons you would like in PVP.\n Input example: Deagle Spas12 M4", "Change", "Close");
		            }
		        }
		    }
		    else
		    {
		        MostraConfig( playerid );
		    }
		}
		case DIALOG_BASESPACK_SELECT:
		{
		    if (!response) return Play_ShowMenu (playerid);
		    if (listitem < 0 || listitem > 4) return Play_ShowMenu (playerid);
		    cmd_loadpack(playerid, basesPacks[listitem][packName]);
		    return Play_ShowMenu (playerid);
		}
		case DIALOG_CONFIG_DEBUGMODULE:
		{
		    if (!response) return MostraConfig (playerid);
		    switch (listitem)
		    {
				case 0:
				{
				    // Textdraws status
				}
				case 1:
				{
					// MySQL Status
					/*
					new
					    status [800],
						destination [128];

					format (status, sizeof status, "Total querys executed: %d\n", MySQLStatus[TotalQuerys]);
					format (status, sizeof status, "%sMySQL Ping: %d\n", status, mysql_ping());

					mysql_stat(destination);

					format (status, sizeof status, "%sMySQL Stat: %s", status, destination);
					*/
					new
					    status [220],
						destination [120];

					mysql_stat(destination);

					strcat (status, sprintf("Total querys executed: %d\n", MySQLStatus[TotalQuerys]));
//					strcat (status, sprintf("MySQL Ping: %d\n", mysql_ping()));
					strcat (status, sprintf("MySQL Stat: %s\n", destination));

					ShowPlayerDialog(
					    playerid,
					    DIALOG_MYSQLSTATUS,
						DIALOG_STYLE_MSGBOX,
						"MySQL Status",
						status,
						"Update",
						"Back");
				}
				default:
				{
				    OpenPlayerDialog(playerid, PDIALOG_DEBUG);
				}
		    }
		    return true;
		}
		case DIALOG_MYSQLSTATUS:
		{
		    if (response)
		    {
				new
				    status [220],
					destination [120];

				mysql_stat(destination);

				strcat (status, sprintf("Total querys executed: %d\n", MySQLStatus[TotalQuerys]));
//				strcat (status, sprintf("MySQL Ping: %d\n", mysql_ping()));
				strcat (status, sprintf("MySQL Stat: %s\n", destination));

				ShowPlayerDialog(
				    playerid,
				    DIALOG_MYSQLSTATUS,
					DIALOG_STYLE_MSGBOX,
					"MySQL Status",
					status,
					"Update",
					"Back");
		    }
		    else
		    {
		        OpenPlayerDialog(playerid, PDIALOG_DEBUG);
		    }
		}
		case DIALOG_PVPWEAPONS:
		{
		    if (!response) return OpenPlayerDialog(playerid, PDIALOG_GAMECONFIG);
		    if (sscanf(inputtext, "k<weaps>K<weaps>(0)K<weaps>(0)K<weaps>(0)K<weaps>(0)", PVPWeapons[0], PVPWeapons[1], PVPWeapons[2], PVPWeapons[3], PVPWeapons[4]))
		    {
      			ShowPlayerDialog (playerid, DIALOG_PVPWEAPONS, DIALOG_STYLE_INPUT, "PVP Weapons", "Write the weapons you would like in PVP.\n Input example: Deagle Spas12 M4", "Change", "Close");
      			return true;
		    }

	    	format( stringo , sizeof stringo, "Player vs Player weapons: {"#COLOR_SYSTEM_FOCUS"}%s %s %s %s %s", (PVPWeapons[0] > 0 ? aWeaponNames[PVPWeapons[0]] : ("")), (PVPWeapons[1] > 0 ? aWeaponNames[PVPWeapons[1]] : ("")), (PVPWeapons[2] > 0 ? aWeaponNames[PVPWeapons[2]] : ("")), (PVPWeapons[3] > 0 ? aWeaponNames[PVPWeapons[3]] : ("")), (PVPWeapons[4] > 0 ? aWeaponNames[PVPWeapons[4]] : ("")));
            SendClientMessageToAll(COLOR_SYSTEM, stringo);
			MySQLStatus[TotalQuerys] ++; mysql_tquery(g_MySQLConnection, sprintf ("UPDATE config SET pvpweaps = '%d,%d,%d,%d,%d' WHERE gid = %d", PVPWeapons[0], PVPWeapons[1], PVPWeapons[2], PVPWeapons[3], PVPWeapons[4], G_ID), "", "");
            OpenPlayerDialog(playerid, PDIALOG_GAMECONFIG);
		    return true;
		}
		case DIALOG_CONFIG_TEAM1SKIN:
		{
		    if (!response) return OpenPlayerDialog(playerid, PDIALOG_TEAMS);
		    if (!strlen( inputtext ))return ShowPlayerDialog(playerid, DIALOG_CONFIG_TEAM1SKIN, DIALOG_STYLE_INPUT, "Skin team", "Insert the ID of the new skin that will be used", "Change skin", "Back");
	        new skin = strval( inputtext );
		    if (skin < 0 || skin > 299) return ShowPlayerDialog(playerid, DIALOG_CONFIG_TEAM1SKIN, DIALOG_STYLE_INPUT, "Skin team", "Insert the ID of the new skin that will be used", "Change skin", "Back");
			iTeam[TEAM_A][Skin] = skin;
			//SyncConfigFile();
			MySQLStatus[TotalQuerys] ++; mysql_tquery(g_MySQLConnection, sprintf("UPDATE teams SET skin = '%d' WHERE id = '1' AND gid = %d", skin, G_ID), "", "");
	  		format(stringo, sizeof stringo, "Admin/Mod {"#COLOR_SYSTEM_FOCUS"}%s{"#COLOR_SYSTEM_REST"} changed %s skin to %d." , Player[ playerid ][ Nickname ] , iTeam[ TEAM_A ][ Name ] , skin );
 	        SendClientMessageToAll( COLOR_SYSTEM , stringo);
	        OpenPlayerDialog(playerid, PDIALOG_TEAMS);
	        PlayerPlaySound(playerid, SOUND_SUCCESS, 0.0, 0.0, 0.0);
		}
		case DIALOG_CONFIG_TEAM2SKIN:
		{
		    if (!response) return OpenPlayerDialog(playerid, PDIALOG_TEAMS);
		    if (!strlen( inputtext ))return ShowPlayerDialog(playerid, DIALOG_CONFIG_TEAM2SKIN, DIALOG_STYLE_INPUT, "Skin team", "Insert the ID of the new skin that will be used", "Change skin", "Back");
	        new skin = strval( inputtext );
		    if (skin < 0 || skin > 299) return ShowPlayerDialog(playerid, DIALOG_CONFIG_TEAM2SKIN, DIALOG_STYLE_INPUT, "Skin team", "Insert the ID of the new skin that will be used", "Change skin", "Back");
			iTeam[TEAM_B][Skin] = skin;
			//SyncConfigFile();
			MySQLStatus[TotalQuerys] ++; mysql_tquery(g_MySQLConnection, sprintf("UPDATE teams SET skin = '%d' WHERE id = '2' AND gid = %d", skin, G_ID), "", "");
	  		format(stringo, sizeof stringo, "Admin/Mod {"#COLOR_SYSTEM_FOCUS"}%s{"#COLOR_SYSTEM_REST"} changed %s skin to %d." , Player[ playerid ][ Nickname ] , iTeam[ TEAM_B ][ Name ] , skin );
            SendClientMessageToAll( COLOR_SYSTEM , stringo);
			OpenPlayerDialog(playerid, PDIALOG_TEAMS);
	        PlayerPlaySound(playerid, SOUND_SUCCESS, 0.0, 0.0, 0.0);
		}
		case DIALOG_CONFIG_TEAM3SKIN:
		{
		    if (!response) return OpenPlayerDialog(playerid, PDIALOG_TEAMS);
		    if (!strlen( inputtext ))return ShowPlayerDialog(playerid, DIALOG_CONFIG_TEAM3SKIN, DIALOG_STYLE_INPUT, "Skin team", "Insert the ID of the new skin that will be used", "Change skin", "Back");
	        new skin = strval( inputtext );
		    if (skin < 0 || skin > 299) return ShowPlayerDialog(playerid, DIALOG_CONFIG_TEAM3SKIN, DIALOG_STYLE_INPUT, "Skin team", "Insert the ID of the new skin that will be used", "Change skin", "Back");
			iTeam[TEAM_REF][Skin] = skin;
			//SyncConfigFile();
			MySQLStatus[TotalQuerys] ++; mysql_tquery(g_MySQLConnection, sprintf("UPDATE teams SET skin = '%d' WHERE id = '3' AND gid = %d", skin, G_ID), "", "");
	  		format(stringo, sizeof stringo, "Admin/Mod {"#COLOR_SYSTEM_FOCUS"}%s{"#COLOR_SYSTEM_REST"} changed %s skin to %d." , Player[ playerid ][ Nickname ] , iTeam[ TEAM_REF ][ Name ] , skin );
            SendClientMessageToAll( COLOR_SYSTEM , stringo );
	        OpenPlayerDialog(playerid, PDIALOG_TEAMS);
	        PlayerPlaySound(playerid, SOUND_SUCCESS, 0.0, 0.0, 0.0);
		}
		case DIALOG_CONFIG_PINGLIMIT:
		{
		    if(!response) return MostraConfig(playerid);
		    switch(listitem) {
		        case 0: {
		            PlayerPlaySound(playerid, SOUND_SUCCESS, 0.0, 0.0, 0.0);
	         		if( gConfig[ EPingLimit ] )
	 				{
          				MySQLStatus[TotalQuerys] ++; mysql_tquery(g_MySQLConnection, sprintf ("UPDATE config SET useping = '0' WHERE gid = %d", G_ID), "", "");
	           			gConfig[ EPingLimit ] = 0;
	              		//SyncConfigFile();
	              		format (stringo, sizeof stringo, "Admin/Mod {"#COLOR_SYSTEM_FOCUS"}%s{"#COLOR_SYSTEM_REST"} has disabled Ping Kick.", Player[playerid][Nickname]);
	                }
	         		else
	 				{
	 				    MySQLStatus[TotalQuerys] ++; mysql_tquery(g_MySQLConnection, sprintf ("UPDATE config SET useping = '1' WHERE gid = %d", G_ID), "", "");
	           			gConfig[ EPingLimit ] = 1;
	              		//SyncConfigFile();
	              		format (stringo, sizeof stringo, "Admin/Mod {"#COLOR_SYSTEM_FOCUS"}%s{"#COLOR_SYSTEM_REST"} has enabled Ping Kick.", Player[playerid][Nickname]);

	                }

	                SendClientMessageToAll(COLOR_SYSTEM, stringo);
	                MostraConfig (playerid);
		        }
		        case 1:
				{
				    ShowPlayerDialog(playerid, DIALOG_CHANGEPING, DIALOG_STYLE_INPUT, "Ping Limit Change", "New ping limit:", "Change", "Back");
				}
		    }
		}
		case DIALOG_CHANGEPING:
		{
		    if (!response) return MostraConfig(playerid);
		    if (isnull(inputtext))return ShowPlayerDialog(playerid, DIALOG_CHANGEPING, DIALOG_STYLE_INPUT, "Ping Limit Change", "New ping limit:", "Change", "Back");
	        gConfig[PingLimit] = strval(inputtext);
	        MySQLStatus[TotalQuerys] ++; mysql_tquery(g_MySQLConnection, sprintf("UPDATE config SET pinglimit = '%d' WHERE gid = %d", gConfig[PingLimit], G_ID), "", "");
	   		format(stringo, sizeof stringo, "Admin/Mod {"#COLOR_SYSTEM_FOCUS"}%s{"#COLOR_SYSTEM_REST"} changed Ping Limit to %d.", Player[playerid][Nickname], gConfig[PingLimit]);
            SendClientMessageToAll(COLOR_SYSTEM, stringo);
			MostraConfig(playerid);
		}
		case DIALOG_CONFIG_PLLIMIT:
		{
		    switch(listitem) {
		        case 0: {
		            PlayerPlaySound(playerid, SOUND_SUCCESS, 0.0, 0.0, 0.0);
	         		if( gConfig[ EPLLimit ] )
	 				{
	 				    MySQLStatus[TotalQuerys] ++; mysql_tquery(g_MySQLConnection, sprintf ("UPDATE config SET usepl = '0' WHERE gid = %d", G_ID), "", "");
	           			gConfig[ EPLLimit ] = 0;
	              		//SyncConfigFile();
	              		format(stringo, sizeof stringo, "Admin/Mod {"#COLOR_SYSTEM_FOCUS"}%s{"#COLOR_SYSTEM_REST"} has disabled Packetloss Kick.", Player[playerid][Nickname]);
	                }
	         		else
	   				{
					    MySQLStatus[TotalQuerys] ++; mysql_tquery(g_MySQLConnection, sprintf ("UPDATE config SET usepl = '1' WHERE gid = %d", G_ID), "", "");
	           			gConfig[ EPLLimit ] = 1;
	              		//SyncConfigFile();
	              		format(stringo, sizeof stringo, "Admin/Mod {"#COLOR_SYSTEM_FOCUS"}%s{"#COLOR_SYSTEM_REST"} has enabled Packetloss Kick.", Player[playerid][Nickname]);
	                }

	                SendClientMessageToAll(COLOR_SYSTEM, stringo);
	                MostraConfig(playerid);
		        }
		        case 1: {
	 				ShowPlayerDialog(playerid, DIALOG_CHANGEPL, DIALOG_STYLE_INPUT, "Packloss Limit Change", "New packetloss limit:", "Change", "Back");
				}
		    }
		}
		case DIALOG_CHANGEPL:
		{
		    if (!response) return MostraConfig(playerid);
		    if (isnull(inputtext))return ShowPlayerDialog(playerid, DIALOG_CHANGEPL, DIALOG_STYLE_INPUT, "Packloss Limit Change", "New packetloss limit:", "Change", "Back");
	        gConfig[PlLimit] = strval(inputtext);
	        MySQLStatus[TotalQuerys] ++; mysql_tquery(g_MySQLConnection, sprintf("UPDATE config SET pllimit = '%.1f' WHERE gid = %d", gConfig[PlLimit], G_ID), "", "");
	   		format(stringo, sizeof stringo, "Admin/Mod {"#COLOR_SYSTEM_FOCUS"}%s{"#COLOR_SYSTEM_REST"} changed Packetloss Limit to %.1f.", Player[playerid][Nickname], gConfig[PlLimit]);
            SendClientMessageToAll(COLOR_SYSTEM, stringo);
	        MostraConfig(playerid);
		}
		case DIALOG_CONFIG_FPSLIMIT:
		{
		    switch(listitem)
			{
		        case 0:
				{
				    PlayerPlaySound(playerid, SOUND_SUCCESS, 0.0, 0.0, 0.0);
	         		if( gConfig[ EFpsLimit ] )
					 {
					    MySQLStatus[TotalQuerys] ++; mysql_tquery(g_MySQLConnection, sprintf ("UPDATE config SET usefps = '0' WHERE gid = %d", G_ID), "", "");
	           			gConfig[ EFpsLimit ] = 0;
	              		//SyncConfigFile();
	              		format (stringo, sizeof stringo, "Admin/Mod {"#COLOR_SYSTEM_FOCUS"}%s{"#COLOR_SYSTEM_REST"} has disabled FPS Kick.", Player[playerid][Nickname]);
	                }
	         		else if(! gConfig[ EFpsLimit ] )
			 		{
			 		    MySQLStatus[TotalQuerys] ++; mysql_tquery(g_MySQLConnection, sprintf ("UPDATE config SET usefps = '1' WHERE gid = %d", G_ID), "", "");
	           			gConfig[ EFpsLimit ] = 1;
	              		//SyncConfigFile();
	              		format (stringo, sizeof stringo, "Admin/Mod {"#COLOR_SYSTEM_FOCUS"}%s{"#COLOR_SYSTEM_REST"} has enabled FPS Kick.", Player[playerid][Nickname]);
	                }

                    SendClientMessageToAll(COLOR_SYSTEM, stringo);
                    MostraConfig(playerid);
		        }
		        case 1: {
				    ShowPlayerDialog(playerid, DIALOG_CHANGEFPS, DIALOG_STYLE_INPUT, "FPS Limit Change", "New fps limit:", "Change", "Back");
				}
		    }
		}
		case DIALOG_CHANGEFPS:
		{
		    if (!response) return MostraConfig(playerid);
		    if (isnull(inputtext))return ShowPlayerDialog(playerid, DIALOG_CHANGEFPS, DIALOG_STYLE_INPUT, "Ping Limit Change", "New ping limit:", "Change", "Back");
	        gConfig[FpsLimit] = strval(inputtext);
	        MySQLStatus[TotalQuerys] ++; mysql_tquery(g_MySQLConnection, sprintf("UPDATE config SET fpslimit = '%d' WHERE gid = %d", gConfig[FpsLimit], G_ID), "", "");
	   		format(stringo, sizeof stringo, "Admin/Mod {"#COLOR_SYSTEM_FOCUS"}%s{"#COLOR_SYSTEM_REST"} changed FPS Limit to %d.", Player[playerid][Nickname], gConfig[FpsLimit]);
            SendClientMessageToAll(COLOR_SYSTEM, stringo);
	        MostraConfig(playerid);
		}
		case DIALOG_CONFIG_TDMKILLS:
		{
		    if(!response) return MostraConfig(playerid);
		    if(strval(inputtext) < 1) return ShowPlayerDialog(playerid, DIALOG_CONFIG_TDMKILLS, DIALOG_STYLE_INPUT, "TDM Kills limit", "Invalid inserted value.", "Set", "Cancel");
	        PlayerPlaySound(playerid, SOUND_SUCCESS, 0.0, 0.0, 0.0);
			gConfig[TDMKills] = strval(inputtext);
		    //SyncConfigFile();
		    MySQLStatus[TotalQuerys] ++; mysql_tquery(g_MySQLConnection, sprintf("UPDATE config SET tdmkills = '%d' WHERE gid = %d", gConfig[TDMKills], G_ID), "", "");
		    if (RoundStarted) SyncTextdraw(1);
			OpenPlayerDialog(playerid, PDIALOG_GAMECONFIG);
			format(stringo, sizeof stringo, "Admin/Mod {"#COLOR_SYSTEM_FOCUS"}%s{"#COLOR_SYSTEM_REST"} has set TDM kills limit to {"#COLOR_SYSTEM_FOCUS"}%d", Player[playerid][Nickname], gConfig[TDMKills]);
            SendClientMessageToAll(COLOR_SYSTEM, stringo);
		}
		case DIALOG_CONFIG_REFSKIN:
		{
		    if(!response) return MostraConfig(playerid);
		    PlayerPlaySound(playerid, SOUND_SUCCESS, 0.0, 0.0, 0.0);
			iTeam[TEAM_REF][Skin] = strval(inputtext);
			//SyncConfigFile();

			OpenPlayerDialog(playerid, PDIALOG_GAMECONFIG);
			format(stringo, sizeof stringo, "Admin/Mod {"#COLOR_SYSTEM_FOCUS"}%s{"#COLOR_SYSTEM_REST"} has set Ref skin to {"#COLOR_SYSTEM_FOCUS"}%d", Player[playerid][Nickname], iTeam[TEAM_REF][Name]);
            SendClientMessageToAll(COLOR_SYSTEM, stringo);
		}
		case DIALOG_CONFIG_ROUNDTIME:
		{
		    if(!response) return MostraConfig(playerid);
		    PlayerPlaySound(playerid, SOUND_SUCCESS, 0.0, 0.0, 0.0);
		    gConfig[RTime_Mins] = strval(inputtext);
		    MySQLStatus[TotalQuerys] ++; mysql_tquery(g_MySQLConnection, sprintf("UPDATE config SET roundtime = '%d' WHERE gid = %d", gConfig[RTime_Mins], G_ID), "", "");
		    OpenPlayerDialog(playerid, PDIALOG_GAMECONFIG);
	        //SyncConfigFile();
			format(stringo, sizeof stringo, "Admin/Mod {"#COLOR_SYSTEM_FOCUS"}%s{"#COLOR_SYSTEM_REST"} has set the round time limit to {"#COLOR_SYSTEM_FOCUS"}%d", Player[playerid][Nickname], gConfig[RTime_Mins]);
            SendClientMessageToAll(COLOR_SYSTEM, stringo);
		}
		case DIALOG_CONFIG_CPSECS:
		{
		    if(!response) return MostraConfig(playerid);
		    PlayerPlaySound(playerid, SOUND_SUCCESS, 0.0, 0.0, 0.0);
		    gConfig[TCp] = strval(inputtext);
		    MySQLStatus[TotalQuerys] ++; mysql_tquery(g_MySQLConnection, sprintf("UPDATE config SET tcp = '%d' WHERE gid = %d", gConfig[TCp], G_ID), "", "");
		    OpenPlayerDialog(playerid, PDIALOG_GAMECONFIG);
		    //SyncConfigFile();
		    format(stringo, sizeof stringo, "Admin/Mod {"#COLOR_SYSTEM_FOCUS"}%s{"#COLOR_SYSTEM_REST"} has set the checkpoint time to {"#COLOR_SYSTEM_FOCUS"}%d", Player[playerid][Nickname], gConfig[TCp]);
            SendClientMessageToAll(COLOR_SYSTEM, stringo);
		}
		case DIALOG_CONFIG_TEAMNAMEA:
		{
		    if(!response) return MostraConfig(playerid);

	        if( strlen( inputtext ) >= MAX_TEAM_NAME )
	        {
	        	ShowPlayerDialog(playerid, DIALOG_CONFIG_TEAMNAMEA, DIALOG_STYLE_INPUT, "Team name", "Invalid name length (1-"#MAX_TEAM_NAME")", "Go", "Cancel");
				PlayerPlaySound(playerid, SOUND_WRONG, 0.0, 0.0, 0.0);
				return false;
	        }

	        PlayerPlaySound(playerid, SOUND_SUCCESS, 0.0, 0.0, 0.0);
			format(stringo, sizeof stringo, "Admin/Mod {"#COLOR_SYSTEM_FOCUS"}%s{"#COLOR_SYSTEM_REST"} has set the name of the team %s to {"#COLOR_SYSTEM_FOCUS"}%s", Player[playerid][Nickname], iTeam[TEAM_A][Name], inputtext);
            SendClientMessageToAll(COLOR_SYSTEM, stringo);

            ChangeTeamName(TEAM_A, inputtext);
		    OpenPlayerDialog(playerid, PDIALOG_TEAMS);
		    //SyncConfigFile();
			RefreshTextGeneralTD();
		}
		case DIALOG_CONFIG_TEAMNAMEB:
		{
		    if(!response) return MostraConfig(playerid);
	        if( strlen( inputtext ) >= MAX_TEAM_NAME )
	        {
	        	ShowPlayerDialog(playerid, DIALOG_CONFIG_TEAMNAMEB, DIALOG_STYLE_INPUT, "Team name", "Invalid name length (1-"#MAX_TEAM_NAME")", "Go", "Cancel");
				PlayerPlaySound(playerid, SOUND_WRONG, 0.0, 0.0, 0.0);
				return false;
	        }
	        PlayerPlaySound(playerid, SOUND_SUCCESS, 0.0, 0.0, 0.0);
			format(stringo, sizeof stringo, "Admin/Mod {"#COLOR_SYSTEM_FOCUS"}%s{"#COLOR_SYSTEM_REST"} has set the name of the team %s to {"#COLOR_SYSTEM_FOCUS"}%s", Player[playerid][Nickname], iTeam[TEAM_B][Name], inputtext);
            SendClientMessageToAll(COLOR_SYSTEM, stringo);

            ChangeTeamName (TEAM_B, inputtext);
            /*
		    strcpy_2(iTeam[TEAM_B][Name], inputtext);

            MySQLStatus[TotalQuerys] ++; mysql_tquery(g_MySQLConnection, sprintf("UPDATE teams SET name = '%s' WHERE id = '2' AND gid = %d", inputtext, G_ID), "", "");
		    RefreshReadyTDs_Esl ();
		    SyncTextdraw(1);

			if(gConfig[Matchmode] != MATCHMODE_NOSCORES)
			{
				SendRconCommand(sprintf("mapname Lobby %s %d:%d %s", iTeam[TEAM_A][Name], iTeam[TEAM_A][RoundWins], iTeam[TEAM_B][RoundWins], iTeam[TEAM_B][Name]));
			}

		    format(iTeam[TEAM_B_SUB][Name], 128, "Sub-%s", inputtext);*/
		    OpenPlayerDialog(playerid, PDIALOG_TEAMS);
		    //SyncConfigFile();
			RefreshTextGeneralTD();
		}
		#if BUON_NATALE == true
		case DIALOG_DESIDERI:
		{
		    if (!response) 			return true;
		    if (isnull(inputtext)) 	return true;

		    new File:f = fopen("regali.txt", io_append);
		    fwrite(f, sprintf("%s=%s\r\n", Player[playerid][Nickname], inputtext));
		    fclose(f);

		    format(stringo, sizeof stringo, "La tua lettera ï¿½ stata inviata! Altre %d persone hanno inviato una lettera a babbo natale!", ServerStats[BabboNatale]);
            SendClientMessage(playerid, COLOR_SYSTEM, stringo);

            Server_RefreshStats(BabboNatale, 1);
		}
		#endif
	}
	return true;
}

forward OnReadScores();
public OnReadScores()
{
    if(gConfig[Matchmode] == MATCHMODE_TCWCW) return true;

	new tmp[24];
	cache_get_field_content(0, "scores", tmp);
	sscanf(tmp, "p<,>dd", iTeam[TEAM_A][RoundWins], iTeam[TEAM_B][RoundWins]);

	PlayingRound = 0;
	RefreshTextGeneralTD();
	SendRconCommand(sprintf("mapname Lobby %d:%d", iTeam[TEAM_A][RoundWins], iTeam[TEAM_B][RoundWins]));
	return true;
}

stock Role_Opposto(role)
 {
	if(role == ATTACKERS)
	{
	    return DEFENDERS;
	}
	return ATTACKERS;
}

public OnPlayerStateChange(playerid, newstate, oldstate)
{
	if(newstate == PLAYER_STATE_DRIVER || newstate == PLAYER_STATE_PASSENGER)
	{
	    /*new veh = GetPlayerVehicleID(playerid);
	    #if AC_ENABLED == true
	    AC_VehicleCheck(veh, playerid);
	    #endif
		*/
		//player entra nel veicolo
		new veh = GetPlayerVehicleID(playerid);

		if (Player[playerid][InGame]) {
			foreach(new i:Player)
			{
			    if(InSpec[i] == playerid)
				{
	//		        TogglePlayerSpectating(i, 1);
			        PlayerSpectateVehicle(i, veh);
			    }
			}
		}

		SetPlayerArmedWeapon(playerid, 0);

		Player_LastVeh[playerid] = veh;
		Player_LastSeat[playerid] = GetPlayerVehicleSeat(playerid);
	}
	else if(/*newstate == PLAYER_STATE_ONFOOT && */(oldstate == PLAYER_STATE_DRIVER || oldstate == PLAYER_STATE_PASSENGER))
	{
	    // player esce dal veicolo

	    if (Player[playerid][InGame]) {
			foreach(new i:Player)
			{
			    if(InSpec[i] == playerid)
				{
	//		        TogglePlayerSpectating(i, 1);
			        PlayerSpectatePlayer(i, playerid);
			    }
			}
		}

		if (Player_LastSeat[playerid] == 0)
		{
			new veh = Player_LastVeh[playerid];

		    if (IsValidVehicle(veh))
			{
			    new model = GetVehicleModel(veh);

			    if(model==449||model==537||model==538||model==570||model==569)
			        return true;

			    new Float:x, Float:y, Float:z, Float:r;
			    GetVehiclePos(veh, x, y, z);
			    GetVehicleZAngle(veh, r);

				new Float:health;
				GetVehicleHealth(veh, health);

			    // I should admit a thing
			    // using DestroyVehicleEx(veh); first should allow CreateVehicle to use the same id of the prev. destroyed vehicle
			    // but i'm not sure about it, so i avoid this (maybe we will see?)

				new veh2 = CreateVehicleEx(model, x, y, z, r, iVeh[veh][Color1], iVeh[veh][Color2], -1);
				SetVehicleHealth(veh2, health);
				ChangeVehiclePaintjobEx(veh2, iVeh[veh][Paint]);

                DestroyVehicleEx(veh);

                SetVehicleVirtualWorld(veh2, GetPlayerVirtualWorld(playerid));

                Player_LastVeh[playerid] = -1;
		    }
		}
	}
	return true;
}

public OnPlayerEnterCheckpoint(playerid)
{
//	SendClientMessageToAll(-1, "OnPlayerEnterCheckpoint = %d playerid", playerid);
	if (RoundStarted)
	{
	    if (Player[playerid][InGame])
	    {
	        if (TeamRole[Player[playerid][Team]] == DEFENDERS)
	        {
	        	// cp is in capture?
	        	// un difensore passa x il cp riprendendolo
	            if (RealCPTime != gConfig[TCp])
	            {
	                RealCPTime = gConfig[TCp];
	                GangZoneStopFlashForAll(ZonaAttornoCP);
	                //GangZoneFlashForAll(ZonaAttornoCP, (TeamRole[TEAM_A] == DEFENDERS ? iTeam[TEAM_A][InGameColor] : iTeam[TEAM_B][InGameColor]));
	                //GangZonePulseForAll(ZonaAttornoCP, (TeamRole[TEAM_A] == ATTACKERS ? iTeam[TEAM_A][InGameColor] : iTeam[TEAM_B][InGameColor]), (TeamRole[TEAM_A] == DEFENDERS ? iTeam[TEAM_A][InGameColor] : iTeam[TEAM_B][InGameColor]), 1000);
	                //GangZoneStopPulseForAll(ZonaAttornoCP);
	                SyncTextdraw (2);
	            }
	        }
	        else
	        {
	            // e' se fosse giï¿½ passatoun secondo?
	            TextDrawSetString(CPTimer, sprintf("~b~~h~Checkpoint: ~w~~h~%d", RealCPTime));
	            if (RealCPTime == gConfig[TCp]) // mostra il cp + pulse
	            {
		            TextDrawShowForAll(CPTimer);
		            //GangZoneFlashForAll(ZonaAttornoCP, (TeamRole[TEAM_A] == ATTACKERS ? iTeam[TEAM_A][InGameColor] : iTeam[TEAM_B][InGameColor]));
		            //GangZonePulseForAll(ZonaAttornoCP, (TeamRole[TEAM_A] == DEFENDERS ? iTeam[TEAM_A][InGameColor] : iTeam[TEAM_B][InGameColor]), (TeamRole[TEAM_A] == ATTACKERS ? iTeam[TEAM_A][InGameColor] : iTeam[TEAM_B][InGameColor]), 1000);
				}
	        }
	    }
	}
	return true;
}//X11_GREEN
/*
//#define COLOR_GANGZONE_NOCAPTURE    (X11_GREEN) // fade: team che lo nn possiede to team che lo ha
												//(TeamRole[TEAM_A] == DEFENDERS ? iTeam[TEAM_A][InGameColor] : iTeam[TEAM_B][InGameColor])
//#define COLOR_GANGZONE_CAPTURE      (X11_RED)  // (TeamRole[TEAM_A] == ATTACKERS ? iTeam[TEAM_A][InGameColor] : iTeam[TEAM_B][InGameColor])


public OnPlayerLeaveCheckpoint(playerid) {
    SendClientMessageToAll(-1, "OnPlayerLeaveCheckpoint = %d playerid", playerid);
	return true;
}*/

// Match SQL Code system

/*forward SQLMatch_MatchCreated();
public SQLMatch_MatchCreated()
{
	webMatch[MatchID] = mysql_insert_id(webMatch[g_Connection]);
	SendClientMessageToAll(COLOR_SYSTEM, "Match ID: %d", webMatch[MatchID]);
}

forward SQLMatch_MatchEnded();
public SQLMatch_MatchEnded ()
{
	SendClientMessageToAll(COLOR_SYSTEM, "Match closed.");
	SetTimer("close_connection", 50, false);
}

forward close_connection(); public close_connection() { mysql_close(webMatch[g_Connection]); }
*/
// End match sql code system

public OnPlayerGiveDamage(playerid, damagedid, Float: amount, weaponid, bodypart)
{
//	SendClientMessageToAll(-1, "OnPlayerGiveDamage(playerid, damagedid, Float: amount, weaponid) %d %d %f %d", playerid, damagedid, Float: amount, weaponid);
	if (RoundStarted)
	{
		if (Gaming == GAMETYPE_LASTBULLET)
		{
		    if (Player[playerid][InGame] && Player[damagedid][InGame])
		    {
		        if (weaponid == 4 || weaponid == 24)
		        {
					// && Gaming != GAMETYPE_LASTBULLET
					// "gestisco" manualmente l'onplayerdeath
					// dato che bugga in questo caso

					sys_m_onplayerdeath[damagedid] = true;
					sys_m_PlayerKillerid[damagedid] = playerid;
					sys_m_PlayerReason[damagedid] = weaponid;

					SetPlayerHealth (damagedid, 0.0);
				//	SetTimerEx ("OnPlayerDeath", 50, false, "iii", damagedid, playerid, weaponid);
				}
		    }
		}
	}
 	return true;
}

#define TD_HIT_ROSSO                                                      		1
#define TD_HIT_VERDE                                                      		0

public OnPlayerTakeDamage(playerid, issuerid, Float: amount, weaponid, bodypart)
{
	// Playerid = Chi ha preso l'hit
	// Issuerid = Chi ha dato l'hit
	// -> INVALID_PLAYER_ID = Se collision
	// -> ID = Se hit

	new pG = Player[playerid][InGame];

	if (RoundStarted && pG)
	{
		if (Gaming != GAMETYPE_GUNGAME && Gaming != GAMETYPE_FIGHT && Gaming != GAMETYPE_LASTBULLET)
			if (Player[playerid][Team] == ( issuerid != INVALID_PLAYER_ID ? ( Player[issuerid][Team] ) : ( -1 ))) return false;
	}

	new pT = Player[playerid][Team];

	new Float:tmpH, Float:tmpA;

	GetPlayerHealth (playerid, tmpH);
	GetPlayerArmour (playerid, tmpA);

    new pHealth = floatround (tmpH), pArmour = floatround (tmpA);
	new pickupToCreate;
	// 1 = armour
	// 2 = health
	// 3 = tutti e due

	new Amount = floatround (amount);

    new diff = pHealth - Amount;

	// Il player ha ancora dell'armatura
	if (tmpA > 0 && (issuerid != INVALID_PLAYER_ID && weaponid != 37) ) {
		pArmour -= Amount;
		pickupToCreate = 1;

		// Se l'armatura è andata sotto zero, signifia che ha perso anche della vita
		if (pArmour < 0) {
		    pHealth -= (pArmour * -1);
		    pArmour = 0; // Riporto l'armtura a 0

		    pickupToCreate = 3;
		}
	}
	else if(tmpH > 0)
	{
		// Non aveva l'armatura ma la vita, Quindi tolgo la vita
	    pHealth -= Amount;
	    pickupToCreate = 2;

	    if (pHealth < 0) {
			Amount = Amount - (-diff);
			pHealth = 0;
		}

		// In caso di necessità; si può sapere se il player è morto per colpa di questo hit
	}

	// A questo punto ho la vita fixata per playerid
	// Ora per l'altro td mi serve anche la vita di issuerid
	//

	// Prendo la sua vita da GetPlayerHealth
	// Bisogna fare dei test usando anche LastHP e LastArmour
	new iHealth, iArmour;

	// Se non era per collisione, prendo la vita dell'altro player
	if (issuerid != INVALID_PLAYER_ID)
	{
		GetPlayerHealth (issuerid, tmpH);

		iHealth = floatround (tmpH);

		GetPlayerArmour (issuerid, tmpH);

		iArmour = floatround (tmpH);
	}

	if (pG)
	{
		if (CamMove) return false;
	    if (issuerid == INVALID_PLAYER_ID)
	    {
	        if (AntiHits == true)
			{
				SetPlayerHealth(playerid, tmpH);
				SetPlayerArmour(playerid, tmpA);
				return true;
	        }
	    }
	    else if ( AntiHits == true )
	    {
	        AntiHits = false;
	        SendClientMessageToAll(COLOR_SYSTEM, "** First Hit! Fall Protection is disabled now.");

	        foreach(new i:Player)
	        {
	            if (Player[i][InGame])
	            {
	                TextDrawHideForPlayer(i, TD_NoHitsScritta);
	            }
	        }
	    }
	}

	if (RoundStarted && pG)
	{
		if (Gaming != GAMETYPE_GUNGAME && Gaming != GAMETYPE_FIGHT && Gaming != GAMETYPE_FALLOUT && Gaming != GAMETYPE_LASTBULLET)
 		{
			if (TeamHitsTimer[pT] != Timer:-1) stop TeamHitsTimer[pT];

			TotalTeamDMG[pT] += Amount;

			if(pT == TEAM_A)
			{
			    format(stringo, sizeof stringo, "~w~-~r~~h~%d", TotalTeamDMG[pT]);
				TextDrawSetString(DamageTeamA, stringo);
		  		TextDrawShowForAll(DamageTeamA);
			}
			else
			{
			    format(stringo, sizeof stringo, "~w~-~b~~h~%d", TotalTeamDMG[pT]);
				TextDrawSetString(DamageTeamB, stringo);
				TextDrawShowForAll(DamageTeamB);
			}

            TeamHitsTimer[pT] = defer HideTeamDamage(pT);//3500

			if( weaponid == 49 ) // vehicle collision
			{
	 			DestroyVehicleEx( GetPlayerVehicleID( issuerid ) );
				GameTextForPlayer( issuerid , "~r~No vehicle collision" , 500 , 3 );
			}
			else
			{
		   		if (issuerid != INVALID_PLAYER_ID)
		   		{
					Player[issuerid][RDamage] += Amount;
					new somma = Player[issuerid][Damage] + Player[issuerid][RDamage];

					if (Player[issuerid][Team] == TEAM_A)
					{
						TextDrawSetString(PlayerSpecInfo[issuerid][1], sprintf ("~"#GT_TEAMA"~~h~Damage ~w~%d", Player[issuerid][RDamage]));
						TextDrawSetString(PlayerSpecInfo[issuerid][8], sprintf ("~"#GT_TEAMA"~~h~T.Dmg ~w~%d", somma));
					}
					else
					{
						TextDrawSetString(PlayerSpecInfo[issuerid][1], sprintf ("~"#GT_TEAMB"~~h~Damage ~w~%d", Player[issuerid][RDamage]));
		            	TextDrawSetString(PlayerSpecInfo[issuerid][8], sprintf ("~"#GT_TEAMB"~~h~T.Dmg ~w~%d", somma));
					}

					PlayerTextDrawSetString (issuerid, PlayerInfo[1], sprintf("DMG ~b~~h~%d~n~~w~Tot. DMG ~b~~h~%d", Player[issuerid][RDamage], somma));

					if (gConfig[ UseHealthBars ])
					{
						SetPlayerScore(issuerid, Player[issuerid][RDamage]);
					}

					PlayerPlaySound(issuerid, 17802, 0.0, 0.0, 0.0);
				}
			}

	 		PlayerPlaySound(playerid, 1057,  0.0, 0.0, 0.0);
		}
		else
		{
			if (issuerid != INVALID_PLAYER_ID)
			{
				PlayerPlaySound(issuerid, 17802, 0.0, 0.0, 0.0);
	            new somma = Player[issuerid][Damage] + Player[issuerid][RDamage];

				if (Player[issuerid][Team] == TEAM_A)
				{
					TextDrawSetString(PlayerSpecInfo[issuerid][1], sprintf ("~"#GT_TEAMA"~~h~Damage ~w~%d", Player[issuerid][RDamage]));
					TextDrawSetString(PlayerSpecInfo[issuerid][8], sprintf ("~"#GT_TEAMA"~~h~T.Dmg ~w~%d", somma));
				}
				else
				{
					TextDrawSetString(PlayerSpecInfo[issuerid][1], sprintf ("~"#GT_TEAMB"~~h~Damage ~w~%d", Player[issuerid][RDamage]));
					TextDrawSetString(PlayerSpecInfo[issuerid][8], sprintf ("~"#GT_TEAMB"~~h~T.Dmg ~w~%d", somma));
				}

				Player[issuerid][RDamage] += Amount;

				PlayerTextDrawSetString (issuerid, PlayerInfo[1], sprintf("DMG ~b~~h~%d~n~~w~Tot. DMG ~b~~h~%d", Player[issuerid][RDamage], somma));

				if (gConfig[ UseHealthBars ])
				{
					SetPlayerScore(issuerid, Player[issuerid][RDamage]);
				}
			}

	 		PlayerPlaySound(playerid, 1057,  0.0, 0.0, 0.0);
		}

		foreach(new i:Player)
		{
		    if(i != issuerid) {
			    if (InSpec[i] == issuerid) {
                    PlayerPlaySound(i, 17802, 0.0, 0.0, 0.0);
			    }
		    }
		    else if(i != playerid) {
			    if (InSpec[i] == playerid) {
                    PlayerPlaySound(i, 1057, 0.0, 0.0, 0.0);
			    }
		    }
		}
	}
	else//round not started
	{
   		PlayerPlaySound(playerid, 1057,  0.0, 0.0, 0.0);

   		if (issuerid != INVALID_PLAYER_ID)
   		{
			PlayerPlaySound(issuerid, 17802, 0.0, 0.0, 0.0);

	   		if (Player[issuerid][InDm] != -1)
	   		{
	   		    Player[issuerid][DDamage] += Amount;
	   		}
		}
	}

	// Ok ora ho le vite di tutti e due i players fixate
	// SU:
	// playerid: pHealth pArmour
	// issuerid: iHealth iArmour

//	format (stringo, sizeof stringo, "Playerid data: Health %d Armour %d", pHealth, pArmour);
//	SendClientMessageToAll (-1, stringo);

//	format (stringo, sizeof stringo, "issuerid data: Health %d Armour %d", iHealth, iArmour);
//	SendClientMessageToAll (-1, stringo);

	switch (pickupToCreate)
	{
	    case 1:
	    {
//	        SendClientMessage(playerid, -1, "Armour");
	        // Armour
			stop Player[playerid][Timer_ObjArmour];
			DestroyObject (Player[playerid][HeadObj_Armour]);

			Player[playerid][HeadObj_Armour] = CreateObject(1242, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0);
            AttachObjectToPlayer(Player[playerid][HeadObj_Armour], playerid, 0.0, 0.0, 1.5, 0.0, 0.0, 0.0);
			Player[playerid][Timer_ObjArmour] = defer Destroy_Obj(Player[playerid][HeadObj_Armour]);
	    }
	    case 2:
		{
	//	    SendClientMessage(playerid, -1, "Health");
		    // Health
			stop Player[playerid][Timer_ObjHealth];
			DestroyObject (Player[playerid][HeadObj_Health]);

			Player[playerid][HeadObj_Health] = CreateObject(1240, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0);
            AttachObjectToPlayer(Player[playerid][HeadObj_Health], playerid, 0.0, 0.0, 1.5, 0.0, 0.0, 0.0);
			Player[playerid][Timer_ObjHealth] = defer Destroy_Obj(Player[playerid][HeadObj_Health]);
		}
		case 3:
		{
	//	    SendClientMessage(playerid, -1, "H+A");
			// Crea due objects
			// E due timers
		    // Armour / Health
			stop Player[playerid][Timer_ObjArmour];
			DestroyObject (Player[playerid][HeadObj_Armour]);

			Player[playerid][HeadObj_Armour] = CreateObject(1242, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0);
            AttachObjectToPlayer(Player[playerid][HeadObj_Armour], playerid, 0.0, 0.0, 1.5, 0.0, 0.0, 0.0);
			Player[playerid][Timer_ObjArmour] = defer Destroy_Obj(Player[playerid][HeadObj_Armour]);

			stop Player[playerid][Timer_ObjHealth];
			DestroyObject (Player[playerid][HeadObj_Health]);

			Player[playerid][HeadObj_Health] = CreateObject(1240, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0);
            AttachObjectToPlayer(Player[playerid][HeadObj_Health], playerid, 0.0, 0.0, 1.5, 0.0, 0.0, 0.0);
			Player[playerid][Timer_ObjHealth] = defer Destroy_Obj(Player[playerid][HeadObj_Health]);
		}
/*		default:
		{
		    SendClientMessage(playerid, -1, "No case");
		}
*/
	}

	/**
			// 0 VERDE
			TD0_ID                  [MAX_MULTI_HITS],                           // INVALID_PLAYER_ID IF NOT ASSIGNED YET <-> COLLISION_ID IF COLLISION
			TD0_WEAP                [MAX_MULTI_HITS],
			TD0_DMG              [MAX_MULTI_HITS],
			TD0_HEALTH              [MAX_MULTI_HITS],

			// 1 ROSSO
			TD1_ID                  [MAX_MULTI_HITS],                           // INVALID_PLAYER_ID IF NOT ASSIGNED YET <-> COLLISION_ID IF COLLISION
			TD1_WEAP                [MAX_MULTI_HITS],
			TD1_DMG              [MAX_MULTI_HITS],
			TD1_HEALTH              [MAX_MULTI_HITS],
	*/

	// TD_Player_Damages[0] => Verde  ( TD_HIT_VERDE )
	// TD_Player_Damages[1] => Rosso  ( TD_HIT_ROSSO )

	// Player (issuerid) ha hittato un altro player (playerid)
	// Player hitta player


	//
	// variabili generali
	#define MAX_BLOCCO_STR 128
	new szl [MAX_BLOCCO_STR];

	// indica se l'hit è di un player che ha già un td
	new bool:vecchioHit = false;

    new
        sommapHealth = (pHealth+pArmour);

	if (issuerid != INVALID_PLAYER_ID)
	{
	    // In Questo caso:
	    // issuerid ha hittato playerid

	    // prima cosa:
	    // vedo se il player conosce già il player
	    if (Player[issuerid][TD0_ID][0] == playerid)
	    {
	        Player [issuerid][TD0_DMG][0] += Amount;

	        Player [issuerid][TD0_WEAP][0] = weaponid;
	        Player [issuerid][TD0_HEALTH][0] = sommapHealth;

			stop Player [issuerid][TD0_TIMER][0];
			Player [issuerid][TD0_TIMER][0] = defer HideTextDraw0(issuerid, 0);

			if (sommapHealth > 100) {
			    format (szl, MAX_BLOCCO_STR, "~g~~h~%s~w~ +%d / ~g~~h~%s ~w~(~w~%d~w~)~n~",
			        Player[playerid][Nickname_WOTag],
					Player[issuerid][TD0_DMG][0],
					aWeaponNames [weaponid],
					sommapHealth);
			}
			else
			{
			    format (szl, MAX_BLOCCO_STR, "~g~~h~%s~w~ +%d / ~g~~h~%s ~w~(~r~~h~~h~%d~w~)~n~",
			        Player[playerid][Nickname_WOTag],
					Player[issuerid][TD0_DMG][0],
					aWeaponNames [weaponid],
					sommapHealth);
			}

			PlayerTextDrawSetString(issuerid, TD_Player_Damages[0][0], szl);


			vecchioHit = true;
	    }// if (Player[issuerid][TD0_ID][0] == playerid)

	    if (!vecchioHit && Player[issuerid][TD0_ID][1] == playerid)
	    {
	        Player [issuerid][TD0_DMG][1] += Amount;
	        Player [issuerid][TD0_WEAP][1] = weaponid;
	        Player [issuerid][TD0_HEALTH][1] = sommapHealth;

			stop Player [issuerid][TD0_TIMER][1];
			Player [issuerid][TD0_TIMER][1] = defer HideTextDraw0(issuerid, 1);

			if (sommapHealth > 100) {
			    format (szl, MAX_BLOCCO_STR, "~g~~h~%s~w~ +%d / ~g~~h~%s ~w~(~w~%d~w~)~n~",
			        Player[playerid][Nickname_WOTag],
					Player[issuerid][TD0_DMG][1],
					aWeaponNames [weaponid],
					sommapHealth);
			}
			else
			{
			    format (szl, MAX_BLOCCO_STR, "~g~~h~%s~w~ +%d / ~g~~h~%s ~w~(~r~~h~~h~%d~w~)~n~",
			        Player[playerid][Nickname_WOTag],
					Player[issuerid][TD0_DMG][1],
					aWeaponNames [weaponid],
					sommapHealth);
			}

			PlayerTextDrawSetString(issuerid, TD_Player_Damages[0][1], szl);
			vecchioHit = true;
	    }// if (Player[issuerid][TD0_ID][1] == playerid)

	    if (!vecchioHit && Player[issuerid][TD0_ID][2] == playerid)
	    {
	        Player [issuerid][TD0_DMG][2] += Amount;
	        Player [issuerid][TD0_WEAP][2] = weaponid;
	        Player [issuerid][TD0_HEALTH][2] = sommapHealth;

			stop Player [issuerid][TD0_TIMER][2];
			Player [issuerid][TD0_TIMER][2] = defer HideTextDraw0(issuerid, 2);

			if (sommapHealth > 100) {
			    format (szl, MAX_BLOCCO_STR, "~g~~h~%s~w~ +%d / ~g~~h~%s ~w~(~w~%d~w~)~n~",
			        Player[playerid][Nickname_WOTag],
					Player[issuerid][TD0_DMG][2],
					aWeaponNames [weaponid],
					sommapHealth);
			}
			else
			{
			    format (szl, MAX_BLOCCO_STR, "~g~~h~%s~w~ +%d / ~g~~h~%s ~w~(~r~~h~~h~%d~w~)~n~",
			        Player[playerid][Nickname_WOTag],
					Player[issuerid][TD0_DMG][2],
					aWeaponNames [weaponid],
					sommapHealth);
			}

			PlayerTextDrawSetString(issuerid, TD_Player_Damages[0][2], szl);
			vecchioHit = true;
	    }// if (Player[issuerid][TD0_ID][2] == playerid)

	    if (!vecchioHit && Player[issuerid][TD0_ID][3] == playerid)
	    {
	        Player [issuerid][TD0_DMG][3] += Amount;
	        Player [issuerid][TD0_WEAP][3] = weaponid;
	        Player [issuerid][TD0_HEALTH][3] = sommapHealth;

			stop Player [issuerid][TD0_TIMER][3];
			Player [issuerid][TD0_TIMER][3] = defer HideTextDraw0(issuerid, 3);

			if (sommapHealth > 100) {
			    format (szl, MAX_BLOCCO_STR, "~g~~h~%s~w~ +%d / ~g~~h~%s ~w~(~w~%d~w~)~n~",
			        Player[playerid][Nickname_WOTag],
					Player[issuerid][TD0_DMG][3],
					aWeaponNames [weaponid],
					sommapHealth);
			}
			else
			{
			    format (szl, MAX_BLOCCO_STR, "~g~~h~%s~w~ +%d / ~g~~h~%s ~w~(~r~~h~~h~%d~w~)~n~",
			        Player[playerid][Nickname_WOTag],
					Player[issuerid][TD0_DMG][3],
					aWeaponNames [weaponid],
					sommapHealth);
			}

            PlayerTextDrawSetString(issuerid, TD_Player_Damages[0][3], szl);
			vecchioHit = true;
	    }// if (Player[issuerid][TD0_ID][3] == playerid)

	    if (!vecchioHit && Player[issuerid][TD0_ID][4] == playerid)
	    {
	        Player [issuerid][TD0_DMG][4] += Amount;
	        Player [issuerid][TD0_WEAP][4] = weaponid;
	        Player [issuerid][TD0_HEALTH][4] = sommapHealth;

			stop Player [issuerid][TD0_TIMER][4];
			Player [issuerid][TD0_TIMER][4] = defer HideTextDraw0(issuerid, 4);

			if (sommapHealth > 100) {
			    format (szl, MAX_BLOCCO_STR, "~g~~h~%s~w~ +%d / ~g~~h~%s ~w~(~w~%d~w~)~n~",
			        Player[playerid][Nickname_WOTag],
					Player[issuerid][TD0_DMG][4],
					aWeaponNames [weaponid],
					sommapHealth);
			}
			else
			{
			    format (szl, MAX_BLOCCO_STR, "~g~~h~%s~w~ +%d / ~g~~h~%s ~w~(~r~~h~~h~%d~w~)~n~",
			        Player[playerid][Nickname_WOTag],
					Player[issuerid][TD0_DMG][4],
					aWeaponNames [weaponid],
					sommapHealth);
			}

            PlayerTextDrawSetString(issuerid, TD_Player_Damages[0][4], szl);
			vecchioHit = true;
	    }// if (Player[issuerid][TD0_ID][4] == playerid)

	    if (!vecchioHit)
	    {
	        //
	        // Bisogna aggiungerlo
	        new
	            free_td = searchMostFreeTDN0(issuerid);

			if (free_td != -1)
			{
			    Player[issuerid][TD0_ID][free_td] = playerid;
			    Player[issuerid][TD0_WEAP][free_td] = weaponid;
			    Player[issuerid][TD0_DMG][free_td] = Amount;
			    Player[issuerid][TD0_HEALTH][free_td] = sommapHealth;

				if (sommapHealth > 100) {
				    format (szl, MAX_BLOCCO_STR, "~g~~h~%s~w~ +%d / ~g~~h~%s ~w~(~w~%d~w~)~n~",
				        Player[playerid][Nickname_WOTag],
						Player[issuerid][TD0_DMG][free_td],
						aWeaponNames [weaponid],
						sommapHealth);
				}
				else
				{
				    format (szl, MAX_BLOCCO_STR, "~g~~h~%s~w~ +%d / ~g~~h~%s ~w~(~r~~h~~h~%d~w~)~n~",
				        Player[playerid][Nickname_WOTag],
						Player[issuerid][TD0_DMG][free_td],
						aWeaponNames [weaponid],
						sommapHealth);
				}

				if (Player [issuerid][TD0_TIMER][free_td] != Timer:-1)
					stop Player [issuerid][TD0_TIMER][free_td];

				Player [issuerid][TD0_TIMER][free_td] = defer HideTextDraw0(issuerid, free_td);

				PlayerTextDrawSetString(issuerid, TD_Player_Damages[0][free_td], szl);
				PlayerTextDrawShow(issuerid, TD_Player_Damages[0][free_td]);

			}// if (free_td != -1)
			else
			{
				new
				    tid, tweap, tdmg, thealth, Timer:ttimer,
				    tid2, tweap2, tdmg2, thealth2, Timer:ttimer2;

			    //
				// issuerid non ha dati che riguardano playerid

				//
				// eseguo il solito swap speriamo che ora è ok

				tid = Player[issuerid][TD0_ID][1];
				tweap = Player[issuerid][TD0_WEAP][1];
				tdmg = Player[issuerid][TD0_DMG][1];
				thealth = Player[issuerid][TD0_HEALTH][1];
				ttimer = Player[issuerid][TD0_TIMER][1];

				Player[issuerid][TD0_ID][1] = Player[issuerid][TD0_ID][0];
				Player[issuerid][TD0_WEAP][1] = Player[issuerid][TD0_WEAP][0];
				Player[issuerid][TD0_DMG][1] = Player[issuerid][TD0_DMG][0];
				Player[issuerid][TD0_HEALTH][1] = Player[issuerid][TD0_HEALTH][0];
				Player[issuerid][TD0_TIMER][1] = Player[issuerid][TD0_TIMER][0];

				tid2 = Player[issuerid][TD0_ID][2];
				tweap2 = Player[issuerid][TD0_WEAP][2];
				tdmg2 = Player[issuerid][TD0_DMG][2];
				thealth2 = Player[issuerid][TD0_HEALTH][2];
				ttimer2 = Player[issuerid][TD0_TIMER][2];

				Player[issuerid][TD0_ID][2] = tid;
				Player[issuerid][TD0_WEAP][2] = tweap;
				Player[issuerid][TD0_DMG][2] = tdmg;
				Player[issuerid][TD0_HEALTH][2] = thealth;
				Player[issuerid][TD0_TIMER][2] = ttimer;

				tid = Player[issuerid][TD0_ID][3];
				tweap = Player[issuerid][TD0_WEAP][3];
				tdmg = Player[issuerid][TD0_DMG][3];
				thealth = Player[issuerid][TD0_HEALTH][3];
				ttimer = Player[issuerid][TD0_TIMER][3];

				Player[issuerid][TD0_ID][3] = tid2;
				Player[issuerid][TD0_WEAP][3] = tweap2;
				Player[issuerid][TD0_DMG][3] = tdmg2;
				Player[issuerid][TD0_HEALTH][3] = thealth2;
				Player[issuerid][TD0_TIMER][3] = ttimer2;

				Player[issuerid][TD0_ID][4] = tid;
				Player[issuerid][TD0_WEAP][4] = tweap;
				Player[issuerid][TD0_DMG][4] = tdmg;
				Player[issuerid][TD0_HEALTH][4] = thealth;
				Player[issuerid][TD0_TIMER][4] = ttimer;

				Player[issuerid][TD0_ID][0] = playerid;
				Player[issuerid][TD0_WEAP][0] = weaponid;
				Player[issuerid][TD0_DMG][0] = Amount;
				Player[issuerid][TD0_HEALTH][0] = sommapHealth;

				//canbeimproved

				if (sommapHealth > 100) {
				    format (szl, MAX_BLOCCO_STR, "~g~~h~%s~w~ +%d / ~g~~h~%s ~w~(~w~%d~w~)~n~",
				        Player[playerid][Nickname_WOTag],
						Amount,
						aWeaponNames [weaponid],
						sommapHealth);
				}
				else
				{
				    format (szl, MAX_BLOCCO_STR, "~g~~h~%s~w~ +%d / ~g~~h~%s ~w~(~r~~h~~h~%d~w~)~n~",
				        Player[playerid][Nickname_WOTag],
						Amount,
						aWeaponNames [weaponid],
						sommapHealth);
				}

				if (Player [issuerid][TD0_TIMER][0] != Timer:-1)
					stop Player [issuerid][TD0_TIMER][0];

				Player [issuerid][TD0_TIMER][0] = defer HideTextDraw0(issuerid, 0);

				PlayerTextDrawSetString(issuerid, TD_Player_Damages[0][0], szl);
				PlayerTextDrawShow(issuerid, TD_Player_Damages[0][0]);

				// 1

				if (Player[issuerid][TD0_ID][1] != INVALID_PLAYER_ID)
				{
					if (Player[issuerid][TD0_HEALTH][1] > 100) {
					    format (szl, MAX_BLOCCO_STR, "~g~~h~%s~w~ +%d / ~g~~h~%s ~w~(~w~%d~w~)~n~",
					        Player[Player[issuerid][TD0_ID][1]][Nickname_WOTag],
							Player[issuerid][TD0_DMG][1],
							aWeaponNames [Player[issuerid][TD0_WEAP][1]],
							Player[issuerid][TD0_HEALTH][1]);
					}
					else
					{
					    format (szl, MAX_BLOCCO_STR, "~g~~h~%s~w~ +%d / ~g~~h~%s ~w~(~r~~h~~h~%d~w~)~n~",
					        Player[Player[issuerid][TD0_ID][1]][Nickname_WOTag],
							Player[issuerid][TD0_DMG][1],
							aWeaponNames [Player[issuerid][TD0_WEAP][1]],
							Player[issuerid][TD0_HEALTH][1]);
					}

	                //if (Player [issuerid][TD0_TIMER][1] != Timer:-1)
	                //    stop Player [issuerid][TD0_TIMER][1];

	                //Player [issuerid][TD0_TIMER][1] = defer HideTextDraw0(issuerid, 1);

					PlayerTextDrawSetString(issuerid, TD_Player_Damages[0][1], szl);
					PlayerTextDrawShow(issuerid, TD_Player_Damages[0][1]);

				}

				// 2
				if (Player[issuerid][TD0_ID][2] != INVALID_PLAYER_ID)
				{
					if (Player[issuerid][TD0_HEALTH][2] > 100) {
					    format (szl, MAX_BLOCCO_STR, "~g~~h~%s~w~ +%d / ~g~~h~%s ~w~(~w~%d~w~)~n~",
					        Player[Player[issuerid][TD0_ID][2]][Nickname_WOTag],
							Player[issuerid][TD0_DMG][2],
							aWeaponNames [Player[issuerid][TD0_WEAP][2]],
							Player[issuerid][TD0_HEALTH][2]);
					}
					else
					{
					    format (szl, MAX_BLOCCO_STR, "~g~~h~%s~w~ +%d / ~g~~h~%s ~w~(~r~~h~~h~%d~w~)~n~",
					        Player[Player[issuerid][TD0_ID][2]][Nickname_WOTag],
							Player[issuerid][TD0_DMG][2],
							aWeaponNames [Player[issuerid][TD0_WEAP][2]],
							Player[issuerid][TD0_HEALTH][2]);
					}

	                //if (Player [issuerid][TD0_TIMER][2] != Timer:-1)
	                //    stop Player [issuerid][TD0_TIMER][2];

	                //Player [issuerid][TD0_TIMER][2] = defer HideTextDraw0(issuerid, 2);

					PlayerTextDrawSetString(issuerid, TD_Player_Damages[0][2], szl);
					PlayerTextDrawShow(issuerid, TD_Player_Damages[0][2]);
				}
				// 3
				if (Player[issuerid][TD0_ID][3] != INVALID_PLAYER_ID)
				{
					if (Player[issuerid][TD0_HEALTH][3] > 100) {
					    format (szl, MAX_BLOCCO_STR, "~g~~h~%s~w~ +%d / ~g~~h~%s ~w~(~w~%d~w~)~n~",
					        Player[Player[issuerid][TD0_ID][3]][Nickname_WOTag],
							Player[issuerid][TD0_DMG][3],
							aWeaponNames [Player[issuerid][TD0_WEAP][3]],
							Player[issuerid][TD0_HEALTH][3]);
					}
					else
					{
					    format (szl, MAX_BLOCCO_STR, "~g~~h~%s~w~ +%d / ~g~~h~%s ~w~(~r~~h~~h~%d~w~)~n~",
					        Player[Player[issuerid][TD0_ID][3]][Nickname_WOTag],
							Player[issuerid][TD0_DMG][3],
							aWeaponNames [Player[issuerid][TD0_WEAP][3]],
							Player[issuerid][TD0_HEALTH][3]);
	                }

	                //if (Player [issuerid][TD0_TIMER][3] != Timer:-1)
	                //    stop Player [issuerid][TD0_TIMER][3];

	                //Player [issuerid][TD0_TIMER][3] = defer HideTextDraw0(issuerid, 3);

					PlayerTextDrawSetString(issuerid, TD_Player_Damages[0][3], szl);
					PlayerTextDrawShow(issuerid, TD_Player_Damages[0][3]);
				}

				// 4
				if (Player[issuerid][TD0_ID][4] != INVALID_PLAYER_ID)
				{
					if (Player[issuerid][TD0_HEALTH][4] > 100) {
					    format (szl, MAX_BLOCCO_STR, "~g~~h~%s~w~ +%d / ~g~~h~%s ~w~(~w~%d~w~)~n~",
					        Player[Player[issuerid][TD0_ID][4]][Nickname_WOTag],
							Player[issuerid][TD0_DMG][4],
							aWeaponNames [Player[issuerid][TD0_WEAP][4]],
							Player[issuerid][TD0_HEALTH][4]);
					}
					else
					{
					    format (szl, MAX_BLOCCO_STR, "~g~~h~%s~w~ +%d / ~g~~h~%s ~w~(~r~~h~~h~%d~w~)~n~",
					        Player[Player[issuerid][TD0_ID][4]][Nickname_WOTag],
							Player[issuerid][TD0_DMG][4],
							aWeaponNames [Player[issuerid][TD0_WEAP][4]],
							Player[issuerid][TD0_HEALTH][4]);
					}

	                //if (Player [issuerid][TD0_TIMER][4] != Timer:-1)
	                //    stop Player [issuerid][TD0_TIMER][4];

	                //Player [issuerid][TD0_TIMER][4] = defer HideTextDraw0(issuerid, 4);

					PlayerTextDrawSetString(issuerid, TD_Player_Damages[0][4], szl);
					PlayerTextDrawShow(issuerid, TD_Player_Damages[0][4]);
				}
			}//else of // if (free_td != -1)

	    }// if (!vecchioHit)

	    // ora lo stesso codice per playerid
	    vecchioHit = false;
	    new
	        sommaiHealth = (iHealth+iArmour);

	    // In Questo caso:
	    // issuerid ha hittato playerid

	    // prima cosa:
	    // vedo se il player conosce già il player
	    #define ID_TO_USE 	        			  0
	    if (Player[playerid][TD1_ID][ID_TO_USE] == issuerid)
	    {
	        Player [playerid][TD1_DMG][ID_TO_USE] += Amount;
	        Player [playerid][TD1_WEAP][ID_TO_USE] = weaponid;
	        Player [playerid][TD1_HEALTH][ID_TO_USE] = sommaiHealth;

			stop Player [playerid][TD1_TIMER][ID_TO_USE];
			Player [playerid][TD1_TIMER][ID_TO_USE] = defer HideTextDraw1(playerid, ID_TO_USE);


			if (sommaiHealth > 100) {
			    format (szl, MAX_BLOCCO_STR, "~r~~h~%s~w~ -%d / ~r~~h~%s ~w~(~w~%d~w~)~n~",
			        Player[issuerid][Nickname_WOTag],
					Player[playerid][TD1_DMG][ID_TO_USE],
					aWeaponNames [weaponid],
					sommaiHealth);
			}
			else
			{
			    format (szl, MAX_BLOCCO_STR, "~r~~h~%s~w~ -%d / ~r~~h~%s ~w~(~r~~h~~h~%d~w~)~n~",
			        Player[issuerid][Nickname_WOTag],
					Player[playerid][TD1_DMG][ID_TO_USE],
					aWeaponNames [weaponid],
					sommaiHealth);
			}

			PlayerTextDrawSetString(playerid, TD_Player_Damages[1][ID_TO_USE], szl);


			vecchioHit = true;
	    }// if (Player[issuerid][TD0_ID][0] == playerid)
		#undef ID_TO_USE
		#define ID_TO_USE                           1
	    if (!vecchioHit && Player[playerid][TD1_ID][ID_TO_USE] == issuerid)
	    {


	        Player [playerid][TD1_DMG][ID_TO_USE] += Amount;



	        Player [playerid][TD1_WEAP][ID_TO_USE] = weaponid;
	        Player [playerid][TD1_HEALTH][ID_TO_USE] = sommaiHealth;

			stop Player [playerid][TD1_TIMER][ID_TO_USE];
			Player [playerid][TD1_TIMER][ID_TO_USE] = defer HideTextDraw1(playerid, ID_TO_USE);

			if (sommaiHealth > 100) {
			    format (szl, MAX_BLOCCO_STR, "~r~~h~%s~w~ -%d / ~r~~h~%s ~w~(~w~%d~w~)~n~",
			        Player[issuerid][Nickname_WOTag],
					Player[playerid][TD1_DMG][ID_TO_USE],
					aWeaponNames [weaponid],
					sommaiHealth);
			}
			else
			{
			    format (szl, MAX_BLOCCO_STR, "~r~~h~%s~w~ -%d / ~r~~h~%s ~w~(~r~~h~~h~%d~w~)~n~",
			        Player[issuerid][Nickname_WOTag],
					Player[playerid][TD1_DMG][ID_TO_USE],
					aWeaponNames [weaponid],
					sommaiHealth);
			}

			PlayerTextDrawSetString(playerid, TD_Player_Damages[1][ID_TO_USE], szl);


			vecchioHit = true;
	    }// if (Player[issuerid][TD0_ID][ID_TO_USE] == playerid)
		#undef ID_TO_USE
		#define ID_TO_USE                           2
	    if (!vecchioHit && Player[playerid][TD1_ID][ID_TO_USE] == issuerid)
	    {


	        Player [playerid][TD1_DMG][ID_TO_USE] += Amount;



	        Player [playerid][TD1_WEAP][ID_TO_USE] = weaponid;
	        Player [playerid][TD1_HEALTH][ID_TO_USE] = sommaiHealth;

			stop Player [playerid][TD1_TIMER][ID_TO_USE];
			Player [playerid][TD1_TIMER][ID_TO_USE] = defer HideTextDraw1(playerid, ID_TO_USE);

			if (sommaiHealth > 100) {
			    format (szl, MAX_BLOCCO_STR, "~r~~h~%s~w~ -%d / ~r~~h~%s ~w~(~w~%d~w~)~n~",
			        Player[issuerid][Nickname_WOTag],
					Player[playerid][TD1_DMG][ID_TO_USE],
					aWeaponNames [weaponid],
					sommaiHealth);
			}
			else
			{
			    format (szl, MAX_BLOCCO_STR, "~r~~h~%s~w~ -%d / ~r~~h~%s ~w~(~r~~h~~h~%d~w~)~n~",
			        Player[issuerid][Nickname_WOTag],
					Player[playerid][TD1_DMG][ID_TO_USE],
					aWeaponNames [weaponid],
					sommaiHealth);
			}

			PlayerTextDrawSetString(playerid, TD_Player_Damages[1][ID_TO_USE], szl);


			vecchioHit = true;
	    }// if (Player[issuerid][TD0_ID][ID_TO_USE] == playerid)
		#undef ID_TO_USE
		#define ID_TO_USE                           3
	    if (!vecchioHit && Player[playerid][TD1_ID][ID_TO_USE] == issuerid)
	    {


	        Player [playerid][TD1_DMG][ID_TO_USE] += Amount;



	        Player [playerid][TD1_WEAP][ID_TO_USE] = weaponid;
	        Player [playerid][TD1_HEALTH][ID_TO_USE] = sommaiHealth;

			stop Player [playerid][TD1_TIMER][ID_TO_USE];
			Player [playerid][TD1_TIMER][ID_TO_USE] = defer HideTextDraw1(playerid, ID_TO_USE);

			if (sommaiHealth > 100) {
			    format (szl, MAX_BLOCCO_STR, "~r~~h~%s~w~ -%d / ~r~~h~%s ~w~(~w~%d~w~)~n~",
			        Player[issuerid][Nickname_WOTag],
					Player[playerid][TD1_DMG][ID_TO_USE],
					aWeaponNames [weaponid],
					sommaiHealth);
			}
			else
			{
			    format (szl, MAX_BLOCCO_STR, "~r~~h~%s~w~ -%d / ~r~~h~%s ~w~(~r~~h~~h~%d~w~)~n~",
			        Player[issuerid][Nickname_WOTag],
					Player[playerid][TD1_DMG][ID_TO_USE],
					aWeaponNames [weaponid],
					sommaiHealth);
			}

			PlayerTextDrawSetString(playerid, TD_Player_Damages[1][ID_TO_USE], szl);


			vecchioHit = true;
	    }// if (Player[issuerid][TD0_ID][ID_TO_USE] == playerid)
		#undef ID_TO_USE
		#define ID_TO_USE                           4
	    if (!vecchioHit && Player[playerid][TD1_ID][ID_TO_USE] == issuerid)
	    {


	        Player [playerid][TD1_DMG][ID_TO_USE] += Amount;



	        Player [playerid][TD1_WEAP][ID_TO_USE] = weaponid;
	        Player [playerid][TD1_HEALTH][ID_TO_USE] = sommaiHealth;

			stop Player [playerid][TD1_TIMER][ID_TO_USE];
			Player [playerid][TD1_TIMER][ID_TO_USE] = defer HideTextDraw1(playerid, ID_TO_USE);

			if (sommaiHealth > 100) {
			    format (szl, MAX_BLOCCO_STR, "~r~~h~%s~w~ -%d / ~r~~h~%s ~w~(~w~%d~w~)~n~",
			        Player[issuerid][Nickname_WOTag],
					Player[playerid][TD1_DMG][ID_TO_USE],
					aWeaponNames [weaponid],
					sommaiHealth);
			}
			else
			{
			    format (szl, MAX_BLOCCO_STR, "~r~~h~%s~w~ -%d / ~r~~h~%s ~w~(~r~~h~~h~%d~w~)~n~",
			        Player[issuerid][Nickname_WOTag],
					Player[playerid][TD1_DMG][ID_TO_USE],
					aWeaponNames [weaponid],
					sommaiHealth);
			}

			PlayerTextDrawSetString(playerid, TD_Player_Damages[1][ID_TO_USE], szl);


			vecchioHit = true;
	    }// if (Player[issuerid][TD0_ID][ID_TO_USE] == playerid)

	    if (!vecchioHit)
	    {
	        //
	        // Bisogna aggiungerlo
	        new
	            free_td = searchMostFreeTDN1(playerid);

			if (free_td != -1)
			{
			    Player[playerid][TD1_ID][free_td] = issuerid;
			    Player[playerid][TD1_WEAP][free_td] = weaponid;
			    Player[playerid][TD1_DMG][free_td] = Amount;
			    Player[playerid][TD1_HEALTH][free_td] = sommaiHealth;

				if (sommaiHealth > 100) {
				    format (szl, MAX_BLOCCO_STR, "~r~~h~%s~w~ -%d / ~r~~h~%s ~w~(~w~%d~w~)~n~",
				        Player[issuerid][Nickname_WOTag],
						Player[playerid][TD1_DMG][free_td],
						aWeaponNames [weaponid],
						sommaiHealth);
				}
				else
				{
				    format (szl, MAX_BLOCCO_STR, "~r~~h~%s~w~ -%d / ~r~~h~%s ~w~(~r~~h~~h~%d~w~)~n~",
				        Player[issuerid][Nickname_WOTag],
						Player[playerid][TD1_DMG][free_td],
						aWeaponNames [weaponid],
						sommaiHealth);
				}

				if (Player [playerid][TD1_TIMER][free_td] != Timer:-1)
					stop Player [playerid][TD1_TIMER][free_td];

				Player [playerid][TD1_TIMER][free_td] = defer HideTextDraw1(playerid, free_td);

				PlayerTextDrawSetString(playerid, TD_Player_Damages[1][free_td], szl);
				PlayerTextDrawShow(playerid, TD_Player_Damages[1][free_td]);

			}// if (free_td != -1)
			else
			{
			    //playerid

				new
				    tid, tweap, tdmg, thealth, Timer:ttimer,
				    tid2, tweap2, tdmg2, thealth2, Timer:ttimer2;

			    //
				// issuerid non ha dati che riguardano playerid

				//
				// eseguo il solito swap speriamo che ora è ok

				tid = Player[playerid][TD1_ID][1];
				tweap = Player[playerid][TD1_WEAP][1];
				tdmg = Player[playerid][TD1_DMG][1];
				thealth = Player[playerid][TD1_HEALTH][1];
				ttimer = Player[playerid][TD1_TIMER][1];

				Player[playerid][TD1_ID][1] = Player[playerid][TD1_ID][0];
				Player[playerid][TD1_WEAP][1] = Player[playerid][TD1_WEAP][0];
				Player[playerid][TD1_DMG][1] = Player[playerid][TD1_DMG][0];
				Player[playerid][TD1_HEALTH][1] = Player[playerid][TD1_HEALTH][0];
				Player[playerid][TD1_TIMER][1] = Player[playerid][TD1_TIMER][0];

				tid2 = Player[playerid][TD1_ID][2];
				tweap2 = Player[playerid][TD1_WEAP][2];
				tdmg2 = Player[playerid][TD1_DMG][2];
				thealth2 = Player[playerid][TD1_HEALTH][2];
				ttimer2 = Player[playerid][TD1_TIMER][2];

				Player[playerid][TD1_ID][2] = tid;
				Player[playerid][TD1_WEAP][2] = tweap;
				Player[playerid][TD1_DMG][2] = tdmg;
				Player[playerid][TD1_HEALTH][2] = thealth;
				Player[playerid][TD1_TIMER][2] = ttimer;

				tid = Player[playerid][TD1_ID][3];
				tweap = Player[playerid][TD1_WEAP][3];
				tdmg = Player[playerid][TD1_DMG][3];
				thealth = Player[playerid][TD1_HEALTH][3];
				ttimer = Player[playerid][TD1_TIMER][3];

				Player[playerid][TD1_ID][3] = tid2;
				Player[playerid][TD1_WEAP][3] = tweap2;
				Player[playerid][TD1_DMG][3] = tdmg2;
				Player[playerid][TD1_HEALTH][3] = thealth2;
				Player[playerid][TD1_TIMER][3] = ttimer2;

				Player[playerid][TD1_ID][4] = tid;
				Player[playerid][TD1_WEAP][4] = tweap;
				Player[playerid][TD1_DMG][4] = tdmg;
				Player[playerid][TD1_HEALTH][4] = thealth;
				Player[playerid][TD1_TIMER][4] = ttimer;

				Player[playerid][TD1_ID][0] = issuerid;
				Player[playerid][TD1_WEAP][0] = weaponid;
				Player[playerid][TD1_DMG][0] = Amount;
				Player[playerid][TD1_HEALTH][0] = sommaiHealth;

				//canbeimproved

				if (sommaiHealth > 100) {
				    format (szl, MAX_BLOCCO_STR, "~r~~h~%s~w~ -%d / ~r~~h~%s ~w~(~w~%d~w~)~n~",
				        Player[issuerid][Nickname_WOTag],
						Amount,
						aWeaponNames [weaponid],
						sommaiHealth);
				}
				else
				{
				    format (szl, MAX_BLOCCO_STR, "~r~~h~%s~w~ -%d / ~r~~h~%s ~w~(~r~~h~~h~%d~w~)~n~",
				        Player[issuerid][Nickname_WOTag],
						Amount,
						aWeaponNames [weaponid],
						sommaiHealth);
				}

				if (Player [playerid][TD1_TIMER][0] != Timer:-1)
					stop Player [playerid][TD1_TIMER][0];

				Player [playerid][TD1_TIMER][0] = defer HideTextDraw1(playerid, 0);

				PlayerTextDrawSetString(playerid, TD_Player_Damages[1][0], szl);
				PlayerTextDrawShow(playerid, TD_Player_Damages[1][0]);

				// 1

				if (Player[playerid][TD1_ID][1] != INVALID_PLAYER_ID)
				{
					if (Player[playerid][TD1_HEALTH][1] > 100) {
					    format (szl, MAX_BLOCCO_STR, "~r~~h~%s~w~ -%d / ~r~~h~%s ~w~(~w~%d~w~)~n~",
					        Player[Player[playerid][TD1_ID][1]][Nickname_WOTag],
							Player[playerid][TD1_DMG][1],
							aWeaponNames [Player[playerid][TD1_WEAP][1]],
							Player[playerid][TD1_HEALTH][1]);
					}
					else
					{
					    format (szl, MAX_BLOCCO_STR, "~r~~h~%s~w~ -%d / ~r~~h~%s ~w~(~r~~h~~h~%d~w~)~n~",
					        Player[Player[playerid][TD1_ID][1]][Nickname_WOTag],
							Player[playerid][TD1_DMG][1],
							aWeaponNames [Player[playerid][TD1_WEAP][1]],
							Player[playerid][TD1_HEALTH][1]);
					}

	                //if (Player [issuerid][TD0_TIMER][1] != Timer:-1)
	                //    stop Player [issuerid][TD0_TIMER][1];

	                //Player [issuerid][TD0_TIMER][1] = defer HideTextDraw0(issuerid, 1);

					PlayerTextDrawSetString(playerid, TD_Player_Damages[1][1], szl);
					PlayerTextDrawShow(playerid, TD_Player_Damages[1][1]);

				}

				// 2
				if (Player[playerid][TD1_ID][2] != INVALID_PLAYER_ID)
				{
					if (Player[playerid][TD1_HEALTH][2] > 100) {
					    format (szl, MAX_BLOCCO_STR, "~r~~h~%s~w~ -%d / ~r~~h~%s ~w~(~w~%d~w~)~n~",
					        Player[Player[playerid][TD1_ID][2]][Nickname_WOTag],
							Player[playerid][TD1_DMG][2],
							aWeaponNames [Player[playerid][TD1_WEAP][2]],
							Player[playerid][TD1_HEALTH][2]);
					}
					else
					{
					    format (szl, MAX_BLOCCO_STR, "~r~~h~%s~w~ -%d / ~r~~h~%s ~w~(~r~~h~~h~%d~w~)~n~",
					        Player[Player[playerid][TD1_ID][2]][Nickname_WOTag],
							Player[playerid][TD1_DMG][2],
							aWeaponNames [Player[playerid][TD1_WEAP][2]],
							Player[playerid][TD1_HEALTH][2]);
					}

	                //if (Player [issuerid][TD0_TIMER][2] != Timer:-1)
	                //    stop Player [issuerid][TD0_TIMER][2];

	                //Player [issuerid][TD0_TIMER][2] = defer HideTextDraw0(issuerid, 2);

					PlayerTextDrawSetString(playerid, TD_Player_Damages[1][2], szl);
					PlayerTextDrawShow(playerid, TD_Player_Damages[1][2]);
				}
				// 3
				if (Player[playerid][TD1_ID][3] != INVALID_PLAYER_ID)
				{
					if (Player[playerid][TD1_HEALTH][3] > 100) {
					    format (szl, MAX_BLOCCO_STR, "~r~~h~%s~w~ -%d / ~r~~h~%s ~w~(~w~%d~w~)~n~",
					        Player[Player[playerid][TD1_ID][3]][Nickname_WOTag],
							Player[playerid][TD1_DMG][3],
							aWeaponNames [Player[playerid][TD1_WEAP][3]],
							Player[playerid][TD1_HEALTH][3]);
					}
					else
					{
					    format (szl, MAX_BLOCCO_STR, "~r~~h~%s~w~ -%d / ~r~~h~%s ~w~(~r~~h~~h~%d~w~)~n~",
					        Player[Player[playerid][TD1_ID][3]][Nickname_WOTag],
							Player[playerid][TD1_DMG][3],
							aWeaponNames [Player[playerid][TD1_WEAP][3]],
							Player[playerid][TD1_HEALTH][3]);
	                }

	                //if (Player [issuerid][TD0_TIMER][3] != Timer:-1)
	                //    stop Player [issuerid][TD0_TIMER][3];

	                //Player [issuerid][TD0_TIMER][3] = defer HideTextDraw0(issuerid, 3);

					PlayerTextDrawSetString(playerid, TD_Player_Damages[1][3], szl);
					PlayerTextDrawShow(playerid, TD_Player_Damages[1][3]);
				}

				// 4
				if (Player[playerid][TD1_ID][4] != INVALID_PLAYER_ID)
				{
					if (Player[playerid][TD1_HEALTH][4] > 100) {
					    format (szl, MAX_BLOCCO_STR, "~r~~h~%s~w~ -%d / ~r~~h~%s ~w~(~w~%d~w~)~n~",
					        Player[Player[playerid][TD1_ID][4]][Nickname_WOTag],
							Player[playerid][TD1_DMG][4],
							aWeaponNames [Player[playerid][TD1_WEAP][4]],
							Player[playerid][TD1_HEALTH][4]);
					}
					else
					{
					    format (szl, MAX_BLOCCO_STR, "~r~~h~%s~w~ -%d / ~r~~h~%s ~w~(~r~~h~~h~%d~w~)~n~",
					        Player[Player[playerid][TD1_ID][4]][Nickname_WOTag],
							Player[playerid][TD1_DMG][4],
							aWeaponNames [Player[playerid][TD1_WEAP][4]],
							Player[playerid][TD1_HEALTH][4]);
					}

	                //if (Player [issuerid][TD0_TIMER][4] != Timer:-1)
	                //    stop Player [issuerid][TD0_TIMER][4];

	                //Player [issuerid][TD0_TIMER][4] = defer HideTextDraw0(issuerid, 4);

					PlayerTextDrawSetString(playerid, TD_Player_Damages[1][4], szl);
					PlayerTextDrawShow(playerid, TD_Player_Damages[1][4]);
				}
			}//else of // if (free_td != -1)

	    }// if (!vecchioHit)
	} // (issuerid != INVALID_PLAYER_ID)
	else
	{
	    #undef ID_TO_USE
	    #define ID_TO_USE 	        			  0
	    if (Player[playerid][TD1_ID][ID_TO_USE] == COLLISION_ID)
	    {
	        Player [playerid][TD1_DMG][ID_TO_USE] += Amount;

	        Player [playerid][TD1_WEAP][ID_TO_USE] = weaponid;
	        Player [playerid][TD1_HEALTH][ID_TO_USE] = sommapHealth;

			stop Player [playerid][TD1_TIMER][ID_TO_USE];
			Player [playerid][TD1_TIMER][ID_TO_USE] = defer HideTextDraw1(playerid, ID_TO_USE);


			if (sommapHealth > 100) {
			    format (szl, MAX_BLOCCO_STR, "~r~~h~Collision~w~ -%d ~w~(~w~%d~w~)~n~",
					Player[playerid][TD1_DMG][ID_TO_USE],
					sommapHealth);
			}
			else
			{
			    format (szl, MAX_BLOCCO_STR, "~r~~h~Collision~w~ -%d ~w~(~r~~h~~h~%d~w~)~n~",
					Player[playerid][TD1_DMG][ID_TO_USE],
					sommapHealth);
			}

			PlayerTextDrawSetString(playerid, TD_Player_Damages[1][ID_TO_USE], szl);


			vecchioHit = true;
	    }// if (Player[issuerid][TD0_ID][0] == playerid)
		#undef ID_TO_USE
		#define ID_TO_USE                           1
	    if (!vecchioHit && Player[playerid][TD1_ID][ID_TO_USE] == COLLISION_ID)
	    {
	        Player [playerid][TD1_DMG][ID_TO_USE] += Amount;

	        Player [playerid][TD1_WEAP][ID_TO_USE] = weaponid;
	        Player [playerid][TD1_HEALTH][ID_TO_USE] = sommapHealth;

			stop Player [playerid][TD1_TIMER][ID_TO_USE];
			Player [playerid][TD1_TIMER][ID_TO_USE] = defer HideTextDraw1(playerid, ID_TO_USE);

			if (sommapHealth > 100) {
			    format (szl, MAX_BLOCCO_STR, "~r~~h~Collision~w~ -%d ~w~(~w~%d~w~)~n~",
					Player[playerid][TD1_DMG][ID_TO_USE],
					sommapHealth);
			}
			else
			{
			    format (szl, MAX_BLOCCO_STR, "~r~~h~Collision~w~ -%d ~w~(~r~~h~~h~%d~w~)~n~",
					Player[playerid][TD1_DMG][ID_TO_USE],
					sommapHealth);
			}

			PlayerTextDrawSetString(playerid, TD_Player_Damages[1][ID_TO_USE], szl);


			vecchioHit = true;
	    }// if (Player[issuerid][TD0_ID][ID_TO_USE] == playerid)
		#undef ID_TO_USE
		#define ID_TO_USE                           2
	    if (!vecchioHit && Player[playerid][TD1_ID][ID_TO_USE] == COLLISION_ID)
	    {
	        Player [playerid][TD1_DMG][ID_TO_USE] += Amount;

	        Player [playerid][TD1_WEAP][ID_TO_USE] = weaponid;
	        Player [playerid][TD1_HEALTH][ID_TO_USE] = sommapHealth;

			stop Player [playerid][TD1_TIMER][ID_TO_USE];
			Player [playerid][TD1_TIMER][ID_TO_USE] = defer HideTextDraw1(playerid, ID_TO_USE);

			if (sommapHealth > 100) {
			    format (szl, MAX_BLOCCO_STR, "~r~~h~Collision~w~ -%d ~w~(~w~%d~w~)~n~",
					Player[playerid][TD1_DMG][ID_TO_USE],
					sommapHealth);
			}
			else
			{
			    format (szl, MAX_BLOCCO_STR, "~r~~h~Collision~w~ -%d ~w~(~r~~h~~h~%d~w~)~n~",
					Player[playerid][TD1_DMG][ID_TO_USE],
					sommapHealth);
			}

			PlayerTextDrawSetString(playerid, TD_Player_Damages[1][ID_TO_USE], szl);


			vecchioHit = true;
	    }// if (Player[issuerid][TD0_ID][ID_TO_USE] == playerid)
		#undef ID_TO_USE
		#define ID_TO_USE                           3
	    if (!vecchioHit && Player[playerid][TD1_ID][ID_TO_USE] == COLLISION_ID)
	    {

	        Player [playerid][TD1_DMG][ID_TO_USE] += Amount;

	        Player [playerid][TD1_WEAP][ID_TO_USE] = weaponid;
	        Player [playerid][TD1_HEALTH][ID_TO_USE] = sommapHealth;

			stop Player [playerid][TD1_TIMER][ID_TO_USE];
			Player [playerid][TD1_TIMER][ID_TO_USE] = defer HideTextDraw1(playerid, ID_TO_USE);

			if (sommapHealth > 100) {
			    format (szl, MAX_BLOCCO_STR, "~r~~h~Collision~w~ -%d ~w~(~w~%d~w~)~n~",
					Player[playerid][TD1_DMG][ID_TO_USE],
					sommapHealth);
			}
			else
			{
			    format (szl, MAX_BLOCCO_STR, "~r~~h~Collision~w~ -%d ~w~(~r~~h~~h~%d~w~)~n~",
					Player[playerid][TD1_DMG][ID_TO_USE],
					sommapHealth);
			}

			PlayerTextDrawSetString(playerid, TD_Player_Damages[1][ID_TO_USE], szl);


			vecchioHit = true;
	    }// if (Player[issuerid][TD0_ID][ID_TO_USE] == playerid)
		#undef ID_TO_USE
		#define ID_TO_USE                           4
	    if (!vecchioHit && Player[playerid][TD1_ID][ID_TO_USE] == COLLISION_ID)
	    {

	        Player [playerid][TD1_DMG][ID_TO_USE] += Amount;


	        Player [playerid][TD1_WEAP][ID_TO_USE] = weaponid;
	        Player [playerid][TD1_HEALTH][ID_TO_USE] = sommapHealth;

			stop Player [playerid][TD1_TIMER][ID_TO_USE];
			Player [playerid][TD1_TIMER][ID_TO_USE] = defer HideTextDraw1(playerid, ID_TO_USE);

			if (sommapHealth > 100) {
			    format (szl, MAX_BLOCCO_STR, "~r~~h~Collision~w~ -%d / ~w~(~w~%d~w~)~n~",
					Player[playerid][TD1_DMG][ID_TO_USE],
					sommapHealth);
			}
			else
			{
			    format (szl, MAX_BLOCCO_STR, "~r~~h~Collision~w~ -%d / ~w~(~r~~h~~h~%d~w~)~n~",
					Player[playerid][TD1_DMG][ID_TO_USE],
					sommapHealth);
			}

			PlayerTextDrawSetString(playerid, TD_Player_Damages[1][ID_TO_USE], szl);


			vecchioHit = true;
	    }// if (Player[issuerid][TD0_ID][ID_TO_USE] == playerid)

	    if (!vecchioHit)
	    {
	        //
	        // Bisogna aggiungerlo
	        new
	            free_td = searchMostFreeTDN1(playerid);

			if (free_td != -1)
			{

			    Player[playerid][TD1_ID][free_td] = COLLISION_ID;
			    Player[playerid][TD1_WEAP][free_td] = weaponid;
			    Player[playerid][TD1_DMG][free_td] = Amount;
			    Player[playerid][TD1_HEALTH][free_td] = sommapHealth;

				if (sommapHealth > 100) {
				    format (szl, MAX_BLOCCO_STR, "~r~~h~Collision~w~ -%d ~w~(~w~%d~w~)~n~",
						Player[playerid][TD1_DMG][free_td],
						sommapHealth);
				}
				else
				{
				    format (szl, MAX_BLOCCO_STR, "~r~~h~Collision~w~ -%d ~w~(~r~~h~~h~%d~w~)~n~",
						Player[playerid][TD1_DMG][free_td],
						sommapHealth);
				}

				if (Player [playerid][TD1_TIMER][free_td] != Timer:-1)
					stop Player [playerid][TD1_TIMER][free_td];

				Player [playerid][TD1_TIMER][free_td] = defer HideTextDraw1(playerid, free_td);

				PlayerTextDrawSetString(playerid, TD_Player_Damages[1][free_td], szl);
				PlayerTextDrawShow(playerid, TD_Player_Damages[1][free_td]);

			}// if (free_td != -1)
			else
			{

			    //playerid

				new
				    tid, tweap, tdmg, thealth, Timer:ttimer,
				    tid2, tweap2, tdmg2, thealth2, Timer:ttimer2;

			    //
				// issuerid non ha dati che riguardano playerid

				//
				// eseguo il solito swap speriamo che ora è ok

				tid = Player[playerid][TD1_ID][1];
				tweap = Player[playerid][TD1_WEAP][1];
				tdmg = Player[playerid][TD1_DMG][1];
				thealth = Player[playerid][TD1_HEALTH][1];
				ttimer = Player[playerid][TD1_TIMER][1];

				Player[playerid][TD1_ID][1] = Player[playerid][TD1_ID][0];
				Player[playerid][TD1_WEAP][1] = Player[playerid][TD1_WEAP][0];
				Player[playerid][TD1_DMG][1] = Player[playerid][TD1_DMG][0];
				Player[playerid][TD1_HEALTH][1] = Player[playerid][TD1_HEALTH][0];
				Player[playerid][TD1_TIMER][1] = Player[playerid][TD1_TIMER][0];

				tid2 = Player[playerid][TD1_ID][2];
				tweap2 = Player[playerid][TD1_WEAP][2];
				tdmg2 = Player[playerid][TD1_DMG][2];
				thealth2 = Player[playerid][TD1_HEALTH][2];
				ttimer2 = Player[playerid][TD1_TIMER][2];

				Player[playerid][TD1_ID][2] = tid;
				Player[playerid][TD1_WEAP][2] = tweap;
				Player[playerid][TD1_DMG][2] = tdmg;
				Player[playerid][TD1_HEALTH][2] = thealth;
				Player[playerid][TD1_TIMER][2] = ttimer;

				tid = Player[playerid][TD1_ID][3];
				tweap = Player[playerid][TD1_WEAP][3];
				tdmg = Player[playerid][TD1_DMG][3];
				thealth = Player[playerid][TD1_HEALTH][3];
				ttimer = Player[playerid][TD1_TIMER][3];

				Player[playerid][TD1_ID][3] = tid2;
				Player[playerid][TD1_WEAP][3] = tweap2;
				Player[playerid][TD1_DMG][3] = tdmg2;
				Player[playerid][TD1_HEALTH][3] = thealth2;
				Player[playerid][TD1_TIMER][3] = ttimer2;

				Player[playerid][TD1_ID][4] = tid;
				Player[playerid][TD1_WEAP][4] = tweap;
				Player[playerid][TD1_DMG][4] = tdmg;
				Player[playerid][TD1_HEALTH][4] = thealth;
				Player[playerid][TD1_TIMER][4] = ttimer;

				Player[playerid][TD1_ID][0] = COLLISION_ID;
				Player[playerid][TD1_WEAP][0] = weaponid;
				Player[playerid][TD1_DMG][0] = Amount;
				Player[playerid][TD1_HEALTH][0] = sommapHealth;

				//canbeimproved
				//già so che 0 è collision_id
				if (Player[playerid][TD1_HEALTH][0] > 100) {
				    format (szl, MAX_BLOCCO_STR, "~r~~h~Collision~w~ -%d / ~w~(~w~%d~w~)~n~",
						Amount,
						aWeaponNames [weaponid],
						sommapHealth);
				}
				else
				{
				    format (szl, MAX_BLOCCO_STR, "~r~~h~Collision~w~ -%d ~w~(~r~~h~~h~%d~w~)~n~",
						aWeaponNames [weaponid],
						sommapHealth);
				}

				if (Player [playerid][TD1_TIMER][0] != Timer:-1)
					stop Player [playerid][TD1_TIMER][0];

				Player [playerid][TD1_TIMER][0] = defer HideTextDraw1(playerid, 0);

				PlayerTextDrawSetString(playerid, TD_Player_Damages[1][0], szl);
				PlayerTextDrawShow(playerid, TD_Player_Damages[1][0]);

				// 1

				if (Player[playerid][TD1_ID][1] != INVALID_PLAYER_ID)
				{
				    if (Player[playerid][TD1_ID][1] != COLLISION_ID)
				    {
						if (Player[playerid][TD1_HEALTH][1] > 100) {
						    format (szl, MAX_BLOCCO_STR, "~r~~h~%s~w~ -%d / ~r~~h~%s ~w~(~w~%d~w~)~n~",
						        Player[Player[playerid][TD1_ID][1]][Nickname_WOTag],
								Player[playerid][TD1_DMG][1],
								aWeaponNames [Player[playerid][TD1_WEAP][1]],
								Player[playerid][TD1_HEALTH][1]);
						}
						else
						{
						    format (szl, MAX_BLOCCO_STR, "~r~~h~%s~w~ -%d / ~r~~h~%s ~w~(~r~~h~~h~%d~w~)~n~",
						        Player[Player[playerid][TD1_ID][1]][Nickname_WOTag],
								Player[playerid][TD1_DMG][1],
								aWeaponNames [Player[playerid][TD1_WEAP][1]],
								Player[playerid][TD1_HEALTH][1]);
						}
					}
					else
					{
						if (Player[playerid][TD1_HEALTH][1] > 100) {
						    format (szl, MAX_BLOCCO_STR, "~r~~h~Collision~w~ -%d ~w~(~w~%d~w~)~n~",
								Player[playerid][TD1_DMG][1],
								Player[playerid][TD1_HEALTH][1]);
						}
						else
						{
						    format (szl, MAX_BLOCCO_STR, "~r~~h~Collision~w~ -%d ~w~(~r~~h~~h~%d~w~)~n~",
								Player[playerid][TD1_DMG][1],
								Player[playerid][TD1_HEALTH][1]);
						}
					}

	                //if (Player [issuerid][TD0_TIMER][1] != Timer:-1)
	                //    stop Player [issuerid][TD0_TIMER][1];

	                //Player [issuerid][TD0_TIMER][1] = defer HideTextDraw0(issuerid, 1);

					PlayerTextDrawSetString(playerid, TD_Player_Damages[1][1], szl);
					PlayerTextDrawShow(playerid, TD_Player_Damages[1][1]);

				}

				// 2
				if (Player[playerid][TD1_ID][2] != INVALID_PLAYER_ID)
				{
				    if (Player[playerid][TD1_ID][2] != COLLISION_ID)
				    {
						if (Player[playerid][TD1_HEALTH][2] > 100) {
						    format (szl, MAX_BLOCCO_STR, "~r~~h~%s~w~ -%d / ~w~(~w~%d~w~)~n~",
						        Player[Player[playerid][TD1_ID][2]][Nickname_WOTag],
								Player[playerid][TD1_DMG][2],
								Player[playerid][TD1_HEALTH][2]);
						}
						else
						{
						    format (szl, MAX_BLOCCO_STR, "~r~~h~%s~w~ -%d / ~w~(~r~~h~~h~%d~w~)~n~",
						        Player[Player[playerid][TD1_ID][2]][Nickname_WOTag],
								Player[playerid][TD1_DMG][2],
								Player[playerid][TD1_HEALTH][2]);
						}
					}
					else
					{
						if (Player[playerid][TD1_HEALTH][2] > 100) {
						    format (szl, MAX_BLOCCO_STR, "~r~~h~Collision~w~ -%d ~w~(~w~%d~w~)~n~",
								Player[playerid][TD1_DMG][2],
								Player[playerid][TD1_HEALTH][2]);
						}
						else
						{
						    format (szl, MAX_BLOCCO_STR, "~r~~h~Collision~w~ -%d ~w~(~r~~h~~h~%d~w~)~n~",
								Player[playerid][TD1_DMG][2],
								Player[playerid][TD1_HEALTH][2]);
						}
					}

	                //if (Player [issuerid][TD0_TIMER][2] != Timer:-1)
	                //    stop Player [issuerid][TD0_TIMER][2];

	                //Player [issuerid][TD0_TIMER][2] = defer HideTextDraw0(issuerid, 2);

					PlayerTextDrawSetString(playerid, TD_Player_Damages[1][2], szl);
					PlayerTextDrawShow(playerid, TD_Player_Damages[1][2]);
				}
				// 3
				if (Player[playerid][TD1_ID][3] != INVALID_PLAYER_ID)
				{
				    if (Player[playerid][TD1_ID][3] != COLLISION_ID)
				    {
						if (Player[playerid][TD1_HEALTH][3] > 100) {
						    format (szl, MAX_BLOCCO_STR, "~r~~h~%s~w~ -%d / ~r~~h~%s ~w~(~w~%d~w~)~n~",
						        Player[Player[playerid][TD1_ID][3]][Nickname_WOTag],
								Player[playerid][TD1_DMG][3],
								aWeaponNames [Player[playerid][TD1_WEAP][3]],
								Player[playerid][TD1_HEALTH][3]);
						}
						else
						{
						    format (szl, MAX_BLOCCO_STR, "~r~~h~%s~w~ -%d / ~r~~h~%s ~w~(~r~~h~~h~%d~w~)~n~",
						        Player[Player[playerid][TD1_ID][3]][Nickname_WOTag],
								Player[playerid][TD1_DMG][3],
								aWeaponNames [Player[playerid][TD1_WEAP][3]],
								Player[playerid][TD1_HEALTH][3]);
		                }
					}
					else
					{
						if (Player[playerid][TD1_HEALTH][3] > 100) {
						    format (szl, MAX_BLOCCO_STR, "~r~~h~Collision~w~ -%d ~w~(~w~%d~w~)~n~",
								Player[playerid][TD1_DMG][3],
								Player[playerid][TD1_HEALTH][3]);
						}
						else
						{
						    format (szl, MAX_BLOCCO_STR, "~r~~h~Collision~w~ -%d ~w~(~r~~h~~h~%d~w~)~n~",
								Player[playerid][TD1_DMG][3],
								Player[playerid][TD1_HEALTH][3]);
		                }
	                }

	                //if (Player [issuerid][TD0_TIMER][3] != Timer:-1)
	                //    stop Player [issuerid][TD0_TIMER][3];

	                //Player [issuerid][TD0_TIMER][3] = defer HideTextDraw0(issuerid, 3);

					PlayerTextDrawSetString(playerid, TD_Player_Damages[1][3], szl);
					PlayerTextDrawShow(playerid, TD_Player_Damages[1][3]);
				}

				// 4
				if (Player[playerid][TD1_ID][4] != INVALID_PLAYER_ID)
				{
				    if (Player[playerid][TD1_ID][4] != COLLISION_ID)
				    {
						if (Player[playerid][TD1_HEALTH][4] > 100) {
						    format (szl, MAX_BLOCCO_STR, "~r~~h~%s~w~ -%d / ~r~~h~%s ~w~(~w~%d~w~)~n~",
						        Player[Player[playerid][TD1_ID][4]][Nickname_WOTag],
								Player[playerid][TD1_DMG][4],
								aWeaponNames [Player[playerid][TD1_WEAP][4]],
								Player[playerid][TD1_HEALTH][4]);
						}
						else
						{
						    format (szl, MAX_BLOCCO_STR, "~r~~h~%s~w~ -%d / ~r~~h~%s ~w~(~r~~h~~h~%d~w~)~n~",
						        Player[Player[playerid][TD1_ID][4]][Nickname_WOTag],
								Player[playerid][TD1_DMG][4],
								aWeaponNames [Player[playerid][TD1_WEAP][4]],
								Player[playerid][TD1_HEALTH][4]);
						}
					}
					else
					{
						if (Player[playerid][TD1_HEALTH][4] > 100) {
						    format (szl, MAX_BLOCCO_STR, "~r~~h~Collision~w~ -%d ~w~(~w~%d~w~)~n~",
								Player[playerid][TD1_DMG][4],
								Player[playerid][TD1_HEALTH][4]);
						}
						else
						{
						    format (szl, MAX_BLOCCO_STR, "~r~~h~Collision~w~ -%d ~w~(~r~~h~~h~%d~w~)~n~",
								Player[playerid][TD1_DMG][4],
								Player[playerid][TD1_HEALTH][4]);
						}
					}

	                //if (Player [issuerid][TD0_TIMER][4] != Timer:-1)
	                //    stop Player [issuerid][TD0_TIMER][4];

	                //Player [issuerid][TD0_TIMER][4] = defer HideTextDraw0(issuerid, 4);

					PlayerTextDrawSetString(playerid, TD_Player_Damages[1][4], szl);
					PlayerTextDrawShow(playerid, TD_Player_Damages[1][4]);
				}
			}//else of // if (free_td != -1)

	    }// if (!vecchioHit)

	} // else of // (issuerid != INVALID_PLAYER_ID)
	return true;
}

stock searchMostFreeTDN0(playerid)
{
	if (Player[playerid][TD0_ID][0] == INVALID_PLAYER_ID)
		return 0;

	if (Player[playerid][TD0_ID][1] == INVALID_PLAYER_ID)
		return 1;

	if (Player[playerid][TD0_ID][2] == INVALID_PLAYER_ID)
		return 2;

	if (Player[playerid][TD0_ID][3] == INVALID_PLAYER_ID)
		return 3;

	if (Player[playerid][TD0_ID][4] == INVALID_PLAYER_ID)
		return 4;

	return -1;
}

stock searchMostFreeTDN1(playerid)
{
	if (Player[playerid][TD1_ID][0] == INVALID_PLAYER_ID)
		return 0;

	if (Player[playerid][TD1_ID][1] == INVALID_PLAYER_ID)
		return 1;

	if (Player[playerid][TD1_ID][2] == INVALID_PLAYER_ID)
		return 2;

	if (Player[playerid][TD1_ID][3] == INVALID_PLAYER_ID)
		return 3;

	if (Player[playerid][TD1_ID][4] == INVALID_PLAYER_ID)
		return 4;

	return -1;
}


timer HideTextDraw0[5000](playerid, slot)
{
	PlayerTextDrawHide (playerid, TD_Player_Damages [0][ slot ]);

	Player [playerid][TD0_ID][slot] = INVALID_PLAYER_ID;
	Player [playerid][TD0_WEAP][slot] = 0;
	Player [playerid][TD0_DMG][slot] = 0;
	Player [playerid][TD0_HEALTH][slot] = 0;
    Player [playerid][TD0_TIMER][slot] = Timer:-1;
}

timer HideTextDraw1[5000](playerid, slot)
{
	PlayerTextDrawHide (playerid, TD_Player_Damages [1][ slot ]);

	Player [playerid][TD1_ID][slot] = INVALID_PLAYER_ID;
	Player [playerid][TD1_WEAP][slot] = 0;
	Player [playerid][TD1_DMG][slot] = 0;
	Player [playerid][TD1_HEALTH][slot] = 0;
	Player [playerid][TD1_TIMER][slot] = Timer:-1;//can cause a bug
}

timer Destroy_Obj[1000](obj) {
	DestroyObject(obj);
}

timer HideTeamDamage[3500](team)//<_<
{
	if(!RoundStarted) return true;
	if(team==TEAM_A)
	{
	    TotalTeamDMG[TEAM_A] = 0;
		TextDrawHideForAll(DamageTeamA);
	}
	else
	{
	    TotalTeamDMG[TEAM_B] = 0;
	    TextDrawHideForAll(DamageTeamB);
	}
	return true;
}

public OnRconLoginAttempt(ip[], password[], success)
{
	if( success )
	{
	    new p = GetPlayerFromIp(ip);
	    format(stringo, sizeof stringo, "{"#COLOR_SYSTEM_FOCUS"}%s{"#COLOR_SYSTEM_REST"} has logged into RCON", Player[p][Nickname]);
		SendClientMessageToAll(COLOR_SYSTEM, stringo);

	    foreach(new i:Player)
   			PlayerPlaySound(i, SOUND_SUCCESS, 0.0, 0.0, 0.0);
	}
	else
	{
	    new p = GetPlayerFromIp(ip);
	    Player[p][RconFails] ++;
	    if( Player[p][RconFails] > 1 )
		{
		    format(stringo, sizeof stringo, "Warning, {"#COLOR_SYSTEM_FOCUS"}%s{"#COLOR_SYSTEM_REST"} has entered a wrong rcon password for more than 1 times! (Attempts: %d - Rcon: %s)", Player[p][Nickname], Player[p][RconFails], password);
		    foreach(new i:Player)
			{
		        if(IsPlayerAdmin( i ))
				{
		            SendClientMessage(i, COLOR_SYSTEM, stringo);
		        }
		    }
	    }
	}
	return true;
}

forward OnIDAssigned();
public OnIDAssigned()
{
	//CurrentMatchID
	CurrentMatchID = cache_insert_id();
	return true;
}

//http://sphotos-h.ak.fbcdn.net/hphotos-ak-snc7/420948_410593555661388_1823917108_n.jpg
public OnPlayerUpdate(playerid)
{
	/*Player[playerid][Last_Tick] = Getgettime( );

  	if(Player[playerid][AfkLabelCreated] == true) // rimosso sistema afk
 	{// riaggiungerlo !!!!!!!!!!!!!!!!!!!
 	    // almeno il kick x afk!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  	    PlayerAfk_Seconds[playerid] = 0;
		Delete3DTextLabel(Player[playerid][AfkLabel]);
		Player[playerid][AfkLabelCreated] = false;
	}

    if (6 || gConfig[GameMode] == GAMEMODE_NOCBUG)
    {
        // da scrivre nuovo algoritmo per l'anticbug
        // questo funziona na chiavaca

		new Keys, ud, lr;
	    GetPlayerKeys(playerid, Keys, ud, lr);

		if((Keys & KEY_CROUCH) && !(Keys & KEY_FIRE)&& GetPlayerCameraMode(playerid) == 53 && GetPlayerWeapon(playerid) > 0 && GetPlayerSpecialAction(playerid) != SPECIAL_ACTION_DUCK )
		{
			ApplyAnimation(playerid,"PED","getup",4.1,0,0,0,0,0);
	    }
	}*/
/*
	if (gConfig[GameMode] == GAMEMODE_NOCBUG || gConfig[AntiCBug])
	{
		new Keys, ud, lr;
		GetPlayerKeys(playerid, Keys, ud, lr);
		if(CheckCrouch[playerid] == 1) {
			switch(WeaponID[playerid]) {
			    case 23..25, 27, 29..34, 41: {
			    	if((Keys & KEY_CROUCH) && !((Keys & KEY_FIRE) || (Keys & KEY_HANDBRAKE)) && GetPlayerSpecialAction(playerid) != SPECIAL_ACTION_DUCK ) {
			    		if(Ammo[playerid][GetPlayerWeapon(playerid)] > GetPlayerAmmo(playerid)) {
							//OnPlayerCBug(playerid);
							ApplyAnimation(playerid, "PED", "BIKE_fall_off", 4.1, 0, 1, 1, 1, 1, 1);
						}
			    	}
			    	//else SendClientMessage(playerid, COLOR_RED, "Failed in onplayer update");
			    }
			}
		}
	}
	*/
	return true;
}

/*
//forward CrouchCheck(playerid);
timer CrouchCheck[3000](playerid) {
	CheckCrouch[playerid] = 0;
	return 1;
}
*/
public OnPlayerStreamIn(playerid, forplayerid)
{
	if (RoundStarted)
	{
	    if (Gaming == GAMETYPE_FIGHT || Gaming == GAMETYPE_GUNGAME || Gaming == GAMETYPE_LASTBULLET || Gaming == GAMETYPE_FALLOUT) return true;

		if (Player[playerid][InGame])
		{
		    RefreshIcons();
		}

		if (Player[playerid][Team] == Player[forplayerid][Team]) {
		    ShowPlayerNameTagForPlayer (playerid, forplayerid, 1);
		    ShowPlayerNameTagForPlayer (forplayerid, playerid, 1);
		}
	}
	return true;
}

public OnPlayerStreamOut(playerid, forplayerid)
{
	/*
	if (Player[playerid][Team] == Player[forplayerid][Team]) {
	    ShowPlayerNameTagForPlayer (playerid, forplayerid, 0);
	    ShowPlayerNameTagForPlayer (forplayerid, playerid, 0);
	}*/
	return true;
}

public OnVehicleStreamIn(vehicleid, forplayerid)
{
	if(RoundStarted)
	{
	    if(GetVehicleVirtualWorld(vehicleid) == GAME_WORLD)
		{
		    if (Gaming == GAMETYPE_FIGHT || Gaming == GAMETYPE_GUNGAME) return true;
			if(TeamRole[Player[forplayerid][Team]] == DEFENDERS)
			{
			    SetVehicleParamsForPlayer(vehicleid, forplayerid, 0, 1);
			}
	    }
	}
	return true;
}

public OnPlayerClickPlayer(playerid, clickedplayerid, source)
{
	if(FinalCW||CamMove) return true;
	if(!RoundStarted) return SendClientMessage(playerid, red, "You cannot do this since round is not active"), PlayerPlaySound(playerid, SOUND_WRONGCOMMAND, 0.0, 0.0, 0.0);
//	if(gConfig[GameMode] == GAMEMODE_ESL) return SendClientMessage(playerid, red, "Spec is disabled in ESL mode."), PlayerPlaySound(playerid, SOUND_WRONGCOMMAND, 0.0, 0.0, 0.0);
	if(Player[playerid][InGame]) return SendClientMessage(playerid, red, "You cannot do this since you are in-game."), PlayerPlaySound(playerid, SOUND_WRONGCOMMAND, 0.0, 0.0, 0.0);
//	if(Player[playerid][InDm]!=-1)return SendClientMessage(playerid, red, "You cannot do this since you are in a DM."), PlayerPlaySound(playerid, SOUND_WRONGCOMMAND, 0.0, 0.0, 0.0);
	if(clickedplayerid==playerid) return SendClientMessage(playerid, red, "You cannot spec yourself."), PlayerPlaySound(playerid, SOUND_WRONGCOMMAND, 0.0, 0.0, 0.0);
	if(!Player[clickedplayerid][InGame])return SendClientMessage(playerid, red, "You can only spec in-game players."), PlayerPlaySound(playerid, SOUND_WRONGCOMMAND, 0.0, 0.0, 0.0);
	if(Gaming != GAMETYPE_FIGHT && Gaming != GAMETYPE_FALLOUT && Gaming != GAMETYPE_GUNGAME)
	{
		if(Player[playerid][Team] != TEAM_REF)
		{
		    if(Player[playerid][Team] != Player[clickedplayerid][Team] && Player[playerid][Team] != GetHisSubTeam(clickedplayerid))
			{
				return SendClientMessage(playerid, red, "You cannot spectate players in teams different from your own!"), 0, PlayerPlaySound(playerid, SOUND_WRONGCOMMAND, 0.0, 0.0, 0.0);
			}
		}
	}
	if(InSpec[clickedplayerid] != -1) return SendClientMessage(playerid, red, "This player is already specting."), PlayerPlaySound(playerid, SOUND_WRONGCOMMAND, 0.0, 0.0, 0.0);
	if(InSpec[playerid] != -1)
	{
	    Spec_ChangeSpecTarget( playerid , clickedplayerid );
	}
	else
	{
	    Spec_PutPlayerInSpec( playerid , clickedplayerid );
	}
	PlayerPlaySound(playerid, SOUND_SUCCESS, 0.0, 0.0, 0.0);
	return true;
}

forward OnVehicleTakeDamage(vehicleid, Float:vHealth);
public OnVehicleTakeDamage(vehicleid, Float:vHealth)
{//20 + 34
    //stringo = "";
//	stringo = aVehicleNames[GetVehicleModel(vehicleid)-400];
// ?¤¤¤ ¤
//    szScritta = "{"#HEX_OTHER_COLOR"}- {"#HEX_HEALTH_COLOR_VEH"}¤¤¤¤¤¤¤¤¤¤{"#HEX_OTHER_COLOR"} -\n";

	switch ((floatround(vHealth) * 100) / 1000)
	{
	    case 90 .. 100:
	    {
	        stringo = "{"##HEX_OTHER_COLOR"}- {"##HEX_HEALTH_COLOR_VEH"}¤¤¤¤¤¤¤¤¤¤{"#HEX_OTHER_COLOR"} -\n";
	       // stringo = "{FF0000}- ¤¤¤¤¤¤¤¤¤¤ -\n";
	    }
	    case 80 .. 89:
	    {
	        stringo = "{"##HEX_OTHER_COLOR"}- {"##HEX_HEALTH_COLOR_VEH"}¤¤¤¤¤¤¤¤¤{"#HEX_BLACK_HEALTH"}¤{"#HEX_OTHER_COLOR"} -\n";
	        //strcat( stringo, "\n{FF0000}- |||||||||{000000}|{FF0000} -");
	    }
	    case 70 .. 79:
	    {
	        stringo = "{"##HEX_OTHER_COLOR"}- {"#HEX_HEALTH_COLOR_VEH"}¤¤¤¤¤¤¤¤{"#HEX_BLACK_HEALTH"}¤¤{"#HEX_OTHER_COLOR"} -\n";
	        //strcat( stringo, "\n{FF0000}- ||||||||{000000}||{FF0000} -");
	    }
	    case 60 .. 69:
	    {
	        stringo = "{"##HEX_OTHER_COLOR"}- {"#HEX_HEALTH_COLOR_VEH"}¤¤¤¤¤¤¤{"#HEX_BLACK_HEALTH"}¤¤¤{"#HEX_OTHER_COLOR"} -\n";
	        //strcat( stringo, "\n{FF0000}- |||||||{000000}|||{FF0000} -");
	    }
	    case 50 .. 59:
	    {
	        stringo = "{"#HEX_OTHER_COLOR"}- {"#HEX_HEALTH_COLOR_VEH"}¤¤¤¤¤¤{"#HEX_BLACK_HEALTH"}¤¤¤¤{"#HEX_OTHER_COLOR"} -\n";
	        //strcat( stringo, "\n{FF0000}- ||||||{000000}||||{FF0000} -");
	    }
	    case 40 .. 49:
	    {
	        stringo = "{"#HEX_OTHER_COLOR"}- {"#HEX_HEALTH_COLOR_VEH"}¤¤¤¤¤{"#HEX_BLACK_HEALTH"}¤¤¤¤¤{"#HEX_OTHER_COLOR"} -\n";
	        //strcat( stringo, "\n{FF0000}- |||||{000000}|||||{FF0000} -");
	    }
	    case 30 .. 39:
	    {
	        stringo = "{"#HEX_OTHER_COLOR"}- {"#HEX_HEALTH_COLOR_VEH"}¤¤¤¤{"#HEX_BLACK_HEALTH"}¤¤¤¤¤¤{"#HEX_OTHER_COLOR"} -\n";
	    //    strcat( stringo, "\n{FF0000}- ||||{000000}||||||{FF0000} -");
	    }
	    case 20 .. 29:
	    {
	        stringo = "{"#HEX_OTHER_COLOR"}- {"#HEX_HEALTH_COLOR_VEH"}¤¤¤{"#HEX_BLACK_HEALTH"}¤¤¤¤¤¤¤{"#HEX_OTHER_COLOR"} -\n";
	       // strcat( stringo, "\n{FF0000}- |||{000000}|||||||{FF0000} -");
	    }
	    case 10 .. 19:
	    {
	        stringo = "{"#HEX_OTHER_COLOR"}- {"#HEX_HEALTH_COLOR_VEH"}¤¤{"#HEX_BLACK_HEALTH"}¤¤¤¤¤¤¤¤{"#HEX_OTHER_COLOR"} -\n";
	       // strcat( stringo, "\n{FF0000}- ||{000000}||||||||{FF0000} -");
	    }
	    case 0 .. 9:
	    {
	        stringo = "{"#HEX_OTHER_COLOR"}- {"#HEX_BLACK_HEALTH"}¤¤¤¤¤¤¤¤¤¤{"#HEX_OTHER_COLOR"} -\n";
	       // strcat( stringo, "\n{FF0000}- {000000}||||||||||{FF0000} -");
	    }
	}

    strcat( stringo, aVehicleNames[GetVehicleModel(vehicleid)-400]);
	Update3DTextLabelText(VehLabel[vehicleid], 0xA61100AA, stringo);
	return true;
}

timer OnVehicleUpdate[3140]()//3140 ms <- chiamato ogni
{
    static Float:vHealth;

	foreach(new vehicleid:iVehicles)
	{
		GetVehicleHealth(vehicleid, vHealth);
		if( iVeh[vehicleid][LHealth] != vHealth )
		{
		    OnVehicleTakeDamage(vehicleid, vHealth);
		    iVeh[vehicleid][LHealth]  = vHealth;
		}
	}
}

public OnVehicleSpawn(vehicleid)
{
	DestroyVehicleEx(vehicleid);
//    stringo = "";
//	strcat( stringo, aVehicleNames[GetVehicleModel(vehicleid)-400]);
//	strcat( stringo, "\n{FF0000}- |||||||||| -");

//	Update3DTextLabelText(VehLabel[vehicleid], 0xA61100AA, stringo);
	return true;
}

public OnVehicleDeath(vehicleid, killerid)
{
	return true;
}

//pSkinAttachObject

public OnPlayerEditAttachedObject(playerid, response, index, modelid, boneid, Float:fOffsetX, Float:fOffsetY, Float:fOffsetZ, Float:fRotX, Float:fRotY, Float:fRotZ, Float:fScaleX, Float:fScaleY, Float:fScaleZ)
{
    #define i index
    if(response) {

        pSkinAttachObject[playerid][index][ao_model] = modelid;
        pSkinAttachObject[playerid][index][ao_bone]  = boneid;
        pSkinAttachObject[playerid][index][ao_x]  = fOffsetX;
        pSkinAttachObject[playerid][index][ao_y]  = fOffsetY;
        pSkinAttachObject[playerid][index][ao_z]  = fOffsetZ;

        pSkinAttachObject[playerid][index][ao_rx] = fRotX;
        pSkinAttachObject[playerid][index][ao_ry] = fRotY;
        pSkinAttachObject[playerid][index][ao_rz] = fRotZ;

        pSkinAttachObject[playerid][index][ao_sx] = fScaleX;
        pSkinAttachObject[playerid][index][ao_sy] = fScaleY;
        pSkinAttachObject[playerid][index][ao_sz] = fScaleZ;
    }
    else {
        cmd_skin(playerid, "");

        SetPlayerAttachedObject(playerid, index, modelid, boneid, pSkinAttachObject[playerid][i][ao_x], pSkinAttachObject[playerid][i][ao_y], pSkinAttachObject[playerid][i][ao_z], pSkinAttachObject[playerid][i][ao_rx], pSkinAttachObject[playerid][i][ao_ry], pSkinAttachObject[playerid][i][ao_rz], pSkinAttachObject[playerid][i][ao_sx], pSkinAttachObject[playerid][i][ao_sy], pSkinAttachObject[playerid][i][ao_sz]);
    }
    #undef i
    return true;
}

public OnPlayerInteriorChange(playerid, newinteriorid, oldinteriorid)
{
	if (RoundStarted)
	{// LO SPEC SI PUï¿½ USARE SOLAMENTE QUANDO IL ROUND ï¿½ IN CORSO QUINDI CONTROLLO
		foreach(new i:Player)
		{
		    if( InSpec[i] == playerid )
			{
		        SetPlayerInterior( i , newinteriorid );
		    }
		}
	}
	return true;
}

public OnPlayerRequestSpawn(playerid)
{
	/*
	if (FullyReady != FULLY_READY_STEPS) {
	    format (stringo, sizeof stringo, "Wait! The gamemode is sill in loading, might bug... (%d / "#FULLY_READY_STEPS")", FullyReady);
	    SendClientMessage (playerid, -1, stringo);
	    //return false;
	}

	new auto_assign[ 21 ];

	switch (pClassid[playerid])
	{
	    case 0: pClassid[ playerid ] = GetTeamWithLessMembers(), auto_assign = "(Auto-Assign)";
	    case 1: pClassid[ playerid ] = TEAM_A;
	    case 2: pClassid[ playerid ] = TEAM_A_SUB;
	    case 3: pClassid[ playerid ] = TEAM_B;
	    case 4: pClassid[ playerid ] = TEAM_B_SUB;
	    case 5: pClassid[ playerid ] = TEAM_REF;
	}

	if (!Player[ playerid ][ Loggen ] && Player[ playerid ][ AccountExist ])
	{
	    ShowPlayerDialog(playerid, DIALOG_LOGIN, DIALOG_STYLE_PASSWORD, "Login", "You must be logged in to spawn.", "Login", "");
	    return false;
	}

	if (iTeam [pClassid[playerid]][tLocked]) {
	    GameTextForPlayer (playerid, "~r~Locked team", 3000, 3);
	    return false;
	}

	if (Player[playerid][Team] != NULL_TEAM)
		iTeam[Player[playerid][Team]][tPlayers] --;

//	if (!RoundStarted) TextDrawShowForPlayer(playerid, HintTD);
	TextDrawHideForPlayer( playerid , SkinSelection_TDs );

    StopAudioStreamForPlayer(playerid);
    PlayerTextDrawHide(playerid, Classtd_SpawnTN[0]);
	PlayerTextDrawHide(playerid, Classtd_SpawnTN[1]);
	PlayerTextDrawHide(playerid, Classtd_SpawnTN[2]);
	PlayerTextDrawHide(playerid, Classtd_SpawnTN[3]);
	PlayerTextDrawHide(playerid, Classtd_SpawnTN[4]);
	PlayerTextDrawHide(playerid, Classtd_SpawnTN[5]);
	PlayerTextDrawHide(playerid, Classtd_SpawnTN[6]);
	PlayerTextDrawHide(playerid, Classtd_SpawnTN[7]);
	PlayerTextDrawHide(playerid, Classtd_SpawnTN[8]);

    FirstCreated[playerid] = 0;
	Player[playerid][Team] = pClassid[playerid];

	TextDrawShowForPlayer(playerid, GeneralTD[0]);
	TextDrawShowForPlayer(playerid, GeneralTD[1]);

	TextDrawShowForPlayer(playerid, TeamPlayers_TD);

	PlayerTextDrawShow(playerid, PlayerInfo[0]);
	PlayerTextDrawShow(playerid, PlayerInfo[1]);
	PlayerTextDrawShow(playerid, PlayerInfo[2]);

	switch (pClassid[playerid])
	{
		case TEAM_A:
		{
		    iTeam[TEAM_A][tPlayers] ++;
		    format(stringo, sizeof stringo, "{"#SC_TEAMA"}%s{FFFFFF} has spawned as {"#SC_TEAMA"}%s{FFFFFF} ({"#SC_TEAMA"}%s{FFFFFF}) %s", Player[playerid][Nickname], iTeam[TEAM_A][Name], GetRoleName(TeamRole[TEAM_A]), auto_assign);
		}
		case TEAM_A_SUB:
		{
		    iTeam[TEAM_A_SUB][tPlayers] ++;
		    format(stringo, sizeof stringo, "{"#SC_TEAMSA"}%s{FFFFFF} has spawned as {"#SC_TEAMSA"}%s{FFFFFF} ({"#SC_TEAMSA"}%s{FFFFFF}) %s", Player[playerid][Nickname], iTeam[TEAM_A_SUB][Name], "Sub", auto_assign);
		}
		case TEAM_B:
		{
            iTeam[TEAM_B][tPlayers] ++;
		    format(stringo, sizeof stringo, "{"#SC_TEAMB"}%s{FFFFFF} has spawned as {"#SC_TEAMB"}%s{FFFFFF} ({"#SC_TEAMB"}%s{FFFFFF}) %s", Player[playerid][Nickname], iTeam[TEAM_B][Name], GetRoleName(TeamRole[TEAM_B]), auto_assign);
		}
		case TEAM_B_SUB:
		{
		    iTeam[TEAM_B_SUB][tPlayers] ++;
		    format(stringo, sizeof stringo, "{"#SC_TEAMSB"}%s{FFFFFF} has spawned as {"#SC_TEAMSB"}%s{FFFFFF} ({"#SC_TEAMSB"}%s{FFFFFF}) %s", Player[playerid][Nickname], iTeam[TEAM_B_SUB][Name], "Sub", auto_assign);
		}
		case TEAM_REF:
		{
		    iTeam[TEAM_REF][tPlayers] ++;
		    format(stringo, sizeof stringo, "{"#SC_TEAMR"}%s{FFFFFF} has spawned as {"#SC_TEAMR"}%s{FFFFFF} ({"#SC_TEAMR"}%s{FFFFFF})", Player[playerid][Nickname], iTeam[TEAM_REF][Name], GetRoleName(TeamRole[TEAM_REF]), auto_assign);
		}
	}

	SendClientMessageToAll(-1, stringo);

	SetSpawnInfo(playerid, Player[playerid][Team], GetPlayerSkinEx(playerid), Lobby[0] - MAX_RANDOM_SPAWN + random( MAX_RANDOM_SPAWN ), Lobby[1] - MAX_RANDOM_SPAWN + random( MAX_RANDOM_SPAWN ), Lobby[2], Lobby[3], 0, 0, 0, 0, 0, 0);

	if (gConfig[GameMode] == GAMEMODE_ESL && !RoundStarted)
	{
 		TextDrawShowForPlayer(playerid, ESLModeReady[0]);
 		TextDrawShowForPlayer(playerid, ESLModeReady[1]);
 		TextDrawShowForPlayer(playerid, ESLModeReady[2]);
 		TextDrawShowForPlayer(playerid, ESLModeReady[3]);

 		RefreshReadyTDs_Esl();
	}
	else if (RoundStarted)
	{
		TextDrawShowForPlayer(playerid, RoundStats[0]);
		TextDrawShowForPlayer(playerid, RoundStats[1]);
		TextDrawShowForPlayer(playerid, RoundStats[2]);
		TextDrawShowForPlayer(playerid, RoundStats[3]);
	}

	RefreshTeamPlayers_TD();*/
	return true;
}

stock GetTeamWithLessMembers()
{
	new
	    TeamA,
	    TeamB;

	foreach(new i:Player)
	{
	    if (Player[i][Team] == TEAM_A)
	    {
	        TeamA++;
	    }
	    else if (Player[i][Team] == TEAM_B)
	    {
	        TeamB++;
	    }
	}

	return ( TeamA > TeamB ) ? TEAM_B : TEAM_A;
}

stock RefreshTeamPlayers_TD()
{
//	if(!RoundStarted)
//	{
	format(stringo, sizeof stringo, "Teams ~"#GT_TEAMA"~~h~%d~w~/~"#GT_TEAMB"~~h~%d", iTeam[TEAM_A][tPlayers], iTeam[TEAM_B][tPlayers]);
//	}
//	else
//	{
//		format(stringo, sizeof stringo, "Teams ~b~~h~%d~w~/~g~~h~%d", TeamPlayers[TEAM_A], TeamPlayers[TEAM_B]);
//	}

	TextDrawSetString(TeamPlayers_TD, stringo);
	return true;
}

stock GetRoleName(role)
{
	new str[ 11 ];
	switch(role)
	{
	    case ATTACKERS: str = "Attackers";
		case DEFENDERS: str = "Defenders";
		case REFEREE:   str = "Referee";
	}
	return str;
}

public OnPlayerKeyStateChange(playerid, newkeys, oldkeys)
{
//	SendClientMessage(playerid, -1, "newkeys=%d | oldkeys=%d", newkeys, oldkeys);
	if(CamMove) return true;

	if((newkeys == 160 && oldkeys == 128) || (newkeys == 168 && oldkeys == 136) || (newkeys == 160 && oldkeys == 32))
	{
	    if(IsPlayerInAnyVehicle(playerid) || GetPlayerWeapon(playerid) != 0||InSpec[playerid]!=-1) return false;
		if(Player[playerid][IsAfk]||FinalCW) return SendClientMessage(playerid, red, "You cannot use this command now");
//		if(SyncLocked[playerid])return SendClientMessage(playerid, red, "Error! You can only sync every 3 seconds."), PlayerPlaySound(playerid, SOUND_WRONGCOMMAND, 0.0, 0.0, 0.0);
		if((gettime() - SyncLocked[playerid]) < 3){
		    SendClientMessage(playerid, red, sprintf("Wait %d seconds to sync again!", 3 - (gettime() - SyncLocked[playerid])) );
//			SendClientMessage(playerid, red, "Error! You can only sync every 3 seconds!");
			PlayerPlaySound(playerid, SOUND_WRONGCOMMAND, 0.0, 0.0, 0.0);
			return true;
		}
		if(g_PlayerFreezed [playerid] == true) return SendClientMessage(playerid, red,"You are freezed!"), PlayerPlaySound(playerid, SOUND_WRONGCOMMAND, 0.0, 0.0, 0.0);
		if(Player[playerid][InGame])
		{
		    if (GamePaused || CamMove)
		    {
		        SendClientMessage(playerid, red, "You cannot sync while the game is paused.");
		        PlayerPlaySound(playerid, SOUND_WRONGCOMMAND, 0.0, 0.0, 0.0);
		        return true;
		    }
		}
        if(Sync_InCorso[playerid])return SendClientMessage(playerid, red, "#sync error-1 Sync running");

	    new Float:x, Float:y, Float:z, Float:a;
	    GetPlayerPos(playerid, x, y, z);
	    GetPlayerFacingAngle(playerid, a);

		Sync_InCorso[playerid] = 1;

		GetPlayerWeaponData(playerid, 0, Sync_Weapons_ID[playerid][0], Sync_Weapons_AMMO[playerid][0]);
		GetPlayerWeaponData(playerid, 1, Sync_Weapons_ID[playerid][1], Sync_Weapons_AMMO[playerid][1]);
		GetPlayerWeaponData(playerid, 2, Sync_Weapons_ID[playerid][2], Sync_Weapons_AMMO[playerid][2]);
		GetPlayerWeaponData(playerid, 3, Sync_Weapons_ID[playerid][3], Sync_Weapons_AMMO[playerid][3]);
		GetPlayerWeaponData(playerid, 4, Sync_Weapons_ID[playerid][4], Sync_Weapons_AMMO[playerid][4]);
		GetPlayerWeaponData(playerid, 5, Sync_Weapons_ID[playerid][5], Sync_Weapons_AMMO[playerid][5]);
		GetPlayerWeaponData(playerid, 6, Sync_Weapons_ID[playerid][6], Sync_Weapons_AMMO[playerid][6]);
		GetPlayerWeaponData(playerid, 7, Sync_Weapons_ID[playerid][7], Sync_Weapons_AMMO[playerid][7]);
		GetPlayerWeaponData(playerid, 8, Sync_Weapons_ID[playerid][8], Sync_Weapons_AMMO[playerid][8]);
		GetPlayerWeaponData(playerid, 9, Sync_Weapons_ID[playerid][9], Sync_Weapons_AMMO[playerid][9]);
		GetPlayerWeaponData(playerid, 10, Sync_Weapons_ID[playerid][10], Sync_Weapons_AMMO[playerid][10]);
		GetPlayerWeaponData(playerid, 11, Sync_Weapons_ID[playerid][11], Sync_Weapons_AMMO[playerid][11]);
		GetPlayerWeaponData(playerid, 12, Sync_Weapons_ID[playerid][12], Sync_Weapons_AMMO[playerid][12]);

		if (Player[playerid][InGame])
		{
			foreach(new i:Player)
			{
				SetPlayerMarkerForPlayer( i, playerid, ( GetPlayerColor( playerid ) & 0xFFFFFF00 ) );
			}
		}

	    SetSpawnInfo(playerid, Player[playerid][Team], GetPlayerSkinEx(playerid), x, y, z - 0.5, a, 0, 0, 0, 0, 0, 0);

	    GetPlayerHealth(playerid, Sync_Health[playerid]);
	    GetPlayerArmour(playerid, Sync_Armour[playerid]);

	    SpawnPlayer(playerid);

	    SendClientMessage(playerid, COLOR_SYSTEM, "* Synchronized!");
	    SyncLocked[playerid] = gettime();
	    return true;
	}

	if(newkeys & KEY_FIRE)
	{
		if (InSpec[playerid] != -1)
	    {
	    	Spec_SwitchSpec(playerid);
	    	return true;
		}
		else
		{
		    if (GetPlayerState(playerid) == PLAYER_STATE_DRIVER)
		    {
			    new veh = GetPlayerVehicleID(playerid);
				if( IsNosCompatible( GetVehicleModel( veh ) ) )
				{
				    AddVehicleComponent(veh, 1008);
				}
			}

			// dentro a onplayerkeystatechange
			if (Editor_SettingSpawn[playerid] && (Editor_WorkingType[playerid] == EDITOR_WORKTYPE_GUNGAME || Editor_WorkingType[playerid] == EDITOR_WORKTYPE_FIGHT))
			{
				if (Editor_CurrentSpawnID[playerid] > 19)
				{
					SendClientMessage(playerid, COLOR_RED, "Hai raggiunto il numero massimo di spawns! Usa /e per continuare.");
					return false;
				}
				else
				{
					new p = Editor_CurrentSpawnID[playerid];

					GetPlayerPos(playerid, Editor_SpawnsPos [playerid][p][0], Editor_SpawnsPos [playerid][p][1], Editor_SpawnsPos [playerid][p][2]);
					Editor_CurrentSpawnID [playerid] ++;

					format(stringo, sizeof stringo, "Spawn #%d di 20 salvato.", Editor_CurrentSpawnID[playerid]);
					SendClientMessage(playerid, COLOR_SYSTEM, stringo);
					return true;
				}
			}
		}
	}

	if(newkeys & KEY_NO)
	{
	    if (RoundStarted)
	    {
	        if (Gaming == GAMETYPE_FIGHT || Gaming == GAMETYPE_GUNGAME || Gaming == GAMETYPE_LASTBULLET) return true;
	        if (gConfig[Matchmode] == MATCHMODE_NOSCORES) return true;

		    if (Player[playerid][InGame])
		    {
				// if((Getgettime() - HelperLocked[playerid]) * (0.001) < 5) return true;
    			if (HelperLocked[playerid]) return true;

				new frase[ 128 ], r = random(sizeof frasiHelp);
				strcat(frase, frasiHelp[r]);

				new
				    Float:fX,
				    Float:fY,
				    Float:fZ,
					      dist = strfind(frase, "@", true);

                new pT = Player[playerid][Team];
                GetPlayerPos(playerid, fX, fY, fZ);

				foreach(new i:Player)
				{
				    if (Player[i][Team] == pT)
				    {
				        strdel(frase, dist, dist+1);
						strins(frase, sprintf("%.2f", GetPlayerDistanceFromPoint(i, fX, fY, fZ)), dist);

						// can be improved?
						// see yaaa later

						format (stringo, sizeof stringo, "(Team) %s:{FFFFFF} (%d) %s", Player[playerid][Nickname], playerid, frase);
						SendClientMessage(i, iTeam[pT][InGameColor], stringo);

			            PlayerPlaySound(i, 45400, 0.0, 0.0, 0.0);

			            if (pT == TEAM_A)
							SetPlayerMarkerForPlayer( i, playerid, 0xe5575744 );
			            else
							SetPlayerMarkerForPlayer( i, playerid, 0x5790E644 );

						strcpy_2(frase, frasiHelp[r]);
				    }
				}

				HelperLocked[playerid] = true;
				defer HideMyIcon(playerid);
				//SetTimerEx( "HideMyIcon" , 5000 , false , "i" , playerid );
			}
		}
		else
		{
		    if (gConfig[GameMode] == GAMEMODE_ESL)
		    {
      			cmd_notready(playerid, "");
      			return 1;
		    }
		}
	}

	if (newkeys & KEY_YES)
	{
		if (RoundStarted)
		{
			if (gConfig[Matchmode] == MATCHMODE_NOSCORES) return true;

		    if (Player[playerid][aLevel] >= _:lMod)
			{
      			if (!GamePaused)
				{
					PauseRound ();

					format (stringo, sizeof stringo, "{"#COLOR_SYSTEM_FOCUS"}%s{"#COLOR_SYSTEM_REST"} has paused the round.", Player[playerid][Nickname]);
                    SendClientMessageToAll(COLOR_SYSTEM, stringo);
				}
				else
				{
					if(UnPausingRunning)
					    return true;

					UnPauseRound ();

					format(stringo, sizeof stringo, "{"#COLOR_SYSTEM_FOCUS"}%s{"#COLOR_SYSTEM_REST"} has unpaused the round.", Player[playerid][Nickname]);
                    SendClientMessageToAll(COLOR_SYSTEM, stringo);
				}
		    }//if (Player[playerid][aLevel] >= _:lMod) {
		    else
		    {
		        if (Player[playerid][InGame])
				{
		            if (!GamePaused)
		            {
						format (stringo, sizeof stringo, "{"#COLOR_SYSTEM_FOCUS"}%s{"#COLOR_SYSTEM_REST"} asked to pause the round.", Player[playerid][Nickname]);
	                    SendClientMessageToAll(COLOR_SYSTEM, stringo);
					}//if (!GamePaused)
					else
					{
						format (stringo, sizeof stringo, "{"#COLOR_SYSTEM_FOCUS"}%s{"#COLOR_SYSTEM_REST"} asked to unpause the round.", Player[playerid][Nickname]);
	                    SendClientMessageToAll(COLOR_SYSTEM, stringo);
					}
		        }//if (Player[playerid][InGame])
		    }//
		}//if (RoundStarted)
	}//if (newkeys & KEY_YES)

	// Fast messages
	if (RoundStarted)
	{
	    // num 8
		if (newkeys & KEY_ANALOG_UP) {
		    // 8 => Sniper
		    SendTeamMessage(playerid, "I found their sniper!", 0);
		}
		// num 2
		else if (newkeys & KEY_ANALOG_DOWN) {
			// 2 => Spasser
			SendTeamMessage(playerid, "I found their spaser!", 0);
		}
		// num 4
		else if (newkeys & KEY_ANALOG_LEFT) {
			// 4 => Camp!
			SendTeamMessage(playerid, "Camp it!", 0);
		}
		// num 6
		else if (newkeys & KEY_ANALOG_RIGHT) {
			// 6 => Rush!
			SendTeamMessage(playerid, "Let's rush now Go!", 0);
		}
	}

	/*
	// anticbug script
	if (gConfig[GameMode] == GAMEMODE_NOCBUG || gConfig[AntiCBug])
	{
	    if((newkeys & KEY_FIRE) && (oldkeys & KEY_CROUCH) && !((oldkeys & KEY_FIRE) || (newkeys & KEY_HANDBRAKE)) || (oldkeys & KEY_FIRE) && (newkeys & KEY_CROUCH) && !((newkeys & KEY_FIRE) || (newkeys & KEY_HANDBRAKE)) ) {
	        switch(GetPlayerWeapon(playerid)) {
			    case 23..25, 27, 29..34, 41: {
			        if(Ammo[playerid][GetPlayerWeapon(playerid)] > GetPlayerAmmo(playerid)) {
						//OnPlayerCBug(playerid);
						ApplyAnimation(playerid, "PED", "BIKE_fall_off", 4.1, 0, 1, 1, 1, 1, 1);
					}
					return 1;
				}
			}
		}

		if(CheckCrouch[playerid] == 1) {
			switch(WeaponID[playerid]) {
			    case 23..25, 27, 29..34, 41: {
			    	if((newkeys & KEY_CROUCH) && !((newkeys & KEY_FIRE) || (newkeys & KEY_HANDBRAKE)) && GetPlayerSpecialAction(playerid) != SPECIAL_ACTION_DUCK ) {
			    		if(Ammo[playerid][GetPlayerWeapon(playerid)] > GetPlayerAmmo(playerid)) {
							//OnPlayerCBug(playerid);
							ApplyAnimation(playerid, "PED", "BIKE_fall_off", 4.1, 0, 1, 1, 1, 1, 1);
						}
			    	}
			    }
			}
		}

		//if(newkeys & KEY_CROUCH || (oldkeys & KEY_CROUCH)) return 1;

		else if(((newkeys & KEY_FIRE) && (newkeys & KEY_HANDBRAKE) && !((newkeys & KEY_SPRINT) || (newkeys & KEY_JUMP))) ||
		(newkeys & KEY_FIRE) && !((newkeys & KEY_SPRINT) || (newkeys & KEY_JUMP)) ||
		(NotMoving[playerid] && (newkeys & KEY_FIRE) && (newkeys & KEY_HANDBRAKE)) ||
		(NotMoving[playerid] && (newkeys & KEY_FIRE)) ||
		(newkeys & KEY_FIRE) && (oldkeys & KEY_CROUCH) && !((oldkeys & KEY_FIRE) || (newkeys & KEY_HANDBRAKE)) ||
		(oldkeys & KEY_FIRE) && (newkeys & KEY_CROUCH) && !((newkeys & KEY_FIRE) || (newkeys & KEY_HANDBRAKE)) ) {
			//SetTimerEx("CrouchCheck", 3000, 0, "d", playerid);
			defer CrouchCheck(playerid);
			CheckCrouch[playerid] = 1;
			WeaponID[playerid] = GetPlayerWeapon(playerid);
			Ammo[playerid][GetPlayerWeapon(playerid)] = GetPlayerAmmo(playerid);
			return 1;
		}
	}
	*/
	return true;
}


//forward HideMyIcon(p);
timer HideMyIcon[5000](p)
{
    HelperLocked[p] = false;
	RefreshIcons();
}

/*
	* play command
*/

COMMAND:play(playerid, params[])
{//lNbAdmin
	#pragma unused params
	if(!IsPlayerAdminEx(playerid, lNbAdmin)) return true;
	Play_ShowMenu(playerid);
	return true;
}

COMMAND:balance(playerid, params[])
{
	#pragma unused params
	if(!IsPlayerAdminEx(playerid, lMod)) return true;
	if(RoundStarted) return SendClientMessage(playerid, red, "You cannot use this command now.");
	BalancePlayers(playerid);
	return 1;
}

COMMAND:allvs(playerid, params[])
{
    if(!IsPlayerAdminEx(playerid, lMod)) return true;
	if(RoundStarted) return SendClientMessage(playerid, red, "You cannot use this command now.");
	new s[24];
	if(sscanf(params, "s[24]", s))
    {
        SendClientMessage(playerid, red, "Use /allvs [name/tag]");
        PlayerPlaySound(playerid, SOUND_WRONGCOMMAND, 0.0, 0.0, 0.0);
    }
    else
    {
		new
			Float:x, Float:y, Float:z, Float:a;
		// WHY NO MERGE WITH THE CODE INSIDE PLAY MENU?
		foreach(new i:Player)
		{
			if(!Player[i][Spawned]) continue;
			if(Player[i][Team] == TEAM_REF || Player[i][Team] == TEAM_A_SUB || Player[i][Team] == TEAM_B_SUB) continue;
			if(Player[i][IsAfk]) continue;

			GetPlayerPos(i, x, y, z);
			GetPlayerFacingAngle(i, a);

			iTeam[Player[i][Team]][tPlayers] --;
			if(!strfind(GetClan(Player[i][Nickname]), s, true) && strlen(GetClan(Player[i][Nickname])) > 1)
			{
			    Player[i][Team] = TEAM_A;
			    iTeam[TEAM_A][tPlayers] ++;
			    format (stringo, sizeof stringo, "You have been switched in the team %s", iTeam[TEAM_A][Name]);
			    SetSpawnInfo(i, TEAM_A, GetPlayerSkinEx(i), x, y, z - 0.5, a, 0, 0, 0, 0, 0, 0);
			}
			else if(!strfind(Player[i][Nickname], s, true))
			{
			    Player[i][Team] = TEAM_A;
			    iTeam[TEAM_A][tPlayers] ++;
			    format (stringo, sizeof stringo, "You have been switched in the team %s", iTeam[TEAM_A][Name]);
			    SetSpawnInfo(i, TEAM_A, GetPlayerSkinEx(i), x, y, z - 0.5, a, 0, 0, 0, 0, 0, 0);
			}
			else
			{
			    Player[i][Team] = TEAM_B;
			    iTeam[TEAM_B][tPlayers] ++;
			    format (stringo, sizeof stringo, "You have been switched in the team %s", iTeam[TEAM_B][Name]);
			    SetSpawnInfo(i, TEAM_B, GetPlayerSkinEx(i), x, y, z - 0.5, a, 0, 0, 0, 0, 0, 0);
			}
            SendClientMessage(i, COLOR_SYSTEM, stringo);

			GetPlayerPos(i, x, y, z);
			GetPlayerFacingAngle(i, a);

			Sync_InCorso[i] = 1;

			GetPlayerWeaponData(i, 0, Sync_Weapons_ID[i][0], Sync_Weapons_AMMO[i][0]);
			GetPlayerWeaponData(i, 1, Sync_Weapons_ID[i][1], Sync_Weapons_AMMO[i][1]);
			GetPlayerWeaponData(i, 2, Sync_Weapons_ID[i][2], Sync_Weapons_AMMO[i][2]);
			GetPlayerWeaponData(i, 3, Sync_Weapons_ID[i][3], Sync_Weapons_AMMO[i][3]);
			GetPlayerWeaponData(i, 4, Sync_Weapons_ID[i][4], Sync_Weapons_AMMO[i][4]);
			GetPlayerWeaponData(i, 5, Sync_Weapons_ID[i][5], Sync_Weapons_AMMO[i][5]);
			GetPlayerWeaponData(i, 6, Sync_Weapons_ID[i][6], Sync_Weapons_AMMO[i][6]);
			GetPlayerWeaponData(i, 7, Sync_Weapons_ID[i][7], Sync_Weapons_AMMO[i][7]);
			GetPlayerWeaponData(i, 8, Sync_Weapons_ID[i][8], Sync_Weapons_AMMO[i][8]);
			GetPlayerWeaponData(i, 9, Sync_Weapons_ID[i][9], Sync_Weapons_AMMO[i][9]);
			GetPlayerWeaponData(i, 10, Sync_Weapons_ID[i][10], Sync_Weapons_AMMO[i][10]);
			GetPlayerWeaponData(i, 11, Sync_Weapons_ID[i][11], Sync_Weapons_AMMO[i][11]);
			GetPlayerWeaponData(i, 12, Sync_Weapons_ID[i][12], Sync_Weapons_AMMO[i][12]);

			GetPlayerHealth(i, Sync_Health[i]);
			GetPlayerArmour(i, Sync_Armour[i]);

			SpawnPlayer(i);

			new veh, seat;
			if ((veh = GetPlayerVehicleID(i)) != 0 && (seat = GetPlayerVehicleSeat(i)) != 128) { PutPlayerInVehicle(i, veh, seat);  }
		}

		RefreshTeamPlayers_TD();
        RefreshReadyTDs_Esl();
		format(stringo, sizeof stringo, "Balance {"#COLOR_SYSTEM_FOCUS"}all vs %s{"#COLOR_SYSTEM_REST"} finished by {"#COLOR_SYSTEM_FOCUS"}%s.", s, Player[playerid][Nickname]);
        SendClientMessageToAll(COLOR_SYSTEM, stringo);
	    PlayerPlaySound(playerid, SOUND_SUCCESS, 0.0, 0.0, 0.0);
    }
	return 1;
}

/*
	* game command
	* admin commands
*/
/*
SSCANF:bantypes(string[])
{
    if ('0' <= string[0] <= '9')
    {
        new
            ret = strval(string);
        if (BANTYPE_IP <= ret <= BANTYPE_SERIAL)
        {
            return ret;
        }
    }
    else if (!strcmp(string, "ip")) return BANTYPE_IP;
    else if (!strcmp(string, "nickname")) return BANTYPE_NICKNAME;
    else if (!strcmp(string, "serial")) return BANTYPE_SERIAL;
	return -1;
}

COMMAND:ban(playerid, params[])
{
	if(!IsPlayerAdminEx(playerid, lAdmin)) return true;
	new id, type, reason[100];
	if(sscanf(params, "ik<bantypes>s[100]", id, type, reason))
	{
	    SendClientMessage(playerid, COLOR_RED, "Use /ban [playerid] [ip/nickname/serial] [reason]");
	    PlayerPlaySound(playerid, SOUND_WRONGCOMMAND, 0.0, 0.0, 0.0);
	}
	else
	{
		if(IsPlayerAdmin(id)) return SendClientMessage(playerid, COLOR_RED, "You cannot ban an admin."), PlayerPlaySound(playerid, SOUND_WRONGCOMMAND, 0.0, 0.0, 0.0);
		if(!IsPlayerConnected(id))return SendClientMessage(playerid, COLOR_RED, "Invalid ID."), PlayerPlaySound(playerid, SOUND_WRONGCOMMAND, 0.0, 0.0, 0.0);
		SendClientMessageToAll(COLOR_SYSTEM, "Admin/Mod {"#COLOR_SYSTEM_FOCUS"}%s{"#COLOR_SYSTEM_REST"} has banned {"#COLOR_SYSTEM_FOCUS"}%s{"#COLOR_SYSTEM_REST"} from the server (Reason: %s).", Player[playerid][Nickname], Player[id][Nickname], reason);

		Ban(id, true, type, reason, Player[playerid][Nickname]);
	    PlayerPlaySound(playerid, SOUND_SUCCESS, 0.0, 0.0, 0.0);
	}
	return true;
}*/

COMMAND:ban(playerid, params[])
{
	if(!IsPlayerAdminEx(playerid, lAdmin)) return true;

	new id, reason[39];
	if(sscanf(params, "iS(N/D)[39]", id, reason))
	{
	    SendClientMessage(playerid, COLOR_RED, "Use /ban [playerid] [reason - Max 38 char]");
	    PlayerPlaySound(playerid, SOUND_WRONGCOMMAND, 0.0, 0.0, 0.0);
	}
	else
	{
		if(IsPlayerAdmin(id)) return SendClientMessage(playerid, COLOR_RED, "You cannot ban an admin."), PlayerPlaySound(playerid, SOUND_WRONGCOMMAND, 0.0, 0.0, 0.0);
		if(!IsPlayerConnected(id))return SendClientMessage(playerid, COLOR_RED, "Invalid ID."), PlayerPlaySound(playerid, SOUND_WRONGCOMMAND, 0.0, 0.0, 0.0);
	//	format(stringo, sizeof stringo, "Admin/Mod %s has banned %s (Reason: %s).", Player[playerid][Nickname], Player[id][Nickname], reason);
    //    SendClientMessageToAll(COLOR_SYSTEM, stringo);

        _Ban(id, playerid, reason, .newban = true, .bantype = BANTYPE_IP);
	//	Ban(id, true, BANTYPE_IP, reason, Player[playerid][Nickname]);
	    PlayerPlaySound(playerid, SOUND_SUCCESS, 0.0, 0.0, 0.0);
	}
	return true;
}

COMMAND:banserial(playerid, params[])
{
	if(!IsPlayerAdminEx(playerid, lAdmin)) return true;

	new id, reason[39];
	if(sscanf(params, "iS(N/D)[39]", id, reason))
	{
	    SendClientMessage(playerid, COLOR_RED, "Use /banserial [playerid] [reason - Max 38 char]");
	    PlayerPlaySound(playerid, SOUND_WRONGCOMMAND, 0.0, 0.0, 0.0);
	}
	else
	{
		if(IsPlayerAdmin(id)) return SendClientMessage(playerid, COLOR_RED, "You cannot ban an admin."), PlayerPlaySound(playerid, SOUND_WRONGCOMMAND, 0.0, 0.0, 0.0);
		if(!IsPlayerConnected(id))return SendClientMessage(playerid, COLOR_RED, "Invalid ID."), PlayerPlaySound(playerid, SOUND_WRONGCOMMAND, 0.0, 0.0, 0.0);
	//	format(stringo, sizeof stringo, "Admin/Mod %s has banned %s (Reason: %s).", Player[playerid][Nickname], Player[id][Nickname], reason);
       // SendClientMessageToAll(COLOR_SYSTEM, stringo);

        _Ban(id, playerid, reason, .newban = true, .bantype = BANTYPE_SERIAL);
	//	Ban(id, true, BANTYPE_SERIAL, reason, Player[playerid][Nickname]);
	    PlayerPlaySound(playerid, SOUND_SUCCESS, 0.0, 0.0, 0.0);
	}
	return true;
}

COMMAND:bannick(playerid, params[])
{
	if(!IsPlayerAdminEx(playerid, lAdmin)) return true;

	new id, reason[39];
	if(sscanf(params, "iS(N/D)[39]", id, reason))
	{
	    SendClientMessage(playerid, COLOR_RED, "Use /bannick [playerid] [reason - Max 38 char]");
	    PlayerPlaySound(playerid, SOUND_WRONGCOMMAND, 0.0, 0.0, 0.0);
	}
	else
	{
		if(IsPlayerAdmin(id)) return SendClientMessage(playerid, COLOR_RED, "You cannot ban an admin."), PlayerPlaySound(playerid, SOUND_WRONGCOMMAND, 0.0, 0.0, 0.0);
		if(!IsPlayerConnected(id))return SendClientMessage(playerid, COLOR_RED, "Invalid ID."), PlayerPlaySound(playerid, SOUND_WRONGCOMMAND, 0.0, 0.0, 0.0);
	//	format(stringo, sizeof stringo, "Admin/Mod %s has banned %s (Reason: %s).", Player[playerid][Nickname], Player[id][Nickname], reason);
    //    SendClientMessageToAll(COLOR_SYSTEM, stringo);

        _Ban(id, playerid, reason, .newban = true, .bantype = BANTYPE_SERIAL);
	//	Ban(id, true, BANTYPE_NICKNAME, reason, Player[playerid][Nickname]);
	    PlayerPlaySound(playerid, SOUND_SUCCESS, 0.0, 0.0, 0.0);
	}
	return true;
}

COMMAND:unban(playerid, params[])
{
	if(!IsPlayerAdminEx(playerid, lAdmin)) return true;
	if(isnull(params)) return SendClientMessage(playerid, COLOR_RED, "Use /unban <IP>"), PlayerPlaySound(playerid, SOUND_WRONGCOMMAND, 0.0, 0.0, 0.0);
	SendRconCommand( sprintf( "unbanip %s" , params ) );
	SendRconCommand( "reloadbans" );
	MySQLStatus[TotalQuerys] ++; mysql_tquery(g_MySQLConnection, sprintf ("UPDATE bans SET banned = '0', unbannick = '%s' WHERE ip = '%s'", Player[playerid][Nickname], params), "", "");
	format(stringo, sizeof stringo, "Admin/Mod {"#COLOR_SYSTEM_FOCUS"}%s{"#COLOR_SYSTEM_REST"} has unbanned IP {"#COLOR_SYSTEM_FOCUS"}%s{"#COLOR_SYSTEM_REST"}.", Player[playerid][Nickname], params);
    SendClientMessageToAll(COLOR_SYSTEM, stringo);
    PlayerPlaySound(playerid, SOUND_SUCCESS, 0.0, 0.0, 0.0);
    return true;
}

COMMAND:unbannick(playerid, params[])
{
	if(!IsPlayerAdminEx(playerid, lAdmin)) return true;
	if(isnull(params)) return SendClientMessage(playerid, COLOR_RED, "Use /unbannick <Nickname>"), PlayerPlaySound(playerid, SOUND_WRONGCOMMAND, 0.0, 0.0, 0.0);
//	SendRconCommand( sprintf( "unbanip %s" , params ) );
//	SendRconCommand( "reloadbans" );
	MySQLStatus[TotalQuerys] ++; mysql_tquery(g_MySQLConnection, sprintf ("UPDATE bans SET banned = '0', unbannick = '%s' WHERE nickname = '%s'", Player[playerid][Nickname], params), "", "");
	format (stringo, sizeof stringo, "Admin/Mod {"#COLOR_SYSTEM_FOCUS"}%s{"#COLOR_SYSTEM_REST"} has unbanned Nickname {"#COLOR_SYSTEM_FOCUS"}%s{"#COLOR_SYSTEM_REST"}.", Player[playerid][Nickname], params);
    SendClientMessageToAll(COLOR_SYSTEM, stringo);
    PlayerPlaySound(playerid, SOUND_SUCCESS, 0.0, 0.0, 0.0);
    return true;
}

COMMAND:unbanserial(playerid, params[])
{
	if(!IsPlayerAdminEx(playerid, lAdmin)) return true;
	if(isnull(params)) return SendClientMessage(playerid, COLOR_RED, "Use /unbanserial <Serial>"), PlayerPlaySound(playerid, SOUND_WRONGCOMMAND, 0.0, 0.0, 0.0);
//	SendRconCommand( sprintf( "unbanip %s" , params ) );
//	SendRconCommand( "reloadbans" );
	MySQLStatus[TotalQuerys] ++; mysql_tquery(g_MySQLConnection, sprintf ("UPDATE bans SET banned = '0', unbannick = '%s' WHERE serial = '%s'", Player[playerid][Nickname], params), "", "");
	format (stringo, sizeof stringo, "Admin/Mod {"#COLOR_SYSTEM_FOCUS"}%s{"#COLOR_SYSTEM_REST"} has unbanned Serial {"#COLOR_SYSTEM_FOCUS"}%s{"#COLOR_SYSTEM_REST"}.", Player[playerid][Nickname], params);
    SendClientMessageToAll(COLOR_SYSTEM, stringo);

    PlayerPlaySound(playerid, SOUND_SUCCESS, 0.0, 0.0, 0.0);
    return true;
}

COMMAND:kick(playerid, params[])
{
	if(!IsPlayerAdminEx(playerid, lNbAdmin)) return true;
	new id, reason[39];

	if(sscanf(params, "iS(N/D)[39]", id, reason))
	{
	    SendClientMessage(playerid, COLOR_RED, "Use /kick [playerid] [reason - Max 38 char]");
	    PlayerPlaySound(playerid, SOUND_WRONGCOMMAND, 0.0, 0.0, 0.0);
	}
	else
	{
	//
	//	if(IsPlayerAdmin(id)) return SendClientMessage(playerid, COLOR_RED, "You cannot kick an admin."), PlayerPlaySound(playerid, SOUND_WRONGCOMMAND, 0.0, 0.0, 0.0);
		if(!IsPlayerConnected(id))return SendClientMessage(playerid, COLOR_RED, "Invalid ID."), PlayerPlaySound(playerid, SOUND_WRONGCOMMAND, 0.0, 0.0, 0.0);
		//format(stringo, sizeof stringo, "Admin/Mod %s has kicked %s (Reason: %s).", Player[playerid][Nickname], Player[id][Nickname], reason);
        //SendClientMessageToAll(COLOR_SYSTEM, stringo);
		//Kick(id, reason);
		_Kick(id, playerid, reason);
	    PlayerPlaySound(playerid, SOUND_SUCCESS, 0.0, 0.0, 0.0);
	}
	return true;
}

COMMAND:mute(playerid, params[])
{
	if(!IsPlayerAdminEx(playerid, lNbAdmin)) return true;
	new id, reason[100];
	if(sscanf(params, "iS(N/D)[100]", id, reason))
	{
		SendClientMessage(playerid, COLOR_RED, "Use /mute [playerid] [reason]");
		PlayerPlaySound(playerid, SOUND_WRONGCOMMAND, 0.0, 0.0, 0.0);
	}
	else
	{
		if(Player[id][Muted] == true) return SendClientMessage(playerid, COLOR_RED, "This player is already muted."), PlayerPlaySound(playerid, SOUND_WRONGCOMMAND, 0.0, 0.0, 0.0);
		if(IsPlayerAdmin(id)) return SendClientMessage(playerid, COLOR_RED, "You cannot mute an admin."), PlayerPlaySound(playerid, SOUND_WRONGCOMMAND, 0.0, 0.0, 0.0);
		if(!IsPlayerConnected(id))return SendClientMessage(playerid, COLOR_RED, "Invalid ID."), PlayerPlaySound(playerid, SOUND_WRONGCOMMAND, 0.0, 0.0, 0.0);
		format(stringo, sizeof stringo, "Admin/Mod {"#COLOR_SYSTEM_FOCUS"}%s{"#COLOR_SYSTEM_REST"} has muted {"#COLOR_SYSTEM_FOCUS"}%s{"#COLOR_SYSTEM_REST"} (Reason: %s)", Player[playerid][Nickname], Player[id][Nickname], reason);
        SendClientMessageToAll(COLOR_SYSTEM, stringo);
		Player[id][Muted] = true;
	    PlayerPlaySound(playerid, SOUND_SUCCESS, 0.0, 0.0, 0.0);
	}
	return true;
}

COMMAND:unmute(playerid, params[])
{
	if(!IsPlayerAdminEx(playerid, lNbAdmin)) return true;
	new id;
	if(sscanf(params, "i", id))
	{
		SendClientMessage(playerid, COLOR_RED, "Use /unmute [playerid]");
		PlayerPlaySound(playerid, SOUND_WRONGCOMMAND, 0.0, 0.0, 0.0);
	}
	else
	{
		if(Player[id][Muted] == false) return SendClientMessage(playerid, COLOR_RED, "This player is not muted."), PlayerPlaySound(playerid, SOUND_WRONGCOMMAND, 0.0, 0.0, 0.0);
		if(IsPlayerAdmin(id)) return SendClientMessage(playerid, COLOR_RED, "You cannot mute an admin."), PlayerPlaySound(playerid, SOUND_WRONGCOMMAND, 0.0, 0.0, 0.0);
		if(!IsPlayerConnected(id))return SendClientMessage(playerid, COLOR_RED, "Invalid ID."), PlayerPlaySound(playerid, SOUND_WRONGCOMMAND, 0.0, 0.0, 0.0);
		format(stringo, sizeof stringo, "Admin/Mod {"#COLOR_SYSTEM_FOCUS"}%s{"#COLOR_SYSTEM_REST"} has unmuted {"#COLOR_SYSTEM_FOCUS"}%s{"#COLOR_SYSTEM_REST"}", Player[playerid][Nickname], Player[id][Nickname]);
        SendClientMessageToAll(COLOR_SYSTEM, stringo);
		Player[id][Muted] = false;
	    PlayerPlaySound(playerid, SOUND_SUCCESS, 0.0, 0.0, 0.0);
	}
	return true;
}

COMMAND:explode(playerid, params[])
{
    if(!IsPlayerAdminEx(playerid, lAdmin)) return true;
	new id;
	if(sscanf(params, "i", id))
	{
	    SendClientMessage(playerid, COLOR_RED, "Use /explode [playerid]");
	    PlayerPlaySound(playerid, SOUND_WRONGCOMMAND, 0.0, 0.0, 0.0);
	}
	else
	{
	    if(!IsPlayerConnected(id))return SendClientMessage(playerid, red, "Invalid player");
	    new Float:x, Float:y, Float:z;
	    if(IsPlayerInAnyVehicle(id))
			GetVehiclePos(GetPlayerVehicleID(id), x, y, z);
		else GetPlayerPos(id, x, y, z);

		for(new i = 0; i < 5; i++) CreateExplosion(x,y,z,10,0);

		format(stringo, sizeof stringo, "Admin/Mod {"#COLOR_SYSTEM_FOCUS"}%s{"#COLOR_SYSTEM_REST"} has exploded {"#COLOR_SYSTEM_FOCUS"}%s{"#COLOR_SYSTEM_REST"}", Player[playerid][Nickname], Player[id][Nickname]);
        SendClientMessageToAll(COLOR_SYSTEM, stringo);
	    PlayerPlaySound(playerid, SOUND_SUCCESS, 0.0, 0.0, 0.0);
	}
	return true;
}

COMMAND:freeze(playerid, params[])
{
    if(!IsPlayerAdminEx(playerid, lNbAdmin)) return true;
	new id;
	if(sscanf(params, "i", id))
	{
	    SendClientMessage(playerid, COLOR_RED, "Use /freeze [playerid]");
	    PlayerPlaySound(playerid, SOUND_WRONGCOMMAND, 0.0, 0.0, 0.0);
	}
	else
	{
	    if(!IsPlayerConnected(id))return SendClientMessage(playerid, red, "Invalid player");
	    TogglePlayerControllable(id, false);
	    //g_PlayerFreezed[id] = true;

		format(stringo, sizeof stringo, "Admin/Mod {"#COLOR_SYSTEM_FOCUS"}%s{"#COLOR_SYSTEM_REST"} has frozen {"#COLOR_SYSTEM_FOCUS"}%s{"#COLOR_SYSTEM_REST"}", Player[playerid][Nickname], Player[id][Nickname]);
        SendClientMessageToAll(COLOR_SYSTEM, stringo);
        PlayerPlaySound(playerid, SOUND_SUCCESS, 0.0, 0.0, 0.0);
	}
	return true;
}

COMMAND:unfreeze(playerid, params[])
{
    if(!IsPlayerAdminEx(playerid, lNbAdmin)) return true;
	new id;
	if(sscanf(params, "i", id))
	{
	    SendClientMessage(playerid, COLOR_RED, "Use /unfreeze [playerid]");
	    PlayerPlaySound(playerid, SOUND_WRONGCOMMAND, 0.0, 0.0, 0.0);
	}
	else
	{
	    if(!IsPlayerConnected(id))return SendClientMessage(playerid, red, "Invalid player");
	    TogglePlayerControllable(id, true);
        //g_PlayerFreezed[id] = false;

		format (stringo, sizeof stringo, "Admin/Mod {"#COLOR_SYSTEM_FOCUS"}%s{"#COLOR_SYSTEM_REST"} has unfrozen {"#COLOR_SYSTEM_FOCUS"}%s{"#COLOR_SYSTEM_REST"}", Player[playerid][Nickname], Player[id][Nickname]);
        SendClientMessageToAll(COLOR_SYSTEM, stringo);

        PlayerPlaySound(playerid, SOUND_SUCCESS, 0.0, 0.0, 0.0);
	}
	return true;
}

COMMAND:unfreezeall(playerid, params[])
{
    if(!IsPlayerAdminEx(playerid, lNbAdmin)) return true;
    foreach(new i:Player)
    {
        TogglePlayerControllable(i, true);
        //g_PlayerFreezed[i] = false;
    }

	format(stringo, sizeof stringo, "Admin/Mod {"#COLOR_SYSTEM_FOCUS"}%s{"#COLOR_SYSTEM_REST"} has unfrozen everyone.", Player[playerid][Nickname]);
    SendClientMessageToAll(COLOR_SYSTEM, stringo);
    PlayerPlaySound(playerid, SOUND_SUCCESS, 0.0, 0.0, 0.0);
	return true;
}

COMMAND:freezeall(playerid, params[])
{
    if(!IsPlayerAdminEx(playerid, lNbAdmin)) return true;
    foreach(new i:Player)
    {
        TogglePlayerControllable(i, false);
        //g_PlayerFreezed[i] = true;
    }

	format(stringo, sizeof stringo, "Admin/Mod {"#COLOR_SYSTEM_FOCUS"}%s{"#COLOR_SYSTEM_REST"} has frozen everyone.", Player[playerid][Nickname]);
    SendClientMessageToAll(COLOR_SYSTEM, stringo);
    PlayerPlaySound(playerid, SOUND_SUCCESS, 0.0, 0.0, 0.0);
	return true;
}

COMMAND:sfreeze(playerid, params[])
{
	return cmd_unfreeze(playerid, params);
}

COMMAND:giveweapon(playerid, params[])
{
    if(!IsPlayerAdminEx(playerid, lAdmin)) return true;

	new id, weap, ammo;
	if(sscanf(params, "ik<weaps>I(999)", id, weap, ammo))
	{
	    SendClientMessage(playerid, COLOR_RED, "Use /giveweapon [playerid] [weapon] [ammo]");
	    PlayerPlaySound(playerid, SOUND_WRONGCOMMAND, 0.0, 0.0, 0.0);
	}
	else
	{
		if (!IsPlayerConnected (id)) return SendClientMessage(playerid, red, "Not connected.");

		if (ammo < 0 || ammo > 9999)
		    ammo = 999;

	    GivePlayerWeapon(id, weap, ammo);

		format(stringo, sizeof stringo, "Admin/Mod {"#COLOR_SYSTEM_FOCUS"}%s{"#COLOR_SYSTEM_REST"} has given %s (Ammo: %d) to {"#COLOR_SYSTEM_FOCUS"}%s{"#COLOR_SYSTEM_REST"}.", Player[playerid][Nickname], aWeaponNames[weap], ammo, Player[id][Nickname]);
        SendClientMessageToAll(COLOR_SYSTEM, stringo);
	    PlayerPlaySound(playerid, SOUND_SUCCESS, 0.0, 0.0, 0.0);
	}
	return true;
}

COMMAND:say(playerid, params[])
{
    if(!IsPlayerAdminEx(playerid, lAdmin)) return true;
    if(isnull(params)) return false;

	SendRconCommand(sprintf("say %s", params));
	PlayerPlaySound(playerid, SOUND_SUCCESS, 0.0, 0.0, 0.0);
	return true;
}

COMMAND:ann(playerid, params[])
{
    if(!IsPlayerAdminEx(playerid, lAdmin)) return true;
    if(isnull(params)) return false;

    GameTextForAll(params, 3000, 5);
    PlayerPlaySound(playerid, SOUND_SUCCESS, 0.0, 0.0, 0.0);
    return true;
}

COMMAND:eject(playerid, params[])
{
    if(!IsPlayerAdminEx(playerid, lAdmin)) return true;
	new id;
	if(sscanf(params, "i", id))
	{
	    SendClientMessage(playerid, COLOR_RED, "Use /eject [playerid]");
	    PlayerPlaySound(playerid, SOUND_WRONGCOMMAND, 0.0, 0.0, 0.0);
	}
	else
	{
	    if(!IsPlayerConnected(id))return SendClientMessage(playerid, red, "Invalid player");
		if(!IsPlayerInAnyVehicle(id))return SendClientMessage(playerid, red, "You cannot eject this player!");

		new Float:x, Float:y, Float:z;
		GetPlayerPos(id, x, y, z);

		SetPlayerPos(id, x, y, z + 1.5);

		format(stringo, sizeof stringo, "Admin/Mod {"#COLOR_SYSTEM_FOCUS"}%s{"#COLOR_SYSTEM_REST"} has ejected {"#COLOR_SYSTEM_FOCUS"}%s{"#COLOR_SYSTEM_REST"} from the vehicle", Player[playerid][Nickname], Player[id][Nickname]);
        SendClientMessageToAll(COLOR_SYSTEM, stringo);
        PlayerPlaySound(playerid, SOUND_SUCCESS, 0.0, 0.0, 0.0);
	}
	return true;
}

COMMAND:slap(playerid, params[])
{
    if(!IsPlayerAdminEx(playerid, lAdmin)) return true;
	new id;
	if(sscanf(params, "i", id))
	{
	    SendClientMessage(playerid, COLOR_RED, "Use /slap [playerid]");
	    PlayerPlaySound(playerid, SOUND_WRONGCOMMAND, 0.0, 0.0, 0.0);
	}
	else
	{
	    if(!IsPlayerConnected(id)) return SendClientMessage(playerid, red, "Invalid player");
	    new Float:x, Float:y, Float:z;
	    if(IsPlayerInAnyVehicle(id))
	    {
			GetVehiclePos(GetPlayerVehicleID(id), x, y, z);
			SetVehiclePos(GetPlayerVehicleID(id), x, y, z + 5.5);
		}
		else
		{
			GetPlayerPos(id, x, y, z);
			SetPlayerPos(id, x, y, z + 5.5);
		}

		format(stringo, sizeof stringo, "Admin/Mod {"#COLOR_SYSTEM_FOCUS"}%s{"#COLOR_SYSTEM_REST"} has slapped {"#COLOR_SYSTEM_FOCUS"}%s{"#COLOR_SYSTEM_REST"}", Player[playerid][Nickname], Player[id][Nickname]);
        SendClientMessageToAll(COLOR_SYSTEM, stringo);
        PlayerPlaySound(playerid, SOUND_SUCCESS, 0.0, 0.0, 0.0);
	}
	return true;
}

COMMAND:unmuteall(playerid, params[])
{
    if(!IsPlayerAdminEx(playerid, lNbAdmin)) return true;
	foreach(new i:Player)
	{
	    Player[i][Muted] = false;
	}

	format(stringo, sizeof stringo, "Admin/Mod {"#COLOR_SYSTEM_FOCUS"}%s{"#COLOR_SYSTEM_REST"} has unmuted everyone.", Player[playerid][Nickname]);
    SendClientMessageToAll(COLOR_SYSTEM, stringo);
 	PlayerPlaySound(playerid, SOUND_SUCCESS, 0.0, 0.0, 0.0);
 	return true;
}

COMMAND:muteall(playerid, params[])
{
    if(!IsPlayerAdminEx(playerid, lNbAdmin)) return true;
	foreach(new i:Player)
	{
	    Player[i][Muted] = true;
	}

	format(stringo, sizeof stringo, "Admin/Mod {"#COLOR_SYSTEM_FOCUS"}%s{"#COLOR_SYSTEM_REST"} has muted everyone.", Player[playerid][Nickname]);
    SendClientMessageToAll(COLOR_SYSTEM, stringo);
 	PlayerPlaySound(playerid, SOUND_SUCCESS, 0.0, 0.0, 0.0);
 	return true;
}

COMMAND:dmkick(playerid, params[])
{
	if(!IsPlayerAdminEx(playerid, lNbAdmin)) return true;
	if(isnull(params)) return SendClientMessage(playerid, COLOR_RED, "Use /dmkick [ID or \"All\"]"), PlayerPlaySound(playerid, SOUND_WRONGCOMMAND, 0.0, 0.0, 0.0);
	if(!strcmp(params, "all", true))
	{
	    foreach(new i:Player)
		{
	        if(Player[i][InDm] == -1) continue;
	        MySQLStatus[TotalQuerys] ++; mysql_tquery(g_MySQLConnection, sprintf("UPDATE bestdmplayer SET damage = '%d', kills = '%d' WHERE nickname = '%s' AND dmid = '%d'", Player[i][DDamage], Player[i][DKills], Player[i][Nickname], Player[i][InDm]), "", "");
			Player[i][InDm] = -1;

			SetSpawnInfo(i, playerid, GetPlayerSkinEx(i), Lobby[0] - MAX_RANDOM_SPAWN + random( MAX_RANDOM_SPAWN ), Lobby[1] - MAX_RANDOM_SPAWN + random( MAX_RANDOM_SPAWN ), Lobby[2], Lobby[3], 0, 0, 0, 0, 0, 0);
			SpawnPlayer(i);

			SetPlayerVirtualWorld(i, NORMAL_WORLD);
//            if (!RoundStarted) TextDrawShowForPlayer(i, HintTD);

			SpawnPlayer(i);
	    }
	    format(stringo, sizeof stringo, "Admin/Mod {"#COLOR_SYSTEM_FOCUS"}%s{"#COLOR_SYSTEM_REST"} has kicked everyone from DMs.", Player[playerid][Nickname]);
	}
	else
	{
	    new id = strval(params);
	    if(!IsPlayerConnected(id)) return SendClientMessage(playerid, red, "Invalid ID.");
	    if(Player[id][InDm] == -1)return SendClientMessage(playerid, red, "This player is not in any DM");
		MySQLStatus[TotalQuerys] ++; mysql_tquery(g_MySQLConnection, sprintf("UPDATE bestdmplayer SET damage = '%d', kills = '%d' WHERE nickname = '%s' AND dmid = '%d'", Player[id][DDamage], Player[id][DKills], Player[id][Nickname], Player[id][InDm]), "", "");
		Player[id][InDm] = -1;

		SetSpawnInfo(playerid, id, GetPlayerSkinEx(id), Lobby[0] - MAX_RANDOM_SPAWN + random( MAX_RANDOM_SPAWN ), Lobby[1] - MAX_RANDOM_SPAWN + random( MAX_RANDOM_SPAWN ), Lobby[2], Lobby[3], 0, 0, 0, 0, 0, 0);
		SpawnPlayer(id);

		SetPlayerVirtualWorld(id, NORMAL_WORLD);
//		if (!RoundStarted) TextDrawShowForPlayer(id, HintTD);

		SpawnPlayer(id);
   		format(stringo, sizeof stringo, "Admin/Mod {"#COLOR_SYSTEM_FOCUS"}%s{"#COLOR_SYSTEM_REST"} has kicked {"#COLOR_SYSTEM_FOCUS"}%s{"#COLOR_SYSTEM_REST"} from DM.", Player[playerid][Nickname], Player[id][Nickname]);
	}

	SendClientMessageToAll(COLOR_SYSTEM, stringo);
    PlayerPlaySound(playerid, SOUND_SUCCESS, 0.0, 0.0, 0.0);
	return true;
}

COMMAND:lockdm(playerid, params[])
{
	if (!IsPlayerAdminEx(playerid, lNbAdmin)) return true;//lNbAdmin
	new i, psw[ 20 ];
	if (sscanf(params, "iS[20]", i, psw))
	{
	    SendClientMessage(playerid, COLOR_RED, "Use /lockdm [id] [optional: password]");
	    PlayerPlaySound(playerid, SOUND_WRONGCOMMAND, 0.0, 0.0, 0.0);
	}
	else
	{
		if (i < 0 || i >= MAX_DMS) return SendClientMessage(playerid, red, "Invalid DM ID."), PlayerPlaySound(playerid, SOUND_WRONGCOMMAND, 0.0, 0.0, 0.0);

		if (DMLocked[i])
		{
		    DMLocked[i] = false;
		    DMLocked_Password[i] = "";
		    format(stringo, sizeof stringo, "Admin/Mod {"#COLOR_SYSTEM_FOCUS"}%s{"#COLOR_SYSTEM_REST"} has unlocked DM %d", Player[playerid][Nickname], i);
		}
		else if (!DMLocked[i])
		{
		    DMLocked[i] = true;
			if ( ! isnull ( psw ) )
			{
			    if ( strlen( psw ) > 20 )
				{
			        SendClientMessage( playerid , red , "The length of the password must be lower than 20 chars.");
			        return PlayerPlaySound(playerid, SOUND_WRONGCOMMAND, 0.0, 0.0, 0.0);
			    }
			    if ( strlen( psw ) < 3 )
				{
			        SendClientMessage( playerid , red , "The length of the password must be higher than 3 chars.");
			        return PlayerPlaySound(playerid, SOUND_WRONGCOMMAND, 0.0, 0.0, 0.0);
			    }
				strcpy( DMLocked_Password[i] , psw );
			    format(stringo, sizeof stringo, "Admin/Mod {"#COLOR_SYSTEM_FOCUS"}%s{"#COLOR_SYSTEM_REST"} has locked DM %d with a password.", Player[playerid][Nickname], i);
			}
			else
			{
				format(stringo, sizeof stringo, "Admin/Mod {"#COLOR_SYSTEM_FOCUS"}%s{"#COLOR_SYSTEM_REST"} has locked DM %d", Player[playerid][Nickname], i);
			}
		}

		SendClientMessageToAll(COLOR_SYSTEM, stringo);
	}
    PlayerPlaySound(playerid, SOUND_SUCCESS, 0.0, 0.0, 0.0);
    return true;
}

COMMAND:lockteam(playerid, params[]) {
	new id;
	if (sscanf( params, "k<teamname>", id)) {
		SendClientMessage (playerid, red, "Use: /lockteam [team]");
		format (stringo, sizeof stringo, "Teams: %s (%s), %s (%s), %s (%s), %s (%s), %s (%s)", iTeam [TEAM_A][Name], (iTeam[TEAM_A][tLocked] ? ("Locked") : ("Unlocked")), iTeam [TEAM_B][Name], (iTeam[TEAM_B][tLocked] ? ("Locked") : ("Unlocked")), iTeam [TEAM_REF][Name], (iTeam[TEAM_REF][tLocked] ? ("Locked") : ("Unlocked")), iTeam [TEAM_A_SUB][Name], (iTeam[TEAM_A_SUB][tLocked] ? ("Locked") : ("Unlocked")), iTeam [TEAM_B_SUB][Name], (iTeam[TEAM_B_SUB][tLocked] ? ("Locked") : ("Unlocked")));
		SendClientMessage (playerid, COLOR_SYSTEM, stringo);
		//SendClientMessage (playerid, red, "Teams: %s (%s), %s (%s), %s (%s), %s (%s), %s (%s)", iTeam [TEAM_A][Name], (iTeam[TEAM_A][tLocked] ? ("Locked") : ("Unlocked")), iTeam [TEAM_B][Name], (iTeam[TEAM_B][tLocked] ? ("Locked") : ("Unlocked")), iTeam [TEAM_REF][Name], (iTeam[TEAM_REF][tLocked] ? ("Locked") : ("Unlocked")), iTeam [TEAM_A_SUB][Name], (iTeam[TEAM_A_SUB][tLocked] ? ("Locked") : ("Unlocked")), iTeam [TEAM_B_SUB][Name], (iTeam[TEAM_B_SUB][tLocked] ? ("Locked") : ("Unlocked")));
	}
	else {
	    if (iTeam[id][tLocked]) {
	        iTeam[id][tLocked] = false;
			format(stringo, sizeof stringo, "Admin/Mod {"#COLOR_SYSTEM_FOCUS"}%s{"#COLOR_SYSTEM_REST"} has unlocked team {"#COLOR_SYSTEM_FOCUS"}%s", Player[playerid][Nickname], iTeam[id][Name]);
	    }
	    else {
	        iTeam[id][tLocked] = true;
	        format(stringo, sizeof stringo, "Admin/Mod {"#COLOR_SYSTEM_FOCUS"}%s{"#COLOR_SYSTEM_REST"} has locked team {"#COLOR_SYSTEM_FOCUS"}%s", Player[playerid][Nickname], iTeam[id][Name]);
	    }

	    SendClientMessageToAll(COLOR_SYSTEM, stringo);
	}
	return 1;
}

COMMAND:allowdm(playerid, params[])
{
	if(!IsPlayerAdminEx(playerid, lAdmin)) return true;//lNbAdmin
	new dmid, pid;
	if(sscanf(params, "ii", pid, dmid))
	{
		SendClientMessage(playerid, COLOR_RED, "Use /allowdm [id] [dmid]");
		PlayerPlaySound(playerid, SOUND_WRONGCOMMAND, 0.0, 0.0, 0.0);
	}
	else
	{
	    if (!IsPlayerConnected(pid)) return SendClientMessage(playerid, red, "Invalid player.");
	    if (dmid < 0 || dmid > MAX_DMS)return SendClientMessage(playerid, red, "Invalid DM.");
	    if (!DMLocked[dmid])return SendClientMessage(playerid, red, "Deathmatch must be locked");
	    if (!Player[pid][AllowDM][dmid])
	    {
	        Player[pid][AllowDM][dmid] = true;
	        format(stringo, sizeof stringo, "Admin/Mod {"#COLOR_SYSTEM_FOCUS"}%s{"#COLOR_SYSTEM_REST"} allowed {"#COLOR_SYSTEM_FOCUS"}%s{"#COLOR_SYSTEM_REST"} to enter deathmatch #{"#COLOR_SYSTEM_FOCUS"}%d", Player[playerid][Nickname], Player[pid][Nickname], dmid);
	    }
	    else
	    {
	        Player[pid][AllowDM][dmid] = false;
	        format(stringo, sizeof stringo, "Admin/Mod {"#COLOR_SYSTEM_FOCUS"}%s{"#COLOR_SYSTEM_REST"} disallowed {"#COLOR_SYSTEM_FOCUS"}%s{"#COLOR_SYSTEM_REST"} to enter deathmatch #{"#COLOR_SYSTEM_FOCUS"}%d", Player[playerid][Nickname], Player[pid][Nickname], dmid);
	    }

        SendClientMessageToAll(COLOR_SYSTEM, stringo);
	}
	return true;
}

COMMAND:pause(playerid, params[])
{
	#pragma unused params
	if(!IsPlayerAdminEx(playerid, lNbAdmin)) return true;
	if(!RoundStarted) return SendClientMessage(playerid, COLOR_RED, "The game is not started."), PlayerPlaySound(playerid, SOUND_WRONGCOMMAND, 0.0, 0.0, 0.0);
	if(GamePaused)return SendClientMessage(playerid, COLOR_RED, "The game is already paused."), PlayerPlaySound(playerid, SOUND_WRONGCOMMAND, 0.0, 0.0, 0.0);
	//GamePaused = 1;
//	PausedBy = PAUSED_BY_ADMIN;
	PauseRound ();
	/*
	TextDrawSetString(RoundPaused, "Round ~r~paused");

	if (auto_resumeTimer != Timer:-1) {
		stop auto_resumeTimer;
	}

	foreach(new i:Player)
	{
	    if(Player[i][InGame])
		{
	        TogglePlayerControllable(i, false);
	        TextDrawShowForPlayer(i, RoundPaused);
			// [todo] => aggiungere un suono quando viene usato freeze
	    }
	}
	*/
	format(stringo, sizeof stringo, "{"#COLOR_SYSTEM_FOCUS"}%s{"#COLOR_SYSTEM_REST"} has paused the round.", Player[playerid][Nickname]);
	SendClientMessageToAll(COLOR_SYSTEM, stringo);
    PlayerPlaySound(playerid, SOUND_SUCCESS, 0.0, 0.0, 0.0);
	return true;
}

COMMAND:unpause(playerid, params[])
{
	#pragma unused params
	if(!IsPlayerAdminEx(playerid, lNbAdmin)) return true;
	if(!RoundStarted) return SendClientMessage(playerid, COLOR_RED, "The game is not started."), PlayerPlaySound(playerid, SOUND_WRONGCOMMAND, 0.0, 0.0, 0.0);
	if(!GamePaused) return SendClientMessage(playerid, COLOR_RED, "The round is already unpaused."), PlayerPlaySound(playerid, SOUND_WRONGCOMMAND, 0.0, 0.0, 0.0);
	if(UnPausingRunning) return SendClientMessage(playerid, COLOR_RED, "No :S."), PlayerPlaySound(playerid, SOUND_WRONGCOMMAND, 0.0, 0.0, 0.0);
	format(stringo, sizeof stringo, "{"#COLOR_SYSTEM_FOCUS"}%s{"#COLOR_SYSTEM_REST"} has unpaused the round.", Player[playerid][Nickname]);
	SendClientMessageToAll(COLOR_SYSTEM, stringo);

	UnPauseRound ();
	/*
	UnPausingRunning = true;
//	SetTimer("countdown_unpause", 0, 1000, 4);
	defer countdown_unpause();

	if (auto_resumeTimer != Timer:-1) {
		stop auto_resumeTimer;
	}

	foreach (new i:Player) { if (Player[i][InGame]) PlayerPlaySound(i, 1139, 0.0, 0.0, 0.0);  }

	TextDrawSetString( RoundPaused, "Unpausing... ~r~~h~3~r~ 2 1" );*/
    PlayerPlaySound(playerid, SOUND_SUCCESS, 0.0, 0.0, 0.0);
    return true;
}

stock PauseRound()
{
	if(GamePaused) return true;
	GamePaused = 1;

	if (auto_resumeTimer != Timer:-1) {
		stop auto_resumeTimer;
	}

	foreach(new i:Player)
	{
	    if(Player[i][InGame])
		{
	        TogglePlayerControllable(i, false);
			// [todo] => aggiungere un suono quando viene usato freeze
	    }
	}

	TextDrawSetString(RoundStats[3], sprintf("Round paused at %02d:%02d", RealRMins, RealRSecs));
	return false;
}

stock UnPauseRound()
{
	if (auto_resumeTimer != Timer:-1) {
		stop auto_resumeTimer;
	}

	UnPausingRunning = true;
	defer countdown_unpause();
	foreach (new i:Player) { if (Player[i][InGame]) PlayerPlaySound(i, 1139, 0.0, 0.0, 0.0);  }

	TextDrawSetString(RoundStats[3], "Unpausing... ~r~~h~3~r~ 2 1");
}

timer countdown_unpause[1000]()
{
//	if(GamePaused) return true;
	static
	    seconds = 3;

	seconds --;

	switch (seconds)
	{
		case 3:
		{
			TextDrawSetString( RoundStats[3], "Unpausing... ~r~~h~3~r~ 2 1" );
			defer countdown_unpause();
		}
		case 2:
		{
			TextDrawSetString( RoundStats[3], "Unpausing... ~r~3 ~h~2~r~ 1" );
			defer countdown_unpause();
		}
		case 1:
		{
			TextDrawSetString( RoundStats[3], "Unpausing... ~r~3 2 ~h~1" );
			defer countdown_unpause();
		}
		case 0:
		{
			GamePaused = 0;

			foreach(new i:Player)
			{
				if(Player[i][InGame])
				{
//					PlayerYVote[i] = false;
					TogglePlayerControllable(i, true);
				}
			}

			UnPausingRunning = false;
			seconds = 3;
			// quando spausa il round controlla che si siano giocatori nei team
			defer CheckPlayers();
			//SetTimer("CheckPlayers", DELAY_CHECKPLAYERS, 0);
			//resto
			defer SyncRound();
			TextDrawSetString( RoundStats[3] , sprintf( "%02d:%02d", RealRMins, RealRSecs ));
		//	SetTimer("SyncRound", 1000, 0);
			return true;
		}
	}

	foreach(new i:Player)
  	{
    	if (Player[i][InGame])
      	{
         	PlayerPlaySound(i, 1139, 0.0, 0.0, 0.0);
		}
	}
	return true;
}

COMMAND:resetscores(playerid, params[])
{
	#pragma unused params
	if(!IsPlayerAdminEx(playerid, lNbAdmin)) return true;
	if(RoundStarted) return SendClientMessage(playerid, COLOR_RED, "You cannot use this command now."), PlayerPlaySound(playerid, SOUND_WRONGCOMMAND, 0.0, 0.0, 0.0);
	ResetScores();

	format(stringo, sizeof stringo, "Admin/Mod {"#COLOR_SYSTEM_FOCUS"}%s{"#COLOR_SYSTEM_REST"} has reset the scores.", Player[playerid][Nickname]);
    SendClientMessageToAll(COLOR_SYSTEM, stringo);
   	PlayerPlaySound(playerid, SOUND_SUCCESS, 0.0, 0.0, 0.0);
	return true;
}

stock ResetScores()
{
	foreach(new i:Player)
	{
	    Player[i][Kills] = 0;
	    Player[i][Deaths] = 0;
	    Player[i][Damage] = 0;
	    Player[i][RKills] = 0;
	    Player[i][RDamage] = 0;

		SetPlayerScore(i, 0);

		PlayerTextDrawSetString (i, PlayerInfo[1], "DMG ~b~~h~0~n~~w~Tot. DMG ~b~~h~0");
	}



	iTeam[TEAM_A][RoundWins] = 0;
	iTeam[TEAM_B][RoundWins] = 0;

	if (gConfig[Matchmode] == MATCHMODE_TCWCW)
	{
		SendRconCommand(sprintf("mapname Lobby %s %d:%d %s", iTeam[TEAM_A][Name], iTeam[TEAM_A][RoundWins], iTeam[TEAM_B][RoundWins], iTeam[TEAM_B][Name]));
	}
	else
	{
		SendRconCommand(sprintf("mapname Lobby %d:%d", iTeam[TEAM_A][RoundWins], iTeam[TEAM_B][RoundWins]));
	}

	mysql_tquery(g_MySQLConnection, sprintf("UPDATE stats SET scores = '0,0' WHERE gid = %d", G_ID), "", "");

	PlayingRound = 0;
	RefreshTextGeneralTD();
}

/*
	* commands
*/

COMMAND:stats(playerid, params[])
{
	#pragma unused params
	ShowPlayerDialog( playerid , DIALOG_REQSTATS , DIALOG_STYLE_MSGBOX , "Stats" , "Choose what kind of stats you want to see." , "Players" , "Server " );
    PlayerPlaySound(playerid, SOUND_SUCCESS, 0.0, 0.0, 0.0);
	return true;
}

COMMAND:info(playerid, params[])
{
	SendClientMessage( playerid , 0x3CA3C6AA  , "************ Gamemode settings:");
 	SendClientMessage( playerid , -1          , "Game types: AAD, Arena, TDM, PVP, Gungame, Ints." );
  	format (stringo, sizeof stringo, "Match type: %s | CP: %s (%d sec) | TDM Kills: %d" , ( gConfig[Matchmode] == MATCHMODE_TCWCW ? ( "TCW/CW Mode" ) : ( "No Scores" ) ) , ( gConfig[ UCp ] == 1 ? ( "Enabled" ) : ( "Disabled" ) ) , gConfig[ TCp ] , gConfig[ TDMKills ] );
    SendClientMessage( playerid , -1          , stringo);

   	format(stringo, sizeof stringo, "Round time: %d | Tag Distance: 9.0 ft" ,gConfig[ RTime_Mins ] );
    SendClientMessage( playerid , -1          , stringo);

	format(stringo, sizeof stringo, "Weaponsets: %d | Use /weaponsets per list." , sizeof Weaponsets );
	SendClientMessage( playerid , -1          , stringo);

    format(stringo, sizeof stringo, "Ready start type: %s | Game time: %d | Game Weather: %d" ,GetReadyStartType() , gConfig[ GameTime ] , gConfig[ GameWeather ] );
	SendClientMessage( playerid , -1          , stringo);

   	format(stringo, sizeof stringo, "Chat: %s | Lobby Weapons: %s | Lobby Vehicles: %s" , ( gConfig[ GlobalChat ] == true ? ( "Enabled" ) : ( "Disabled" ) ) , ( gConfig[ LobbyWeapons ] == true ? ( "Enabled" ) : ( "Disabled" ) ), ( gConfig[ LobbyVehicles ] == true ? ( "Enabled" ) : ( "Disabled" ) ) );
	SendClientMessage( playerid , -1          , stringo);

	format(stringo, sizeof stringo, "FPS Limit: %d (%s) | Packetloss Limit: %.1f (%s) | Ping Limit: %d (%s)", gConfig[FpsLimit] , ( gConfig[EFpsLimit] == 1 ? ( "Enabled" ) : ( "Disabled" ) ) , gConfig[PlLimit] , ( gConfig[EPLLimit] == 1 ? ( "Enabled" ) : ( "Disabled" ) ) , gConfig[PingLimit] , ( gConfig[EPingLimit] == 1 ? ( "Enabled" ) : ( "Disabled" ) ) );
    SendClientMessage( playerid , -1          , stringo);
	/*
	new ticks = gettime() - GM_UpTime;

	new d, h, m, s;
 	d = ticks/86400000;
  	h = ticks/3600000 % 24;
   	m = ticks/60000 % 60;
   	s = ticks/1000 % 60;

	format(stringo, sizeof stringo, "Gamemode uptime: %dd %dh %dm %ds", d, h, m, s);
	SendClientMessage( playerid , -1          , stringo);*/
   	return true;
}

COMMAND:weaponsets(playerid, params[])
{
    SendClientMessage( playerid , 0x3CA3C6AA , "** Weaponsets:" );

	for (new i = 0; i < MAX_WEAPON_SETS; ++ i)
	{
	    if (i == INVALID_WEAPON_SET) break;
	    format (stringo, sizeof stringo, "#%d - %s (%d per team) (Limited: %s) (Restrictions: Disabled in %d mode, Enabled in %d mode)" , i , Weaponsets[i][SetName] , Weaponsets[i][Limit] , ( Weaponsets[i][Limited] == true ? ( "Yes" ) : ( "No" ) ) , Weaponsets[i][LimitedForGM] , Weaponsets[i][DisabledForGm] );
        SendClientMessage( playerid , -1 , stringo);
	}
	return true;
}

COMMAND:aweaponsets(playerid, params[])
{
	if (!IsPlayerAdminEx(playerid, lAdmin)) return true;
	new id, tmp[60], limit = 0;

	if(sscanf(params, "is[60]I(1)", id, tmp, limit))
	{
	    SendClientMessage(playerid, red, "Use /aweaponsets [id (/weaponsets)] [disable/limit/limited]");
	}
	else
	{
		if (!strcmp(tmp, "disable", true))
		{
		    if (Weaponsets[id][Enabled])
		    {
		        MySQLStatus[TotalQuerys] ++; mysql_tquery(g_MySQLConnection, sprintf ("UPDATE weaponsets SET enabled = '0' WHERE id = '%d' AND gid = %d", id, G_ID), "", "");
		        Weaponsets[id][Enabled] = false;
		        format (stringo, sizeof stringo, "Admin/Mod {"#COLOR_SYSTEM_FOCUS"}%s{"#COLOR_SYSTEM_REST"} disabled {"#COLOR_SYSTEM_FOCUS"}%s{"#COLOR_SYSTEM_REST"} set." , Player[ playerid ][ Nickname ] , Weaponsets[ id ][ SetName ] );
		    }
		    else
		    {
		        MySQLStatus[TotalQuerys] ++; mysql_tquery(g_MySQLConnection, sprintf ("UPDATE weaponsets SET enabled = '1' WHERE id = '%d' AND gid = %d", id, G_ID), "", "");
		        Weaponsets[id][Enabled] = true;
		        format (stringo, sizeof stringo, "Admin/Mod {"#COLOR_SYSTEM_FOCUS"}%s{"#COLOR_SYSTEM_REST"} enabled {"#COLOR_SYSTEM_FOCUS"}%s{"#COLOR_SYSTEM_REST"} set." , Player[ playerid ][ Nickname ] , Weaponsets[ id ][ SetName ] );
		    }

            SendClientMessageToAll( COLOR_SYSTEM , stringo);
		}
		else if (!strcmp(tmp, "limit", true))
		{
		    if (limit == 0 || limit > MAX_PLAYERS) return SendClientMessage(playerid, red, "Invalid limit");
			Weaponsets[id][Limit] = limit;
		    format (stringo, sizeof stringo, "Admin/Mod {"#COLOR_SYSTEM_FOCUS"}%s{"#COLOR_SYSTEM_REST"} changed {"#COLOR_SYSTEM_FOCUS"}%s{"#COLOR_SYSTEM_REST"} limit to %d." , Player[ playerid ][ Nickname ] , Weaponsets[ id ][ SetName ] , limit );
			SendClientMessageToAll(COLOR_SYSTEM, stringo);
			MySQLStatus[TotalQuerys] ++; mysql_tquery(g_MySQLConnection, sprintf ("UPDATE weaponsets SET mselection = '%d' WHERE id = '%d' AND gid = %d", limit, id, G_ID), "", "");
		}
		else if (!strcmp(tmp, "limited", true))
		{
		    if (Weaponsets[id][Limited])
		    {
		        MySQLStatus[TotalQuerys] ++; mysql_tquery(g_MySQLConnection, sprintf ("UPDATE weaponsets SET limited = '0' WHERE id = '%d' AND gid = %d", id, G_ID), "", "");
		        Weaponsets[id][Limited] = false;
		        format (stringo, sizeof stringo, "Admin/Mod {"#COLOR_SYSTEM_FOCUS"}%s{"#COLOR_SYSTEM_REST"} limited {"#COLOR_SYSTEM_FOCUS"}%s{"#COLOR_SYSTEM_REST"} set." , Player[ playerid ][ Nickname ] , Weaponsets[ id ][ SetName ] );
		    }
		    else
		    {
		        MySQLStatus[TotalQuerys] ++; mysql_tquery(g_MySQLConnection, sprintf ("UPDATE weaponsets SET limited = '1' WHERE id = '%d' AND gid = %d", id, G_ID), "", "");
		        Weaponsets[id][Limited] = true;
		        format (stringo, sizeof stringo, "Admin/Mod {"#COLOR_SYSTEM_FOCUS"}%s{"#COLOR_SYSTEM_REST"} removed {"#COLOR_SYSTEM_FOCUS"}%s{"#COLOR_SYSTEM_REST"} limit." , Player[ playerid ][ Nickname ] , Weaponsets[ id ][ SetName ] );
		    }

		    SendClientMessageToAll( COLOR_SYSTEM , stringo);
		}
		else SendClientMessage(playerid, red, "Use /aweaponsets [id (/weaponsets)] [disable/limit/limited]");
	}
	return true;
}
// rimosso /tstats

COMMAND:kill(playerid, params[])
{
	#pragma unused params
	if(!Player[playerid][InDm])
	{
		SetSpawnInfo(playerid, playerid, GetPlayerSkinEx(playerid), Lobby[0] - MAX_RANDOM_SPAWN + random( MAX_RANDOM_SPAWN ), Lobby[1] - MAX_RANDOM_SPAWN + random( MAX_RANDOM_SPAWN ), Lobby[2], Lobby[3], 0, 0, 0, 0, 0, 0);
	}
	SetPlayerHealth(playerid, 0.0);
	PlayerPlaySound(playerid, SOUND_SUCCESS, 0.0, 0.0, 0.0);
	return true;
}

/**COMMAND:report(playerid, params[])
{
	new report[ 100 ], email[100];

	if(sscanf(params, "s[100]s[100]", report, email))
	{
	    SendClientMessage(playerid, COLOR_SYSTEM, "Please use /report [report] [email]");
	    SendClientMessage(playerid, COLOR_SYSTEM, "Se sei interessato a ricevere aggiornamenti relativi al tuo report, inserisci il tuo indirizzo email.");
	    PlayerPlaySound(playerid, SOUND_WRONG, 0.0, 0.0, 0.0);
	}
	else
	{
	    SendMail("support@s7domina.gel-gaming.co.uk", (email[0] == '\0' ? ("bugreports@sfld.com") : email), "SLFD", "Bug Report", sprintf("%s ha reportato: %s", Player[playerid][Nickname], report));

		SendClientMessage(playerid, COLOR_SYSTEM, "Thanks for your help! Everything will be used to improve the gamemode.");
		PlayerPlaySound(playerid, SOUND_SUCCESS, 0.0, 0.0, 0.0);
	}
	return true;
}
*/
/**
 * Anticheat
 */
//new bool:acStatus = false;
/*
COMMAND:ac(playerid, params[])
{
    if(!IsPlayerAdminEx(playerid, lAdmin)) return true;
    static Timer:AC_START_TIMER;

    if (AC_GetEnabled() == false) {
		SendClientMessageToAll(COLOR_SYSTEM, "Admin/Mod {"#COLOR_SYSTEM_FOCUS"}%s{"#COLOR_SYSTEM_REST"} has enabled the Anticheat.",Player[playerid][Nickname]);
		SendClientMessageToAll(COLOR_SYSTEM, "You have a minute to turn on the anticheat!");

		AC_START_TIMER = defer StartAnticheat();

		GetServerVarAsString("hostname", g_stored_original_name, sizeof(g_stored_original_name));

		SendRconCommand ( sprintf ("hostname %s [AC]", g_stored_original_name) );
	}
	else {
	    AC_Toggle(false);
	    stop AC_START_TIMER;

		SendClientMessageToAll(COLOR_SYSTEM, "Admin/Mod {"#COLOR_SYSTEM_FOCUS"}%s{"#COLOR_SYSTEM_REST"} has disabled the Anticheat.",Player[playerid][Nickname]);

        SendRconCommand ( sprintf ("hostname %s", g_stored_original_name) );
	}
    return true;
}
*/
timer StartAnticheat[60000]() {
    AC_Toggle (true);
    AC_State = STATE_ENABLED;
}

public OnACUpdated(playerid) {
	if(!AC_Running(playerid))
	{
	    //SendClientMessage(playerid, COLOR_SYSTEM, "{"#COLOR_SYSTEM_FOCUS"}You are not running{"#COLOR_SYSTEM_REST"} the United Army Anticheat!");
        _Kick(playerid, GAMEMODE_ID_ARR, "No Anticheat");

		//format (stringo, sizeof stringo, "%s has been kicked from the server! (No Anticheat)", Player[playerid][Nickname]);
	    //SendClientMessageToAll(COLOR_SYSTEM, stringo);

		//SetTimerEx("_RKick", 1000, 0, "i", playerid);
		//defer _RKick(playerid);
	}
	else if(AC_HasTrainer(playerid))
	{
	    //SendClientMessage(playerid, COLOR_SYSTEM, "{"#COLOR_SYSTEM_FOCUS"}You are not allowed{"#COLOR_SYSTEM_REST"} to run trainers!.");
	    //format(stringo, sizeof stringo, "%s has been kicked from the server! (Trainers)", Player[playerid][Nickname]);
     	//SendClientMessageToAll(COLOR_SYSTEM, stringo);

     	_Kick(playerid, GAMEMODE_ID_ARR, "Trainers");

		//SetTimerEx("_RKick", 1000, 0, "i", playerid);
//		defer _RKick(playerid);
	}
	else if(AC_ASI(playerid))
	{
//	    SendClientMessage(playerid, COLOR_SYSTEM, "{"#COLOR_SYSTEM_FOCUS"}You are using{"#COLOR_SYSTEM_REST"} .ASI scripts that are not allowed.");
//	    format(stringo, sizeof stringo, "%s has been kicked from the server! (.ASI Scripts)", Player[playerid][Nickname]);
  //      SendClientMessageToAll(COLOR_SYSTEM, stringo);

        _Kick(playerid, GAMEMODE_ID_ARR, ".ASI Scripts");

	    //SetTimerEx("_RKick", 1000, 0, "i", playerid);
	 //   defer _RKick(playerid);
	}

	return 1;
}

public OnACFileModified(playerid, file[]) {
//	format(stringo, sizeof stringo, "{"#COLOR_SYSTEM_FOCUS"}You have modified{"#COLOR_SYSTEM_REST"} %s which is not allowed on this server!", file);
//    SendClientMessage(playerid, COLOR_SYSTEM, stringo);

// 	format(stringo, sizeof stringo, "%s has been kicked from the server! (File: %s modified)", Player[playerid][Nickname], file);
//    SendClientMessageToAll(COLOR_SYSTEM, stringo);

    _Kick(playerid, GAMEMODE_ID_ARR, "Modified File", file);

    //SetTimerEx("_RKick", 1000, 0, "i", playerid);
//    defer _RKick(playerid);
	return 1;
}

/*
	* game commands
*/

COMMAND:acar(playerid, params[])
{
	if(!IsPlayerAdminEx(playerid, lAdmin)) return true;
	new id;
	if(GetPlayerInterior(playerid) != 0) return SendClientMessage(playerid, COLOR_RED, "You cannot spawn vehicles in interiors."), PlayerPlaySound(playerid, SOUND_WRONGCOMMAND, 0.0, 0.0, 0.0);

	if(InSpec[playerid]!=-1) return SendClientMessage(playerid, red, "You cannot use this command now!"), PlayerPlaySound(playerid, SOUND_WRONGCOMMAND, 0.0, 0.0, 0.0);
	if(IsPlayerInAnyVehicle(playerid) && GetPlayerVehicleSeat(playerid) != 0) return SendClientMessage(playerid, COLOR_RED, "Error: You are already on a vehicle!"), PlayerPlaySound(playerid, SOUND_WRONGCOMMAND, 0.0, 0.0, 0.0), true;

	if(sscanf(params, "k<vehiclex>", id) || id == -1)
	{
		format(stringo, sizeof stringo, "Vehicle %s not found.", params);
		SendClientMessage(playerid, COLOR_RED, stringo);
		PlayerPlaySound(playerid, SOUND_WRONGCOMMAND, 0.0, 0.0, 0.0);
		return true;
	}

	if(id == 425 || id == 432 || id == 520 || id == 469 || id == 476)return SendClientMessage(playerid, COLOR_RED, "You cannot spawn this vehicle."), PlayerPlaySound(playerid, SOUND_WRONGCOMMAND, 0.0, 0.0, 0.0);

	new Float:x, Float:y, Float:z, Float:a;

	GetPlayerPos(playerid, x, y, z);
	GetPlayerFacingAngle(playerid, a);

	if (IsPlayerInAnyVehicle(playerid))
	{
	    SetPlayerPos(playerid, x, y, z + 1.5);
	    DestroyVehicleEx(GetPlayerVehicleID(playerid));
	}

	new veh =  Label_AddStaticVehicleEx(id, x, y, z, a, (Player[playerid][InGame] == 1 ? (Player[playerid][Team] == TEAM_A ? 108 : 86 ) : -1 ) , (Player[playerid][InGame] == 1 ? 1 : -1), GetPlayerVirtualWorld(playerid));
	SetVehicleVirtualWorld(veh, GetPlayerVirtualWorld(playerid));
	PutPlayerInVehicle(playerid, veh, 0);

	if ( IsNosCompatible( id ) )
	{
	    AddVehicleComponent(veh, 1010);
	}

	if (id == 560)
	{
	    AddVehicleComponent( veh , 1026 );
	    AddVehicleComponent( veh , 1029 );
		AddVehicleComponent( veh , ( random(2) == 0 ? 1138 : 1139 ) );
	}

	ChangeVehiclePaintjobEx( veh , random( 3 ) );

	if( RoundStarted && Player[playerid][InGame] )
	{
		foreach(new i:Player)
		{
			if(TeamRole[Player[i][Team]] == DEFENDERS)
			{
   				SetVehicleParamsForPlayer(veh, i, 0, 1);
			}
		}
	}

	format(stringo, sizeof stringo, "You spawned a(n) {"#COLOR_SYSTEM_FOCUS"}%s", aVehicleNames[id - MIN_VEHI_ID]);
	SendClientMessage(playerid, COLOR_SYSTEM, stringo);
    PlayerPlaySound(playerid, SOUND_SUCCESS, 0.0, 0.0, 0.0);
	return true;
}

COMMAND:v(playerid, params[])
{
	new id;
	if(GetPlayerInterior(playerid) != 0) return SendClientMessage(playerid, COLOR_RED, "You cannot spawn vehicles in interiors."), PlayerPlaySound(playerid, SOUND_WRONGCOMMAND, 0.0, 0.0, 0.0), true;

	if(InSpec[playerid]!=-1) return SendClientMessage(playerid, red, "You cannot use this command now!"), PlayerPlaySound(playerid, SOUND_WRONGCOMMAND, 0.0, 0.0, 0.0), true;
	if(IsPlayerInAnyVehicle(playerid) && GetPlayerVehicleSeat(playerid) != 0) return SendClientMessage(playerid, COLOR_RED, "Error: You are already on a vehicle!"), PlayerPlaySound(playerid, SOUND_WRONGCOMMAND, 0.0, 0.0, 0.0), true;

	if(sscanf(params, "k<vehiclex>", id) || id == -1)
	{
		format(stringo, sizeof stringo, "Vehicle %s not found.", params);
		SendClientMessage(playerid, COLOR_RED, stringo);
		PlayerPlaySound(playerid, SOUND_WRONGCOMMAND, 0.0, 0.0, 0.0);
		return true;
	}

	if(id == 425 || id == 432 || id == 520 || id == 469 || id == 476)return SendClientMessage(playerid, COLOR_RED, "You cannot spawn this vehicle."), PlayerPlaySound(playerid, SOUND_WRONGCOMMAND, 0.0, 0.0, 0.0);

	if(Player[playerid][InGame])
	{
        Player[playerid][lastSpawnedVeh] = -1;

	    if(Gaming == GAMETYPE_ARENA || Gaming == GAMETYPE_TDM || Gaming == GAMETYPE_GUNGAME)
	    {
	        SendClientMessage(playerid, COLOR_RED, "You cannot spawn vehicles during arenas or TDMs.");
			PlayerPlaySound(playerid, SOUND_WRONGCOMMAND, 0.0, 0.0, 0.0);
	        return true;
	    }

		if(TeamRole[Player[playerid][Team]] != ATTACKERS)
		{
			SendClientMessage(playerid, COLOR_RED, "You cannot spawn vechicles when you are defending!"), PlayerPlaySound(playerid, SOUND_WRONGCOMMAND, 0.0, 0.0, 0.0);
			PlayerPlaySound(playerid, SOUND_WRONGCOMMAND, 0.0, 0.0, 0.0);
			return true;
		}

		if(!IsPlayerInRangeOfPoint(playerid, 150.0, eScenario[SpawnAttackers][0] - RANDOM_SPAWN_ROUND + random(RANDOM_SPAWN_ROUND), eScenario[SpawnAttackers][1] - RANDOM_SPAWN_ROUND + random(RANDOM_SPAWN_ROUND), eScenario[SpawnAttackers][2]))  return SendClientMessage(playerid, COLOR_RED, "You are too far from your spawn!"), PlayerPlaySound(playerid, SOUND_WRONGCOMMAND, 0.0, 0.0, 0.0);

		if ((id==449||id==537||id==538||id==570||id==569))
		{
			SendClientMessage(playerid, COLOR_RED, "You cannot spawn this vehicle in game.");
			PlayerPlaySound(playerid, SOUND_WRONGCOMMAND, 0.0, 0.0, 0.0);
			return true;
		}
	}
	else
	{
 		if(Player[playerid][InDm]!=-1)
 	   	{
      		SendClientMessage(playerid, COLOR_RED, "You cannot spawn vehicles in dms.");
		 	PlayerPlaySound(playerid, SOUND_WRONGCOMMAND, 0.0, 0.0, 0.0);
     		return true;
  	  	}

   	 	if (!gConfig[LobbyVehicles])
    	{
	    	SendClientMessage(playerid, COLOR_RED, "Lobby vehicles disabled.");
			PlayerPlaySound(playerid, SOUND_WRONGCOMMAND, 0.0, 0.0, 0.0);
  	      	return true;
    	}

		/*
	    if (IsValidVehicle(Player[playerid][lastSpawnedVeh]))
	    	DestroyVehicleEx(Player[playerid][lastSpawnedVeh]);*/
	}

	new Float:x, Float:y, Float:z, Float:a;

	GetPlayerPos(playerid, x, y, z);
	GetPlayerFacingAngle(playerid, a);

	if (IsPlayerInAnyVehicle(playerid))
	{
	    SetPlayerPos(playerid, x, y, z + 1.5);
	    DestroyVehicleEx(GetPlayerVehicleID(playerid));
	}

	new veh = Label_AddStaticVehicleEx(id, x, y, z, a, (Player[playerid][InGame] == 1 ? (Player[playerid][Team] == TEAM_A ? 175 : 108 ) : -1 ) , (Player[playerid][InGame] == 1 ? 1 : -1), GetPlayerVirtualWorld(playerid));
	SetVehicleVirtualWorld(veh, GetPlayerVirtualWorld(playerid));
	PutPlayerInVehicle(playerid, veh, 0);

	Player[playerid][lastSpawnedVeh] = veh;

	if ( IsNosCompatible( id ) )
	{
	    AddVehicleComponent(veh, 1010);
	}

	if (id == 560)
	{
	    AddVehicleComponent( veh , 1026 );
	    AddVehicleComponent( veh , 1029 );
		AddVehicleComponent( veh , ( random(2) == 0 ? 1138 : 1139 ) );
	}

	ChangeVehiclePaintjobEx( veh , random( 3 ) );

	if( RoundStarted && Player[playerid][InGame] )
	{
		foreach(new i:Player)
		{
			if(TeamRole[Player[i][Team]] == DEFENDERS)
			{
   				SetVehicleParamsForPlayer(veh, i, 0, 1);
			}
		}
	}

	format(stringo, sizeof stringo, "You spawned a(n) {"#COLOR_SYSTEM_FOCUS"}%s", aVehicleNames[id - MIN_VEHI_ID]);
	SendClientMessage(playerid, COLOR_SYSTEM, stringo);
    PlayerPlaySound(playerid, SOUND_SUCCESS, 0.0, 0.0, 0.0);
	return true;
}

COMMAND:dvehicles(playerid, params[])
{
	if(!IsPlayerAdminEx(playerid, lAdmin)) return true;

	for (new i = 0; i < MAX_VEHICLES; i++)
	{
	    if (IsValidVehicle(i) && iVeh[i][Created] && GetVehicleVirtualWorld(i) == NORMAL_WORLD)
	    {
			// Maybe useless double check
			// But why call a local function
	        DestroyVehicleEx (i);
	    }
	}

	format (stringo, sizeof stringo, "Admin/Mod {"#COLOR_SYSTEM_FOCUS"}%s{"#COLOR_SYSTEM_REST"} has destroyed all vehicles.",Player[playerid][Nickname]);
    SendClientMessageToAll(COLOR_SYSTEM,stringo);
	return true;
}

COMMAND:test(playerid, params[])
{
 //   MostraWeaponset(playerid);
}

COMMAND:gun(playerid, params[])
{
	if (Player[playerid][InGame]) return SendClientMessage(playerid , red , "You cannot use this command now."),PlayerPlaySound(playerid, SOUND_WRONGCOMMAND, 0.0, 0.0, 0.0);
	if (!gConfig[LobbyWeapons]) return SendClientMessage(playerid , red , "Lobby Weapons disabled."),PlayerPlaySound(playerid, SOUND_WRONGCOMMAND, 0.0, 0.0, 0.0);
	if (Player[playerid][InDm] != -1) return SendClientMessage(playerid , red , "You cannot use this command now."),PlayerPlaySound(playerid, SOUND_WRONGCOMMAND, 0.0, 0.0, 0.0);

	new szString[ 600 ], x = 0;
	for (new i = 1; i < sizeof aWeaponNames; i++)
	{
	    if (i == 19 || i == 20 || i == 21 || i == 0 || i == 39 || i == 37 || i == 38 || i == 39 || i == 40 || i > 46 || i == 35 || i == 36) continue;

	    strcat(szString, sprintf( "#%d - %s\n" , i , aWeaponNames[i] ) );
	    PlayerGunMenu_Arr [playerid][x] = i;
	    //SetPVarInt(playerid, sprintf( "gunmenu_%d" , x ) , i );
	    x++;
	}

	ShowPlayerDialog(playerid, DIALOG_GUN, DIALOG_STYLE_LIST, "Guns", szString, "Take", "Close");
	return true;
}

COMMAND:getgun(playerid, params[])
{
	if (Player[playerid][InGame]) return SendClientMessage(playerid , red , "You cannot use this command now."),PlayerPlaySound(playerid, SOUND_WRONGCOMMAND, 0.0, 0.0, 0.0);
	if (!gConfig[LobbyWeapons]) return SendClientMessage(playerid , red , "Lobby Weapons disabled."),PlayerPlaySound(playerid, SOUND_WRONGCOMMAND, 0.0, 0.0, 0.0);
	if (Player[playerid][InDm] != -1) return SendClientMessage(playerid , red , "You cannot use this command now."),PlayerPlaySound(playerid, SOUND_WRONGCOMMAND, 0.0, 0.0, 0.0);
	if (isnull(params)) return SendClientMessage(playerid , red , "Use /getgun [weapon / weaponset-id /weaponsets]" ),PlayerPlaySound(playerid, SOUND_WRONGCOMMAND, 0.0, 0.0, 0.0);
	if(InSpec[playerid]!=-1) return SendClientMessage(playerid, red, "You cannot use this command now!"), PlayerPlaySound(playerid, SOUND_WRONGCOMMAND, 0.0, 0.0, 0.0);

	new id = strval( params );

	if (id > 0 && id < INVALID_WEAPON_SET)
	{
	    GivePlayerWeapon( playerid , Weaponsets[ id ][ ID1 ] , 9999 );
	    GivePlayerWeapon( playerid , Weaponsets[ id ][ ID2 ] , 9999 );

	    Player[ playerid ][ Weapons ][ GetWeaponSlot(Weaponsets[ id ][ ID1 ]) ] = Weaponsets[ id ][ ID1 ];
	    Player[ playerid ][ Weapons ][ GetWeaponSlot(Weaponsets[ id ][ ID2 ]) ] = Weaponsets[ id ][ ID2 ];

	    SetPlayerArmedWeapon( playerid , Weaponsets[ id ][ ID1 ] );

	    format(stringo, sizeof stringo, "* Weaponset %s was given to you." , Weaponsets[ id ][ SetName ] );
        SendClientMessage( playerid , green , stringo);

		PlayerPlaySound(playerid, SOUND_SUCCESS, 0.0, 0.0, 0.0);

		if (Player[playerid][Loggen])
		{
			new weaps[ 30 ];
			for (new i = 0; i < 13; i++)
			{
			    strcat(weaps, sprintf("%d,", Player[playerid][Weapons][i]));
			}

			MySQLStatus[TotalQuerys] ++; mysql_tquery(g_MySQLConnection, sprintf("UPDATE users SET weapons = '%s' WHERE nickname = '%s'", weaps, Player[playerid][Nickname]), "", "");
		}
		return true;
	}

 	id = GetWeaponModelIDFromName( params );

	if (id == -1)
	{
		format(stringo, sizeof stringo, "Weapon %s not found." , params );
		SendClientMessage(playerid , red , stringo);
		return true;
	}

	if (id == 39 || id == 37 || id == 38 || id == 39 || id == 40 || id == 44 || id == 45  || id > 46 || id == 35 || id == 36)
	{
		format(stringo, sizeof stringo, "Weapon %s is not valid." , params );
		SendClientMessage(playerid , red , stringo);
		return true;
	}

	Player[ playerid ][ Weapons ][ GetWeaponSlot(id) ] = id;
	format(stringo, sizeof stringo, "* Weapon: %s was given to you." , aWeaponNames[ id ] );
    SendClientMessage( playerid , green , stringo);

	GivePlayerWeapon( playerid , id , 900 );
	SetPlayerArmedWeapon( playerid , id );

	PlayerPlaySound(playerid, SOUND_SUCCESS, 0.0, 0.0, 0.0);
	if (Player[playerid][Loggen])
	{
		new weaps[ 30 ];
		for (new i = 0; i < 13; i++)
		{
		    strcat(weaps, sprintf("%d,", Player[playerid][Weapons][i]));
		}

		MySQLStatus[TotalQuerys] ++; mysql_tquery(g_MySQLConnection, sprintf("UPDATE users SET weapons = '%s' WHERE nickname = '%s'", weaps, Player[playerid][Nickname]), "", "");
	}
	return true;
}

COMMAND:disarm(playerid, params[])
{
	if (Player[playerid][InGame]) return SendClientMessage(playerid , red , "You cannot use this command now."),PlayerPlaySound(playerid, SOUND_WRONGCOMMAND, 0.0, 0.0, 0.0);
	if (Player[playerid][InDm] != -1) return SendClientMessage(playerid , red , "You cannot use this command now."),PlayerPlaySound(playerid, SOUND_WRONGCOMMAND, 0.0, 0.0, 0.0);

	for (new i = 0; i < 13 ; ++ i)
	{
	    Player[ playerid ][ Weapons ][ i ] = 0;
	}

	ResetPlayerWeapons( playerid );
	SendClientMessage(playerid, COLOR_SYSTEM , "You have disarmed yourself." );
    PlayerPlaySound(playerid, SOUND_SUCCESS, 0.0, 0.0, 0.0);

	if (Player[playerid][Loggen])
	{
		new weaps[ 30 ];
		for (new i = 0; i < 13; i++)
		{
		    strcat(weaps, sprintf("%d,", Player[playerid][Weapons][i]));
		}

		MySQLStatus[TotalQuerys] ++; mysql_tquery(g_MySQLConnection, sprintf("UPDATE users SET weapons = '%s' WHERE nickname = '%s'", weaps, Player[playerid][Nickname]), "", "");
	}

	return true;
}

/*
	* admin
*/

COMMAND:lock(playerid, params[])
{
	if(!IsPlayerAdminEx(playerid, lAdmin)) return true;
	if(isnull(params)) return SendClientMessage(playerid, red, "Use /lock [password]"), PlayerPlaySound(playerid, SOUND_WRONGCOMMAND, 0.0, 0.0, 0.0);
	if(params[0]=='0'&&params[1]=='\0')return SendClientMessage(playerid, red, "Invalid password."), PlayerPlaySound(playerid, SOUND_WRONGCOMMAND, 0.0, 0.0, 0.0);
	if(strlen(params) >= 20)return SendClientMessage(playerid, red, "Password cannot be more than 20 chars."), PlayerPlaySound(playerid, SOUND_WRONGCOMMAND, 0.0, 0.0, 0.0);

	SendClientMessageToAll(-1, "");

	SendClientMessageToAll(COLOR_SYSTEM, "**********************************");
	SendClientMessageToAll(-1, "");

	if(strlen(Srv_Password)>0)
	{
		strdel(Srv_Password, 0, sizeof(Srv_Password));
		format (stringo, sizeof stringo, "Admin/Mod {"#COLOR_SYSTEM_FOCUS"}%s{"#COLOR_SYSTEM_REST"} has changed server password. New Password: {"#COLOR_SYSTEM_FOCUS"}%s", Player[playerid][Nickname],params);
	}
	else
	{
		format (stringo, sizeof stringo, "Admin/Mod {"#COLOR_SYSTEM_FOCUS"}%s{"#COLOR_SYSTEM_REST"} has locked the server. Password: {"#COLOR_SYSTEM_FOCUS"}%s", Player[playerid][Nickname], params);
	}

    SendClientMessageToAll(COLOR_SYSTEM, stringo);

	SendClientMessageToAll(-1, "");
	SendClientMessageToAll(COLOR_SYSTEM, "**********************************");

	SendClientMessageToAll(-1, "");

	SendRconCommand(sprintf("password %s", params));
	strcat(Srv_Password, params);

    PlayerPlaySound(playerid, SOUND_SUCCESS, 0.0, 0.0, 0.0);
	return true;
}

COMMAND:unlock(playerid, params[])
{
	if(!IsPlayerAdminEx(playerid, lAdmin)) return true;

	SendClientMessageToAll(-1, "");

	SendClientMessageToAll(COLOR_SYSTEM, "**********************************");
	SendClientMessageToAll(-1, "");

	format(stringo, sizeof stringo, "Admin/Mod {"#COLOR_SYSTEM_FOCUS"}%s{"#COLOR_SYSTEM_REST"} has unlocked the server.",Player[playerid][Nickname]);
    SendClientMessageToAll(COLOR_SYSTEM, stringo);

 	SendClientMessageToAll(-1, "");
	SendClientMessageToAll(COLOR_SYSTEM, "**********************************");

	SendClientMessageToAll(-1, "");

	SendRconCommand("password 0");
    strdel(Srv_Password, 0, strlen(Srv_Password));
    PlayerPlaySound(playerid, SOUND_SUCCESS, 0.0, 0.0, 0.0);
	return true;
}

COMMAND:delvotes(playerid, params[])
{
    if(!IsPlayerAdminEx(playerid, lAdmin)) return true;
	if(StartingVoting == Timer:-1)
	    return SendClientMessage(playerid, red, "No votes to delete!");
	else
	{
	    stop StartingVoting;
		StartingVoting = Timer:-1;

		for (new i = 0; i < sizeof(VotesRunning); i++)
		{
		    if (VotesRunning[i][Started] == false) continue;
		    if (VotesRunning[i][Votetype] == VOTETYPE_STARTBASE || VotesRunning[i][Votetype] == VOTETYPE_STARTTDM || VotesRunning[i][Votetype] == VOTETYPE_STARTARENA || VotesRunning[i][Votetype] == VOTETYPE_STARTINT || VotesRunning[i][Votetype] == VOTETYPE_STARTGUNGAME)
		    {
			    VotesRunning[i][Started] 			= false;
			    VotesRunning[i][Votes]   			= 0;
				VotesRunning[i][VoteInformations]   = -1;
			    VotesRunning[i][Votetype]   		= VOTETYPE_NULL;
			    VotesRunning[i][VoteStarter]   		= INVALID_PLAYER_ID;
			}
		}

		format (stringo, sizeof stringo, "Admin/Mod {"#COLOR_SYSTEM_FOCUS"}%s{"#COLOR_SYSTEM_REST"} has deleted all votes.",Player[playerid][Nickname]);
        SendClientMessageToAll(COLOR_SYSTEM,stringo);
	}

	PlayerPlaySound(playerid, SOUND_SUCCESS, 0.0, 0.0, 0.0);
	return true;
}
/*
enum VoteTypes
{
	VOTETYPE_NULL,
	VOTETYPE_RESETSCORES,
	VOTETYPE_STARTBASE,
	VOTETYPE_STARTARENA,
	VOTETYPE_STARTINT,
	VOTETYPE_PLAYERKICK,
	VOTETYPE_STARTGUNGAME
}
*/

COMMAND:lockvote(playerid, params[])
{
	if(!IsPlayerAdminEx(playerid, lNbAdmin)) return true;
	new v;
	if(sscanf (params, "k<lockvotes>", v))
	{
 		SendClientMessage(playerid, red, "Use /lockvote [bases,arene,tdm,interior,gungame,resetscores]");
	}
	else
	{
	    if (v == -1) return SendClientMessage(playerid, red, "Use /lockvote [bases,arene,tdm,interior,gungame,resetscores]");
	    if (VoteTypeEnabled[v])
	    {
	        format(stringo, sizeof stringo, "Admin/Mod {"#COLOR_SYSTEM_FOCUS"}%s{"#COLOR_SYSTEM_REST"} has disabled %s vote.", Player[playerid][Nickname], params);
	        VoteTypeEnabled[v] = false;
		}
	    else
	    {
	        format(stringo, sizeof stringo, "Admin/Mod {"#COLOR_SYSTEM_FOCUS"}%s{"#COLOR_SYSTEM_REST"} has enabled %s vote.", Player[playerid][Nickname], params);
	        VoteTypeEnabled[v] = true;
		}

		SendClientMessage(playerid, COLOR_SYSTEM, stringo);
	}

	PlayerPlaySound(playerid, SOUND_SUCCESS, 0.0, 0.0, 0.0);
	return true;
}

SSCANF:lockvotes(string[])
{
	if (!strcmp(string, "bases", true)) return _:VOTETYPE_STARTBASE;
	else if (!strcmp(string, "arene", true)) return _:VOTETYPE_STARTARENA;
	else if (!strcmp(string, "tdm", true)) return _:VOTETYPE_STARTTDM;
	else if (!strcmp(string, "interior", true)) return _:VOTETYPE_STARTINT;
	else if (!strcmp(string, "gungame", true)) return _:VOTETYPE_STARTGUNGAME;
	else if (!strcmp(string, "resetscores", true)) return _:VOTETYPE_RESETSCORES;
	return -1;
}

COMMAND:delacc(playerid, params[])
{
    if(!IsPlayerAdminEx(playerid, lAdmin)) return true;
	MySQLStatus[TotalQuerys] ++; mysql_tquery(g_MySQLConnection, sprintf ("SELECT NULL FROM users WHERE nickname = '%s'", params), "OnDeleteAccountExist", "is", playerid, params);
	return true;
}

forward OnDeleteAccountExist(p, user[]);
public OnDeleteAccountExist(p, user[])
{
	new rows, fields;
	cache_get_data(rows, fields);

	if (rows)
	{
		MySQLStatus[TotalQuerys] ++; mysql_tquery(g_MySQLConnection, sprintf("DELETE FROM users WHERE nickname = '%s'", user), "", "");
		format (stringo, sizeof stringo, "Admin/Mod {"#COLOR_SYSTEM_FOCUS"}%s{"#COLOR_SYSTEM_REST"} deleted {"#COLOR_SYSTEM_FOCUS"}%s{"#COLOR_SYSTEM_REST"}'s account.", Player[p][Nickname], user);
  		SendClientMessageToAll(COLOR_SYSTEM, stringo);
	}
	else
	{
		format (stringo, sizeof stringo, "Account %s not found.", user);
		SendClientMessage(p, red, stringo);
	}
}

COMMAND:restoreall(playerid, params[])
{
	#pragma unused params
	if(!IsPlayerAdminEx(playerid, lNbAdmin)) return true;
	if(Player[playerid][InGame])
	{
	    foreach(new i:Player)
		{
	        if(!Player[i][InGame]) continue;
	        SetPlayerHealth(i, 100);
	        if(gConfig[GameMode] != GAMEMODE_NOCBUG && Gaming != GAMETYPE_FIGHT && Gaming != GAMETYPE_FIGHT)
	        	SetPlayerArmour(i, 100);
	    }
	    format (stringo, sizeof stringo, "Admin/Mod {"#COLOR_SYSTEM_FOCUS"}%s{"#COLOR_SYSTEM_REST"} has restored health and armour of all players in-game.", Player[playerid][Nickname]);
	}
	else
	{
	    foreach(new i:Player)
		{
	        SetPlayerHealth(i, 100);
	        if(gConfig[GameMode] != GAMEMODE_NOCBUG && Gaming != GAMETYPE_FIGHT && Gaming != GAMETYPE_FIGHT)
	        	SetPlayerArmour(i, 100);
	    }
	    format (stringo, sizeof stringo, "Admin/Mod {"#COLOR_SYSTEM_FOCUS"}%s{"#COLOR_SYSTEM_REST"} has restored everyone's health and armour.", Player[playerid][Nickname]);
	}

	SendClientMessageToAll(COLOR_SYSTEM, stringo);
    PlayerPlaySound(playerid, SOUND_SUCCESS, 0.0, 0.0, 0.0);
	return true;
}

COMMAND:healall(playerid, params[])
{
    #pragma unused params
    if(!IsPlayerAdminEx(playerid, lNbAdmin)) return true;
    new hp = 100;
    sscanf (params, "I(100)", hp);

	if(Player[playerid][InGame])
	{
	    foreach(new i:Player)
		{
	        if(!Player[i][InGame]) continue;
	        SetPlayerHealth(i, hp);
	    }
	    format(stringo, sizeof stringo, "Admin/Mod {"#COLOR_SYSTEM_FOCUS"}%s{"#COLOR_SYSTEM_REST"} has set health of all in-game players to %d.", Player[playerid][Nickname], hp);
	}
	else
	{
	    foreach(new i:Player)
		{
	        SetPlayerHealth(i, hp);
	    }

	    format(stringo, sizeof stringo, "Admin/Mod {"#COLOR_SYSTEM_FOCUS"}%s{"#COLOR_SYSTEM_REST"} has set everyone's health to %d.", Player[playerid][Nickname], hp);
	}

	SendClientMessageToAll(COLOR_SYSTEM, stringo);
    PlayerPlaySound(playerid, SOUND_SUCCESS, 0.0, 0.0, 0.0);
	return true;
}

COMMAND:armourall(playerid, params[])
{
    #pragma unused params
    if(!IsPlayerAdminEx(playerid, lNbAdmin)) return true;
    new hp = 100;
    sscanf (params, "I(100)", hp);

	if(Player[playerid][InGame])
	{
        if(gConfig[GameMode] == GAMEMODE_NOCBUG || Gaming == GAMETYPE_FIGHT || Gaming == GAMETYPE_FIGHT) return SendClientMessage(playerid, red, "You cannot use this command while NoCbug mode is enabled or while you are playing a fight/gungame."), PlayerPlaySound(playerid, SOUND_WRONG, 0.0, 0.0, 0.0);
	    foreach(new i:Player)
		{
	        if(!Player[i][InGame]) continue;
	        SetPlayerArmour(i, hp);
	    }
	    format(stringo, sizeof stringo, "Admin/Mod {"#COLOR_SYSTEM_FOCUS"}%s{"#COLOR_SYSTEM_REST"} has set the armour of all players in-game to %d.", Player[playerid][Nickname], hp);
	}
	else
	{
	    foreach(new i:Player)
		{
	        SetPlayerArmour(i, hp);
	    }
	    format(stringo, sizeof stringo, "Admin/Mod {"#COLOR_SYSTEM_FOCUS"}%s{"#COLOR_SYSTEM_REST"} has set everyone's armour to %d.", Player[playerid][Nickname], hp);
	}

	SendClientMessageToAll(COLOR_SYSTEM, stringo);
    PlayerPlaySound(playerid, SOUND_SUCCESS, 0.0, 0.0, 0.0);
	return true;
}

COMMAND:sethealth(playerid, params[])
{
    if(!IsPlayerAdminEx(playerid, lNbAdmin)) return true;
    new id, val;
    if(sscanf(params, "ii", id, val))
    {
        SendClientMessage(playerid, red, "Use /sethealth [playerid] [health]");
		PlayerPlaySound(playerid, SOUND_WRONGCOMMAND, 0.0, 0.0, 0.0);
    }
    else
    {
		if(!IsPlayerConnected(id))return SendClientMessage(playerid, red, "Not connected player."), PlayerPlaySound(playerid, SOUND_WRONGCOMMAND, 0.0, 0.0, 0.0);
		if(val > 100)return SendClientMessage(playerid, red, "Health cannot be higher than 100 hps."), PlayerPlaySound(playerid, SOUND_WRONGCOMMAND, 0.0, 0.0, 0.0);

		SetPlayerHealth(id, val);
		format (stringo, sizeof stringo, "Admin/Mod {"#COLOR_SYSTEM_FOCUS"}%s{"#COLOR_SYSTEM_REST"} has set {"#COLOR_SYSTEM_FOCUS"}%s{"#COLOR_SYSTEM_REST"}'s health to {"#COLOR_SYSTEM_FOCUS"}%d", Player[playerid][Nickname], Player[id][Nickname], val);
        SendClientMessageToAll(COLOR_SYSTEM, stringo);
	    PlayerPlaySound(playerid, SOUND_SUCCESS, 0.0, 0.0, 0.0);
	}
	return true;
}

COMMAND:setarmour(playerid, params[])
{
    if(!IsPlayerAdminEx(playerid, lNbAdmin)) return true;
    new id, val;
    if(sscanf(params, "ii", id, val))
    {
        SendClientMessage(playerid, red, "Use /setarmour [playerid] [armour]");
		PlayerPlaySound(playerid, SOUND_WRONGCOMMAND, 0.0, 0.0, 0.0);
    }
    else
    {
		if(!IsPlayerConnected(id))return SendClientMessage(playerid, red, "Not connected player."), PlayerPlaySound(playerid, SOUND_WRONGCOMMAND, 0.0, 0.0, 0.0);
		if(val > 100)return SendClientMessage(playerid, red, "Armour cannot be higher than 100 hps."), PlayerPlaySound(playerid, SOUND_WRONGCOMMAND, 0.0, 0.0, 0.0);
		SetPlayerArmour(id, val);
		format (stringo, sizeof stringo, "Admin/Mod {"#COLOR_SYSTEM_FOCUS"}%s{"#COLOR_SYSTEM_REST"} has set {"#COLOR_SYSTEM_FOCUS"}%s{"#COLOR_SYSTEM_REST"}'s armour to {"#COLOR_SYSTEM_FOCUS"}%d", Player[playerid][Nickname], Player[id][Nickname], val);
        SendClientMessageToAll(COLOR_SYSTEM, stringo);
	    PlayerPlaySound(playerid, SOUND_SUCCESS, 0.0, 0.0, 0.0);
	}
	return true;
}

COMMAND:changenotice(playerid, params[])
{
    if(!IsPlayerAdminEx(playerid, lAdmin)) return true;
    if(sscanf(params, "s[100]", notice))
    {
        SendClientMessage(playerid, red, "Use /changenotice <notice>");
		PlayerPlaySound(playerid, SOUND_WRONGCOMMAND, 0.0, 0.0, 0.0);
    }
    else
    {
		SendClientMessageToAll(COLOR_LIGHTBLUE, sprintf( "(NOTICE) %s" , notice ) );
    }
    MySQLStatus[TotalQuerys] ++; mysql_tquery(g_MySQLConnection, sprintf("UPDATE config SET notice = '%s' WHERE gid = %d", notice, G_ID), "", "");
	PlayerPlaySound(playerid, SOUND_SUCCESS, 0.0, 0.0, 0.0);
    //SyncConfigFile();
	return true;
}

COMMAND:notice(playerid, params[])
{
	SendClientMessage(playerid, COLOR_LIGHTBLUE, sprintf( "(NOTICE) %s" , notice ) );
	return true;
}

COMMAND:add(playerid, params[])
{
	if(!IsPlayerAdminEx(playerid, lMod)) return true;
	if(!RoundStarted) return SendClientMessage(playerid, COLOR_RED, "The round is not started."), PlayerPlaySound(playerid, SOUND_WRONGCOMMAND, 0.0, 0.0, 0.0);
	if(Round_PVPMode)return SendClientMessage(playerid, COLOR_RED, "When PVP is running you can just \"readd\" a player."), PlayerPlaySound(playerid, SOUND_WRONGCOMMAND, 0.0, 0.0, 0.0);
	if(isnull(params)) return SendClientMessage(playerid, COLOR_RED, "Use /add [id - all]"), PlayerPlaySound(playerid, SOUND_WRONGCOMMAND, 0.0, 0.0, 0.0);
    if (Gaming == GAMETYPE_FIGHT && RoundFightType == FIGHTSIZE_ONEVSONE)return SendClientMessage(playerid, COLOR_RED, "When Fight (1x1) is running you cannot add a player"), PlayerPlaySound(playerid, SOUND_WRONGCOMMAND, 0.0, 0.0, 0.0);

	new p = 0;
	if(!strcmp(params, "all", true))
	{
	    foreach(new i:Player)
		{
	        if( Player[i][InGame] ) continue;
	        if( Player[i][IsAfk]  ) continue;
			//if( IsPlayerPaused(i) ) continue;
	        if( Player[i][Team] != TEAM_A && Player[i][Team] != TEAM_B ) continue;
	        if( InSpec[i] != -1 ) continue;
		//	new pt = Player[i][Team];
			__staticAddProcess (i);
			p++;
			/*
		    Player_outSecs[i] = 10;

		    CleanSpecTDs (i);

			if(IsPlayerInAnyVehicle(i))
			{
				DestroyVehicleEx(GetPlayerVehicleID(i));
			}

			if (InSpec[i]!=-1) Spec_RemovePlayerFromSpec(i);

			Player[i][InGame] 	  = 1;
			PlayerAfk_Seconds[i] = 0;

//			Player[i][RKills] = 0;
//			Player[i][RDeaths] = 0;
//			Player[i][RDamage] = 0;

			if(TeamRole[pt]==ATTACKERS)
			{
			    if(Gaming == GAMETYPE_BASE)
				{
			        if( !Interior_Base )
					{
					    SendClientMessage(i, COLOR_GREY, TXT_BASE_ATT);
					}
					else
					{
					    SendClientMessage(i, COLOR_GREY, TXT_INT);
					}

					if (Player[i][Team] == TEAM_A)
					{
						TextDrawSetString(PlayerSpecInfo[i][6], "~r~~h~WPS: ~w~-");
					}
					else
					{
						TextDrawSetString(PlayerSpecInfo[i][6], "~b~~h~WPS: ~w~-");
					}

					SetSpawnInfo(i, Player[i][Team], GetPlayerSkinEx(i), eScenario[SpawnAttackers][0] - RANDOM_SPAWN_ROUND + random(RANDOM_SPAWN_ROUND), eScenario[SpawnAttackers][1] - RANDOM_SPAWN_ROUND + random(RANDOM_SPAWN_ROUND), eScenario[SpawnAttackers][2], 0.0, 0, 0, 0, 0, 0, 0);
					SetPlayerMapIcon(i, MAPICON_ATTACKERSPAWN, eScenario[SpawnAttackers][0], eScenario[SpawnAttackers][1], eScenario[SpawnAttackers][2], ATTACKERSMAP_ICON, 0, MAPICON_TYPE_ATTSPAWN);
				}
				else if(Gaming == GAMETYPE_ARENA)
				{
					if (Player[i][Team] == TEAM_A)
					{
						TextDrawSetString(PlayerSpecInfo[i][6], "~r~~h~WPS: ~w~Arena");
					}
					else
					{
						TextDrawSetString(PlayerSpecInfo[i][6], "~b~~h~WPS: ~w~Arena");
					}

					SendClientMessage(i, COLOR_GREY, TXT_ARENA);
					SetSpawnInfo(i, Player[i][Team], GetPlayerSkinEx(i), eScenario[SpawnAttackers][0] - RANDOM_SPAWN_ROUND + random(RANDOM_SPAWN_ROUND), eScenario[SpawnAttackers][1] - RANDOM_SPAWN_ROUND + random(RANDOM_SPAWN_ROUND), eScenario[SpawnAttackers][2], 0.0, 0, 0, 0, 0, 0, 0);
					SetPlayerMapIcon(i, MAPICON_ATTACKERSPAWN, eScenario[SpawnAttackers][0], eScenario[SpawnAttackers][1], eScenario[SpawnAttackers][2], ATTACKERSMAP_ICON, 0, MAPICON_TYPE_ATTSPAWN);
				}
				else if(Gaming == GAMETYPE_TDM)
				{
					if (Player[i][Team] == TEAM_A)
					{
						TextDrawSetString(PlayerSpecInfo[i][6], "~r~~h~WPS: ~w~TDM");
					}
					else
					{
						TextDrawSetString(PlayerSpecInfo[i][6], "~b~~h~WPS: ~w~TDM");
					}

					stringo = "";
					strcat(stringo, TXT_TDM_P1" ");
					strcat(stringo, numstr(gConfig[TDMKills]));
					strcat(stringo, TXT_TDM_P2);

					SendClientMessage(i, COLOR_GREY, stringo);
					SetSpawnInfo(i, Player[i][Team], GetPlayerSkinEx(i), eScenario[SpawnAttackers][0] - RANDOM_SPAWN_ROUND + random(RANDOM_SPAWN_ROUND), eScenario[SpawnAttackers][1] - RANDOM_SPAWN_ROUND + random(RANDOM_SPAWN_ROUND), eScenario[SpawnAttackers][2], 0.0, 0, 0, 0, 0, 0, 0);
					SetPlayerMapIcon(i, MAPICON_ATTACKERSPAWN, eScenario[SpawnAttackers][0], eScenario[SpawnAttackers][1], eScenario[SpawnAttackers][2], ATTACKERSMAP_ICON, 0, MAPICON_TYPE_ATTSPAWN);
				}
				else if(Gaming == GAMETYPE_GUNGAME)
				{
					if (Player[i][Team] == TEAM_A)
					{
						TextDrawSetString(PlayerSpecInfo[i][6], "~r~~h~WPS: ~w~Gungame");
					}
					else
					{
						TextDrawSetString(PlayerSpecInfo[i][6], "~b~~h~WPS: ~w~Gungame");
					}

					SendClientMessage(i, COLOR_GREY, TXT_GUNGAME);
					new rand = random(20);
					SetSpawnInfo(i, i, GetPlayerSkinEx(i), Scenario_MultipleSpawns[rand][0], Scenario_MultipleSpawns[rand][1], Scenario_MultipleSpawns[rand][2], Scenario_MultipleSpawns[rand][3], 0, 0, 0, 0, 0, 0);
				}
				else if(Gaming == GAMETYPE_FIGHT)
				{
					if (Player[i][Team] == TEAM_A)
					{
						TextDrawSetString(PlayerSpecInfo[i][6], "~r~~h~WPS: ~w~Fight");
					}
					else
					{
						TextDrawSetString(PlayerSpecInfo[i][6], "~b~~h~WPS: ~w~Fight");
					}

					SendClientMessage(i, COLOR_GREY, TXT_FIGHT);
			        SetSpawnInfo(i, i, GetPlayerSkinEx(i), fFights_Spawns[eScenario[FileID]][i][0], fFights_Spawns[eScenario[FileID]][i][1], fFights_Spawns[eScenario[FileID]][i][2], 0.0, 0, 0, 0, 0, 0, 0);
			    }
			    else if(Gaming == GAMETYPE_FALLOUT)
			    {
					if (Player[i][Team] == TEAM_A)
	  				{
	  					TextDrawSetString(PlayerSpecInfo[i][6], "_");
		  			}
			  		else
			  		{
				  	    TextDrawSetString(PlayerSpecInfo[i][6], "_");
			  		}

				    SendClientMessage(i, COLOR_GREY, TXT_FALLOUT);
					SetSpawnInfo(i, i, GetPlayerSkinEx(i), 2482.1921 - random(39), -1660.4783 + random(47), 161.0000, random(360), 0, 0, 0, 0, 0, 0);
				}
				else if(Gaming == GAMETYPE_LASTBULLET)
				{
					if (Player[i][Team] == TEAM_A)
	  				{
	  					TextDrawSetString(PlayerSpecInfo[i][6], "~b~~h~WPS: ~w~Deagle");
		  			}
			  		else
			  		{
				  	    TextDrawSetString(PlayerSpecInfo[i][6], "~b~~h~WPS: ~w~Deagle");
			  		}

				    SendClientMessage(i, COLOR_GREY, TXT_LASTBULLET);
					SetSpawnInfo(i, i, GetPlayerSkinEx(i), lBullet_Spawns[eScenario[FileID]][i][0], lBullet_Spawns[eScenario[FileID]][i][1], lBullet_Spawns[eScenario[FileID]][i][2], random(360), 0, 0, 0, 0, 0, 0);

					LifesLeft = CreatePlayerTextDraw(i, 578.000000, 57.000000, "_");
					PlayerTextDrawAlignment(i, LifesLeft, 2);
					PlayerTextDrawBackgroundColor(i, LifesLeft, 51);
					PlayerTextDrawFont(i, LifesLeft, 2);
					PlayerTextDrawLetterSize(i, LifesLeft, 0.210000, 1.100000);
					PlayerTextDrawColor(i, LifesLeft, -1);
					PlayerTextDrawSetOutline(i, LifesLeft, 1);
					PlayerTextDrawSetProportional(i, LifesLeft, 1);
				}
			}
			else
			{
			    if(Gaming == GAMETYPE_BASE)
				{
			        if( !Interior_Base )
					{
				    	SendClientMessage(i, COLOR_GREY, TXT_BASE_DEF);
					}
					else
					{
					    SendClientMessage(i, COLOR_GREY, TXT_INT);
					}


					if (Player[i][Team] == TEAM_A)
					{
						TextDrawSetString(PlayerSpecInfo[i][6], "~r~~h~WPS: ~w~-");
					}
					else
					{
						TextDrawSetString(PlayerSpecInfo[i][6], "~b~~h~WPS: ~w~-");
					}

					SetSpawnInfo(i, Player[i][Team], GetPlayerSkinEx(i), eScenario[SpawnDefenders][0] - RANDOM_SPAWN_ROUND + random(RANDOM_SPAWN_ROUND), eScenario[SpawnDefenders][1] - RANDOM_SPAWN_ROUND + random(RANDOM_SPAWN_ROUND), eScenario[SpawnDefenders][2], 0.0, 0, 0, 0, 0, 0, 0);
				}
				else if(Gaming == GAMETYPE_ARENA)
				{
					if (Player[i][Team] == TEAM_A)
					{
						TextDrawSetString(PlayerSpecInfo[i][6], "~r~~h~WPS: ~w~Arena");
					}
					else
					{
						TextDrawSetString(PlayerSpecInfo[i][6], "~b~~h~WPS: ~w~Arena");
					}

					SendClientMessage(i, COLOR_GREY, TXT_ARENA);
		    		SetSpawnInfo(i, Player[i][Team], GetPlayerSkinEx(i), eScenario[SpawnDefenders][0] - RANDOM_SPAWN_ROUND + random(RANDOM_SPAWN_ROUND), eScenario[SpawnDefenders][1] - RANDOM_SPAWN_ROUND + random(RANDOM_SPAWN_ROUND), eScenario[SpawnDefenders][2], 0.0, 0, 0, 0, 0, 0, 0);
				}
				else if(Gaming == GAMETYPE_TDM)
				{
					if (Player[i][Team] == TEAM_A)
					{
						TextDrawSetString(PlayerSpecInfo[i][6], "~r~~h~WPS: ~w~TDM");
					}
					else
					{
						TextDrawSetString(PlayerSpecInfo[i][6], "~b~~h~WPS: ~w~TDM");
					}

					stringo = "";
					strcat(stringo, TXT_TDM_P1" ");
					strcat(stringo, numstr(gConfig[TDMKills]));
					strcat(stringo, TXT_TDM_P2);

					SendClientMessage(i, COLOR_GREY, stringo);
					SetSpawnInfo(i, Player[i][Team], GetPlayerSkinEx(i), eScenario[SpawnDefenders][0] - RANDOM_SPAWN_ROUND + random(RANDOM_SPAWN_ROUND), eScenario[SpawnDefenders][1] - RANDOM_SPAWN_ROUND + random(RANDOM_SPAWN_ROUND), eScenario[SpawnDefenders][2], 0.0, 0, 0, 0, 0, 0, 0);
				}
				else if(Gaming == GAMETYPE_GUNGAME)
				{
					if (Player[i][Team] == TEAM_A)
					{
						TextDrawSetString(PlayerSpecInfo[i][6], "~r~~h~WPS: ~w~Gungame");
					}
					else
					{
						TextDrawSetString(PlayerSpecInfo[i][6], "~b~~h~WPS: ~w~Gungame");
					}

					SendClientMessage(i, COLOR_GREY, TXT_GUNGAME);
					new rand = random(20);
					SetSpawnInfo(i, i, GetPlayerSkinEx(i), Scenario_MultipleSpawns[rand][0], Scenario_MultipleSpawns[rand][1], Scenario_MultipleSpawns[rand][2], Scenario_MultipleSpawns[rand][3], 0, 0, 0, 0, 0, 0);
				}
				else if(Gaming == GAMETYPE_FIGHT)
				{
					if (Player[i][Team] == TEAM_A)
					{
						TextDrawSetString(PlayerSpecInfo[i][6], "~r~~h~WPS: ~w~Fight");
					}
					else
					{
						TextDrawSetString(PlayerSpecInfo[i][6], "~b~~h~WPS: ~w~Fight");
					}

				    SendClientMessage(i, COLOR_GREY, TXT_FIGHT);
			        SetSpawnInfo(i, i, GetPlayerSkinEx(i), fFights_Spawns[eScenario[FileID]][i][0], fFights_Spawns[eScenario[FileID]][i][1], fFights_Spawns[eScenario[FileID]][i][2], 0.0, 0, 0, 0, 0, 0, 0);
			    }
			    else if(Gaming == GAMETYPE_FALLOUT)
			    {
					if (Player[i][Team] == TEAM_A)
	  				{
	  					TextDrawSetString(PlayerSpecInfo[i][6], "_");
		  			}
			  		else
			  		{
				  	    TextDrawSetString(PlayerSpecInfo[i][6], "_");
			  		}

				    SendClientMessage(i, COLOR_GREY, TXT_FALLOUT);
					SetSpawnInfo(i, i, GetPlayerSkinEx(i), 2482.1921 - random(39), -1660.4783 + random(47), 161.0000, random(360), 0, 0, 0, 0, 0, 0);
				}
				else if(Gaming == GAMETYPE_LASTBULLET)
				{
					if (Player[i][Team] == TEAM_A)
	  				{
	  					TextDrawSetString(PlayerSpecInfo[i][6], "~b~~h~WPS: ~w~Deagle");
		  			}
			  		else
			  		{
				  	    TextDrawSetString(PlayerSpecInfo[i][6], "~b~~h~WPS: ~w~Deagle");
			  		}

				    SendClientMessage(i, COLOR_GREY, TXT_LASTBULLET);
					SetSpawnInfo(i, i, GetPlayerSkinEx(i), lBullet_Spawns[eScenario[FileID]][i][0], lBullet_Spawns[eScenario[FileID]][i][1], lBullet_Spawns[eScenario[FileID]][i][2], random(360), 0, 0, 0, 0, 0, 0);

					LifesLeft = CreatePlayerTextDraw(i, 578.000000, 57.000000, "_");
					PlayerTextDrawAlignment(i, LifesLeft, 2);
					PlayerTextDrawBackgroundColor(i, LifesLeft, 51);
					PlayerTextDrawFont(i, LifesLeft, 2);
					PlayerTextDrawLetterSize(i, LifesLeft, 0.210000, 1.100000);
					PlayerTextDrawColor(i, LifesLeft, -1);
					PlayerTextDrawSetOutline(i, LifesLeft, 1);
					PlayerTextDrawSetProportional(i, LifesLeft, 1);
				}
			}

			if( pt == TEAM_A )
			{
			    Team1_StartHP += gConfig[GameMode] == GAMEMODE_NOCBUG ? 100 : 200;
			}
			else if( pt == TEAM_B )
			{
				Team2_StartHP += gConfig[GameMode] == GAMEMODE_NOCBUG ? 100 : 200;
			}

			if( Player[i][InDm] != -1 )
			{
			    MySQLStatus[TotalQuerys] ++; mysql_tquery(g_MySQLConnection, sprintf("UPDATE bestdmplayer SET damage = '%d', kills = '%d' WHERE nickname = '%s' AND dmid = '%d'", Player[i][DDamage], Player[i][DKills], Player[i][Nickname], Player[i][InDm]), "", "");
			    Player[i][InDm] = -1;
			}

			if (gConfig[UseHealthBars])
			{
				SetPlayerScore(i, Player[i][RDamage]);
			}
			else
			{
			    SetPlayerScore(i, gConfig[GameMode] == GAMEMODE_NOCBUG ? 100 : 200);
			}

			if (AntiHits)
			{
		//	    TextDrawShowForPlayer(i, TD_NotHits);
			    TextDrawShowForPlayer(i, TD_NoHitsScritta);

			}

			__staticAddProcess(i);

			TeamPlayers[pt]++;
			SetPlayerColor(i, iTeam[pt][InGameColor]);
			SetPlayerVirtualWorld(i, GAME_WORLD);

			if( GamePaused )
			{
			    TogglePlayerControllable( i , false );
			    TextDrawShowForPlayer( i , RoundPaused );
			}

			if(Gaming == GAMETYPE_BASE)
			{
				DisablePlayerCheckpoint(i);
				if(!Interior_Base)
					SetPlayerCheckpointEx(i, eScenario[Checkpoint][0], eScenario[Checkpoint][1], eScenario[Checkpoint][2]+1.5, 2.0);

				MostraWeaponset(i);
			}

			// all great things are simple, and many can be expressed in single words: freedom, justice, honor, duty, mercy, hope.

			TextDrawShowForPlayer(i, RoundStats[0]);
			TextDrawShowForPlayer(i, RoundStats[1]);
			TextDrawShowForPlayer(i, RoundStats[2]);
			TextDrawShowForPlayer(i, RoundStats[3]);

			TextDrawHideForPlayer(i, TeamPlayers_TD);

			GangZoneShowForPlayer(i, ZonaAttornoCP, GANGZONE_COLORAZIONE);
			SpawnPlayer(i);

	        p ++;
	        timeoutPlayer[i] = false;

	        if (Player[i][FinalRound_Status] != FINALROUND_STATUS_HIDDEN)
	        {
				for (new i2 = 0; i2 < MAX_STATIC_TEXTDRAWS; i2++) TextDrawHideForPlayer(i, FineRound_Static[i2]);

				new cv = Player[i][CurrentView];

				TextDrawHideForPlayer(i, FineRound_Dynamic[cv][BluePlayers]);
				TextDrawHideForPlayer(i, FineRound_Dynamic[cv][GreenPlayers]);
				TextDrawHideForPlayer(i, FineRound_Dynamic[cv][BlueKills]);
				TextDrawHideForPlayer(i, FineRound_Dynamic[cv][BlueDamages]);
				TextDrawHideForPlayer(i, FineRound_Dynamic[cv][GreenKills]);
				TextDrawHideForPlayer(i, FineRound_Dynamic[cv][GreenDamage]);
				TextDrawHideForPlayer(i, FineRound_Dynamic[cv][TotalKGreen]);
				TextDrawHideForPlayer(i, FineRound_Dynamic[cv][TotalDGreen]);
				TextDrawHideForPlayer(i, FineRound_Dynamic[cv][TotalKBlue]);
				TextDrawHideForPlayer(i, FineRound_Dynamic[cv][TotalDBlue]);
				TextDrawHideForPlayer(i, FineRound_Dynamic[cv][Top2_Nick]);
				TextDrawHideForPlayer(i, FineRound_Dynamic[cv][Top2_Stats]);
				TextDrawHideForPlayer(i, FineRound_Dynamic[cv][Top3_Stats]);
				TextDrawHideForPlayer(i, FineRound_Dynamic[cv][Top3_Nick]);
				TextDrawHideForPlayer(i, FineRound_Dynamic[cv][Top1_Stats]);
				TextDrawHideForPlayer(i, FineRound_Dynamic[cv][Top1_Nick]);
				TextDrawHideForPlayer(i, FineRound_Dynamic[cv][RoundsInfo]);
				TextDrawHideForPlayer(i, FineRound_Dynamic[cv][AttDefWin]);
		        TextDrawHideForPlayer(i, FineRound_Dynamic[cv][Stringa_Winner2]);
		        TextDrawHideForPlayer(i, FineRound_Dynamic[cv][Stringa_TeamWin]);
		        TextDrawHideForPlayer(i, FineRound_Dynamic[cv][Stringa_Winner1]);
				TextDrawHideForPlayer(i, FineRound_Dynamic[cv][Stringa_RoundInfo]);
		        TextDrawHideForPlayer(i, FineRound_Dynamic[cv][Stringa_TmpBest]);

                if (gConfig[Matchmode] == MATCHMODE_TCWCW)
		        	CancelSelectTextDraw (i);

			    Player[i][FinalRound_Status] = FINALROUND_STATUS_HIDDEN;

			}*/
	    }

		if (p > 0)
		{
		    SyncTextdraw(1);
			RefreshTeamPlayers_TD();
		    FixHealthBars();

			format (stringo, sizeof stringo, "Admin/Mod {"#COLOR_SYSTEM_FOCUS"}%s{"#COLOR_SYSTEM_REST"} has brought {"#COLOR_SYSTEM_FOCUS"}%d{"#COLOR_SYSTEM_REST"} players into the round.", Player[playerid][Nickname], p);
            SendClientMessageToAll(COLOR_SYSTEM, stringo);
	   	 	PlayerPlaySound(playerid, SOUND_SUCCESS, 0.0, 0.0, 0.0);
		}
		else
		{
		    SendClientMessage(playerid, COLOR_RED, "No players!");
		}
		return true;
	}
	else if(!strcmp(params, "ball", true))
	{
	    foreach(new i:Player)
		{
	        if( Player[i][InGame] ) continue;
	        if( Player[i][IsAfk]  ) continue;
			//if( IsPlayerPaused(i) ) continue;
	        if( Player[i][Team] != TEAM_A && Player[i][Team] != TEAM_B ) continue;
	        if( InSpec[i] != -1 ) continue;

	        iTeam[Player[i][Team]][tPlayers] --;
	        Player[i][Team] = GetTeamWithLessMembers();
//	        new pt = Player[i][Team];
	        iTeam[Player[i][Team]][tPlayers] ++;
	        __staticAddProcess (i);
	        p++;
	        /*
		    Player_outSecs[i] = 10;

			if(IsPlayerInAnyVehicle(i))
			{
				DestroyVehicleEx(GetPlayerVehicleID(i));
			}

			if (InSpec[i]!=-1) Spec_RemovePlayerFromSpec(i);

			Player[i][InGame] 	 = 1;
			PlayerAfk_Seconds[i] = 0;

//			Player[i][RKills] = 0;
//			Player[i][RDeaths] = 0;
//			Player[i][RDamage] = 0;

			CleanSpecTDs (i);

			if(TeamRole[pt]==ATTACKERS)
			{
			    if(Gaming == GAMETYPE_BASE)
				{
			        if( !Interior_Base )
					{
					    SendClientMessage(i, COLOR_GREY, TXT_BASE_ATT);
					}
					else
					{
					    SendClientMessage(i, COLOR_GREY, TXT_INT);
					}

					if (Player[i][Team] == TEAM_A)
					{
						TextDrawSetString(PlayerSpecInfo[i][6], "~r~~h~WPS: ~w~-");
					}
					else
					{
						TextDrawSetString(PlayerSpecInfo[i][6], "~b~~h~WPS: ~w~-");
					}

					SetSpawnInfo(i, Player[i][Team], GetPlayerSkinEx(i), eScenario[SpawnAttackers][0] - RANDOM_SPAWN_ROUND + random(RANDOM_SPAWN_ROUND), eScenario[SpawnAttackers][1] - RANDOM_SPAWN_ROUND + random(RANDOM_SPAWN_ROUND), eScenario[SpawnAttackers][2], 0.0, 0, 0, 0, 0, 0, 0);
					SetPlayerMapIcon(i, MAPICON_ATTACKERSPAWN, eScenario[SpawnAttackers][0], eScenario[SpawnAttackers][1], eScenario[SpawnAttackers][2], ATTACKERSMAP_ICON, 0, MAPICON_TYPE_ATTSPAWN);
				}
				else if(Gaming == GAMETYPE_ARENA)
				{
					if (Player[i][Team] == TEAM_A)
					{
						TextDrawSetString(PlayerSpecInfo[i][6], "~r~~h~WPS: ~w~Arena");
					}
					else
					{
						TextDrawSetString(PlayerSpecInfo[i][6], "~b~~h~WPS: ~w~Arena");
					}

					SendClientMessage(i, COLOR_GREY, TXT_ARENA);
					SetSpawnInfo(i, Player[i][Team], GetPlayerSkinEx(i), eScenario[SpawnAttackers][0] - RANDOM_SPAWN_ROUND + random(RANDOM_SPAWN_ROUND), eScenario[SpawnAttackers][1] - RANDOM_SPAWN_ROUND + random(RANDOM_SPAWN_ROUND), eScenario[SpawnAttackers][2], 0.0, 0, 0, 0, 0, 0, 0);
					SetPlayerMapIcon(i, MAPICON_ATTACKERSPAWN, eScenario[SpawnAttackers][0], eScenario[SpawnAttackers][1], eScenario[SpawnAttackers][2], ATTACKERSMAP_ICON, 0, MAPICON_TYPE_ATTSPAWN);
				}
				else if(Gaming == GAMETYPE_TDM)
				{
					if (Player[i][Team] == TEAM_A)
					{
						TextDrawSetString(PlayerSpecInfo[i][6], "~r~~h~WPS: ~w~TDM");
					}
					else
					{
						TextDrawSetString(PlayerSpecInfo[i][6], "~b~~h~WPS: ~w~TDM");
					}

					stringo = "";
					strcat(stringo, TXT_TDM_P1" ");
					strcat(stringo, numstr(gConfig[TDMKills]));
					strcat(stringo, TXT_TDM_P2);

					SendClientMessage(i, COLOR_GREY, stringo);
					SetSpawnInfo(i, Player[i][Team], GetPlayerSkinEx(i), eScenario[SpawnAttackers][0] - RANDOM_SPAWN_ROUND + random(RANDOM_SPAWN_ROUND), eScenario[SpawnAttackers][1] - RANDOM_SPAWN_ROUND + random(RANDOM_SPAWN_ROUND), eScenario[SpawnAttackers][2], 0.0, 0, 0, 0, 0, 0, 0);
					SetPlayerMapIcon(i, MAPICON_ATTACKERSPAWN, eScenario[SpawnAttackers][0], eScenario[SpawnAttackers][1], eScenario[SpawnAttackers][2], ATTACKERSMAP_ICON, 0, MAPICON_TYPE_ATTSPAWN);
				}
				else if(Gaming == GAMETYPE_GUNGAME)
				{
					if (Player[i][Team] == TEAM_A)
					{
						TextDrawSetString(PlayerSpecInfo[i][6], "~r~~h~WPS: ~w~Gungame");
					}
					else
					{
						TextDrawSetString(PlayerSpecInfo[i][6], "~b~~h~WPS: ~w~Gungame");
					}

					SendClientMessage(i, COLOR_GREY, TXT_GUNGAME);
					new rand = random(20);
					SetSpawnInfo(i, i, GetPlayerSkinEx(i), Scenario_MultipleSpawns[rand][0], Scenario_MultipleSpawns[rand][1], Scenario_MultipleSpawns[rand][2], Scenario_MultipleSpawns[rand][3], 0, 0, 0, 0, 0, 0);
				}
				else if(Gaming == GAMETYPE_FIGHT)
				{
					if (Player[i][Team] == TEAM_A)
					{
						TextDrawSetString(PlayerSpecInfo[i][6], "~r~~h~WPS: ~w~Fight");
					}
					else
					{
						TextDrawSetString(PlayerSpecInfo[i][6], "~b~~h~WPS: ~w~Fight");
					}

					SendClientMessage(i, COLOR_GREY, TXT_FIGHT);
			        SetSpawnInfo(i, i, GetPlayerSkinEx(i), fFights_Spawns[eScenario[FileID]][i][0], fFights_Spawns[eScenario[FileID]][i][1], fFights_Spawns[eScenario[FileID]][i][2], 0.0, 0, 0, 0, 0, 0, 0);
			    }
			    else if(Gaming == GAMETYPE_FALLOUT)
			    {
					if (Player[i][Team] == TEAM_A)
	  				{
	  					TextDrawSetString(PlayerSpecInfo[i][6], "_");
		  			}
			  		else
			  		{
				  	    TextDrawSetString(PlayerSpecInfo[i][6], "_");
			  		}

				    SendClientMessage(i, COLOR_GREY, TXT_FALLOUT);
					SetSpawnInfo(i, i, GetPlayerSkinEx(i), 2482.1921 - random(39), -1660.4783 + random(47), 161.0000, random(360), 0, 0, 0, 0, 0, 0);
				}
				else if(Gaming == GAMETYPE_LASTBULLET)
				{
					if (Player[i][Team] == TEAM_A)
	  				{
	  					TextDrawSetString(PlayerSpecInfo[i][6], "~b~~h~WPS: ~w~Deagle");
		  			}
			  		else
			  		{
				  	    TextDrawSetString(PlayerSpecInfo[i][6], "~b~~h~WPS: ~w~Deagle");
			  		}

				    SendClientMessage(i, COLOR_GREY, TXT_LASTBULLET);
					SetSpawnInfo(i, i, GetPlayerSkinEx(i), lBullet_Spawns[eScenario[FileID]][i][0], lBullet_Spawns[eScenario[FileID]][i][1], lBullet_Spawns[eScenario[FileID]][i][2], random(360), 0, 0, 0, 0, 0, 0);

					LifesLeft = CreatePlayerTextDraw(i, 578.000000, 57.000000, "_");
					PlayerTextDrawAlignment(i, LifesLeft, 2);
					PlayerTextDrawBackgroundColor(i, LifesLeft, 51);
					PlayerTextDrawFont(i, LifesLeft, 2);
					PlayerTextDrawLetterSize(i, LifesLeft, 0.210000, 1.100000);
					PlayerTextDrawColor(i, LifesLeft, -1);
					PlayerTextDrawSetOutline(i, LifesLeft, 1);
					PlayerTextDrawSetProportional(i, LifesLeft, 1);
				}
			}
			else
			{
			    if(Gaming == GAMETYPE_BASE)
				{
			        if( !Interior_Base )
					{
				    	SendClientMessage(i, COLOR_GREY, TXT_BASE_DEF);
					}
					else
					{
					    SendClientMessage(i, COLOR_GREY, TXT_INT);
					}


					if (Player[i][Team] == TEAM_A)
					{
						TextDrawSetString(PlayerSpecInfo[i][6], "~r~~h~WPS: ~w~-");
					}
					else
					{
						TextDrawSetString(PlayerSpecInfo[i][6], "~b~~h~WPS: ~w~-");
					}

					SetSpawnInfo(i, Player[i][Team], GetPlayerSkinEx(i), eScenario[SpawnDefenders][0] - RANDOM_SPAWN_ROUND + random(RANDOM_SPAWN_ROUND), eScenario[SpawnDefenders][1] - RANDOM_SPAWN_ROUND + random(RANDOM_SPAWN_ROUND), eScenario[SpawnDefenders][2], 0.0, 0, 0, 0, 0, 0, 0);
				}
				else if(Gaming == GAMETYPE_ARENA)
				{
					if (Player[i][Team] == TEAM_A)
					{
						TextDrawSetString(PlayerSpecInfo[i][6], "~r~~h~WPS: ~w~Arena");
					}
					else
					{
						TextDrawSetString(PlayerSpecInfo[i][6], "~b~~h~WPS: ~w~Arena");
					}

					SendClientMessage(i, COLOR_GREY, TXT_ARENA);
		    		SetSpawnInfo(i, Player[i][Team], GetPlayerSkinEx(i), eScenario[SpawnDefenders][0] - RANDOM_SPAWN_ROUND + random(RANDOM_SPAWN_ROUND), eScenario[SpawnDefenders][1] - RANDOM_SPAWN_ROUND + random(RANDOM_SPAWN_ROUND), eScenario[SpawnDefenders][2], 0.0, 0, 0, 0, 0, 0, 0);
				}
				else if(Gaming == GAMETYPE_TDM)
				{
					if (Player[i][Team] == TEAM_A)
					{
						TextDrawSetString(PlayerSpecInfo[i][6], "~r~~h~WPS: ~w~TDM");
					}
					else
					{
						TextDrawSetString(PlayerSpecInfo[i][6], "~b~~h~WPS: ~w~TDM");
					}

					stringo = "";
					strcat(stringo, TXT_TDM_P1" ");
					strcat(stringo, numstr(gConfig[TDMKills]));
					strcat(stringo, TXT_TDM_P2);

					SendClientMessage(i, COLOR_GREY, stringo);
					SetSpawnInfo(i, Player[i][Team], GetPlayerSkinEx(i), eScenario[SpawnDefenders][0] - RANDOM_SPAWN_ROUND + random(RANDOM_SPAWN_ROUND), eScenario[SpawnDefenders][1] - RANDOM_SPAWN_ROUND + random(RANDOM_SPAWN_ROUND), eScenario[SpawnDefenders][2], 0.0, 0, 0, 0, 0, 0, 0);
				}
				else if(Gaming == GAMETYPE_GUNGAME)
				{
					if (Player[i][Team] == TEAM_A)
					{
						TextDrawSetString(PlayerSpecInfo[i][6], "~r~~h~WPS: ~w~Gungame");
					}
					else
					{
						TextDrawSetString(PlayerSpecInfo[i][6], "~b~~h~WPS: ~w~Gungame");
					}

					SendClientMessage(i, COLOR_GREY, TXT_GUNGAME);
					new rand = random(20);
					SetSpawnInfo(i, i, GetPlayerSkinEx(i), Scenario_MultipleSpawns[rand][0], Scenario_MultipleSpawns[rand][1], Scenario_MultipleSpawns[rand][2], Scenario_MultipleSpawns[rand][3], 0, 0, 0, 0, 0, 0);
				}
				else if(Gaming == GAMETYPE_FIGHT)
				{
					if (Player[i][Team] == TEAM_A)
					{
						TextDrawSetString(PlayerSpecInfo[i][6], "~r~~h~WPS: ~w~Fight");
					}
					else
					{
						TextDrawSetString(PlayerSpecInfo[i][6], "~b~~h~WPS: ~w~Fight");
					}

				    SendClientMessage(i, COLOR_GREY, TXT_FIGHT);
			        SetSpawnInfo(i, i, GetPlayerSkinEx(i), fFights_Spawns[eScenario[FileID]][i][0], fFights_Spawns[eScenario[FileID]][i][1], fFights_Spawns[eScenario[FileID]][i][2], 0.0, 0, 0, 0, 0, 0, 0);
			    }
			    else if(Gaming == GAMETYPE_FALLOUT)
			    {
					if (Player[i][Team] == TEAM_A)
	  				{
	  					TextDrawSetString(PlayerSpecInfo[i][6], "_");
		  			}
			  		else
			  		{
				  	    TextDrawSetString(PlayerSpecInfo[i][6], "_");
			  		}

				    SendClientMessage(i, COLOR_GREY, TXT_FALLOUT);
					SetSpawnInfo(i, i, GetPlayerSkinEx(i), 2482.1921 - random(39), -1660.4783 + random(47), 161.0000, random(360), 0, 0, 0, 0, 0, 0);
				}
				else if(Gaming == GAMETYPE_LASTBULLET)
				{
					if (Player[i][Team] == TEAM_A)
	  				{
	  					TextDrawSetString(PlayerSpecInfo[i][6], "~b~~h~WPS: ~w~Deagle");
		  			}
			  		else
			  		{
				  	    TextDrawSetString(PlayerSpecInfo[i][6], "~b~~h~WPS: ~w~Deagle");
			  		}

				    SendClientMessage(i, COLOR_GREY, TXT_LASTBULLET);
					SetSpawnInfo(i, i, GetPlayerSkinEx(i), lBullet_Spawns[eScenario[FileID]][i][0], lBullet_Spawns[eScenario[FileID]][i][1], lBullet_Spawns[eScenario[FileID]][i][2], random(360), 0, 0, 0, 0, 0, 0);

					LifesLeft = CreatePlayerTextDraw(i, 578.000000, 57.000000, "_");
					PlayerTextDrawAlignment(i, LifesLeft, 2);
					PlayerTextDrawBackgroundColor(i, LifesLeft, 51);
					PlayerTextDrawFont(i, LifesLeft, 2);
					PlayerTextDrawLetterSize(i, LifesLeft, 0.210000, 1.100000);
					PlayerTextDrawColor(i, LifesLeft, -1);
					PlayerTextDrawSetOutline(i, LifesLeft, 1);
					PlayerTextDrawSetProportional(i, LifesLeft, 1);
				}
			}

			if( pt == TEAM_A )
			{
			    Team1_StartHP += gConfig[GameMode] == GAMEMODE_NOCBUG ? 100 : 200;
			}
			else if( pt == TEAM_B )
			{
				Team2_StartHP += gConfig[GameMode] == GAMEMODE_NOCBUG ? 100 : 200;
			}

			if( Player[i][InDm] != -1 )
			{
			    MySQLStatus[TotalQuerys] ++; mysql_tquery(g_MySQLConnection, sprintf("UPDATE bestdmplayer SET damage = '%d', kills = '%d' WHERE nickname = '%s' AND dmid = '%d'", Player[i][DDamage], Player[i][DKills], Player[i][Nickname], Player[i][InDm]), "", "");
			    Player[i][InDm] = -1;
			}

			if (gConfig[UseHealthBars])
			{
				SetPlayerScore(i, Player[i][RDamage]);
			}
			else
			{
			    SetPlayerScore(i, gConfig[GameMode] == GAMEMODE_NOCBUG ? 100 : 200);
			}

			if (AntiHits)
			{
		//	    TextDrawShowForPlayer(i, TD_NotHits);
			    TextDrawShowForPlayer(i, TD_NoHitsScritta);

			}

			TeamPlayers[pt]++;
			SetPlayerColor(i, iTeam[pt][InGameColor]);
			SetPlayerVirtualWorld(i, GAME_WORLD);
            TextDrawHideForPlayer(i, TeamPlayers_TD);

			if( GamePaused )
			{
			    TogglePlayerControllable( i , false );
			    TextDrawShowForPlayer( i , RoundPaused );
			}

			if(Gaming == GAMETYPE_BASE)
			{
				DisablePlayerCheckpoint(i);
				if(!Interior_Base)
					SetPlayerCheckpointEx(i, eScenario[Checkpoint][0], eScenario[Checkpoint][1], eScenario[Checkpoint][2]+1.5, 2.0);

				MostraWeaponset(i);
			}

			// all great things are simple, and many can be expressed in single words: freedom, justice, honor, duty, mercy, hope.

			TextDrawShowForPlayer(i, RoundStats[0]);
			TextDrawShowForPlayer(i, RoundStats[1]);
			TextDrawShowForPlayer(i, RoundStats[2]);
			TextDrawShowForPlayer(i, RoundStats[3]);

			GangZoneShowForPlayer(i, ZonaAttornoCP, GANGZONE_COLORAZIONE);
			SpawnPlayer(i);

	        p ++;
	        timeoutPlayer[i] = false;

	        if (Player[i][FinalRound_Status] != FINALROUND_STATUS_HIDDEN)
	        {
				for (new i2 = 0; i2 < MAX_STATIC_TEXTDRAWS; i2++) TextDrawHideForPlayer(i, FineRound_Static[i2]);

				new cv = Player[playerid][CurrentView];

				TextDrawHideForPlayer(i, FineRound_Dynamic[cv][BluePlayers]);
				TextDrawHideForPlayer(i, FineRound_Dynamic[cv][GreenPlayers]);
				TextDrawHideForPlayer(i, FineRound_Dynamic[cv][BlueKills]);
				TextDrawHideForPlayer(i, FineRound_Dynamic[cv][BlueDamages]);
				TextDrawHideForPlayer(i, FineRound_Dynamic[cv][GreenKills]);
				TextDrawHideForPlayer(i, FineRound_Dynamic[cv][GreenDamage]);
				TextDrawHideForPlayer(i, FineRound_Dynamic[cv][TotalKGreen]);
				TextDrawHideForPlayer(i, FineRound_Dynamic[cv][TotalDGreen]);
				TextDrawHideForPlayer(i, FineRound_Dynamic[cv][TotalKBlue]);
				TextDrawHideForPlayer(i, FineRound_Dynamic[cv][TotalDBlue]);
				TextDrawHideForPlayer(i, FineRound_Dynamic[cv][Top2_Nick]);
				TextDrawHideForPlayer(i, FineRound_Dynamic[cv][Top2_Stats]);
				TextDrawHideForPlayer(i, FineRound_Dynamic[cv][Top3_Stats]);
				TextDrawHideForPlayer(i, FineRound_Dynamic[cv][Top3_Nick]);
				TextDrawHideForPlayer(i, FineRound_Dynamic[cv][Top1_Stats]);
				TextDrawHideForPlayer(i, FineRound_Dynamic[cv][Top1_Nick]);
				TextDrawHideForPlayer(i, FineRound_Dynamic[cv][RoundsInfo]);
				TextDrawHideForPlayer(i, FineRound_Dynamic[cv][AttDefWin]);
		        TextDrawHideForPlayer(i, FineRound_Dynamic[cv][Stringa_Winner2]);
		        TextDrawHideForPlayer(i, FineRound_Dynamic[cv][Stringa_TeamWin]);
		        TextDrawHideForPlayer(i, FineRound_Dynamic[cv][Stringa_Winner1]);
				TextDrawHideForPlayer(i, FineRound_Dynamic[cv][Stringa_RoundInfo]);
		        TextDrawHideForPlayer(i, FineRound_Dynamic[cv][Stringa_TmpBest]);

                if (gConfig[Matchmode] == MATCHMODE_TCWCW)
		        	CancelSelectTextDraw (i);

			    Player[i][FinalRound_Status] = FINALROUND_STATUS_HIDDEN;

			}*/
	    }

		if (p > 0)
		{
		    SyncTextdraw(1);
			RefreshTeamPlayers_TD();
		    FixHealthBars();

			format(stringo, sizeof stringo, "Admin/Mod {"#COLOR_SYSTEM_FOCUS"}%s{"#COLOR_SYSTEM_REST"} has brought and balanced {"#COLOR_SYSTEM_FOCUS"}%d{"#COLOR_SYSTEM_REST"} players into the round.", Player[playerid][Nickname], p);
            SendClientMessageToAll(COLOR_SYSTEM, stringo);
		   	PlayerPlaySound(playerid, SOUND_SUCCESS, 0.0, 0.0, 0.0);
		}
		else
		{
		    SendClientMessage(playerid, COLOR_RED, "No players!");
		}
	    return true;
	}
	new id = strval(params);

	if(!IsPlayerConnected(id)) return SendClientMessage(playerid, COLOR_RED, "Invalid player."), PlayerPlaySound(playerid, SOUND_WRONGCOMMAND, 0.0, 0.0, 0.0);
	if(Player[id][InGame])return SendClientMessage(playerid, COLOR_RED, "The player is already in-game."), PlayerPlaySound(playerid, SOUND_WRONGCOMMAND, 0.0, 0.0, 0.0);
	if(!Player[id][Spawned])return SendClientMessage(playerid, COLOR_RED, "This player is not spawned."), PlayerPlaySound(playerid, SOUND_WRONGCOMMAND, 0.0, 0.0, 0.0);
	if(Player[id][Team]==NULL_TEAM || Player[id][Team] == TEAM_REF || IsSubPlayer(id))return SendClientMessage(playerid, COLOR_RED, "The player's team is not valid.");

    if (timeoutPlayer[id] == true)
	{
	    // PURTROPPO IL RESTORE PER CRASH
	    // NON PUò ANCOR AESSERE ADATTATO ALL'USO DI __staticAddProcess
	    // QUINDI PER IL MOMENTO USA IL VECCHIO CODICE

	    Player[id][Team] = timeout_Team[id];

		new iT = Player[id][Team];

		Player_outSecs[id] = 10;

		if(IsPlayerInAnyVehicle(id))
		{
			DestroyVehicleEx(GetPlayerVehicleID(id));
		}

		if (InSpec[id]!=-1) Spec_RemovePlayerFromSpec(id);

		Player[id][InGame] 	  = 1;
		PlayerAfk_Seconds[id] = 0;

		CleanSpecTDs (id);

		if(TeamRole[iT]==ATTACKERS)
		{
			if(Gaming == GAMETYPE_BASE)
			{
		    	if( !Interior_Base )
		    	{
		    	    SendClientMessage(id, COLOR_GREY, TXT_BASE_ATT);
		    	}
		    	else
		    	{
		    	    SendClientMessage(id, COLOR_GREY, TXT_INT);
		    	}

				if (Player[id][Team] == TEAM_A)
  				{
  					TextDrawSetString(PlayerSpecInfo[id][6], "~r~~h~WPS: ~w~-");
	  			}
		  		else
		  		{
			  	    TextDrawSetString(PlayerSpecInfo[id][6], "~b~~h~WPS: ~w~-");
		  		}

		  		SetPlayerMapIcon(id, MAPICON_ATTACKERSPAWN, eScenario[SpawnDefenders][0], eScenario[SpawnDefenders][1], eScenario[SpawnDefenders][2], ATTACKERSMAP_ICON, 0, MAPICON_TYPE_ATTSPAWN);
			}
			else if(Gaming == GAMETYPE_ARENA)
			{
				if (Player[id][Team] == TEAM_A)
  				{
  					TextDrawSetString(PlayerSpecInfo[id][6], "~r~~h~WPS: ~w~Arena");
	  			}
		  		else
		  		{
			  	    TextDrawSetString(PlayerSpecInfo[id][6], "~b~~h~WPS: ~w~Arena");
		  		}

				SendClientMessage(id, COLOR_GREY, TXT_ARENA);
			}
			else if(Gaming == GAMETYPE_TDM)
			{
				if (Player[id][Team] == TEAM_A)
  				{
  					TextDrawSetString(PlayerSpecInfo[id][6], "~r~~h~WPS: ~w~TDM");
	  			}
		  		else
		  		{
			  	    TextDrawSetString(PlayerSpecInfo[id][6], "~b~~h~WPS: ~w~TDM");
		  		}

				stringo = "";
				strcat(stringo, TXT_TDM_P1" ");
				strcat(stringo, numstr(gConfig[TDMKills]));
				strcat(stringo, TXT_TDM_P2);

				SendClientMessage(id, COLOR_GREY, stringo);
			}
			else if(Gaming == GAMETYPE_GUNGAME)
			{
				if (Player[id][Team] == TEAM_A)
  				{
  					TextDrawSetString(PlayerSpecInfo[id][6], "~r~~h~WPS: ~w~Gungame");
	  			}
		  		else
		  		{
			  	    TextDrawSetString(PlayerSpecInfo[id][6], "~b~~h~WPS: ~w~Gungame");
		  		}
				SendClientMessage(id, COLOR_GREY, TXT_GUNGAME);
			}
			else if(Gaming == GAMETYPE_FIGHT)
			{
				if (Player[id][Team] == TEAM_A)
  				{
  					TextDrawSetString(PlayerSpecInfo[id][6], "~r~~h~WPS: ~w~Fight");
	  			}
		  		else
		  		{
			  	    TextDrawSetString(PlayerSpecInfo[id][6], "~b~~h~WPS: ~w~Fight");
		  		}

				SendClientMessage(id, COLOR_GREY, TXT_FIGHT);
		        SetSpawnInfo(id, id, GetPlayerSkinEx(id), fFights_Spawns[eScenario[FileID]][id][0], fFights_Spawns[eScenario[FileID]][id][1], fFights_Spawns[eScenario[FileID]][id][2], 0.0, 0, 0, 0, 0, 0, 0);
   			}
		    else if(Gaming == GAMETYPE_FALLOUT)
		    {
				if (Player[id][Team] == TEAM_A)
	  			{
	  				TextDrawSetString(PlayerSpecInfo[id][6], "_");
	 			}
		  		else
		  		{
			  	    TextDrawSetString(PlayerSpecInfo[id][6], "_");
		  		}

			    SendClientMessage(id, COLOR_GREY, TXT_FALLOUT);
				SetSpawnInfo(id, id, GetPlayerSkinEx(id), 2482.1921 - random(39), -1660.4783 + random(47), 161.0000, random(360), 0, 0, 0, 0, 0, 0);
			}
			else if(Gaming == GAMETYPE_LASTBULLET)
			{
				if (Player[id][Team] == TEAM_A)
  				{
  					TextDrawSetString(PlayerSpecInfo[id][6], "~b~~h~WPS: ~w~Deagle");
	  			}
		  		else
		  		{
			  	    TextDrawSetString(PlayerSpecInfo[id][6], "~b~~h~WPS: ~w~Deagle");
		  		}

			    SendClientMessage(id, COLOR_GREY, TXT_LASTBULLET);
				SetSpawnInfo(id, id, GetPlayerSkinEx(id), lBullet_Spawns[eScenario[FileID]][id][0], lBullet_Spawns[eScenario[FileID]][id][1], lBullet_Spawns[eScenario[FileID]][id][2], random(360), 0, 0, 0, 0, 0, 0);

				LifesLeft = CreatePlayerTextDraw(id, 578.000000, 57.000000, "_");
				PlayerTextDrawAlignment(id, LifesLeft, 2);
				PlayerTextDrawBackgroundColor(id, LifesLeft, 51);
				PlayerTextDrawFont(id, LifesLeft, 2);
				PlayerTextDrawLetterSize(id, LifesLeft, 0.210000, 1.100000);
				PlayerTextDrawColor(id, LifesLeft, -1);
				PlayerTextDrawSetOutline(id, LifesLeft, 1);
				PlayerTextDrawSetProportional(id, LifesLeft, 1);
			}
		}
		else
		{
			if(Gaming == GAMETYPE_BASE)
			{
 	 			if( !Interior_Base )
		    	{
		        	SendClientMessage(id, COLOR_GREY, TXT_BASE_DEF);
		    	}
		   	 	else
		    	{
		        	SendClientMessage(id, COLOR_GREY, TXT_INT);
		    	}

				if (Player[id][Team] == TEAM_A)
  				{
  					TextDrawSetString(PlayerSpecInfo[id][6], "~r~~h~WPS: ~w~-");
	  			}
		  		else
		  		{
			  	    TextDrawSetString(PlayerSpecInfo[id][6], "~b~~h~WPS: ~w~-");
		  		}

//			    SetPlayerMapIcon(id, MAPICON_ATTACKERSPAWN, eScenario[SpawnDefenders][0] - RANDOM_SPAWN_ROUND + random(RANDOM_SPAWN_ROUND), eScenario[SpawnDefenders][1] - RANDOM_SPAWN_ROUND + random(RANDOM_SPAWN_ROUND), eScenario[SpawnDefenders][2], ATTACKERSMAP_ICON, 0, MAPICON_LOCAL);
			}
			else if(Gaming == GAMETYPE_ARENA)
			{
				if (Player[id][Team] == TEAM_A)
  				{
  					TextDrawSetString(PlayerSpecInfo[id][6], "~r~~h~WPS: ~w~Arena");
	  			}
		  		else
		  		{
			  	    TextDrawSetString(PlayerSpecInfo[id][6], "~b~~h~WPS: ~w~Arena");
		  		}
				SendClientMessage(id, COLOR_GREY, TXT_ARENA);
			}
			else if(Gaming == GAMETYPE_TDM)
			{
				if (Player[id][Team] == TEAM_A)
  				{
  					TextDrawSetString(PlayerSpecInfo[id][6], "~r~~h~WPS: ~w~TDM");
	  			}
		  		else
		  		{
			  	    TextDrawSetString(PlayerSpecInfo[id][6], "~b~~h~WPS: ~w~TDM");
		  		}

				stringo = "";
				strcat(stringo, TXT_TDM_P1" ");
				strcat(stringo, numstr(gConfig[TDMKills]));
				strcat(stringo, TXT_TDM_P2);

				SendClientMessage(id, COLOR_GREY, stringo);
			}
			else if(Gaming == GAMETYPE_GUNGAME)
			{
				if (Player[id][Team] == TEAM_A)
  				{
  					TextDrawSetString(PlayerSpecInfo[id][6], "~r~~h~WPS: ~w~Gungame");
	  			}
		  		else
		  		{
			  	    TextDrawSetString(PlayerSpecInfo[id][6], "~b~~h~WPS: ~w~Gungame");
		  		}

				SendClientMessage(id, COLOR_GREY, TXT_GUNGAME);
			}
			else if(Gaming == GAMETYPE_FIGHT)
			{
				if (Player[id][Team] == TEAM_A)
  				{
  					TextDrawSetString(PlayerSpecInfo[id][6], "~r~~h~WPS: ~w~Fight");
	  			}
		  		else
		  		{
			  	    TextDrawSetString(PlayerSpecInfo[id][6], "~b~~h~WPS: ~w~Fight");
		  		}

				SendClientMessage(id, COLOR_GREY, TXT_FIGHT);
		        SetSpawnInfo(id, id, GetPlayerSkinEx(id), fFights_Spawns[eScenario[FileID]][id][0], fFights_Spawns[eScenario[FileID]][id][1], fFights_Spawns[eScenario[FileID]][id][2], 0.0, 0, 0, 0, 0, 0, 0);
   			}
		    else if(Gaming == GAMETYPE_FALLOUT)
		    {
				if (Player[id][Team] == TEAM_A)
	  			{
	  				TextDrawSetString(PlayerSpecInfo[id][6], "_");
	 			}
		  		else
		  		{
			  	    TextDrawSetString(PlayerSpecInfo[id][6], "_");
		  		}

			    SendClientMessage(id, COLOR_GREY, TXT_FALLOUT);
				SetSpawnInfo(id, id, GetPlayerSkinEx(id), 2482.1921 - random(39), -1660.4783 + random(47), 161.0000, random(360), 0, 0, 0, 0, 0, 0);
			}
		    else if(Gaming == GAMETYPE_LASTBULLET)
		    {
				if (Player[id][Team] == TEAM_A)
	  			{
	  				TextDrawSetString(PlayerSpecInfo[id][6], "_");
	 			}
		  		else
		  		{
			  	    TextDrawSetString(PlayerSpecInfo[id][6], "_");
		  		}

			    SendClientMessage(id, COLOR_GREY, TXT_LASTBULLET);
				SetSpawnInfo(id, id, GetPlayerSkinEx(id), lBullet_Spawns[eScenario[FileID]][id][0], lBullet_Spawns[eScenario[FileID]][id][1], lBullet_Spawns[eScenario[FileID]][id][2], random(360), 0, 0, 0, 0, 0, 0);

				LifesLeft = CreatePlayerTextDraw(id, 578.000000, 57.000000, "_");
				PlayerTextDrawAlignment(id, LifesLeft, 2);
				PlayerTextDrawBackgroundColor(id, LifesLeft, 51);
				PlayerTextDrawFont(id, LifesLeft, 2);
				PlayerTextDrawLetterSize(id, LifesLeft, 0.210000, 1.100000);
				PlayerTextDrawColor(id, LifesLeft, -1);
				PlayerTextDrawSetOutline(id, LifesLeft, 1);
				PlayerTextDrawSetProportional(id, LifesLeft, 1);
			}
		}

		if( iT == TEAM_A )
		{
			Team1_StartHP += gConfig[GameMode] == GAMEMODE_NOCBUG ? 100 : 200;
		}
		else if( iT == TEAM_B )
		{
			Team2_StartHP += gConfig[GameMode] == GAMEMODE_NOCBUG ? 100 : 200;
		}

		if( Player[id][InDm] != -1 )
		{
			MySQLStatus[TotalQuerys] ++; mysql_tquery(g_MySQLConnection, sprintf("UPDATE bestdmplayer SET damage = '%d', kills = '%d' WHERE nickname = '%s' AND dmid = '%d'", Player[id][DDamage], Player[id][DKills], Player[id][Nickname], Player[id][InDm]), "", "");
			Player[id][InDm] = -1;
		}

		if (gConfig[UseHealthBars])
		{
			SetPlayerScore(id, Player[id][RDamage]);
		}
		else
		{
			SetPlayerScore(id, gConfig[GameMode] == GAMEMODE_NOCBUG ? 100 : 200);
		}

		if (AntiHits)
		{
		//	TextDrawShowForPlayer(id, TD_NotHits);
			TextDrawShowForPlayer(id, TD_NoHitsScritta);
		}

		TeamPlayers[iT]++;
		SetPlayerColor(id, iTeam[iT][InGameColor]);
		SetPlayerVirtualWorld(id, GAME_WORLD);
		TextDrawHideForPlayer(id, TeamPlayers_TD);

		if( GamePaused )
		{
			TogglePlayerControllable( id , false );
	//		TextDrawShowForPlayer( id , RoundPaused );
		}

		if(Gaming == GAMETYPE_BASE)
		{
			DisablePlayerCheckpoint(id);
			if(!Interior_Base)
			    SetPlayerCheckpointEx(id, eScenario[Checkpoint][0], eScenario[Checkpoint][1], eScenario[Checkpoint][2]+1.5, 2.0);

			MostraWeaponset(id);
		}

		// all great things are simple, and many can be expressed in single words: freedom, justice, honor, duty, mercy, hope.
		TextDrawShowForPlayer(id, RoundStats[0]);
		TextDrawShowForPlayer(id, RoundStats[1]);
		TextDrawShowForPlayer(id, RoundStats[2]);
		TextDrawShowForPlayer(id, RoundStats[3]);

		GangZoneShowForPlayer(id, ZonaAttornoCP, GANGZONE_COLORAZIONE);

//		SetPlayerPos(id, timeout_Pos[id][0], timeout_Pos[id][1], timeout_Pos[id][2]);
//		SetPlayerFacingAngle(id, timeout_Pos[id][3]);

        Player[id][InRestoring] = true;

		SetSpawnInfo(id, iT, iTeam[iT][Skin], timeout_Pos[id][0], timeout_Pos[id][1], timeout_Pos[id][2], timeout_Pos[id][3], 0, 0, 0, 0, 0, 0);
		SpawnPlayer (id);

		SetPlayerHealth(id, timeout_Health[id]);
		SetPlayerArmour(id, timeout_Armour[id]);

		SetPlayerInterior(id, eScenario[Interior]);
		SetPlayerTeam(id, Player[id][Team]);
		SetPlayerSkin(id, iTeam[Player[id][Team]][Skin]);

		format (stringo, sizeof stringo, "Admin/Mod {"#COLOR_SYSTEM_FOCUS"}%s{"#COLOR_SYSTEM_REST"} has brought and restored {"#COLOR_SYSTEM_FOCUS"}%s{"#COLOR_SYSTEM_REST"} into the round (%s).", Player[playerid][Nickname], Player[id][Nickname], GetRoleName(TeamRole[Player[id][Team]]));
        SendClientMessageToAll(COLOR_SYSTEM, stringo);
		PlayerPlaySound(playerid, SOUND_SUCCESS, 0.0, 0.0, 0.0);

		MySQLStatus[TotalQuerys] ++; mysql_tquery(g_MySQLConnection, sprintf ("DELETE FROM timeouts WHERE nickname = '%s' AND gid = %d", Player[id][Nickname], G_ID), "", "");

		timeoutPlayer[id] = false;

		SyncTextdraw(1);
		RefreshTeamPlayers_TD();
		FixHealthBars();

		if (Player[id][FinalRound_Status] != FINALROUND_STATUS_HIDDEN)
  		{
			for (new i2 = 0; i2 < MAX_STATIC_TEXTDRAWS; i2++) TextDrawHideForPlayer(id, FineRound_Static[i2]);

			new cv = Player[id][CurrentView];

			TextDrawHideForPlayer(id, FineRound_Dynamic[cv][BluePlayers]);
			TextDrawHideForPlayer(id, FineRound_Dynamic[cv][GreenPlayers]);
			TextDrawHideForPlayer(id, FineRound_Dynamic[cv][BlueKills]);
			TextDrawHideForPlayer(id, FineRound_Dynamic[cv][BlueDamages]);
			TextDrawHideForPlayer(id, FineRound_Dynamic[cv][GreenKills]);
			TextDrawHideForPlayer(id, FineRound_Dynamic[cv][GreenDamage]);
			TextDrawHideForPlayer(id, FineRound_Dynamic[cv][TotalKGreen]);
			TextDrawHideForPlayer(id, FineRound_Dynamic[cv][TotalDGreen]);
			TextDrawHideForPlayer(id, FineRound_Dynamic[cv][TotalKBlue]);
			TextDrawHideForPlayer(id, FineRound_Dynamic[cv][TotalDBlue]);
			TextDrawHideForPlayer(id, FineRound_Dynamic[cv][Top2_Nick]);
			TextDrawHideForPlayer(id, FineRound_Dynamic[cv][Top2_Stats]);
			TextDrawHideForPlayer(id, FineRound_Dynamic[cv][Top3_Stats]);
			TextDrawHideForPlayer(id, FineRound_Dynamic[cv][Top3_Nick]);
			TextDrawHideForPlayer(id, FineRound_Dynamic[cv][Top1_Stats]);
			TextDrawHideForPlayer(id, FineRound_Dynamic[cv][Top1_Nick]);
			TextDrawHideForPlayer(id, FineRound_Dynamic[cv][RoundsInfo]);
			TextDrawHideForPlayer(id, FineRound_Dynamic[cv][AttDefWin]);
	        TextDrawHideForPlayer(id, FineRound_Dynamic[cv][Stringa_Winner2]);
	        TextDrawHideForPlayer(id, FineRound_Dynamic[cv][Stringa_TeamWin]);
	        TextDrawHideForPlayer(id, FineRound_Dynamic[cv][Stringa_Winner1]);
			TextDrawHideForPlayer(id, FineRound_Dynamic[cv][Stringa_RoundInfo]);
	        TextDrawHideForPlayer(id, FineRound_Dynamic[cv][Stringa_TmpBest]);

            if (gConfig[Matchmode] == MATCHMODE_TCWCW)
	        	CancelSelectTextDraw (id);

		    Player[id][FinalRound_Status] = FINALROUND_STATUS_HIDDEN;
        }
	}
	else
	{
		format(stringo, sizeof stringo, "Admin/Mod {"#COLOR_SYSTEM_FOCUS"}%s{"#COLOR_SYSTEM_REST"} has brought {"#COLOR_SYSTEM_FOCUS"}%s{"#COLOR_SYSTEM_REST"} into the round.", Player[playerid][Nickname], Player[id][Nickname]);
        SendClientMessageToAll(COLOR_SYSTEM, stringo);

        __staticAddProcess (id);
        RefreshTeamPlayers_TD();
	    FixHealthBars();

		PlayerPlaySound(playerid, SOUND_SUCCESS, 0.0, 0.0, 0.0);
	}

	RefreshIcons();
	return true;
}

/*stock AssignMatchIndex(playerid)
{
	for (new i = 0; i < MAX_MATCH_DATA; ++i) {
	    if (PlayerMatch[i][mNickname][0] == '\0') {
            PlayerMatch[i][mNickname] = Player[playerid][Nickname];
	        return i;
	    }
	}

	return -1;
}*/
stock __staticAddProcess (id)
{
/*	if (Player[id][pMatchID] != -1) {
		PlayerMatch[Player[id][pMatchID]][Played] = true;
	}
	else {
	    Player[id][pMatchID] = AssignMatchIndex (id);

	    if (Player[id][pMatchID] != -1) {
	    	PlayerMatch[Player[id][pMatchID]][Played] = true;
	    	PlayerMatch[Player[id][pMatchID]][mTeam] = Player[id][Team];
		}
		else
		{
		    printf("SearchMatchIndex(Playerid: %d) failed, FIX IT!!!", id);
		}
	}
	*/
  	Player_outSecs[id] = 10;
	new pt = Player[id][Team];

	if(IsPlayerInAnyVehicle(id))
	{
		DestroyVehicleEx(GetPlayerVehicleID(id));
	}

	if (InSpec[id]!=-1) Spec_RemovePlayerFromSpec(id);

	Player[id][InGame] 	  = 1;
	PlayerAfk_Seconds[id] = 0;

//		Player[id][RKills] = 0;
//		Player[id][RDeaths] = 0;
//		Player[id][RDamage] = 0;

	CleanSpecTDs (id);

	if(TeamRole[pt]==ATTACKERS)
	{
	    if(Gaming == GAMETYPE_BASE)
		{
	        if( !Interior_Base )
			{
			    SendClientMessage(id, COLOR_GREY, TXT_BASE_ATT);
			}
			else
			{
			    SendClientMessage(id, COLOR_GREY, TXT_INT);
			}

			if (Player[id][Team] == TEAM_A)
			{
				TextDrawSetString(PlayerSpecInfo[id][6], "~r~~h~WPS: ~w~-");
  			}
	  		else
	  		{
		  	    TextDrawSetString(PlayerSpecInfo[id][6], "~b~~h~WPS: ~w~-");
	  		}

			SetSpawnInfo(id, Player[id][Team], GetPlayerSkinEx(id), eScenario[SpawnAttackers][0] - RANDOM_SPAWN_ROUND + random(RANDOM_SPAWN_ROUND), eScenario[SpawnAttackers][1] - RANDOM_SPAWN_ROUND + random(RANDOM_SPAWN_ROUND), eScenario[SpawnAttackers][2], 0.0, 0, 0, 0, 0, 0, 0);
			SetPlayerMapIcon(id, MAPICON_ATTACKERSPAWN, eScenario[SpawnAttackers][0], eScenario[SpawnAttackers][1], eScenario[SpawnAttackers][2], ATTACKERSMAP_ICON, 0, MAPICON_TYPE_ATTSPAWN);
		}
		else if(Gaming == GAMETYPE_ARENA)
		{
			if (Player[id][Team] == TEAM_A)
			{
				TextDrawSetString(PlayerSpecInfo[id][6], "~r~~h~WPS: ~w~Arena");
  			}
	  		else
	  		{
		  	    TextDrawSetString(PlayerSpecInfo[id][6], "~b~~h~WPS: ~w~Arena");
	  		}

			SendClientMessage(id, COLOR_GREY, TXT_ARENA);
			SetSpawnInfo(id, Player[id][Team], GetPlayerSkinEx(id), eScenario[SpawnAttackers][0] - RANDOM_SPAWN_ROUND + random(RANDOM_SPAWN_ROUND), eScenario[SpawnAttackers][1] - RANDOM_SPAWN_ROUND + random(RANDOM_SPAWN_ROUND), eScenario[SpawnAttackers][2], 0.0, 0, 0, 0, 0, 0, 0);
			SetPlayerMapIcon(id, MAPICON_ATTACKERSPAWN, eScenario[SpawnAttackers][0], eScenario[SpawnAttackers][1], eScenario[SpawnAttackers][2], ATTACKERSMAP_ICON, 0, MAPICON_TYPE_ATTSPAWN);
		}
		else if(Gaming == GAMETYPE_TDM)
		{
			if (Player[id][Team] == TEAM_A)
			{
				TextDrawSetString(PlayerSpecInfo[id][6], "~r~~h~WPS: ~w~TDM");
  			}
	  		else
	  		{
		  	    TextDrawSetString(PlayerSpecInfo[id][6], "~b~~h~WPS: ~w~TDM");
	  		}

			stringo = "";
			strcat(stringo, TXT_TDM_P1" ");
			strcat(stringo, numstr(gConfig[TDMKills]));
			strcat(stringo, TXT_TDM_P2);

			SendClientMessage(id, COLOR_GREY, stringo);
			SetSpawnInfo(id, Player[id][Team], GetPlayerSkinEx(id), eScenario[SpawnAttackers][0] - RANDOM_SPAWN_ROUND + random(RANDOM_SPAWN_ROUND), eScenario[SpawnAttackers][1] - RANDOM_SPAWN_ROUND + random(RANDOM_SPAWN_ROUND), eScenario[SpawnAttackers][2], 0.0, 0, 0, 0, 0, 0, 0);
			SetPlayerMapIcon(id, MAPICON_ATTACKERSPAWN, eScenario[SpawnAttackers][0], eScenario[SpawnAttackers][1], eScenario[SpawnAttackers][2], ATTACKERSMAP_ICON, 0, MAPICON_TYPE_ATTSPAWN);
		}
		else if(Gaming == GAMETYPE_GUNGAME)
		{
			if (Player[id][Team] == TEAM_A)
			{
				TextDrawSetString(PlayerSpecInfo[id][6], "~r~~h~WPS: ~w~Gungame");
  			}
	  		else
	  		{
		  	    TextDrawSetString(PlayerSpecInfo[id][6], "~b~~h~WPS: ~w~Gungame");
	  		}

			SendClientMessage(id, COLOR_GREY, TXT_GUNGAME);
			new rand = random(20);
			SetSpawnInfo(id, id, GetPlayerSkinEx(id), Scenario_MultipleSpawns[rand][0], Scenario_MultipleSpawns[rand][1], Scenario_MultipleSpawns[rand][2], Scenario_MultipleSpawns[rand][3], 0, 0, 0, 0, 0, 0);
		}
		else if(Gaming == GAMETYPE_FIGHT)
		{
			if (Player[id][Team] == TEAM_A)
			{
				TextDrawSetString(PlayerSpecInfo[id][6], "~r~~h~WPS: ~w~Fight");
  			}
	  		else
	  		{
		  	    TextDrawSetString(PlayerSpecInfo[id][6], "~b~~h~WPS: ~w~Fight");
	  		}

			SendClientMessage(id, COLOR_GREY, TXT_FIGHT);
	        SetSpawnInfo(id, id, GetPlayerSkinEx(id), fFights_Spawns[eScenario[FileID]][id][0], fFights_Spawns[eScenario[FileID]][id][1], fFights_Spawns[eScenario[FileID]][id][2], 0.0, 0, 0, 0, 0, 0, 0);
		}
	    else if(Gaming == GAMETYPE_FALLOUT)
	    {
			if (Player[id][Team] == TEAM_A)
  			{
  				TextDrawSetString(PlayerSpecInfo[id][6], "_");
 			}
	  		else
	  		{
		  	    TextDrawSetString(PlayerSpecInfo[id][6], "_");
	  		}

		    SendClientMessage(id, COLOR_GREY, TXT_FALLOUT);
			SetSpawnInfo(id, id, GetPlayerSkinEx(id), 2482.1921 - random(39), -1660.4783 + random(47), 161.0000, random(360), 0, 0, 0, 0, 0, 0);
		}
	}
	else
	{
	    if(Gaming == GAMETYPE_BASE)
		{
	        if( !Interior_Base )
			{
			    SendClientMessage(id, COLOR_GREY, TXT_BASE_DEF);
			}
			else
			{
			    SendClientMessage(id, COLOR_GREY, TXT_INT);
			}

			if (Player[id][Team] == TEAM_A)
			{
				TextDrawSetString(PlayerSpecInfo[id][6], "~r~~h~WPS: ~w~-");
  			}
	  		else
	  		{
		  	    TextDrawSetString(PlayerSpecInfo[id][6], "~b~~h~WPS: ~w~-");
	  		}

			SetSpawnInfo(id, Player[id][Team], GetPlayerSkinEx(id), eScenario[SpawnDefenders][0] - RANDOM_SPAWN_ROUND + random(RANDOM_SPAWN_ROUND), eScenario[SpawnDefenders][1] - RANDOM_SPAWN_ROUND + random(RANDOM_SPAWN_ROUND), eScenario[SpawnDefenders][2], 0.0, 0, 0, 0, 0, 0, 0);
			//SetPlayerMapIcon(id, MAPICON_ATTACKERSPAWN, eScenario[SpawnDefenders][0], eScenario[SpawnDefenders][1], eScenario[SpawnDefenders][2], ATTACKERSMAP_ICON, 0, MAPICON_TYPE_ATTSPAWN);
		}
		else if(Gaming == GAMETYPE_ARENA)
		{
			if (Player[id][Team] == TEAM_A)
			{
				TextDrawSetString(PlayerSpecInfo[id][6], "~r~~h~WPS: ~w~Arena");
  			}
	  		else
	  		{
		  	    TextDrawSetString(PlayerSpecInfo[id][6], "~b~~h~WPS: ~w~Arena");
	  		}

			SendClientMessage(id, COLOR_GREY, TXT_ARENA);
	   		SetSpawnInfo(id, Player[id][Team], GetPlayerSkinEx(id), eScenario[SpawnDefenders][0] - RANDOM_SPAWN_ROUND + random(RANDOM_SPAWN_ROUND), eScenario[SpawnDefenders][1] - RANDOM_SPAWN_ROUND + random(RANDOM_SPAWN_ROUND), eScenario[SpawnDefenders][2], 0.0, 0, 0, 0, 0, 0, 0);
		}
		else if(Gaming == GAMETYPE_TDM)
		{
			if (Player[id][Team] == TEAM_A)
			{
				TextDrawSetString(PlayerSpecInfo[id][6], "~r~~h~WPS: ~w~TDM");
  			}
	  		else
	  		{
		  	    TextDrawSetString(PlayerSpecInfo[id][6], "~b~~h~WPS: ~w~TDM");
	  		}

			stringo = "";
			strcat(stringo, TXT_TDM_P1" ");
			strcat(stringo, numstr(gConfig[TDMKills]));
			strcat(stringo, TXT_TDM_P2);

			SendClientMessage(id, COLOR_GREY, stringo);
			SetSpawnInfo(id, Player[id][Team], GetPlayerSkinEx(id), eScenario[SpawnDefenders][0] - RANDOM_SPAWN_ROUND + random(RANDOM_SPAWN_ROUND), eScenario[SpawnDefenders][1] - RANDOM_SPAWN_ROUND + random(RANDOM_SPAWN_ROUND), eScenario[SpawnDefenders][2], 0.0, 0, 0, 0, 0, 0, 0);
		}
		else if(Gaming == GAMETYPE_GUNGAME)
		{
			if (Player[id][Team] == TEAM_A)
			{
				TextDrawSetString(PlayerSpecInfo[id][6], "~r~~h~WPS: ~w~Gungame");
  			}
	  		else
	  		{
		  	    TextDrawSetString(PlayerSpecInfo[id][6], "~b~~h~WPS: ~w~Gungame");
	  		}

			SendClientMessage(id, COLOR_GREY, TXT_GUNGAME);
			new rand = random(20);
			SetSpawnInfo(id, id, GetPlayerSkinEx(id), Scenario_MultipleSpawns[rand][0], Scenario_MultipleSpawns[rand][1], Scenario_MultipleSpawns[rand][2], Scenario_MultipleSpawns[rand][3], 0, 0, 0, 0, 0, 0);
		}
		else if(Gaming == GAMETYPE_FIGHT)
		{
			if (Player[id][Team] == TEAM_A)
			{
				TextDrawSetString(PlayerSpecInfo[id][6], "~r~~h~WPS: ~w~Fight");
  			}
	  		else
	  		{
		  	    TextDrawSetString(PlayerSpecInfo[id][6], "~b~~h~WPS: ~w~Fight");
	  		}

			SendClientMessage(id, COLOR_GREY, TXT_FIGHT);
	        SetSpawnInfo(id, id, GetPlayerSkinEx(id), fFights_Spawns[eScenario[FileID]][id][0], fFights_Spawns[eScenario[FileID]][id][1], fFights_Spawns[eScenario[FileID]][id][2], 0.0, 0, 0, 0, 0, 0, 0);
		}
	    else if(Gaming == GAMETYPE_FALLOUT)
	    {
			if (Player[id][Team] == TEAM_A)
  			{
  				TextDrawSetString(PlayerSpecInfo[id][6], "_");
 			}
	  		else
	  		{
		  	    TextDrawSetString(PlayerSpecInfo[id][6], "_");
	  		}

		    SendClientMessage(id, COLOR_GREY, TXT_FALLOUT);
			SetSpawnInfo(id, id, GetPlayerSkinEx(id), 2482.1921 - random(39), -1660.4783 + random(47), 161.0000, random(360), 0, 0, 0, 0, 0, 0);
		}
	}

	if( pt == TEAM_A )
	{
	    Team1_StartHP += gConfig[GameMode] == GAMEMODE_NOCBUG ? 100 : 200;
	}
	else if( pt == TEAM_B )
	{
		Team2_StartHP += gConfig[GameMode] == GAMEMODE_NOCBUG ? 100 : 200;
	}

	if( Player[id][InDm] != -1 )
	{
	    MySQLStatus[TotalQuerys] ++; mysql_tquery(g_MySQLConnection, sprintf("UPDATE bestdmplayer SET damage = '%d', kills = '%d' WHERE nickname = '%s' AND dmid = '%d'", Player[id][DDamage], Player[id][DKills], Player[id][Nickname], Player[id][InDm]), "", "");
	    Player[id][InDm] = -1;
	}

	if (gConfig[UseHealthBars])
	{
		SetPlayerScore(id, Player[id][RDamage]);
	}
	else
	{
	    SetPlayerScore(id, gConfig[GameMode] == GAMEMODE_NOCBUG ? 100 : 200);
	}

	TeamPlayers[pt]++;
	SetPlayerColor(id, iTeam[pt][InGameColor]);
	SetPlayerVirtualWorld(id, GAME_WORLD);
	TextDrawHideForPlayer(id, TeamPlayers_TD);

	if (AntiHits)
	{
	//    TextDrawShowForPlayer(id, TD_NotHits);
	    TextDrawShowForPlayer(id, TD_NoHitsScritta);
	}

	if( GamePaused )
	{
	    TogglePlayerControllable( id , false );
	    //TextDrawShowForPlayer( id , RoundPaused );
	}

	if(Gaming == GAMETYPE_BASE)
	{
		DisablePlayerCheckpoint(id);
		if(!Interior_Base)
			SetPlayerCheckpointEx(id, eScenario[Checkpoint][0], eScenario[Checkpoint][1], eScenario[Checkpoint][2]+1.5, 2.0);

		MostraWeaponset(id);
	}

	// all great things are simple, and many can be expressed in single words: freedom, justice, honor, duty, mercy, hope.
	TextDrawShowForPlayer(id, RoundStats[0]);
	TextDrawShowForPlayer(id, RoundStats[1]);
	TextDrawShowForPlayer(id, RoundStats[2]);
	TextDrawShowForPlayer(id, RoundStats[3]);

	GangZoneShowForPlayer(id, ZonaAttornoCP, GANGZONE_COLORAZIONE);
	SpawnPlayer(id);

    SyncTextdraw(1);

	if (Player[id][FinalRound_Status] != FINALROUND_STATUS_HIDDEN)
	{
		new cv = Player[id][CurrentView];
		for (new i2 = 0; i2 < MAX_STATIC_TEXTDRAWS; i2++) TextDrawHideForPlayer(id, FineRound_Static[i2]);

		TextDrawHideForPlayer(id, FineRound_Dynamic[cv][BluePlayers]);
		TextDrawHideForPlayer(id, FineRound_Dynamic[cv][GreenPlayers]);
		TextDrawHideForPlayer(id, FineRound_Dynamic[cv][BlueKills]);
		TextDrawHideForPlayer(id, FineRound_Dynamic[cv][BlueDamages]);
		TextDrawHideForPlayer(id, FineRound_Dynamic[cv][GreenKills]);
		TextDrawHideForPlayer(id, FineRound_Dynamic[cv][GreenDamage]);
		TextDrawHideForPlayer(id, FineRound_Dynamic[cv][TotalKGreen]);
		TextDrawHideForPlayer(id, FineRound_Dynamic[cv][TotalDGreen]);
		TextDrawHideForPlayer(id, FineRound_Dynamic[cv][TotalKBlue]);
		TextDrawHideForPlayer(id, FineRound_Dynamic[cv][TotalDBlue]);
		TextDrawHideForPlayer(id, FineRound_Dynamic[cv][Top2_Nick]);
		TextDrawHideForPlayer(id, FineRound_Dynamic[cv][Top2_Stats]);
		TextDrawHideForPlayer(id, FineRound_Dynamic[cv][Top3_Stats]);
		TextDrawHideForPlayer(id, FineRound_Dynamic[cv][Top3_Nick]);
		TextDrawHideForPlayer(id, FineRound_Dynamic[cv][Top1_Stats]);
		TextDrawHideForPlayer(id, FineRound_Dynamic[cv][Top1_Nick]);
		TextDrawHideForPlayer(id, FineRound_Dynamic[cv][RoundsInfo]);
		TextDrawHideForPlayer(id, FineRound_Dynamic[cv][AttDefWin]);
	    TextDrawHideForPlayer(id, FineRound_Dynamic[cv][Stringa_Winner2]);
	    TextDrawHideForPlayer(id, FineRound_Dynamic[cv][Stringa_TeamWin]);
	    TextDrawHideForPlayer(id, FineRound_Dynamic[cv][Stringa_Winner1]);
		TextDrawHideForPlayer(id, FineRound_Dynamic[cv][Stringa_RoundInfo]);
	    TextDrawHideForPlayer(id, FineRound_Dynamic[cv][Stringa_TmpBest]);

	    if (gConfig[Matchmode] == MATCHMODE_TCWCW)
	    	CancelSelectTextDraw (id);

	    Player[id][FinalRound_Status] = FINALROUND_STATUS_HIDDEN;
	}
}

COMMAND:aa(playerid, params[])
{
	return cmd_add(playerid, "all");
}

COMMAND:ab(playerid, params[])
{
    return cmd_add(playerid, "ball");
}

COMMAND:readd(playerid, params[])
{
	if(!IsPlayerAdminEx(playerid, lMod)) return true;
	if(!RoundStarted) return SendClientMessage(playerid, COLOR_RED, "The round is not started."), PlayerPlaySound(playerid, SOUND_WRONGCOMMAND, 0.0, 0.0, 0.0);
	new id;
	if(sscanf(params, "u", id))
	{
		SendClientMessage(playerid, COLOR_RED, "Use /readd [id]"), PlayerPlaySound(playerid, SOUND_WRONGCOMMAND, 0.0, 0.0, 0.0);
	}
	else
	{
		if(!IsPlayerConnected(id)) return SendClientMessage(playerid, COLOR_RED, "Invalid player."), PlayerPlaySound(playerid, SOUND_WRONGCOMMAND, 0.0, 0.0, 0.0);
		if(!Player[id][InGame])return SendClientMessage(playerid, COLOR_RED, "The player is not in-game."), PlayerPlaySound(playerid, SOUND_WRONGCOMMAND, 0.0, 0.0, 0.0);
		if(!Player[id][Spawned])return SendClientMessage(playerid, COLOR_RED, "The player is not spawned."), PlayerPlaySound(playerid, SOUND_WRONGCOMMAND, 0.0, 0.0, 0.0);
		if(Player[id][Team]==NULL_TEAM || Player[id][Team] == TEAM_REF || IsSubPlayer(id))return SendClientMessage(playerid, COLOR_RED, "The player's team is not valid.");
		format(stringo, sizeof stringo, "Admin/Mod {"#COLOR_SYSTEM_FOCUS"}%s{"#COLOR_SYSTEM_REST"} has re-added {"#COLOR_SYSTEM_FOCUS"}%s{"#COLOR_SYSTEM_REST"} into the round.", Player[playerid][Nickname], Player[id][Nickname]);
        SendClientMessageToAll(COLOR_SYSTEM, stringo);

		new iT = Player[id][Team];

		Player_outSecs[id] = 10;

	    DisablePlayerCheckpoint(id);

		if (Gaming == GAMETYPE_BASE)
		{
			if(Player[id][Weaponset] != INVALID_WEAPON_SET)
			{
				Weaponsets[Player[id][Weaponset]][TeamSelection][Player[id][Team]] --;
			}

			Player[id][Weaponset] = INVALID_WEAPON_SET;
		}

//		TextDrawShowForPlayer(id, TeamPlayers_TD);
		if(IsPlayerInAnyVehicle(id))
		{
			DestroyVehicleEx(GetPlayerVehicleID(id));
		}

		PlayerAfk_Seconds[id] = 0;

	//	Player[id][RKills] = 0;
	//	Player[id][RDeaths] = 0;
	//	Player[id][RDamage] = 0;

		FixHealthBars();

		if (AntiHits)
		{
	//	    TextDrawShowForPlayer(id, TD_NotHits);
		    TextDrawShowForPlayer(id, TD_NoHitsScritta);

		}

		if(TeamRole[iT]==ATTACKERS)
		{
		    if(Gaming == GAMETYPE_BASE)
			{
		        if( !Interior_Base )
				{
				    SendClientMessage(id, COLOR_GREY, TXT_BASE_ATT);
				}
				else
				{
				    SendClientMessage(id, COLOR_GREY, TXT_INT);
				}
				SetSpawnInfo(id, Player[id][Team], GetPlayerSkinEx(id), eScenario[SpawnAttackers][0] - RANDOM_SPAWN_ROUND + random(RANDOM_SPAWN_ROUND), eScenario[SpawnAttackers][1] - RANDOM_SPAWN_ROUND + random(RANDOM_SPAWN_ROUND), eScenario[SpawnAttackers][2], 0.0, 0, 0, 0, 0, 0, 0);
				SetPlayerMapIcon(id, MAPICON_ATTACKERSPAWN, eScenario[SpawnAttackers][0], eScenario[SpawnAttackers][1], eScenario[SpawnAttackers][2], ATTACKERSMAP_ICON, 0, MAPICON_TYPE_ATTSPAWN);
			}
			else if(Gaming == GAMETYPE_ARENA)
			{
			    SendClientMessage(id, COLOR_GREY, TXT_ARENA);
				SetSpawnInfo(id, Player[id][Team], GetPlayerSkinEx(id), eScenario[SpawnAttackers][0] - RANDOM_SPAWN_ROUND + random(RANDOM_SPAWN_ROUND), eScenario[SpawnAttackers][1] - RANDOM_SPAWN_ROUND + random(RANDOM_SPAWN_ROUND), eScenario[SpawnAttackers][2], 0.0, 0, 0, 0, 0, 0, 0);
				SetPlayerMapIcon(id, MAPICON_ATTACKERSPAWN, eScenario[SpawnAttackers][0], eScenario[SpawnAttackers][1], eScenario[SpawnAttackers][2], ATTACKERSMAP_ICON, 0, MAPICON_TYPE_ATTSPAWN);
			}
			else if(Gaming == GAMETYPE_TDM)
			{
				stringo = "";
				strcat(stringo, TXT_TDM_P1" ");
				strcat(stringo, numstr(gConfig[TDMKills]));
				strcat(stringo, TXT_TDM_P2);

			    SendClientMessage(id, COLOR_GREY, stringo);
				SetSpawnInfo(id, Player[id][Team], GetPlayerSkinEx(id), eScenario[SpawnAttackers][0] - RANDOM_SPAWN_ROUND + random(RANDOM_SPAWN_ROUND), eScenario[SpawnAttackers][1] - RANDOM_SPAWN_ROUND + random(RANDOM_SPAWN_ROUND), eScenario[SpawnAttackers][2], 0.0, 0, 0, 0, 0, 0, 0);
				SetPlayerMapIcon(id, MAPICON_ATTACKERSPAWN, eScenario[SpawnAttackers][0], eScenario[SpawnAttackers][1], eScenario[SpawnAttackers][2], ATTACKERSMAP_ICON, 0, MAPICON_TYPE_ATTSPAWN);
			}
			else if(Gaming == GAMETYPE_GUNGAME)
			{
			    SendClientMessage(id, COLOR_GREY, TXT_GUNGAME);
				new rand = random(20);
				SetSpawnInfo(id, id, GetPlayerSkinEx(id), Scenario_MultipleSpawns[rand][0], Scenario_MultipleSpawns[rand][1], Scenario_MultipleSpawns[rand][2], Scenario_MultipleSpawns[rand][3], 0, 0, 0, 0, 0, 0);
			}
		    else if(Gaming == GAMETYPE_FALLOUT)
		    {
			    SendClientMessage(id, COLOR_GREY, TXT_FALLOUT);
				SetSpawnInfo(id, id, GetPlayerSkinEx(id), 2482.1921 - random(39), -1660.4783 + random(47), 161.0000, random(360), 0, 0, 0, 0, 0, 0);
			}
		}
		else
		{
		    if(Gaming == GAMETYPE_BASE)
			{
		        if( !Interior_Base )
				{
			    	SendClientMessage(id, COLOR_GREY, TXT_BASE_DEF);
				}
				else
				{
				    SendClientMessage(id, COLOR_GREY, TXT_INT);
				}
				SetSpawnInfo(id, Player[id][Team], GetPlayerSkinEx(id), eScenario[SpawnDefenders][0] - RANDOM_SPAWN_ROUND + random(RANDOM_SPAWN_ROUND), eScenario[SpawnDefenders][1] - RANDOM_SPAWN_ROUND + random(RANDOM_SPAWN_ROUND), eScenario[SpawnDefenders][2], 0.0, 0, 0, 0, 0, 0, 0);
			}
			else if(Gaming == GAMETYPE_ARENA)
			{
			    SendClientMessage(id, COLOR_GREY, TXT_ARENA);
	    		SetSpawnInfo(id, Player[id][Team], GetPlayerSkinEx(id), eScenario[SpawnDefenders][0] - RANDOM_SPAWN_ROUND + random(RANDOM_SPAWN_ROUND), eScenario[SpawnDefenders][1] - RANDOM_SPAWN_ROUND + random(RANDOM_SPAWN_ROUND), eScenario[SpawnDefenders][2], 0.0, 0, 0, 0, 0, 0, 0);
			}
			else if(Gaming == GAMETYPE_TDM)
			{
				stringo = "";
				strcat(stringo, TXT_TDM_P1" ");
				strcat(stringo, numstr(gConfig[TDMKills]));
				strcat(stringo, TXT_TDM_P2);

			    SendClientMessage(id, COLOR_GREY, stringo);
				SetSpawnInfo(id, Player[id][Team], GetPlayerSkinEx(id), eScenario[SpawnDefenders][0] - RANDOM_SPAWN_ROUND + random(RANDOM_SPAWN_ROUND), eScenario[SpawnDefenders][1] - RANDOM_SPAWN_ROUND + random(RANDOM_SPAWN_ROUND), eScenario[SpawnDefenders][2], 0.0, 0, 0, 0, 0, 0, 0);
			}
			else if(Gaming == GAMETYPE_GUNGAME)
			{
			    SendClientMessage(id, COLOR_GREY, TXT_GUNGAME);
				new rand = random(20);
				SetSpawnInfo(id, id, GetPlayerSkinEx(id), Scenario_MultipleSpawns[rand][0], Scenario_MultipleSpawns[rand][1], Scenario_MultipleSpawns[rand][2], Scenario_MultipleSpawns[rand][3], 0, 0, 0, 0, 0, 0);
			}
		    else if(Gaming == GAMETYPE_FALLOUT)
		    {
			    SendClientMessage(id, COLOR_GREY, TXT_FALLOUT);
				SetSpawnInfo(id, id, GetPlayerSkinEx(id), 2482.1921 - random(39), -1660.4783 + random(47), 161.0000, random(360), 0, 0, 0, 0, 0, 0);
			}
		}

		if (gConfig[UseHealthBars])
		{
			SetPlayerScore(id, Player[id][RDamage]);
		}
		else
		{
		    SetPlayerScore(id, gConfig[GameMode] == GAMEMODE_NOCBUG ? 100 : 200);
		}

		SetPlayerColor(id, iTeam[Player[id][Team]][InGameColor]);
		SetPlayerVirtualWorld(id, GAME_WORLD);

		if( GamePaused )
		{
		    TogglePlayerControllable( id , false );
		  //  TextDrawShowForPlayer( id , RoundPaused );
		}

		if(Gaming == GAMETYPE_BASE)
		{
			DisablePlayerCheckpoint(id);
			if(!Interior_Base)
				SetPlayerCheckpointEx(id, eScenario[Checkpoint][0], eScenario[Checkpoint][1], eScenario[Checkpoint][2]+1.5, 2.0);

	       	MostraWeaponset(id);
		}

		// all great things are simple, and many can be expressed in single words: freedom, justice, honor, duty, mercy, hope.
		TextDrawShowForPlayer(id, RoundStats[0]);
		TextDrawShowForPlayer(id, RoundStats[1]);
		TextDrawShowForPlayer(id, RoundStats[2]);
		TextDrawShowForPlayer(id, RoundStats[3]);

		GangZoneShowForPlayer(id, ZonaAttornoCP, GANGZONE_COLORAZIONE);
		SpawnPlayer(id);

	    SyncTextdraw(1);
		RefreshTeamPlayers_TD();
	    PlayerPlaySound(playerid, SOUND_SUCCESS, 0.0, 0.0, 0.0);
	}
	RefreshIcons();
	return true;
}

COMMAND:remove(playerid, params[]) {
	if(!IsPlayerAdminEx(playerid, lMod)) return true;
	if(!RoundStarted) return SendClientMessage(playerid, COLOR_RED, "The round is not started."), PlayerPlaySound(playerid, SOUND_WRONGCOMMAND, 0.0, 0.0, 0.0);
//	if(Round_PVPMode)return SendClientMessage(playerid, COLOR_RED, "When pvp is running you can just \"readd\" a player."), PlayerPlaySound(playerid, SOUND_WRONGCOMMAND, 0.0, 0.0, 0.0);
	new id;
	if(sscanf(params, "u", id))
	{
		SendClientMessage(playerid, COLOR_RED, "Use /remove [id]"), PlayerPlaySound(playerid, SOUND_WRONGCOMMAND, 0.0, 0.0, 0.0);
	}
	else
	{
		if(!IsPlayerConnected(id)) return SendClientMessage(playerid, COLOR_RED, "Invalid player."), PlayerPlaySound(playerid, SOUND_WRONGCOMMAND, 0.0, 0.0, 0.0);
		if(!Player[id][InGame])return SendClientMessage(playerid, COLOR_RED, "The player is not in-game."), PlayerPlaySound(playerid, SOUND_WRONGCOMMAND, 0.0, 0.0, 0.0);
		if(!Player[id][Spawned])return SendClientMessage(playerid, COLOR_RED, "The player is not spawned."), PlayerPlaySound(playerid, SOUND_WRONGCOMMAND, 0.0, 0.0, 0.0);
		if(Player[id][Team]==NULL_TEAM || Player[id][Team] == TEAM_REF || IsSubPlayer(id))return SendClientMessage(playerid, COLOR_RED, "The player's team is not valid.");
		format(stringo, sizeof stringo, "Admin/Mod {"#COLOR_SYSTEM_FOCUS"}%s{"#COLOR_SYSTEM_REST"} has removed {"#COLOR_SYSTEM_FOCUS"}%s{"#COLOR_SYSTEM_REST"} from the round.", Player[playerid][Nickname], Player[id][Nickname]);
        SendClientMessageToAll(COLOR_SYSTEM, stringo);

		// se il player è stato rimosso e non ha effettuato neanche un po' di damage viene ignorato
		/*if (Player[id][RDamage] == 0)
		{
			if (Player[id][pMatchID] != -1) {
				PlayerMatch[Player[id][pMatchID]][Played] = false;
			}
			else {
			    Player[id][pMatchID] = AssignMatchIndex (id);

			    if (Player[id][pMatchID] != -1) {
			    	PlayerMatch[Player[id][pMatchID]][Played] = false;
			    	PlayerMatch[Player[id][pMatchID]][mTeam] = Player[id][Team];
				}
				else
				{
				    printf("SearchMatchIndex(Playerid: %d) failed, FIX IT!!!", id);
				}
			}
		}
        */
		foreach(new i:Player)
		{
		    if (InSpec[i] == id)
		        Spec_SwitchSpec(i, 1);
		}

		if (Gaming == GAMETYPE_FALLOUT)
		{
/*			TextDrawHideForPlayer(id, RoundStats[0]);
			TextDrawHideForPlayer(id, RoundStats[1]);
			TextDrawHideForPlayer(id, RoundStats[2]);
			TextDrawHideForPlayer(id, RoundStats[3]);
*/
			DisablePlayerCheckpoint(id);

			Player[id][InGame] = 0;
			SetPlayerVirtualWorld(id, NORMAL_WORLD);
			SetPlayerColor(playerid, iTeam[Player[id][Team]][OutColor]);
			TeamPlayers[Player[id][Team]] --;

			SyncTextdraw (1);

			TextDrawShowForPlayer(id, TeamPlayers_TD);
			SetSpawnInfo(id, id, GetPlayerSkinEx(id), Lobby[0] - MAX_RANDOM_SPAWN + random( MAX_RANDOM_SPAWN ), Lobby[1] - MAX_RANDOM_SPAWN + random( MAX_RANDOM_SPAWN ), Lobby[2], Lobby[3], 0, 0, 0, 0, 0, 0);

			GangZoneHideForPlayer(id, ZonaAttornoCP);

			SpawnPlayer(playerid);

			if (TeamPlayers[TEAM_A] == 0 && TeamPlayers[TEAM_B] == 0)
			{
			    EndRound (INVALID_PLAYER_ID, WINTYPE_EVERYONEFELL);
			}
		}
		else
		{
		    Player_outSecs[id] = 10;

/*			TextDrawHideForPlayer(id, RoundStats[0]);
			TextDrawHideForPlayer(id, RoundStats[1]);
			TextDrawHideForPlayer(id, RoundStats[2]);
			TextDrawHideForPlayer(id, RoundStats[3]);

*/		    DisablePlayerCheckpoint(id);

			Player[id][InGame] = 0;
			SetPlayerVirtualWorld(id, NORMAL_WORLD);
			SetPlayerColor(id, iTeam[Player[id][Team]][OutColor]);

			RemovePlayerMapIcon(id, MAPICON_ATTACKERSPAWN);

			if( Player[id][Team] == TEAM_A )
			{
			    Team1_StartHP -= gConfig[GameMode] == GAMEMODE_NOCBUG ? 100 : 200;

				if (Team1_StartHP == 0)
				    Team1_StartHP = 1;
			}
			else if( Player[id][Team] == TEAM_B )
			{
				Team2_StartHP -= gConfig[GameMode] == GAMEMODE_NOCBUG ? 100 : 200;

				if (Team2_StartHP == 0)
				    Team2_StartHP = 1;
			}
			TeamPlayers[Player[id][Team]] --;

			if (Gaming == GAMETYPE_BASE)
			{
				if(Player[id][Weaponset] != INVALID_WEAPON_SET)
				{
					Weaponsets[Player[id][Weaponset]][TeamSelection][Player[id][Team]] --;
				}

				Player[id][Weaponset] = INVALID_WEAPON_SET;
			}

			TextDrawShowForPlayer(id, TeamPlayers_TD);
			SetSpawnInfo(id, id, GetPlayerSkinEx(id), Lobby[0] - MAX_RANDOM_SPAWN + random( MAX_RANDOM_SPAWN ), Lobby[1] - MAX_RANDOM_SPAWN + random( MAX_RANDOM_SPAWN ), Lobby[2], Lobby[3], 0, 0, 0, 0, 0, 0);
	        SpawnPlayer(id);

			if( GamePaused )
			{
				TogglePlayerControllable(id, true);
		//	 	TextDrawHideForPlayer(id, RoundPaused );
			}

		   	GangZoneHideForPlayer(id, ZonaAttornoCP);
			SetPlayerScore(id, 0);

			FixHealthBars();
			SyncTextdraw(1);

			if (AntiHits)
			{
	//		    TextDrawHideForPlayer(id, TD_NotHits);
			    TextDrawHideForPlayer(id, TD_NoHitsScritta);

			}

			RefreshTeamPlayers_TD();

			if (Gaming == GAMETYPE_FIGHT && RoundFightType == FIGHTSIZE_ONEVSONE)
			{
			    Iter_Remove(ovoInGame, id);

			    if (!Player[id][fInWaiting]) // il player aveva un avversario (non aspettava nessun player che finiva il suo duel)
			    {
			        new killerid = PlayerAvversario[id]; // laaazzzy scripter
			        PlayerAvversario[id] = INVALID_PLAYER_ID;

			        new avversario = INVALID_PLAYER_ID;

			        if (Iter_Count(ovoInGame) > 1)
			        {
			            foreach(new x:ovoInGame)
			            {
			                if (Player[x][fInWaiting])
			                {
			                    Player[x][fInWaiting] = false;
			                    avversario = x;
			                    break;
			                }
			            }
			        }
			        else
			        {
			            EndRound (killerid);
			            return true;
			        }

			        if (avversario == INVALID_PLAYER_ID)
			        {
			            Player[killerid][fInWaiting] = true;
			            PlayerAvversario[killerid] = INVALID_PLAYER_ID;

			            SendClientMessage (killerid, COLOR_SYSTEM, "Wait for the next opponent.");

			            new szString[ 123 ] = "Current fights: ";// szString

			            new bool:written[MAX_PLAYERS] = {false, ...};

			            foreach(new x:ovoInGame)
			            {
			                if (written[x]) continue;

			                if (!Player[x][fInWaiting])
			                {
			                    format (szString, sizeof szString, "%s%s vs %s ", szString, Player[x][Nickname], Player[PlayerAvversario[x]][Nickname]);

			                    if (strlen(szString) > 120)
			                    {
			                        SendClientMessage (killerid, COLOR_SYSTEM, szString);
			                        szString = "";
			                    }

			                    written[PlayerAvversario[x]] = true;
			                }
			            }

			            SendClientMessage (killerid, COLOR_SYSTEM, szString);
			        }
			        else
			        {

			            SetPlayerHealth (killerid, 100.0);

			//				SetPlayerVirtualWorld (killerid, MIN_GM_WORLD + killerid);
			            SetPlayerVirtualWorld (avversario, GetPlayerVirtualWorld (killerid));

			            PlayerAvversario [avversario] = killerid;
			            PlayerAvversario [killerid]   = avversario;

			            new xid = eScenario[FileID];

			            ShowPlayerNameTagForPlayer(killerid, avversario, true);
			            ShowPlayerNameTagForPlayer(avversario, killerid, true);

			            GivePlayerWeapon (killerid, RoundFightWeapon, 500);

			            //SetSpawnInfo (avversario, NO_TEAM, GetPlayerSkinEx(avversario), fFights_Spawns[id][1][0], fFights_Spawns[id][1][1], fFights_Spawns[id][1][2], 0.0, 0, 0, 0, 0, 0, 0);
			            //SpawnPlayer (avversario);

			            SetPlayerPos(avversario, fFights_Spawns[xid][1][0], fFights_Spawns[xid][1][1], fFights_Spawns[xid][1][2]);
			        }
			    }
			}
			else
			{
				if(GamePaused) return true;
				defer CheckPlayers();
		    	//SetTimer("CheckPlayers", DELAY_CHECKPLAYERS, 0);
			}
		}

		PlayerPlaySound(playerid, SOUND_SUCCESS, 0.0, 0.0, 0.0);
	}
	RefreshIcons();
	return true;
}

COMMAND:replace(playerid, params[])
{
	if(!RoundStarted) return SendClientMessage(playerid, COLOR_RED, "The round is not started."), PlayerPlaySound(playerid, SOUND_WRONGCOMMAND, 0.0, 0.0, 0.0);
	if(!IsPlayerAdminEx(playerid, lMod)) return true;
	if(Gaming == GAMETYPE_FIGHT) return SendClientMessage(playerid, COLOR_RED, "Replace is not avaitable while you play a Fight."), PlayerPlaySound(playerid, SOUND_WRONGCOMMAND, 0.0, 0.0, 0.0);

	//
	// ID: Player da rimuovere
	// with: Player da sostituire
	// samedata: Utilizzare gli stessi dati del player rimosso?
	//

	new id, with, samedata;
	if(sscanf(params, "uuI(0)", id, with, samedata))
	{
		SendClientMessage(playerid, COLOR_RED, "Use /replace [id] with [id] [samedata - optional]"), PlayerPlaySound(playerid, SOUND_WRONGCOMMAND, 0.0, 0.0, 0.0);
	}
	else
	{
		if(!IsPlayerConnected(with)||!IsPlayerConnected(id)) return SendClientMessage(playerid, COLOR_RED, "Invalid player."), PlayerPlaySound(playerid, SOUND_WRONGCOMMAND, 0.0, 0.0, 0.0);
		if(Player[with][InGame]||!Player[id][InGame])return SendClientMessage(playerid, COLOR_RED, "Invalid IDs."), PlayerPlaySound(playerid, SOUND_WRONGCOMMAND, 0.0, 0.0, 0.0);
		if(!Player[with][Spawned]||!Player[id][Spawned])return SendClientMessage(playerid, COLOR_RED, "The player is not spawned."), PlayerPlaySound(playerid, SOUND_WRONGCOMMAND, 0.0, 0.0, 0.0);
		if(Player[with][Team]==NULL_TEAM || Player[with][Team] == TEAM_REF || IsSubPlayer(with))return SendClientMessage(playerid, COLOR_RED, "The player's team is not valid.");

		format(stringo, sizeof stringo, "Admin/Mod {"#COLOR_SYSTEM_FOCUS"}%s{"#COLOR_SYSTEM_REST"} has replaced {"#COLOR_SYSTEM_FOCUS"}%s{"#COLOR_SYSTEM_REST"} with {"#COLOR_SYSTEM_FOCUS"}%s{"#COLOR_SYSTEM_REST"}.", Player[playerid][Nickname], Player[id][Nickname], Player[with][Nickname]);

		SendClientMessageToAll(COLOR_SYSTEM, stringo);

        // move the team of ID to WITh team
        if (!timeoutPlayer[with])
        	Player[with][Team] = Player[id][Team];

        // take the old player-datas
        // yeah i know, i take memory but should be free when go out-of-scope
        new
            Float:ofX,
            Float:ofY,
            Float:ofZ,
            Float:ofH,
            Float:ofA;

		if (samedata && !timeoutPlayer[with])
		{
		    // Why take the data if samedata is off?
			// or if the player have timeout-data?

			GetPlayerHealth (id, ofH);
			GetPlayerArmour (id, ofA);

			GetPlayerPos (id, ofX, ofY, ofZ);
		}

		foreach(new i:Player)
		{
		    if (InSpec[i] == id)
		        Spec_SwitchSpec(i, 1);
		}

		if (Gaming == GAMETYPE_FALLOUT)
		{
/*			TextDrawHideForPlayer(id, RoundStats[0]);
			TextDrawHideForPlayer(id, RoundStats[1]);
			TextDrawHideForPlayer(id, RoundStats[2]);
			TextDrawHideForPlayer(id, RoundStats[3]);
*/
			DisablePlayerCheckpoint(id);

			Player[id][InGame] = 0;
			SetPlayerVirtualWorld(id, NORMAL_WORLD);
			SetPlayerColor(playerid, iTeam[Player[id][Team]][OutColor]);
			TeamPlayers[Player[id][Team]] --;

			SyncTextdraw (1);

			TextDrawShowForPlayer(id, TeamPlayers_TD);
			SetSpawnInfo(id, id, GetPlayerSkinEx(id), Lobby[0] - MAX_RANDOM_SPAWN + random( MAX_RANDOM_SPAWN ), Lobby[1] - MAX_RANDOM_SPAWN + random( MAX_RANDOM_SPAWN ), Lobby[2], Lobby[3], 0, 0, 0, 0, 0, 0);

			GangZoneHideForPlayer(id, ZonaAttornoCP);

			SpawnPlayer(playerid);

			if (TeamPlayers[TEAM_A] == 0 && TeamPlayers[TEAM_B] == 0)
			{
			    EndRound (INVALID_PLAYER_ID, WINTYPE_EVERYONEFELL);
			}
		}
		else
		{
		    Player_outSecs[id] = 10;

/*			TextDrawHideForPlayer(id, RoundStats[0]);
			TextDrawHideForPlayer(id, RoundStats[1]);
			TextDrawHideForPlayer(id, RoundStats[2]);
			TextDrawHideForPlayer(id, RoundStats[3]);

*/		    DisablePlayerCheckpoint(id);

			Player[id][InGame] = 0;
			SetPlayerVirtualWorld(id, NORMAL_WORLD);
			SetPlayerColor(id, iTeam[Player[id][Team]][OutColor]);

			RemovePlayerMapIcon(id, MAPICON_ATTACKERSPAWN);

			if( Player[id][Team] == TEAM_A )
			{
			    Team1_StartHP -= gConfig[GameMode] == GAMEMODE_NOCBUG ? 100 : 200;

				if (Team1_StartHP == 0)
				    Team1_StartHP = 1;
			}
			else if( Player[id][Team] == TEAM_B )
			{
				Team2_StartHP -= gConfig[GameMode] == GAMEMODE_NOCBUG ? 100 : 200;

				if (Team2_StartHP == 0)
				    Team2_StartHP = 1;
			}
			TeamPlayers[Player[id][Team]] --;

			if (Gaming == GAMETYPE_BASE)
			{
				if(Player[id][Weaponset] != INVALID_WEAPON_SET)
				{
					Weaponsets[Player[id][Weaponset]][TeamSelection][Player[id][Team]] --;
				}

				Player[id][Weaponset] = INVALID_WEAPON_SET;
			}

			TextDrawShowForPlayer(id, TeamPlayers_TD);
			SetSpawnInfo(id, id, GetPlayerSkinEx(id), Lobby[0] - MAX_RANDOM_SPAWN + random( MAX_RANDOM_SPAWN ), Lobby[1] - MAX_RANDOM_SPAWN + random( MAX_RANDOM_SPAWN ), Lobby[2], Lobby[3], 0, 0, 0, 0, 0, 0);
	        SpawnPlayer(id);

			if( GamePaused )
			{
				TogglePlayerControllable(id, true);
		//	 	TextDrawHideForPlayer(id, RoundPaused );
			}

		   	GangZoneHideForPlayer(id, ZonaAttornoCP);
			SetPlayerScore(id, 0);

			FixHealthBars();
			SyncTextdraw(1);

			if (AntiHits)
			{
	//		    TextDrawHideForPlayer(id, TD_NotHits);
			    TextDrawHideForPlayer(id, TD_NoHitsScritta);
			}

			RefreshTeamPlayers_TD();
			/*

			if(!GamePaused)
				defer CheckPlayers();*/
		}

		// adding player
		// replace id /with/ with
	  	Player_outSecs[with] = 10;
  		new pt = Player[with][Team];

		if(IsPlayerInAnyVehicle(with))
		{
			DestroyVehicleEx(GetPlayerVehicleID(with));
		}

		if (InSpec[with]!=-1) Spec_RemovePlayerFromSpec(with);

		Player[with][InGame] 	  = 1;
		PlayerAfk_Seconds[with] = 0;

//		Player[id][RKills] = 0;
//		Player[id][RDeaths] = 0;
//		Player[id][RDamage] = 0;

		CleanSpecTDs (with);

		if(TeamRole[pt]==ATTACKERS)
		{
		    if(Gaming == GAMETYPE_BASE)
			{
		        if( !Interior_Base )
				{
				    SendClientMessage(with, COLOR_GREY, TXT_BASE_ATT);
				}
				else
				{
				    SendClientMessage(with, COLOR_GREY, TXT_INT);
				}

				if (pt == TEAM_A)
  				{
  					TextDrawSetString(PlayerSpecInfo[with][6], "~r~~h~WPS: ~w~-");
	  			}
		  		else
		  		{
			  	    TextDrawSetString(PlayerSpecInfo[with][6], "~b~~h~WPS: ~w~-");
		  		}

				SetSpawnInfo(with, Player[with][Team], GetPlayerSkinEx(with), eScenario[SpawnAttackers][0] - RANDOM_SPAWN_ROUND + random(RANDOM_SPAWN_ROUND), eScenario[SpawnAttackers][1] - RANDOM_SPAWN_ROUND + random(RANDOM_SPAWN_ROUND), eScenario[SpawnAttackers][2], 0.0, 0, 0, 0, 0, 0, 0);
				SetPlayerMapIcon(with, MAPICON_ATTACKERSPAWN, eScenario[SpawnAttackers][0], eScenario[SpawnAttackers][1], eScenario[SpawnAttackers][2], ATTACKERSMAP_ICON, 0, MAPICON_TYPE_ATTSPAWN);
			}
			else if(Gaming == GAMETYPE_ARENA)
			{
				if (pt == TEAM_A)
  				{
  					TextDrawSetString(PlayerSpecInfo[with][6], "~r~~h~WPS: ~w~Arena");
	  			}
		  		else
		  		{
			  	    TextDrawSetString(PlayerSpecInfo[with][6], "~b~~h~WPS: ~w~Arena");
		  		}

				SendClientMessage(with, COLOR_GREY, TXT_ARENA);
				SetSpawnInfo(with, Player[with][Team], GetPlayerSkinEx(id), eScenario[SpawnAttackers][0] - RANDOM_SPAWN_ROUND + random(RANDOM_SPAWN_ROUND), eScenario[SpawnAttackers][1] - RANDOM_SPAWN_ROUND + random(RANDOM_SPAWN_ROUND), eScenario[SpawnAttackers][2], 0.0, 0, 0, 0, 0, 0, 0);
				SetPlayerMapIcon(with, MAPICON_ATTACKERSPAWN, eScenario[SpawnAttackers][0], eScenario[SpawnAttackers][1], eScenario[SpawnAttackers][2], ATTACKERSMAP_ICON, 0, MAPICON_TYPE_ATTSPAWN);
			}
			else if(Gaming == GAMETYPE_TDM)
			{
				if (pt == TEAM_A)
  				{
  					TextDrawSetString(PlayerSpecInfo[with][6], "~r~~h~WPS: ~w~TDM");
	  			}
		  		else
		  		{
			  	    TextDrawSetString(PlayerSpecInfo[with][6], "~b~~h~WPS: ~w~TDM");
		  		}

				stringo = "";
				strcat(stringo, TXT_TDM_P1" ");
				strcat(stringo, numstr(gConfig[TDMKills]));
				strcat(stringo, TXT_TDM_P2);

				SendClientMessage(with, COLOR_GREY, stringo);
				SetSpawnInfo(with, Player[with][Team], GetPlayerSkinEx(id), eScenario[SpawnAttackers][0] - RANDOM_SPAWN_ROUND + random(RANDOM_SPAWN_ROUND), eScenario[SpawnAttackers][1] - RANDOM_SPAWN_ROUND + random(RANDOM_SPAWN_ROUND), eScenario[SpawnAttackers][2], 0.0, 0, 0, 0, 0, 0, 0);
				SetPlayerMapIcon(with, MAPICON_ATTACKERSPAWN, eScenario[SpawnAttackers][0], eScenario[SpawnAttackers][1], eScenario[SpawnAttackers][2], ATTACKERSMAP_ICON, 0, MAPICON_TYPE_ATTSPAWN);
			}
			else if(Gaming == GAMETYPE_GUNGAME)
			{
				if (pt == TEAM_A)
  				{
  					TextDrawSetString(PlayerSpecInfo[with][6], "~r~~h~WPS: ~w~Gungame");
	  			}
		  		else
		  		{
			  	    TextDrawSetString(PlayerSpecInfo[with][6], "~b~~h~WPS: ~w~Gungame");
		  		}

				SendClientMessage(with, COLOR_GREY, TXT_GUNGAME);
				new rand = random(20);
				SetSpawnInfo(with, with, GetPlayerSkinEx(with), Scenario_MultipleSpawns[rand][0], Scenario_MultipleSpawns[rand][1], Scenario_MultipleSpawns[rand][2], Scenario_MultipleSpawns[rand][3], 0, 0, 0, 0, 0, 0);
			}
		    else if(Gaming == GAMETYPE_FALLOUT)
		    {
				if (pt == TEAM_A)
	  			{
	  				TextDrawSetString(PlayerSpecInfo[with][6], "_");
	 			}
		  		else
		  		{
			  	    TextDrawSetString(PlayerSpecInfo[with][6], "_");
		  		}

			    SendClientMessage(with, COLOR_GREY, TXT_FALLOUT);
				SetSpawnInfo(with, with, GetPlayerSkinEx(with), 2482.1921 - random(39), -1660.4783 + random(47), 161.0000, random(360), 0, 0, 0, 0, 0, 0);
			}
		}
		else
		{
		    if(Gaming == GAMETYPE_BASE)
			{
		        if( !Interior_Base )
				{
				    SendClientMessage(with, COLOR_GREY, TXT_BASE_DEF);
				}
				else
				{
				    SendClientMessage(with, COLOR_GREY, TXT_INT);
				}

				if (pt == TEAM_A)
  				{
  					TextDrawSetString(PlayerSpecInfo[with][6], "~r~~h~WPS: ~w~-");
	  			}
		  		else
		  		{
			  	    TextDrawSetString(PlayerSpecInfo[with][6], "~b~~h~WPS: ~w~-");
		  		}

				SetSpawnInfo(with, Player[with][Team], GetPlayerSkinEx(with), eScenario[SpawnDefenders][0] - RANDOM_SPAWN_ROUND + random(RANDOM_SPAWN_ROUND), eScenario[SpawnDefenders][1] - RANDOM_SPAWN_ROUND + random(RANDOM_SPAWN_ROUND), eScenario[SpawnDefenders][2], 0.0, 0, 0, 0, 0, 0, 0);
				//SetPlayerMapIcon(id, MAPICON_ATTACKERSPAWN, eScenario[SpawnDefenders][0], eScenario[SpawnDefenders][1], eScenario[SpawnDefenders][2], ATTACKERSMAP_ICON, 0, MAPICON_TYPE_ATTSPAWN);
			}
			else if(Gaming == GAMETYPE_ARENA)
			{
				if (pt == TEAM_A)
  				{
  					TextDrawSetString(PlayerSpecInfo[with][6], "~r~~h~WPS: ~w~Arena");
	  			}
		  		else
		  		{
			  	    TextDrawSetString(PlayerSpecInfo[with][6], "~b~~h~WPS: ~w~Arena");
		  		}

				SendClientMessage(with, COLOR_GREY, TXT_ARENA);
		   		SetSpawnInfo(with, Player[with][Team], GetPlayerSkinEx(with), eScenario[SpawnDefenders][0] - RANDOM_SPAWN_ROUND + random(RANDOM_SPAWN_ROUND), eScenario[SpawnDefenders][1] - RANDOM_SPAWN_ROUND + random(RANDOM_SPAWN_ROUND), eScenario[SpawnDefenders][2], 0.0, 0, 0, 0, 0, 0, 0);
			}
			else if(Gaming == GAMETYPE_TDM)
			{
				if (pt == TEAM_A)
  				{
  					TextDrawSetString(PlayerSpecInfo[with][6], "~r~~h~WPS: ~w~TDM");
	  			}
		  		else
		  		{
			  	    TextDrawSetString(PlayerSpecInfo[with][6], "~b~~h~WPS: ~w~TDM");
		  		}

				stringo = "";
				strcat(stringo, TXT_TDM_P1" ");
				strcat(stringo, numstr(gConfig[TDMKills]));
				strcat(stringo, TXT_TDM_P2);

				SendClientMessage(with, COLOR_GREY, stringo);
				SetSpawnInfo(with, Player[with][Team], GetPlayerSkinEx(with), eScenario[SpawnDefenders][0] - RANDOM_SPAWN_ROUND + random(RANDOM_SPAWN_ROUND), eScenario[SpawnDefenders][1] - RANDOM_SPAWN_ROUND + random(RANDOM_SPAWN_ROUND), eScenario[SpawnDefenders][2], 0.0, 0, 0, 0, 0, 0, 0);
			}
			else if(Gaming == GAMETYPE_GUNGAME)
			{
				if (pt == TEAM_A)
  				{
  					TextDrawSetString(PlayerSpecInfo[id][6], "~r~~h~WPS: ~w~Gungame");
	  			}
		  		else
		  		{
			  	    TextDrawSetString(PlayerSpecInfo[id][6], "~b~~h~WPS: ~w~Gungame");
		  		}

				SendClientMessage(with, COLOR_GREY, TXT_GUNGAME);
				new rand = random(20);
				SetSpawnInfo(with, with, GetPlayerSkinEx(with), Scenario_MultipleSpawns[rand][0], Scenario_MultipleSpawns[rand][1], Scenario_MultipleSpawns[rand][2], Scenario_MultipleSpawns[rand][3], 0, 0, 0, 0, 0, 0);
			}
		    else if(Gaming == GAMETYPE_FALLOUT)
		    {
				if (pt == TEAM_A)
	  			{
	  				TextDrawSetString(PlayerSpecInfo[with][6], "_");
	 			}
		  		else
		  		{
			  	    TextDrawSetString(PlayerSpecInfo[with][6], "_");
		  		}

			    SendClientMessage(with, COLOR_GREY, TXT_FALLOUT);
				SetSpawnInfo(with, with, GetPlayerSkinEx(with), 2482.1921 - random(39), -1660.4783 + random(47), 161.0000, random(360), 0, 0, 0, 0, 0, 0);
			}
		}

		if( pt == TEAM_A )
		{
		    Team1_StartHP += gConfig[GameMode] == GAMEMODE_NOCBUG ? 100 : 200;
		}
		else if( pt == TEAM_B )
		{
			Team2_StartHP += gConfig[GameMode] == GAMEMODE_NOCBUG ? 100 : 200;
		}

		if( Player[with][InDm] != -1 )
		{
		    MySQLStatus[TotalQuerys] ++; mysql_tquery(g_MySQLConnection, sprintf("UPDATE bestdmplayer SET damage = '%d', kills = '%d' WHERE nickname = '%s' AND dmid = '%d'", Player[with][DDamage], Player[with][DKills], Player[with][Nickname], Player[with][InDm]), "", "");
		    Player[with][InDm] = -1;
		}

		if (gConfig[UseHealthBars])
		{
			SetPlayerScore(with, Player[with][RDamage]);
		}
		else
		{
		    SetPlayerScore(with, gConfig[GameMode] == GAMEMODE_NOCBUG ? 100 : 200);
		}

		TeamPlayers[with]++;
		SetPlayerColor(id, iTeam[with][InGameColor]);
		SetPlayerVirtualWorld(with, GAME_WORLD);
		TextDrawHideForPlayer(with, TeamPlayers_TD);

		if (AntiHits)
		{
		//    TextDrawShowForPlayer(id, TD_NotHits);
		    TextDrawShowForPlayer(with, TD_NoHitsScritta);
		}

		if( GamePaused )
		{
		    TogglePlayerControllable( with , false );
		  //  TextDrawShowForPlayer( with , RoundPaused );
		}

		if(Gaming == GAMETYPE_BASE)
		{
			DisablePlayerCheckpoint(with);
			if(!Interior_Base)
				SetPlayerCheckpointEx(with, eScenario[Checkpoint][0], eScenario[Checkpoint][1], eScenario[Checkpoint][2]+1.5, 2.0);

			MostraWeaponset(with);
		}

		// all great things are simple, and many can be expressed in single words: freedom, justice, honor, duty, mercy, hope.
		TextDrawShowForPlayer(with, RoundStats[0]);
		TextDrawShowForPlayer(with, RoundStats[1]);
		TextDrawShowForPlayer(with, RoundStats[2]);
		TextDrawShowForPlayer(with, RoundStats[3]);

		GangZoneShowForPlayer(with, ZonaAttornoCP, GANGZONE_COLORAZIONE);
		// Ok spawn the player
//		SpawnPlayer(with);

		if (timeoutPlayer[with])
		{
	        Player[with][InRestoring] = true;

			// Yeah, in this case i call SetSpawnInfo two times, should be improved too.
			SetSpawnInfo(with, pt, iTeam[pt][Skin], timeout_Pos[with][0], timeout_Pos[with][1], timeout_Pos[with][2], timeout_Pos[with][3], 0, 0, 0, 0, 0, 0);
            SpawnPlayer (with);

			SetPlayerHealth(with, timeout_Health[with]);
			SetPlayerArmour(with, timeout_Armour[with]);

			SetPlayerInterior(with, eScenario[Interior]);
			SetPlayerTeam(with, Player[with][Team]);
			SetPlayerSkin(with, iTeam[Player[with][Team]][Skin]);

			//format (stringo, sizeof stringo, "Admin/Mod {"#COLOR_SYSTEM_FOCUS"}%s{"#COLOR_SYSTEM_REST"} has brought and restored {"#COLOR_SYSTEM_FOCUS"}%s{"#COLOR_SYSTEM_REST"} into the round (%s).", Player[playerid][Nickname], Player[id][Nickname], GetRoleName(TeamRole[Player[id][Team]]));
	        //SendClientMessageToAll(COLOR_SYSTEM, stringo);
			//PlayerPlaySound(playerid, SOUND_SUCCESS, 0.0, 0.0, 0.0);

			MySQLStatus[TotalQuerys] ++; mysql_tquery(g_MySQLConnection, sprintf ("DELETE FROM timeouts WHERE nickname = '%s' AND gid = %d", Player[with][Nickname], G_ID), "", "");

			timeoutPlayer[with] = false;
		}
		else
		{
			// Restore DATA of prev player
			if (samedata)
			{
			    // At this point, the prev player has been removed
			    // so i cant take data here
	//		    SpawnPlayer (with);//two spawnplayer istruct, i know, should be improved.

				// Yeah, in this case i call SetSpawnInfo two times, should be improved too.
				SetSpawnInfo(with, pt, iTeam[pt][Skin], ofX, ofY, ofZ, random(360), 0, 0, 0, 0, 0, 0);
	            SpawnPlayer (with);

			 //   SetPlayerPos (with, ofX, ofY, ofZ);
			    SetPlayerHealth (with, ofH);
				SetPlayerArmour (with, ofA);
			}
			else
			{
			    SpawnPlayer (with);
			}
		}

	    SyncTextdraw(1);
		RefreshTeamPlayers_TD();
	    FixHealthBars();

		PlayerPlaySound(with, SOUND_SUCCESS, 0.0, 0.0, 0.0);

		if (Player[with][FinalRound_Status] != FINALROUND_STATUS_HIDDEN)
  		{
			new cv = Player[with][CurrentView];
			for (new i2 = 0; i2 < MAX_STATIC_TEXTDRAWS; i2++) TextDrawHideForPlayer(with, FineRound_Static[i2]);

			TextDrawHideForPlayer(with, FineRound_Dynamic[cv][BluePlayers]);
			TextDrawHideForPlayer(with, FineRound_Dynamic[cv][GreenPlayers]);
			TextDrawHideForPlayer(with, FineRound_Dynamic[cv][BlueKills]);
			TextDrawHideForPlayer(with, FineRound_Dynamic[cv][BlueDamages]);
			TextDrawHideForPlayer(with, FineRound_Dynamic[cv][GreenKills]);
			TextDrawHideForPlayer(with, FineRound_Dynamic[cv][GreenDamage]);
			TextDrawHideForPlayer(with, FineRound_Dynamic[cv][TotalKGreen]);
			TextDrawHideForPlayer(with, FineRound_Dynamic[cv][TotalDGreen]);
			TextDrawHideForPlayer(with, FineRound_Dynamic[cv][TotalKBlue]);
			TextDrawHideForPlayer(with, FineRound_Dynamic[cv][TotalDBlue]);
			TextDrawHideForPlayer(with, FineRound_Dynamic[cv][Top2_Nick]);
			TextDrawHideForPlayer(with, FineRound_Dynamic[cv][Top2_Stats]);
			TextDrawHideForPlayer(with, FineRound_Dynamic[cv][Top3_Stats]);
			TextDrawHideForPlayer(with, FineRound_Dynamic[cv][Top3_Nick]);
			TextDrawHideForPlayer(with, FineRound_Dynamic[cv][Top1_Stats]);
			TextDrawHideForPlayer(with, FineRound_Dynamic[cv][Top1_Nick]);
			TextDrawHideForPlayer(with, FineRound_Dynamic[cv][RoundsInfo]);
			TextDrawHideForPlayer(with, FineRound_Dynamic[cv][AttDefWin]);
	        TextDrawHideForPlayer(with, FineRound_Dynamic[cv][Stringa_Winner2]);
	        TextDrawHideForPlayer(with, FineRound_Dynamic[cv][Stringa_TeamWin]);
	        TextDrawHideForPlayer(with, FineRound_Dynamic[cv][Stringa_Winner1]);
			TextDrawHideForPlayer(with, FineRound_Dynamic[cv][Stringa_RoundInfo]);
	        TextDrawHideForPlayer(with, FineRound_Dynamic[cv][Stringa_TmpBest]);

            if (gConfig[Matchmode] == MATCHMODE_TCWCW)
	        	CancelSelectTextDraw (with);

		    Player[with][FinalRound_Status] = FINALROUND_STATUS_HIDDEN;
        }

		PlayerPlaySound(playerid, SOUND_SUCCESS, 0.0, 0.0, 0.0);
	}

	RefreshIcons();
	return true;
}

COMMAND:rem(playerid, params[])
{
	if(!RoundStarted) return SendClientMessage(playerid, COLOR_RED, "The round is not started."), PlayerPlaySound(playerid, SOUND_WRONGCOMMAND, 0.0, 0.0, 0.0);
	if(!Player[playerid][InGame])return SendClientMessage(playerid, COLOR_RED, "You are not in game."), PlayerPlaySound(playerid, SOUND_WRONGCOMMAND, 0.0, 0.0, 0.0);

	format (stringo, sizeof stringo, "{"#COLOR_SYSTEM_FOCUS"}%s{"#COLOR_SYSTEM_REST"} has removed himself from the round.", Player[playerid][Nickname]);
    SendClientMessageToAll(COLOR_SYSTEM, stringo);
	PlayerPlaySound(playerid, SOUND_SUCCESS, 0.0, 0.0, 0.0);

/*
	if (Player[playerid][pMatchID] != -1) {
		PlayerMatch[Player[playerid][pMatchID]][Played] = false;
	}
	else {
	    Player[playerid][pMatchID] = AssignMatchIndex (playerid);

	    if (Player[playerid][pMatchID] != -1) {
	    	PlayerMatch[Player[playerid][pMatchID]][Played] = false;
	    	PlayerMatch[Player[playerid][pMatchID]][mTeam] = Player[playerid][Team];
		}
		else
		{
		    printf("SearchMatchIndex(Playerid: %d) failed, FIX IT!!!", playerid);
		}
	}
*/

	foreach(new i:Player)
	{
	    if (InSpec[i] == playerid)
	        Spec_SwitchSpec(i, 1);
	}

	if (Gaming == GAMETYPE_FALLOUT)
	{
/*		TextDrawHideForPlayer(playerid, RoundStats[0]);
		TextDrawHideForPlayer(playerid, RoundStats[1]);
		TextDrawHideForPlayer(playerid, RoundStats[2]);
		TextDrawHideForPlayer(playerid, RoundStats[3]);
*/
		DisablePlayerCheckpoint(playerid);

		Player[playerid][InGame] = 0;
		SetPlayerVirtualWorld(playerid, NORMAL_WORLD);
		SetPlayerColor(playerid, iTeam[Player[playerid][Team]][OutColor]);
		TeamPlayers[Player[playerid][Team]] --;

		SyncTextdraw (1);

		TextDrawShowForPlayer(playerid, TeamPlayers_TD);
		SetSpawnInfo(playerid, playerid, GetPlayerSkinEx(playerid), Lobby[0] - MAX_RANDOM_SPAWN + random( MAX_RANDOM_SPAWN ), Lobby[1] - MAX_RANDOM_SPAWN + random( MAX_RANDOM_SPAWN ), Lobby[2], Lobby[3], 0, 0, 0, 0, 0, 0);

		GangZoneHideForPlayer(playerid, ZonaAttornoCP);

		SpawnPlayer(playerid);

		if (TeamPlayers[TEAM_A] == 0 && TeamPlayers[TEAM_B] == 0)
		{
		    EndRound (INVALID_PLAYER_ID, WINTYPE_EVERYONEFELL);
		}
	}
	else
	{
	    Player_outSecs[playerid] = 10;

/*		TextDrawHideForPlayer(playerid, RoundStats[0]);
		TextDrawHideForPlayer(playerid, RoundStats[1]);
		TextDrawHideForPlayer(playerid, RoundStats[2]);
		TextDrawHideForPlayer(playerid, RoundStats[3]);
*/
	    DisablePlayerCheckpoint(playerid);

		Player[playerid][InGame] = 0;
		SetPlayerScore(playerid, 0);
		SetPlayerVirtualWorld(playerid, NORMAL_WORLD);
		SetPlayerColor(playerid, iTeam[Player[playerid][Team]][OutColor]);

		RemovePlayerMapIcon(playerid, MAPICON_ATTACKERSPAWN);

		if( Player[playerid][Team] == TEAM_A )
		{
		    Team1_StartHP -= gConfig[GameMode] == GAMEMODE_NOCBUG ? 100 : 200;

			if (Team1_StartHP == 0)
		   		Team1_StartHP = 1;
		}
		else if( Player[playerid][Team] == TEAM_B )
		{
			Team2_StartHP -= gConfig[GameMode] == GAMEMODE_NOCBUG ? 100 : 200;

			if (Team2_StartHP == 0)
			    Team2_StartHP = 1;
		}
		TeamPlayers[Player[playerid][Team]] --;

		FixHealthBars();
		SyncTextdraw(1);

		if (Gaming == GAMETYPE_BASE)
		{
			if(Player[playerid][Weaponset] != INVALID_WEAPON_SET)
			{
				Weaponsets[Player[playerid][Weaponset]][TeamSelection][Player[playerid][Team]] --;
			}

			Player[playerid][Weaponset] = INVALID_WEAPON_SET;
		}

		TextDrawShowForPlayer(playerid, TeamPlayers_TD);
		SetSpawnInfo(playerid, playerid, GetPlayerSkinEx(playerid), Lobby[0] - MAX_RANDOM_SPAWN + random( MAX_RANDOM_SPAWN ), Lobby[1] - MAX_RANDOM_SPAWN + random( MAX_RANDOM_SPAWN ), Lobby[2], Lobby[3], 0, 0, 0, 0, 0, 0);
	    SpawnPlayer(playerid);

		if( GamePaused )
		{
			TogglePlayerControllable(playerid, true);
		 //	TextDrawHideForPlayer(playerid, RoundPaused );
		}

	   	GangZoneHideForPlayer(playerid, ZonaAttornoCP);

		if (AntiHits)
		{
	//	    TextDrawHideForPlayer(playerid, TD_NotHits);
		    TextDrawHideForPlayer(playerid, TD_NoHitsScritta);

		}

		RefreshTeamPlayers_TD();

		if (Gaming == GAMETYPE_FIGHT && RoundFightType == FIGHTSIZE_ONEVSONE)
		{
		    Iter_Remove(ovoInGame, playerid);

		    if (!Player[playerid][fInWaiting]) // il player aveva un avversario (non aspettava nessun player che finiva il suo duel)
		    {
		        new killerid = PlayerAvversario[playerid]; // laaazzzy scripter
		        PlayerAvversario[playerid] = INVALID_PLAYER_ID;

				new avversario = INVALID_PLAYER_ID;

				if (Iter_Count(ovoInGame) > 1)
				{
	   				foreach(new x:ovoInGame)
	       			{
	          			if (Player[x][fInWaiting])
	             		{
	               			Player[x][fInWaiting] = false;
	                  		avversario = x;
	                  		break;
	               		}
		            }
	       		}
				else
		   		{
	      			EndRound (killerid);
	     			return true;
	        	}

				if (avversario == INVALID_PLAYER_ID)
	   			{
	      			Player[killerid][fInWaiting] = true;
	         		PlayerAvversario[killerid] = INVALID_PLAYER_ID;

					SendClientMessage (killerid, COLOR_SYSTEM, "Wait for the next opponent.");

		            new szString[ 123 ] = "Current fights: ";// szString
					// l'ironia 123 lol

		            new bool:written[MAX_PLAYERS] = {false, ...};

		            foreach(new x:ovoInGame)
		            {
		                if (written[x]) continue;

		                if (!Player[x][fInWaiting])
		                {
		                    format (szString, sizeof szString, "%s%s vs %s ", szString, Player[x][Nickname], Player[PlayerAvversario[x]][Nickname]);

			                if (strlen(szString) > 110)
	                  		{
		                        SendClientMessage (killerid, COLOR_SYSTEM, szString);
		                        szString = "";
		                    }

		                    written[PlayerAvversario[x]] = true;
		                }
		            }

		            SendClientMessage (killerid, COLOR_SYSTEM, szString);
		        }
		        else
		        {
		            SetPlayerHealth (killerid, 100.0);
		            GivePlayerWeapon (killerid, RoundFightWeapon, 500);

			//				SetPlayerVirtualWorld (killerid, MIN_GM_WORLD + killerid);
		            SetPlayerVirtualWorld (avversario, GetPlayerVirtualWorld (killerid));

		            PlayerAvversario [avversario] = killerid;
		            PlayerAvversario [killerid]   = avversario;

		            new xid = eScenario[FileID];

		            ShowPlayerNameTagForPlayer(killerid, avversario, true);
		            ShowPlayerNameTagForPlayer(avversario, killerid, true);

		            //SetSpawnInfo (avversario, NO_TEAM, GetPlayerSkinEx(avversario), fFights_Spawns[id][1][0], fFights_Spawns[id][1][1], fFights_Spawns[id][1][2], 0.0, 0, 0, 0, 0, 0, 0);
		            //SpawnPlayer (avversario);

		            SetPlayerPos(avversario, fFights_Spawns[xid][1][0], fFights_Spawns[xid][1][1], fFights_Spawns[xid][1][2]);
		        }
		    }
		}
		else
		{
			if(!GamePaused)
			{
			    defer CheckPlayers();//tiamo
				//SetTimer("CheckPlayers", DELAY_CHECKPLAYERS, 0);
				RefreshIcons();
			}
		}
	}
	return true;
}

COMMAND:readytype(playerid, params[])
{
	if(!IsPlayerAdminEx(playerid, lAdmin)) return true;
	new gm;
	if(sscanf(params, "k<gametypes>", gm) || gm == -1)
	{
	    SendClientMessage( playerid , red , "Use /readytype [base/arena/tdm/ints/pvp]");
	    PlayerPlaySound(playerid, SOUND_WRONGCOMMAND, 0.0, 0.0, 0.0);
	}
	else
	{
    	gConfig[ReadyType] = gm;
		format (stringo, sizeof stringo, "Admin/Mod {"#COLOR_SYSTEM_FOCUS"}%s{"#COLOR_SYSTEM_REST"} has changed /ready start type to %s", Player[playerid][Nickname] , GetReadyStartType() );
        SendClientMessageToAll( COLOR_SYSTEM , stringo);

        MySQLStatus[TotalQuerys] ++; mysql_tquery(g_MySQLConnection, sprintf("UPDATE config SET ready = '%d' WHERE gid = %d", gm, G_ID), "", "");
		//SyncConfigFile();
	 	PlayerPlaySound(playerid, SOUND_SUCCESS, 0.0, 0.0, 0.0);
	}
	return true;
}

COMMAND:fix(playerid, params[]){
	TextDrawShowForAll(GeneralTD[0]);
	TextDrawShowForAll(GeneralTD[1]);
	return true;
}

COMMAND:start(playerid, params[]) {
	if(!IsPlayerAdminEx(playerid, lMod)) return true;
	if(RoundStarted) return SendClientMessage(playerid, COLOR_RED, "The round is already started."), PlayerPlaySound(playerid, SOUND_WRONGCOMMAND, 0.0, 0.0, 0.0);
	new tmp[ 60 ], id, fw, fw2;
	// Comando esteso:
	// /start [TIPO] [ID] [ARGOMENTO AGGIUNTIVO] [ARGOMENTO AGGIUNTOVO - DI TIPO ARMA]
	// /start base
	// /start base -1
	// /start fight -1 1 Deagle <- Starta una fight, arena casuale, di tipo all vs all con l'arma deagle
	// /start pvp -1 M4 Shotgun PVPWeapons
	if(sscanf(params, "s[60]I(-1)K<weaps>(-1)K<weaps>(-1)", tmp, id, fw, fw2))
	{
	    SendClientMessage(playerid, COLOR_RED, "Use start [base/arena/tdm/pvp/ints/gungame/fight/fava/fallout] [ID/-1]"), PlayerPlaySound(playerid, SOUND_WRONGCOMMAND, 0.0, 0.0, 0.0);
	}
	else
	{
	    new tentativi = 0;

	    #define MAX_TENTATIVI       1000

	    #define CONTROLLO_TENTATIVI \
	    if (tentativi >= MAX_TENTATIVI) { \
	    SendClientMessage(playerid, 0xFF0000, "Errore interno: while infinite - max tentativi."); \
	    return true; \
	    }

		if(!strcmp(tmp, "base", true) || !strcmp(tmp, "aad", true))
		{
			if(id == -1)
			{
				do
				{
				    id = random(basesPacks[CurrentGamepack][maxBases]);
				    tentativi++;
				}
				while(!bBases[id][Exists] && tentativi < MAX_TENTATIVI);

				CONTROLLO_TENTATIVI

				LastRoundType = GAMETYPE_BASE;
				StartRound(id, GAMETYPE_BASE, playerid, 1);
				PlayerPlaySound(playerid, SOUND_SUCCESS, 0.0, 0.0, 0.0);
			}
			else
			{
				if(!bBases[id][Exists]) return SendClientMessage(playerid, COLOR_RED, "Invalid base ID."), PlayerPlaySound(playerid, SOUND_WRONGCOMMAND, 0.0, 0.0, 0.0);

				StartRound(id, GAMETYPE_BASE, playerid);
				LastRoundType = GAMETYPE_BASE;
				PlayerPlaySound(playerid, SOUND_SUCCESS, 0.0, 0.0, 0.0);
			}
		}
		else if(!strcmp(tmp, "ints", true)) {
			if( id == -1 ) {
				do {
				    id = random(MAX_INTS);
				    tentativi++;
				}
				while(!iBases[id][Exists]  && tentativi < MAX_TENTATIVI);

				CONTROLLO_TENTATIVI

				Interior_Base = true;
				LastRoundType = GAMETYPE_INTS;
				StartRound(id, GAMETYPE_BASE, playerid, 1);
				PlayerPlaySound(playerid, SOUND_SUCCESS, 0.0, 0.0, 0.0);
			}
			else {
				if(!iBases[id][Exists]) return SendClientMessage(playerid, COLOR_RED, "Invalid interior ID."), PlayerPlaySound(playerid, SOUND_WRONGCOMMAND, 0.0, 0.0, 0.0);
	            Interior_Base = true;
				StartRound(id, GAMETYPE_BASE, playerid);
				LastRoundType = GAMETYPE_INTS;
				PlayerPlaySound(playerid, SOUND_SUCCESS, 0.0, 0.0, 0.0);
			}
		}
		else if(!strcmp(tmp, "arena", true)) {
			if(id == -1) {
				do {
				    id = random(MAX_ARENE);
				    tentativi++;
				}
				while((!aArene[id][Exists] || aArene[id][bForPVP]) && tentativi < MAX_TENTATIVI);

				CONTROLLO_TENTATIVI

				StartRound(id, GAMETYPE_ARENA, playerid, 1);
				LastRoundType = GAMETYPE_ARENA;
				PlayerPlaySound(playerid, SOUND_SUCCESS, 0.0, 0.0, 0.0);
			}
			else {
				if(!aArene[id][Exists]) return SendClientMessage(playerid, COLOR_RED, "Invalid Arena ID."), PlayerPlaySound(playerid, SOUND_WRONGCOMMAND, 0.0, 0.0, 0.0);
				StartRound(id, GAMETYPE_ARENA, playerid);
				LastRoundType = GAMETYPE_ARENA;
				PlayerPlaySound(playerid, SOUND_SUCCESS, 0.0, 0.0, 0.0);
			}
		}
		else if(!strcmp(tmp, "tdm", true)) {
			if(id == -1) {
				do {
				    id = random(MAX_ARENE);
				    tentativi++;
				}
				while(!aArene[id][Exists] || aArene[id][bForPVP]  && tentativi < MAX_TENTATIVI);

				CONTROLLO_TENTATIVI

				StartRound(id, GAMETYPE_TDM, playerid, 1);
				LastRoundType = GAMETYPE_TDM;
				PlayerPlaySound(playerid, SOUND_SUCCESS, 0.0, 0.0, 0.0);
			}
			else {
				if(!aArene[id][Exists]) return SendClientMessage(playerid, COLOR_RED, "Invalid TDM ID."), PlayerPlaySound(playerid, SOUND_WRONGCOMMAND, 0.0, 0.0, 0.0);
				StartRound(id, GAMETYPE_TDM, playerid);
				LastRoundType = GAMETYPE_TDM;
				PlayerPlaySound(playerid, SOUND_SUCCESS, 0.0, 0.0, 0.0);
			}
		}
		else if(!strcmp(tmp, "pvp", true))
		{
		    new pA = 0, pB = 0;

		    foreach(new i:Player)
			{
				if(Player[i][IsAfk]) continue;
				if(!Player[i][Spawned]) continue;

		        if(Player[i][Team] == TEAM_A) pA++;
		        if(Player[i][Team] == TEAM_B) pB++;
		    }

		    if( pA == 0 || pA > 1) return SendClientMessage(playerid, red, "1 player only must be in the 1st team!"), PlayerPlaySound(playerid, SOUND_WRONGCOMMAND, 0.0, 0.0, 0.0);
		    if( pB == 0 || pB > 1) return SendClientMessage(playerid, red, "1 player only must be in the 2nd team!"), PlayerPlaySound(playerid, SOUND_WRONGCOMMAND, 0.0, 0.0, 0.0);

			do
			{
			    id = random(MAX_ARENE);
                tentativi++;
			}
			while(!aArene[id][Exists] || !aArene[id][bForPVP]  && tentativi < MAX_TENTATIVI);

			CONTROLLO_TENTATIVI

			LastRoundType = GAMETYPE_PVP;
			Round_PVPMode = 1;

			// ha definito due armi
			if (fw != -1) {
			    PVPWeapons [0] = fw;
			}

			if (fw2 != -1) {
			    PVPWeapons [1] = fw2;
			}

		    StartRound(id, GAMETYPE_ARENA, playerid);
	 	    PlayerPlaySound(playerid, SOUND_SUCCESS, 0.0, 0.0, 0.0);
		}
		else if(!strcmp(tmp, "gungame", true))
		{
			if(id == -1)
			{
				do {
				    id = random(MAX_GUNGAME);
				    tentativi++;
				}
				while(!gGunGame[id][Exists]  && tentativi < MAX_TENTATIVI);

				CONTROLLO_TENTATIVI

				StartRound(id, GAMETYPE_GUNGAME, playerid, 1);
				LastRoundType = GAMETYPE_GUNGAME;
				PlayerPlaySound(playerid, SOUND_SUCCESS, 0.0, 0.0, 0.0);
			}
			else {
				if(id >= MAX_GUNGAME) return SendClientMessage(playerid, COLOR_RED, "Invalid \"GunGame\" ID."), PlayerPlaySound(playerid, SOUND_WRONGCOMMAND, 0.0, 0.0, 0.0);
				if(!gGunGame[id][Exists]) return SendClientMessage(playerid, COLOR_RED, "Invalid \"GunGame\" ID."), PlayerPlaySound(playerid, SOUND_WRONGCOMMAND, 0.0, 0.0, 0.0);
				StartRound(id, GAMETYPE_GUNGAME, playerid);
				LastRoundType = GAMETYPE_GUNGAME;
				PlayerPlaySound(playerid, SOUND_SUCCESS, 0.0, 0.0, 0.0);
			}
		}
		else if(!strcmp(tmp, "fava", true))
		{
			if (fw == -1 || fw == 28)
			{
				static weaps [13] = {
					24, 25, 26, 27, 29, 30, 31, 32, 33, 34, 23, 38
				};

				RoundFightWeapon = weaps [random(13)];
			}
			else RoundFightWeapon = fw;

			if (id == -1)
			{
    			do
				{
           			id = random (MAX_FIGHTS);
           			tentativi++;
    			} while (!fFights[id][fExists] || fFights[id][fSize] != FIGHTSIZE_ALLVSALL  && tentativi < MAX_TENTATIVI);

    			CONTROLLO_TENTATIVI

			}
			else
			{
				if(id >= MAX_FIGHTS) return SendClientMessage(playerid, COLOR_RED, "Invalid \"Fight\" ID."), PlayerPlaySound(playerid, SOUND_WRONGCOMMAND, 0.0, 0.0, 0.0);
				if(!fFights[id][fExists]) return SendClientMessage(playerid, COLOR_RED, "Invalid \"Fight\" ID."), PlayerPlaySound(playerid, SOUND_WRONGCOMMAND, 0.0, 0.0, 0.0);
			}

        	RoundFightType = FIGHTSIZE_ALLVSALL;
			LastRoundType = GAMETYPE_FIGHT;
			StartRound(id, GAMETYPE_FIGHT, playerid, 1);

			PlayerPlaySound(playerid, SOUND_SUCCESS, 0.0, 0.0, 0.0);
		}
		else if(!strcmp(tmp, "fight", true))
		{
			if (fw == -1 || fw == 28)
			{
				static weaps [13] = {
					24, 25, 26, 27, 29, 30, 31, 32, 33, 34, 23, 38
				};

				RoundFightWeapon = weaps [random(13)];
			}
			else RoundFightWeapon = fw;

		    if (id == -1)
		    {
			    new pT;

			    foreach(new i:Player)
				{
					if(Player[i][IsAfk]) continue;
					if(!Player[i][Spawned]) continue;

					if(Player[i][Team] == TEAM_A || Player[i][Team] == TEAM_B) pT++;
			    }

			    if (pT % 2 == 0) // fa 1-1 // 1-1 // 1-1 // 1-1
			    {
			        RoundFightType = FIGHTSIZE_ONEVSONE;

		  			do
       				{
           				id = random (MAX_FIGHTS);
           				tentativi++;
		        	} while (!fFights[id][fExists] || fFights[id][fSize] != FIGHTSIZE_ONEVSONE  && tentativi < MAX_TENTATIVI);
	    		}
				else // fa tutti vs tutti
				{
			        RoundFightType = FIGHTSIZE_ALLVSALL;

    				do
        			{
           				id = random (MAX_FIGHTS);
           				tentativi++;
			        } while (!fFights[id][fExists] || fFights[id][fSize] != FIGHTSIZE_ALLVSALL  && tentativi < MAX_TENTATIVI);
				}

				CONTROLLO_TENTATIVI

				LastRoundType = GAMETYPE_FIGHT;
				StartRound(id, GAMETYPE_FIGHT, playerid, 1);

				PlayerPlaySound(playerid, SOUND_SUCCESS, 0.0, 0.0, 0.0);
		    }
		    else
		    {
				if(id >= MAX_FIGHTS) return SendClientMessage(playerid, COLOR_RED, "Invalid \"Fight\" ID."), PlayerPlaySound(playerid, SOUND_WRONGCOMMAND, 0.0, 0.0, 0.0);
				if(!fFights[id][fExists]) return SendClientMessage(playerid, COLOR_RED, "Invalid \"Fight\" ID."), PlayerPlaySound(playerid, SOUND_WRONGCOMMAND, 0.0, 0.0, 0.0);

			    new pT;

			    foreach(new i:Player)
				{
					if(Player[i][IsAfk]) continue;
					if(!Player[i][Spawned]) continue;

					if(Player[i][Team] == TEAM_A || Player[i][Team] == TEAM_B) pT++;
			    }


			    if (pT % 2 == 0)
			        RoundFightType = FIGHTSIZE_ONEVSONE;
				else
				    RoundFightType = FIGHTSIZE_ALLVSALL;

				// /start fight -1 1 Deagle <- Starta una fight, arena casuale, di tipo all vs all con l'arma deagle

				LastRoundType = GAMETYPE_FIGHT;
				StartRound(id, GAMETYPE_FIGHT, playerid);

				PlayerPlaySound(playerid, SOUND_SUCCESS, 0.0, 0.0, 0.0);
		    }
		}
		else if(!strcmp(tmp, "fallout", true))
		{
			StartRound(0, GAMETYPE_FALLOUT, playerid);
			LastRoundType = GAMETYPE_FALLOUT;
			PlayerPlaySound(playerid, SOUND_SUCCESS, 0.0, 0.0, 0.0);
		}
		else if(!strcmp(tmp, "lastbullet", true))
		{
			if(id == -1)
			{
				do {
				    id = random(MAX_LASTBULLET);
				    tentativi++;
				}
				while(!lBullet[id][fExists]  && tentativi < MAX_TENTATIVI);

				CONTROLLO_TENTATIVI

				StartRound(id, GAMETYPE_LASTBULLET, playerid, 1);
				LastRoundType = GAMETYPE_LASTBULLET;
				PlayerPlaySound(playerid, SOUND_SUCCESS, 0.0, 0.0, 0.0);
			}
			else {
				if(id >= MAX_LASTBULLET) return SendClientMessage(playerid, COLOR_RED, "Invalid \"Last Bullet\" ID."), PlayerPlaySound(playerid, SOUND_WRONGCOMMAND, 0.0, 0.0, 0.0);
				if(!lBullet[id][fExists]) return SendClientMessage(playerid, COLOR_RED, "Invalid \"Last Bullet\" ID."), PlayerPlaySound(playerid, SOUND_WRONGCOMMAND, 0.0, 0.0, 0.0);

				StartRound(id, GAMETYPE_LASTBULLET, playerid);
				LastRoundType = GAMETYPE_LASTBULLET;
				PlayerPlaySound(playerid, SOUND_SUCCESS, 0.0, 0.0, 0.0);
			}
			//GAMETYPE_LASTBULLET
		}
		else SendClientMessage(playerid, COLOR_RED, "Use start [bbase/arena/tdm/pvp/ints/gungame/fight/fava/fallout] [ID/-1]"), PlayerPlaySound(playerid, SOUND_WRONGCOMMAND, 0.0, 0.0, 0.0);
	}
	return true;
}

COMMAND:random(playerid, params[])
{
	#pragma unused params
	if(!IsPlayerAdminEx(playerid, lMod)) return true;
	if(RoundStarted) return SendClientMessage(playerid, COLOR_RED, "The round is already started."), PlayerPlaySound(playerid, SOUND_WRONGCOMMAND, 0.0, 0.0, 0.0);

	new id = 0;
	switch( LastRoundType )
	{
	    case GAMETYPE_BASE:
		{
			do
			{
			    id = random(basesPacks[CurrentGamepack][maxBases]);
			}
			while(!bBases[id][Exists]);
			StartRound(id, GAMETYPE_BASE, playerid, 1);
	    }
	    case GAMETYPE_INTS:
	    {
			do
			{
   				id = random(MAX_INTS);
			}
			while(!iBases[id][Exists]);
			Interior_Base = true;
			StartRound(id, GAMETYPE_BASE, playerid, 1);
	    }
	    case GAMETYPE_TDM:
		{
			do
			{
			    id = random(MAX_ARENE);
			}
			while(!aArene[id][Exists]);
			StartRound(id, GAMETYPE_TDM, playerid, 1);
	    }
	    case GAMETYPE_ARENA:
		{
			do {
			    id = random(MAX_ARENE);
			}
			while(!aArene[id][Exists]);
			StartRound(id, GAMETYPE_ARENA, playerid, 1);
	    }
	    case GAMETYPE_PVP:
	    {
		    new pA = 0, pB = 0;

		    foreach(new i:Player)
			{
				if(Player[i][IsAfk]) continue;
				if(!Player[i][Spawned]) continue;

				if(Player[i][Team] == TEAM_A) pA++;
		        if(Player[i][Team] == TEAM_B) pB++;
		    }

		    if( pA == 0 || pA > 1) return SendClientMessage(playerid, red, "1 player only must be in the 1st team!"), PlayerPlaySound(playerid, SOUND_WRONGCOMMAND, 0.0, 0.0, 0.0);
		    if( pB == 0 || pB > 1) return SendClientMessage(playerid, red, "1 player only must be in the 2nd team!"), PlayerPlaySound(playerid, SOUND_WRONGCOMMAND, 0.0, 0.0, 0.0);

			do
			{
			    id = random(MAX_ARENE);
			}
			while(!aArene[id][Exists] || !aArene[id][bForPVP]);

			LastRoundType = GAMETYPE_PVP;
			Round_PVPMode = 1;

		    StartRound(id, GAMETYPE_ARENA, playerid);
	 	    PlayerPlaySound(playerid, SOUND_SUCCESS, 0.0, 0.0, 0.0);
		}
	    case GAMETYPE_GUNGAME:
		{
			do
			{
			    id = random(MAX_GUNGAME);
			}
			while(!gGunGame[id][Exists]);
			StartRound(id, GAMETYPE_GUNGAME, playerid, 1);
	    }
	    case GAMETYPE_FIGHT:
	    {
 	  		new pT;

			static weaps [13] =
			{
				24, 25, 26, 27, 29, 30, 31, 32, 33, 34, 23, 38
			};

			RoundFightWeapon = weaps [random(13)];

		    foreach(new i:Player)
			{
				if(Player[i][IsAfk]) continue;
				if(!Player[i][Spawned]) continue;

				if(Player[i][Team] == TEAM_A || Player[i][Team] == TEAM_B) pT++;
		    }

		    if (pT%2 == 0) // fa 1-1 // 1-1 // 1-1 // 1-1
		    {
		        do
		        {
		            id = random (MAX_FIGHTS);
		        } while (!fFights[id][fExists] || fFights[id][fSize] != FIGHTSIZE_ONEVSONE);
		        RoundFightType = FIGHTSIZE_ONEVSONE;
   			}
			else // fa tutti vs tutti
			{
		        do
		        {
		            id = random (MAX_FIGHTS);
		        } while (!fFights[id][fExists] || fFights[id][fSize] != FIGHTSIZE_ALLVSALL);
		        RoundFightType = FIGHTSIZE_ALLVSALL;
			}

			LastRoundType = GAMETYPE_FIGHT;
			StartRound(id, GAMETYPE_FIGHT, playerid, 1);

			PlayerPlaySound(playerid, SOUND_SUCCESS, 0.0, 0.0, 0.0);
	    }//GunGame
	    default:
		{
			SendClientMessage(playerid, red, "To use this command you must start something firstly.");
 			PlayerPlaySound(playerid, SOUND_WRONGCOMMAND, 0.0, 0.0, 0.0);
		}
	}

    PlayerPlaySound(playerid, SOUND_SUCCESS, 0.0, 0.0, 0.0);
	return true;
}

COMMAND:end(playerid, params[])
{
	#pragma unused params
	if(!IsPlayerAdminEx(playerid, lMod)) return true;
	if(!RoundStarted) return SendClientMessage(playerid, COLOR_RED, "The round is not started."), PlayerPlaySound(playerid, SOUND_WRONGCOMMAND, 0.0, 0.0, 0.0);
	if(Gaming != GAMETYPE_GUNGAME && Gaming != GAMETYPE_FIGHT && Gaming != GAMETYPE_FALLOUT && Gaming != GAMETYPE_LASTBULLET)
	{
		EndRound(NULL_TEAM, WINTYPE_ENDING);
	}
	else
	{
	    EndRound(INVALID_PLAYER_ID, WINTYPE_ENDING);
	}
	format (stringo, sizeof stringo, "Admin/Mod {"#COLOR_SYSTEM_FOCUS"}%s{"#COLOR_SYSTEM_REST"} has ended the round.", Player[playerid][Nickname]);
	SendClientMessageToAll(COLOR_SYSTEM, stringo);
	PlayerPlaySound(playerid, SOUND_SUCCESS, 0.0, 0.0, 0.0);
	return true;
}

/**
	* base editor
*/

COMMAND:e(playerid, params[])
{
	if (!IsPlayerAdminEx(playerid, lAdmin)) return true;
	if (RoundStarted) return SendClientMessage(playerid, COLOR_RED, "The round is started."), PlayerPlaySound(playerid, SOUND_WRONGCOMMAND, 0.0, 0.0, 0.0);

	switch (Editor_WorkingType[playerid])
	{
		case EDITOR_WORKTYPE_NOONE:
		{
			ShowPlayerDialog(playerid, DIALOG_EDITOR_ACTION, DIALOG_STYLE_LIST, "Action", "Crea\nModifica\nEsci", "Scegli", "Chiudi");
		}
		case EDITOR_WORKTYPE_BASE, EDITOR_WORKTYPE_ARENA:
		{
			ShowPlayerDialog(playerid, DIALOG_EDITOR_CREATINGMENU, DIALOG_STYLE_LIST, "Creazione", "Attackers Spawn\nDefenders Spawn\nCheckpoint\nName\nSalva", "Cambia", "Indietro");
		}
		case EDITOR_WORKTYPE_GUNGAME, EDITOR_WORKTYPE_FIGHT:
		{
			if (Editor_SettingSpawn[playerid])
			{
				if (Editor_CurrentSpawnID[playerid] < 19)
				{
					SendClientMessage(playerid, red, "Attenzione: Forse non tutti i spawns sono stati inseriti.");
				}

				Editor_SettingSpawn [playerid] = false;
			}

			ShowPlayerDialog(playerid, DIALOG_EDITOR_CREATEGGFF, DIALOG_STYLE_LIST, "Creazione", "Set name\nSet Spawns\nSet limits\nSalva", "Seleziona", "Indietro");
		}
		case EDITOR_WORKINGTYPE_EDITINGBASE:
		{
			ShowPlayerDialog(playerid, DIALOG_EDITING_BASE, DIALOG_STYLE_LIST, "Base Editing", sprintf(
				"- Go to:\n\
				\tAttackers spawn\n \
				\tDefenders spawn\n \
				\tCheckpoint\n \
				- Change:\n \
				\tChange attackers spawn\n \
				\tChange defenders spawn\n \
				\tChange checkpoint\n \
				\tChange base name (Current name: %s)\n\
				Delete\n\
				Chiudi", bBases[Editing_BaseID[playerid]][bName]
			), "Vai", "Chiudi");
		}
		case EDITOR_WORKINGTYPE_EDITINGARENA:
		{
			ShowPlayerDialog(playerid, DIALOG_EDITING_ARENA, DIALOG_STYLE_LIST, "Arena Editing", sprintf(
				"- Go to:\n\
				\tSpawn 1\n \
				\tSpawn 2\n \
				\tHome\n \
				- Change:\n \
				\tChange Spawn 1\n \
				\tChange Spawn 2\n \
				\tChange Home\n \
				\tChange arena name (Current name: %s)\n\
				Delete arena\n\
				Chiudi", aArene[Editing_BaseID[playerid]][bName]
			), "Vai", "Chiudi");
		}
	}
	return true;
}

forward Editor_OnEditorAdding(playerid);
public Editor_OnEditorAdding(playerid) // viene richiamato in ogni caso sia fight sia arena etc.
{
	SendClientMessage(playerid, COLOR_SYSTEM, "Creazione terminata.");

	if (Editor_GangZoneTest[playerid] != -1)
		GangZoneDestroy(Editor_GangZoneTest[playerid]);

	Editor_GangZoneTest[playerid] = -1;

	Editor_WorkingType[playerid] = EDITOR_WORKTYPE_NOONE;

	Editor_Defenders[playerid][0] = 0.0;
	Editor_Defenders[playerid][1] = 0.0;
	Editor_Defenders[playerid][2] = 0.0;

	Editor_Attackers[playerid][0] = 0.0;
	Editor_Attackers[playerid][1] = 0.0;
	Editor_Attackers[playerid][2] = 0.0;

	Editor_Checkpoint[playerid][0] = 0.0;
	Editor_Checkpoint[playerid][1] = 0.0;
	Editor_Checkpoint[playerid][2] = 0.0;

	Editor_CurrentSpawnID[playerid] = 0;
	Editor_SettingSpawn[playerid] = false;

	for (new i = 0; i < 20; i++)
	{
		Editor_SpawnsPos[playerid][i][0] = 0.0;
		Editor_SpawnsPos[playerid][i][1] = 0.0;
		Editor_SpawnsPos[playerid][i][2] = 0.0;
	}
}

/*
new basesPacks[][ ePacks_bases ] =
{
	{"Slaughterfield", 141, "slfd"},
	{"ESL", 52, "esl"},
	{"WarGrounds", 193, "wargrounds"},
	{"NoCbug", 95, "nocbug"},GAMETYPE_LASTBULLET
	{"Warhead", 144, "warhead"}
};*/

/*
	* function game
*/

// cache-coords
new Float:Start_X,
	Float:Start_Y,
	Float:Start_Z;

new buffer1 [128], buffer2 [128], buffer3 [128];

stock StartRound(id, gametype = GAMETYPE_BASE, playerid = INVALID_PLAYER_ID, xrandom = 0)
{
	printf("StartRound id: %d - gametype: %d - playerid: %d - random: %d", id, gametype, playerid, xrandom);

	if (gametype != GAMETYPE_GUNGAME && gametype != GAMETYPE_FIGHT && gametype != GAMETYPE_FALLOUT && gametype != GAMETYPE_LASTBULLET)
	{
		new pA = 0, pB = 0;

		foreach(new i:Player)
		{
			if(Player[i][IsAfk]) continue;
			if(!Player[i][Spawned]) continue;

			if(Player[i][Team]==TEAM_A)
			{
				pA++;
			}
			else if(Player[i][Team]==TEAM_B)
			{
				pB++;
			}
		}

		iTeam[TEAM_A][tPlayers] = pA;
		iTeam[TEAM_B][tPlayers] = pB;

		if(pA < 1 || pB < 1)
		{
			if (playerid == INVALID_PLAYER_ID)
			{
				SendClientMessageToAll(red, "Cannot start the round, not enough players in every team.");
			}
			else
			{
				SendClientMessage(playerid, red, "Cannot start the round, not enough players in every team.");
			}
			return true;
		}
	}
	else
	{
	    if (gametype != GAMETYPE_FALLOUT)
	    {
			new pA = 0, pB = 0;

			foreach(new i:Player)
			{
				if(Player[i][IsAfk]) continue;
				if(!Player[i][Spawned]) continue;

				if(Player[i][Team]==TEAM_A)
				{
					pA++;
				}
				else if(Player[i][Team]==TEAM_B)
				{
					pB++;
				}
			}

			if ((pA+pB) < 2)
			{
				if (playerid != INVALID_PLAYER_ID)
					SendClientMessage(playerid, red, "Cannot start the round, not enough players in the server.");
				else
					SendClientMessageToAll(red, "Cannot start the round, not enough players in the server.");
				return true;
			}
		}
	}

	if( RoundStarted )
	{
	    SendClientMessageToAll(red, "A round is already started.");
	    return true;
	}

//	stop hint_timer;

	if (StartingVoting != Timer:-1)
	{
	    StartingVoting = Timer:-1;
		for (new i = 0; i < sizeof(VotesRunning); i++)
		{
		    if (VotesRunning[i][Started] == false) continue;
		    if (VotesRunning[i][Votetype] == VOTETYPE_STARTBASE || VotesRunning[i][Votetype] == VOTETYPE_STARTARENA || VotesRunning[i][Votetype] == VOTETYPE_STARTINT || VotesRunning[i][Votetype] == VOTETYPE_STARTGUNGAME)
		    {
			    VotesRunning[i][Started] 			= false;
			    VotesRunning[i][Votes]   			= 0;
				VotesRunning[i][VoteInformations]   = -1;
			    VotesRunning[i][Votetype]   		= VOTETYPE_NULL;
			    VotesRunning[i][VoteStarter]   		= INVALID_PLAYER_ID;
			}
		}

		SendClientMessageToAll(red, "All voting about starting deleted");
	}

	for(new x = 0; x < MAX_PLAYERS; x++)
	{
	    Player[x][Voted] = false;
	}

	if(FinalReady)
	{
	    FinalReady = false;
     	for(new x = 0; x < sizeof(FinalTCWScreen); x++)
 		{
   			TextDrawHideForAll(FinalTCWScreen[x]);
		}
	}

	if (gConfig[GameMode] == GAMEMODE_ESL)
	{
	    TextDrawHideForAll(ESLModeReady[0]);
	    TextDrawHideForAll(ESLModeReady[1]);
	    TextDrawHideForAll(ESLModeReady[2]);
	    TextDrawHideForAll(ESLModeReady[3]);
	}

	stop AutoHide_TD;

    ClearDeathMessages();

	/*
	if (gConfig[SkinSwap])
		iTeam[TEAM_A][Skin] ^= iTeam[TEAM_B][Skin], iTeam[TEAM_B][Skin] ^= iTeam[TEAM_A][Skin], iTeam[TEAM_A][Skin] ^= iTeam[TEAM_B][Skin];
	*/

    eScenario[Interior] 	= 0;

	RealRMins 			= gConfig[RTime_Mins];
	RealRSecs 			= 0;

	switch (gametype)
	{
	    case GAMETYPE_BASE:
	    {
	 	    if(Interior_Base == true)
		    {
			    eScenario[SpawnAttackers][0] = iBases[id][bAttackers][0];
			    eScenario[SpawnAttackers][1] = iBases[id][bAttackers][1];
			    eScenario[SpawnAttackers][2] = iBases[id][bAttackers][2];

			    eScenario[SpawnDefenders][0] = iBases[id][bDefenders][0];
			    eScenario[SpawnDefenders][1] = iBases[id][bDefenders][1];
			    eScenario[SpawnDefenders][2] = iBases[id][bDefenders][2];

			    eScenario[Checkpoint][0] = iBases[id][bCheckpoint][0];
			    eScenario[Checkpoint][1] = iBases[id][bCheckpoint][1];
			    eScenario[Checkpoint][2] = iBases[id][bCheckpoint][2];

			    eScenario[Interior] 	 = iBases[id][bInterior];

                iBases[id][bPlayed] ++;
			    eScenario[Played]  = iBases[id][bPlayed];

			    strcpy_2(eScenario[BaseName], iBases[id][bName]);

			    format (stringo, sizeof stringo, "%s - Interior", eScenario[BaseName]);
				TextDrawSetString(RoundStart_TD1, stringo);

		        format( stringo , sizeof stringo , "mapname Interior: %d" , id );
		        Server_RefreshStats(PlayedInteriors, 1);
		        TextDrawSetString( SkinSelection_TDs , !"Welcome to ~r~Slaughterfield A/D~w~~n~An Int Base is being played");

		        MySQLStatus[TotalQuerys] ++; mysql_tquery (g_MySQLConnection, sprintf("UPDATE bases_interiors SET played = played + 1 WHERE id = '%d'", id), "", "");
			}
			else
			{
			    eScenario[SpawnAttackers][0] = bBases[id][bAttackers][0];
			    eScenario[SpawnAttackers][1] = bBases[id][bAttackers][1];
			    eScenario[SpawnAttackers][2] = bBases[id][bAttackers][2];

			    eScenario[SpawnDefenders][0] = bBases[id][bDefenders][0];
			    eScenario[SpawnDefenders][1] = bBases[id][bDefenders][1];
			    eScenario[SpawnDefenders][2] = bBases[id][bDefenders][2];

			    eScenario[Checkpoint][0] = bBases[id][bCheckpoint][0];
			    eScenario[Checkpoint][1] = bBases[id][bCheckpoint][1];
			    eScenario[Checkpoint][2] = bBases[id][bCheckpoint][2];

			    eScenario[Interior] 	 = bBases[id][bInterior];

			    bBases[id][bPlayed] ++;
			    eScenario[Played]  = bBases[id][bPlayed];

			    strcpy_2(eScenario[BaseName], bBases[id][bName]);

			    format (stringo, sizeof stringo, "%s - AAD", eScenario[BaseName]);
				TextDrawSetString(RoundStart_TD1, stringo);

	            format( stringo , sizeof stringo , "mapname AAD: %d" , id );
	            Server_RefreshStats(PlayedBases, 1);
	            TextDrawSetString( SkinSelection_TDs , !"Welcome to ~r~Slaughterfield A/D~w~~n~A Base is being played");

	            MySQLStatus[TotalQuerys] ++; mysql_tquery (g_MySQLConnection, sprintf("UPDATE bases_%s SET played = played + 1 WHERE id = '%d'", basesPacks[CurrentGamepack][SQLdb], id), "", "");
			}

			AntiHits = true;
		}
		case GAMETYPE_ARENA:
		{
		    eScenario[SpawnAttackers][0] = aArene[id][bAttackers][0];
		    eScenario[SpawnAttackers][1] = aArene[id][bAttackers][1];
		    eScenario[SpawnAttackers][2] = aArene[id][bAttackers][2];

		    eScenario[SpawnDefenders][0] = aArene[id][bDefenders][0];
		    eScenario[SpawnDefenders][1] = aArene[id][bDefenders][1];
		    eScenario[SpawnDefenders][2] = aArene[id][bDefenders][2];

		    eScenario[Checkpoint][0] = aArene[id][bCheckpoint][0];
		    eScenario[Checkpoint][1] = aArene[id][bCheckpoint][1];
		    eScenario[Checkpoint][2] = aArene[id][bCheckpoint][2];

		    eScenario[Interior] 	 = aArene[id][bInterior];

            aArene[id][bPlayed] ++;
		    eScenario[Played]  = aArene[id][bPlayed];

		    eScenario[MinX] = aArene[id][bMinX];
		    eScenario[MinY] = aArene[id][bMinY];

		    eScenario[MaxX] = aArene[id][bMaxX];
		    eScenario[MaxY] = aArene[id][bMaxY];

		    strcpy_2(eScenario[BaseName], aArene[id][bName]);
			Server_RefreshStats(PlayedArene, 1);

			if (!Round_PVPMode)
			{
			    format (stringo, sizeof stringo, "%s - Arena", eScenario[BaseName]);
				TextDrawSetString(RoundStart_TD1, stringo);

				format( stringo , sizeof stringo , "mapname Arena: %d" , id );
				TextDrawSetString( SkinSelection_TDs , !"Welcome to ~r~Slaughterfield A/D~w~~n~An Arena is being played");
			}
			else
			{
			    format (stringo, sizeof stringo, "%s - PVP", eScenario[BaseName]);
				TextDrawSetString(RoundStart_TD1, stringo);

			    format( stringo , sizeof stringo , "mapname PVP: %d" , id );
			    TextDrawSetString( SkinSelection_TDs , !"Welcome to ~r~Slaughterfield A/D~w~~n~A PVP is being played");
			}

            MySQLStatus[TotalQuerys] ++; mysql_tquery (g_MySQLConnection, sprintf("UPDATE arene SET played = played + 1 WHERE id = '%d'", id), "", "");

			RealRMins = 0;
			RealRSecs = 0;

			AntiHits = true;
		}
		case GAMETYPE_TDM:
		{
		    eScenario[SpawnAttackers][0] = aArene[id][bAttackers][0];
		    eScenario[SpawnAttackers][1] = aArene[id][bAttackers][1];
		    eScenario[SpawnAttackers][2] = aArene[id][bAttackers][2];

		    eScenario[SpawnDefenders][0] = aArene[id][bDefenders][0];
		    eScenario[SpawnDefenders][1] = aArene[id][bDefenders][1];
		    eScenario[SpawnDefenders][2] = aArene[id][bDefenders][2];

		    eScenario[Checkpoint][0] = aArene[id][bCheckpoint][0];
		    eScenario[Checkpoint][1] = aArene[id][bCheckpoint][1];
		    eScenario[Checkpoint][2] = aArene[id][bCheckpoint][2];

		    eScenario[MinX] = aArene[id][bMinX];
		    eScenario[MinY] = aArene[id][bMinY];

		    eScenario[MaxX] = aArene[id][bMaxX];
		    eScenario[MaxY] = aArene[id][bMaxY];

		    eScenario[Interior] = aArene[id][bInterior];

            aArene[id][bPlayed] ++;
		    eScenario[Played]  = aArene[id][bPlayed];

		    strcpy_2(eScenario[BaseName], aArene[id][bName]);

		    Server_RefreshStats(PlayedTDMS, 1);

		    format (stringo, sizeof stringo, "%s - TDM", eScenario[BaseName]);
			TextDrawSetString(RoundStart_TD1, stringo);

		    format( stringo , sizeof stringo , "mapname TDM: %d" , id );

		    TextDrawSetString( SkinSelection_TDs , !"Welcome to ~r~Slaughterfield A/D~w~~n~A TDM is being played");

		    MySQLStatus[TotalQuerys] ++; mysql_tquery (g_MySQLConnection, sprintf("UPDATE arene SET played = played + 1 WHERE id = '%d'", id), "", "");

			RealRMins = 0;
			RealRSecs = 0;

			AntiHits = true;
		}
		case GAMETYPE_GUNGAME:
		{
		    //INI_ParseFile(GunGameFile(id), "LoadGunGame", .bPassTag = true);
	        Server_RefreshStats(PlayedGunGame, 1);
//gGunGame_SpecialSpawns

		    eScenario[Interior] 	 = gGunGame[id][bInterior];
		    eScenario[Played]  = gGunGame[id][bPlayed];

		    for (new i = 0; i < 20; i ++)
		    {
		        Scenario_MultipleSpawns[i][0] = gGunGame_SpecialSpawns[id][i][0];
		        Scenario_MultipleSpawns[i][1] = gGunGame_SpecialSpawns[id][i][1];
		        Scenario_MultipleSpawns[i][2] = gGunGame_SpecialSpawns[id][i][2];
		    }

			// eScenario[SpawnAttackers][0] = Scenario_MultipleSpawns[0][0];
	  		// eScenario[SpawnAttackers][1] = Scenario_MultipleSpawns[0][1];
	    	// eScenario[SpawnAttackers][2] = Scenario_MultipleSpawns[0][2];

			eScenario[Checkpoint][0] = Scenario_MultipleSpawns[19][0];
	  		eScenario[Checkpoint][1] = Scenario_MultipleSpawns[19][1];
	    	eScenario[Checkpoint][2] = Scenario_MultipleSpawns[19][2];

			eScenario[MinX] = gGunGame[id][bMinX];
		    eScenario[MinY] = gGunGame[id][bMinY];

		    eScenario[MaxX] = gGunGame[id][bMaxX];
		    eScenario[MaxY] = gGunGame[id][bMaxY];

	    	gGunGame[id][bPlayed]++;
	    	eScenario[Played] = gGunGame[id][bPlayed];

	    	strcpy_2(eScenario[BaseName], gGunGame[id][bName]);

		    format (stringo, sizeof stringo, "%s - GunGame", eScenario[BaseName]);
			TextDrawSetString(RoundStart_TD1, stringo);

	    	format( stringo , sizeof stringo , "mapname GunGame: %d" , id );

	    	TextDrawSetString( SkinSelection_TDs , !"Welcome to ~r~Slaughterfield A/D~w~~n~A Gungame is being played");

//	    	TextDrawSetString( RoundStats[ rStats_AStats ] , "_" );
//	    	TextDrawSetString( RoundStats[ rStats_BStats ] , "_" );

	    	MySQLStatus[TotalQuerys] ++; mysql_tquery (g_MySQLConnection, sprintf("UPDATE gungame SET played = played + 1 WHERE id = '%d'", id), "", "");

			RealRMins = 0;
			RealRSecs = 0;

			AntiHits = false;
		}
		case GAMETYPE_FIGHT:
		{
//	        Server_RefreshStats(PlayedFight, 1);
		    eScenario[Interior] = fFights[id][fInterior];
		    eScenario[Played]  	= fFights[id][fPlayed];

		    eScenario[MinX] = fFights[id][fMinX];
		    eScenario[MinY] = fFights[id][fMinY];

		    eScenario[MaxX] = fFights[id][fMaxX];
		    eScenario[MaxY] = fFights[id][fMaxY];

			eScenario[Checkpoint][0] = fFights_Spawns[id][0][0];
	  		eScenario[Checkpoint][1] = fFights_Spawns[id][0][1];
	    	eScenario[Checkpoint][2] = fFights_Spawns[id][0][2];

	    	fFights[id][fPlayed]++;

	    	strcpy_2(eScenario[BaseName], fFights[id][fName]);

		    format (stringo, sizeof stringo, "%s - Fight", eScenario[BaseName]);
			TextDrawSetString(RoundStart_TD1, stringo);

	    	format( stringo , sizeof stringo , "mapname Fight: %d" , id );

	    	TextDrawSetString( SkinSelection_TDs , !"Welcome to ~r~Slaughterfield A/D~w~~n~A Fight is being played");

//	    	TextDrawSetString( RoundStats[ rStats_AStats ] , "_" );
//	    	TextDrawSetString( RoundStats[ rStats_BStats ] , "_" );

	    	MySQLStatus[TotalQuerys] ++; mysql_tquery (g_MySQLConnection, sprintf("UPDATE fight SET played = played + 1 WHERE id = '%d'", fFights[id][fMySQLid]), "", "");

			RealRMins = 0;
			RealRSecs = 0;

			AntiHits = false;
		}
		case GAMETYPE_FALLOUT:
		{
		    eScenario[MinX] = -20000.0000;
		    eScenario[MinY] = -20000.0000;

		    eScenario[MaxX] = 20000.0000;
		    eScenario[MaxY] = 20000.0000;

		    CreaPiattaforma ();

		    eScenario[Interior] = 0;
		    eScenario[Played] = 0;

            strcpy_2(eScenario[BaseName], "Fallout");

			eScenario[Checkpoint][0] = 2482.1921 - random(39);
	  		eScenario[Checkpoint][1] = -1660.4783 + random(47);
	    	eScenario[Checkpoint][2] = 161.0000;

            // 2482.1921 - random(39)

		    format (stringo, sizeof stringo, "%s - Fallout", eScenario[BaseName]);
			TextDrawSetString(RoundStart_TD1, stringo);

            format( stringo , sizeof stringo , "mapname Fallout" );
	    	TextDrawSetString( SkinSelection_TDs , !"Welcome to ~r~Slaughterfield A/D~w~~n~A Fallout is being played");

//	    	TextDrawSetString( RoundStats[ rStats_AStats ] , "_" );
//	    	TextDrawSetString( RoundStats[ rStats_BStats ] , "_" );

			RealRMins = 0;
			RealRSecs = 0;

		    AntiHits = false;

            fallout_alive_objs = 99;
		}
		case GAMETYPE_LASTBULLET:
		{
		    eScenario[Interior] = lBullet[id][fInterior];
		    eScenario[Played]  	= lBullet[id][fPlayed];

		    eScenario[MinX] = lBullet[id][fMinX];
		    eScenario[MinY] = lBullet[id][fMinY];

		    eScenario[MaxX] = lBullet[id][fMaxX];
		    eScenario[MaxY] = lBullet[id][fMaxY];

		    new p = random (MAX_FIGHT_SPAWNS);

			eScenario[Checkpoint][0] = lBullet_Spawns[id][p][0];
	  		eScenario[Checkpoint][1] = lBullet_Spawns[id][p][1];
	    	eScenario[Checkpoint][2] = lBullet_Spawns[id][p][2];

			RealRMins = 0;
			RealRSecs = 0;

		    AntiHits = false;

			strcpy_2(eScenario[BaseName], lBullet[id][fName]);

		    format (stringo, sizeof stringo, "%s - Last Bullet", eScenario[BaseName]);
			TextDrawSetString(RoundStart_TD1, stringo);

            format( stringo , sizeof stringo , "mapname Last Bullet: %d", id );
	    	TextDrawSetString( SkinSelection_TDs , !"Welcome to ~r~Slaughterfield A/D~w~~n~A Last Bullet is being played");
		}
	}

	SendRconCommand(stringo);

    SendClientMessageToAll(COLOR_SYSTEM, " ");
    SendClientMessageToAll(COLOR_SYSTEM, " ");
    SendClientMessageToAll(COLOR_SYSTEM, " ");
    SendClientMessageToAll(COLOR_SYSTEM, " ");
    SendClientMessageToAll(COLOR_SYSTEM, " ");
    SendClientMessageToAll(COLOR_SYSTEM, " ");
    SendClientMessageToAll(COLOR_SYSTEM, " ");
    SendClientMessageToAll(COLOR_SYSTEM, " ");

    if (gConfig[Matchmode] == MATCHMODE_TCWCW)
    {
	    if (playerid == INVALID_PLAYER_ID)
	    {
	    	format(buffer1, sizeof buffer1, "Round {"#COLOR_SYSTEM_FOCUS"}%d/%d{"#COLOR_SYSTEM_REST"} is gonna start, prepare yourself!", PlayingRound + 1, TotalRounds);
		}
		else
		{
	    	format(buffer1, sizeof buffer1, "Round {"#COLOR_SYSTEM_FOCUS"}%d/%d{"#COLOR_SYSTEM_REST"} is going to be started by {"#COLOR_SYSTEM_FOCUS"}%s{"#COLOR_SYSTEM_REST"}, prepare yourself!", PlayingRound + 1, TotalRounds, Player[playerid][Nickname]);
		}
	}
	else
	{
	    if (playerid == INVALID_PLAYER_ID)
	    {
	    	format(buffer1, sizeof buffer1, "Round is gonna start, prepare yourself!");
		}
		else
		{
	    	format(buffer1, sizeof buffer1, "Round is going to be started by {"#COLOR_SYSTEM_FOCUS"}%s{"#COLOR_SYSTEM_REST"}, prepare yourself!", Player[playerid][Nickname]);
		}
	}

	//SendClientMessageToAll(COLOR_SYSTEM, stringo);

	new q[30];

	switch (gametype)
	{
	    case GAMETYPE_BASE:
	    {
			if (Interior_Base)
				q = "Interior Base";
			else
				q = "Base";
		}
	    case GAMETYPE_ARENA:
	    {
			if (Round_PVPMode)
				q = "PVP";
			else
				q = "Arena";
		}
	    case GAMETYPE_TDM:
	    {
			q = "TDM";
		}
	    case GAMETYPE_GUNGAME:
	    {
			q = "GunGame";
		}
	    case GAMETYPE_FIGHT:
	    {
			q = "Fight";
		}
		case GAMETYPE_FALLOUT:
		{
		    q = "Fallout";
		}
		case GAMETYPE_LASTBULLET:
		{
		    q = "Last Bullet";
		}
	}

	if (xrandom)
	{
	    strcat (q, " (random)");
	}

    format(buffer2, sizeof buffer2, "»» {"#COLOR_SYSTEM_FOCUS"}%s (%d){"#COLOR_SYSTEM_REST"} «« Name: %s «» Played %d times", q, id, eScenario[BaseName], eScenario[Played]);
//	SendClientMessageToAll(COLOR_SYSTEM, buffer2);

	if (Round_PVPMode)
	{
	    format (buffer3, sizeof buffer3, "Player vs Player weapons: {"#COLOR_SYSTEM_FOCUS"}%s %s %s %s %s", (PVPWeapons[0] > 0 ? aWeaponNames[PVPWeapons[0]] : ("")), (PVPWeapons[1] > 0 ? aWeaponNames[PVPWeapons[1]] : ("")), (PVPWeapons[2] > 0 ? aWeaponNames[PVPWeapons[2]] : ("")), (PVPWeapons[3] > 0 ? aWeaponNames[PVPWeapons[3]] : ("")), (PVPWeapons[4] > 0 ? aWeaponNames[PVPWeapons[4]] : ("")));
//        SendClientMessageToAll(COLOR_SYSTEM, buffer3);
	}
	else if (gametype == GAMETYPE_FIGHT)
	{
	    if (RoundFightType == FIGHTSIZE_ALLVSALL)
	    {
	    	format(buffer3, sizeof buffer3, "Fight type: {"#COLOR_SYSTEM_FOCUS"}All Vs All{"#COLOR_SYSTEM_REST"} - Weapon: {"#COLOR_SYSTEM_FOCUS"}%s", aWeaponNames[RoundFightWeapon]);
		}
		else
		{
	    	format(buffer3, sizeof buffer3, "Fight type: {"#COLOR_SYSTEM_FOCUS"}1 vs 1{"#COLOR_SYSTEM_REST"} - Weapon: {"#COLOR_SYSTEM_FOCUS"}%s", aWeaponNames[RoundFightWeapon]);
		}

//        SendClientMessageToAll(COLOR_SYSTEM, stringo);
	}

	eScenario[FileID] 	= id;
	Gaming 				= gametype;
	RoundStarted 		= true;
	RealCPTime 			= gConfig[TCp];
	CamMove 			= true;
	SecondiStart 		= MAX_SECONDI_START;

	#define area_size 100.0

	if(Gaming == GAMETYPE_BASE)
	{
		new Float:xmin,Float:ymax,Float:xmax,Float:ymin;

		xmin = floatsub(eScenario[ Checkpoint ][0], area_size);
		ymax = floatadd(eScenario[ Checkpoint ][1], area_size);
		xmax = floatadd(eScenario[ Checkpoint ][0], area_size);
		ymin = floatsub(eScenario[ Checkpoint ][1], area_size);

		ZonaAttornoCP = GangZoneCreate(xmin,ymin,xmax,ymax);
	}
	else
	{
		ZonaAttornoCP = GangZoneCreate(eScenario[MinX],eScenario[MinY],eScenario[MaxX],eScenario[MaxY]);
	}

	new pteam;

	// I reset round-stats of everyone
	// Disconnected too
	for (new i = 0; i < MAX_PLAYERS; i ++)
	{
		Player[i][RKills] = 0;
		Player[i][RDeaths] = 0;
		Player[i][RDamage] = 0;
	}

	foreach(new i:Player)
	{
	    // dovrebbe essere adattato a __staticAddProcess (i);
//	    TextDrawHideForPlayer(i, HintTD);

//		Player[i][RKills] = 0;
//		Player[i][RDeaths] = 0;
//		Player[i][RDamage] = 0;

	    if(!Player[i][Spawned]) continue;
	    if(Player[i][IsAfk]) continue;
		pteam = Player[i][Team];
	    if(pteam==TEAM_REF||pteam==NULL_TEAM||IsSubPlayer(i))
		{
			SetPlayerScore(i, 0);
			continue;
		}

	    g_PlayerFreezed [i] = false;

		if (Player[i][FinalRound_Status] != FINALROUND_STATUS_HIDDEN)
		{
			new cv = Player[i][CurrentView];
			//CancelSelectTextDraw
			for (new a = 0; a < MAX_STATIC_TEXTDRAWS; a++) TextDrawHideForPlayer(i, FineRound_Static[a]);

			TextDrawHideForPlayer(i, FineRound_Dynamic[cv][BluePlayers]);
			TextDrawHideForPlayer(i, FineRound_Dynamic[cv][GreenPlayers]);
			TextDrawHideForPlayer(i, FineRound_Dynamic[cv][BlueKills]);
			TextDrawHideForPlayer(i, FineRound_Dynamic[cv][BlueDamages]);
			TextDrawHideForPlayer(i, FineRound_Dynamic[cv][GreenKills]);
			TextDrawHideForPlayer(i, FineRound_Dynamic[cv][GreenDamage]);
			TextDrawHideForPlayer(i, FineRound_Dynamic[cv][TotalKGreen]);
			TextDrawHideForPlayer(i, FineRound_Dynamic[cv][TotalDGreen]);
			TextDrawHideForPlayer(i, FineRound_Dynamic[cv][TotalKBlue]);
			TextDrawHideForPlayer(i, FineRound_Dynamic[cv][TotalDBlue]);
			TextDrawHideForPlayer(i, FineRound_Dynamic[cv][Top2_Nick]);
			TextDrawHideForPlayer(i, FineRound_Dynamic[cv][Top2_Stats]);
			TextDrawHideForPlayer(i, FineRound_Dynamic[cv][Top3_Stats]);
			TextDrawHideForPlayer(i, FineRound_Dynamic[cv][Top3_Nick]);
			TextDrawHideForPlayer(i, FineRound_Dynamic[cv][Top1_Stats]);
			TextDrawHideForPlayer(i, FineRound_Dynamic[cv][Top1_Nick]);
			TextDrawHideForPlayer(i, FineRound_Dynamic[cv][RoundsInfo]);
			TextDrawHideForPlayer(i, FineRound_Dynamic[cv][AttDefWin]);
	        TextDrawHideForPlayer(i, FineRound_Dynamic[cv][Stringa_Winner2]);
	        TextDrawHideForPlayer(i, FineRound_Dynamic[cv][Stringa_TeamWin]);
	        TextDrawHideForPlayer(i, FineRound_Dynamic[cv][Stringa_Winner1]);
			TextDrawHideForPlayer(i, FineRound_Dynamic[cv][Stringa_RoundInfo]);
	        TextDrawHideForPlayer(i, FineRound_Dynamic[cv][Stringa_TmpBest]);

            if (gConfig[Matchmode] == MATCHMODE_TCWCW)
	        	CancelSelectTextDraw (i);

	        Player[i][FinalRound_Status] = FINALROUND_STATUS_HIDDEN;
		}

	    Player_outSecs[i] = 10;

		if(IsPlayerInAnyVehicle(i))
		{
			DestroyVehicleEx(GetPlayerVehicleID(i));
		}

		if (InSpec[i]!=-1) Spec_RemovePlayerFromSpec(i);

		Player[i][InGame] 	 = 1;
		PlayerAfk_Seconds[i] = 0;

		//Player[i][FinalRound_Status] = FINALROUND_STATUS_HIDDEN;

		if(TeamRole[pteam]==ATTACKERS)
		{
		    if(Gaming == GAMETYPE_BASE)
			{
		        if( !Interior_Base )
				{
				    SendClientMessage(i, COLOR_GREY, TXT_BASE_ATT);
				}
				else
				{
				    SendClientMessage(i, COLOR_GREY, TXT_INT);
				}
				if (Player[i][Team] == TEAM_A)
  				{
  					TextDrawSetString(PlayerSpecInfo[i][6], "~r~~h~WPS: ~w~-");
	  			}
		  		else
		  		{
			  	    TextDrawSetString(PlayerSpecInfo[i][6], "~b~~h~WPS: ~w~-");
		  		}
				SetSpawnInfo(i, Player[i][Team], GetPlayerSkinEx(i), eScenario[SpawnAttackers][0] - RANDOM_SPAWN_ROUND + random(RANDOM_SPAWN_ROUND), eScenario[SpawnAttackers][1] - RANDOM_SPAWN_ROUND + random(RANDOM_SPAWN_ROUND), eScenario[SpawnAttackers][2], 0.0, 0, 0, 0, 0, 0, 0);
				SetPlayerMapIcon(i, MAPICON_ATTACKERSPAWN, eScenario[SpawnAttackers][0], eScenario[SpawnAttackers][1], eScenario[SpawnAttackers][2], ATTACKERSMAP_ICON, 0, MAPICON_TYPE_ATTSPAWN);
			}
			else if(Gaming == GAMETYPE_ARENA)
			{
				if (Player[i][Team] == TEAM_A)
  				{
  					TextDrawSetString(PlayerSpecInfo[i][6], "~r~~h~WPS: ~w~Arena");
	  			}
		  		else
		  		{
			  	    TextDrawSetString(PlayerSpecInfo[i][6], "~b~~h~WPS: ~w~Arena");
		  		}
			    SendClientMessage(i, COLOR_GREY, TXT_ARENA);
				SetSpawnInfo(i, Player[i][Team], GetPlayerSkinEx(i), eScenario[SpawnAttackers][0] - RANDOM_SPAWN_ROUND + random(RANDOM_SPAWN_ROUND), eScenario[SpawnAttackers][1] - RANDOM_SPAWN_ROUND + random(RANDOM_SPAWN_ROUND), eScenario[SpawnAttackers][2], 0.0, 0, 0, 0, 0, 0, 0);
				SetPlayerMapIcon(i, MAPICON_ATTACKERSPAWN, eScenario[SpawnAttackers][0], eScenario[SpawnAttackers][1], eScenario[SpawnAttackers][2], ATTACKERSMAP_ICON, 0, MAPICON_TYPE_ATTSPAWN);
			}
			else if(Gaming == GAMETYPE_TDM)
			{
				if (Player[i][Team] == TEAM_A)
  				{
  					TextDrawSetString(PlayerSpecInfo[i][6], "~r~~h~WPS: ~w~TDM");
	  			}
		  		else
		  		{
			  	    TextDrawSetString(PlayerSpecInfo[i][6], "~b~~h~WPS: ~w~TDM");
		  		}

				stringo = "";
				strcat(stringo, TXT_TDM_P1" ");
				strcat(stringo, numstr(gConfig[TDMKills]));
				strcat(stringo, TXT_TDM_P2);

			    SendClientMessage(i, COLOR_GREY, stringo);
				SetSpawnInfo(i, Player[i][Team], GetPlayerSkinEx(i), eScenario[SpawnAttackers][0] - RANDOM_SPAWN_ROUND + random(RANDOM_SPAWN_ROUND), eScenario[SpawnAttackers][1] - RANDOM_SPAWN_ROUND + random(RANDOM_SPAWN_ROUND), eScenario[SpawnAttackers][2], 0.0, 0, 0, 0, 0, 0, 0);
				SetPlayerMapIcon(i, MAPICON_ATTACKERSPAWN, eScenario[SpawnAttackers][0], eScenario[SpawnAttackers][1], eScenario[SpawnAttackers][2], ATTACKERSMAP_ICON, 0, MAPICON_TYPE_ATTSPAWN);
			}
			else if(Gaming == GAMETYPE_GUNGAME)
			{
				if (Player[i][Team] == TEAM_A)
  				{
  					TextDrawSetString(PlayerSpecInfo[i][6], "~r~~h~WPS: ~w~Gungame");
	  			}
		  		else
		  		{
			  	    TextDrawSetString(PlayerSpecInfo[i][6], "~b~~h~WPS: ~w~Gungame");
		  		}
			    SendClientMessage(i, COLOR_GREY, TXT_GUNGAME);
				SetSpawnInfo(i, i, GetPlayerSkinEx(i), Scenario_MultipleSpawns[i][0], Scenario_MultipleSpawns[i][1], Scenario_MultipleSpawns[i][2], Scenario_MultipleSpawns[i][3], 0, 0, 0, 0, 0, 0);
			}
			else if(Gaming == GAMETYPE_FIGHT)
			{
				if (Player[i][Team] == TEAM_A)
  				{
  					TextDrawSetString(PlayerSpecInfo[i][6], "~r~~h~WPS: ~w~Fight");
	  			}
		  		else
		  		{
			  	    TextDrawSetString(PlayerSpecInfo[i][6], "~b~~h~WPS: ~w~Fight");
		  		}
			    SendClientMessage(i, COLOR_GREY, TXT_FIGHT);

				if (RoundFightType == FIGHTSIZE_ALLVSALL)
			    {
			        SetSpawnInfo(i, i, GetPlayerSkinEx(i), fFights_Spawns[id][i][0], fFights_Spawns[id][i][1], fFights_Spawns[id][i][2], 0.0, 0, 0, 0, 0, 0, 0);
			    }
			    else // 1 - 1
			    {
					Iter_Add(ovoPlayers, i);
			    }

//				SetSpawnInfo(i, i, GetPlayerSkinEx(i), Scenario_MultipleSpawns[i][0], Scenario_MultipleSpawns[i][1], Scenario_MultipleSpawns[i][2], Scenario_MultipleSpawns[i][3], 0, 0, 0, 0, 0, 0);
			}
			else if(Gaming == GAMETYPE_FALLOUT)
			{
				if (Player[i][Team] == TEAM_A)
  				{
  					TextDrawSetString(PlayerSpecInfo[i][6], "_");
	  			}
		  		else
		  		{
			  	    TextDrawSetString(PlayerSpecInfo[i][6], "_");
		  		}

			    SendClientMessage(i, COLOR_GREY, TXT_FALLOUT);
				SetSpawnInfo(i, i, GetPlayerSkinEx(i), 2482.1921 - random(39), -1660.4783 + random(47), 161.0000, random(360), 0, 0, 0, 0, 0, 0);
			}
			else if(Gaming == GAMETYPE_LASTBULLET)
			{
				if (Player[i][Team] == TEAM_A)
  				{
  					TextDrawSetString(PlayerSpecInfo[i][6], "~b~~h~WPS: ~w~Deagle");
	  			}
		  		else
		  		{
			  	    TextDrawSetString(PlayerSpecInfo[i][6], "~b~~h~WPS: ~w~Deagle");
		  		}

			    SendClientMessage(i, COLOR_GREY, TXT_LASTBULLET);
				SetSpawnInfo(i, i, GetPlayerSkinEx(i), lBullet_Spawns[id][i][0], lBullet_Spawns[id][i][1], lBullet_Spawns[id][i][2], random(360), 0, 0, 0, 0, 0, 0);

				LifesLeft = CreatePlayerTextDraw(i, 578.000000, 57.000000, "_");
				PlayerTextDrawAlignment(i, LifesLeft, 2);
				PlayerTextDrawBackgroundColor(i, LifesLeft, 51);
				PlayerTextDrawFont(i, LifesLeft, 2);
				PlayerTextDrawLetterSize(i, LifesLeft, 0.210000, 1.100000);
				PlayerTextDrawColor(i, LifesLeft, -1);
				PlayerTextDrawSetOutline(i, LifesLeft, 1);
				PlayerTextDrawSetProportional(i, LifesLeft, 1);
			}
		}
		else
		{
		    if(Gaming == GAMETYPE_BASE)
			{
		        if( !Interior_Base )
				{
			    	SendClientMessage(i, COLOR_GREY, TXT_BASE_DEF);
				}
				else
				{
				    SendClientMessage(i, COLOR_GREY, TXT_INT);
				}
				if (Player[i][Team] == TEAM_A)
  				{
  					TextDrawSetString(PlayerSpecInfo[i][6], "~r~~h~WPS: ~w~-");
	  			}
		  		else
		  		{
			  	    TextDrawSetString(PlayerSpecInfo[i][6], "~b~~h~WPS: ~w~-");
		  		}
				SetSpawnInfo(i, Player[i][Team], GetPlayerSkinEx(i), eScenario[SpawnDefenders][0] - RANDOM_SPAWN_ROUND + random(RANDOM_SPAWN_ROUND), eScenario[SpawnDefenders][1] - RANDOM_SPAWN_ROUND + random(RANDOM_SPAWN_ROUND), eScenario[SpawnDefenders][2], 0.0, 0, 0, 0, 0, 0, 0);
			}
			else if(Gaming == GAMETYPE_ARENA)
			{
				if (Player[i][Team] == TEAM_A)
  				{
  					TextDrawSetString(PlayerSpecInfo[i][6], "~r~~h~WPS: ~w~Arena");
	  			}
		  		else
		  		{
			  	    TextDrawSetString(PlayerSpecInfo[i][6], "~b~~h~WPS: ~w~Arena");
		  		}

			    SendClientMessage(i, COLOR_GREY, TXT_ARENA);
	    		SetSpawnInfo(i, Player[i][Team], GetPlayerSkinEx(i), eScenario[SpawnDefenders][0] - RANDOM_SPAWN_ROUND + random(RANDOM_SPAWN_ROUND), eScenario[SpawnDefenders][1] - RANDOM_SPAWN_ROUND + random(RANDOM_SPAWN_ROUND), eScenario[SpawnDefenders][2], 0.0, 0, 0, 0, 0, 0, 0);
			}
			else if(Gaming == GAMETYPE_TDM)
			{
				if (Player[i][Team] == TEAM_A)
  				{
  					TextDrawSetString(PlayerSpecInfo[i][6], "~r~~h~WPS: ~w~TDM");
	  			}
		  		else
		  		{
			  	    TextDrawSetString(PlayerSpecInfo[i][6], "~b~~h~WPS: ~w~TDM");
		  		}

				stringo = "";
				strcat(stringo, TXT_TDM_P1" ");
				strcat(stringo, numstr(gConfig[TDMKills]));
				strcat(stringo, TXT_TDM_P2);

			    SendClientMessage(i, COLOR_GREY, stringo);
				SetSpawnInfo(i, Player[i][Team], GetPlayerSkinEx(i), eScenario[SpawnDefenders][0] - RANDOM_SPAWN_ROUND + random(RANDOM_SPAWN_ROUND), eScenario[SpawnDefenders][1] - RANDOM_SPAWN_ROUND + random(RANDOM_SPAWN_ROUND), eScenario[SpawnDefenders][2], 0.0, 0, 0, 0, 0, 0, 0);
			}
			else if(Gaming == GAMETYPE_GUNGAME)
			{
				if (Player[i][Team] == TEAM_A)
  				{
  					TextDrawSetString(PlayerSpecInfo[i][6], "~r~~h~WPS: ~w~Gungame");
	  			}
		  		else
		  		{
			  	    TextDrawSetString(PlayerSpecInfo[i][6], "~b~~h~WPS: ~w~Gungame");
		  		}
			    SendClientMessage(i, COLOR_GREY, TXT_GUNGAME);
				SetSpawnInfo(i, i, GetPlayerSkinEx(i), Scenario_MultipleSpawns[i][0], Scenario_MultipleSpawns[i][1], Scenario_MultipleSpawns[i][2], Scenario_MultipleSpawns[i][3], 0, 0, 0, 0, 0, 0);
			}
			else if(Gaming == GAMETYPE_FIGHT)
			{
			    SendClientMessage(i, COLOR_GREY, TXT_FIGHT);
				if (Player[i][Team] == TEAM_A)
  				{
  					TextDrawSetString(PlayerSpecInfo[i][6], "~r~~h~WPS: ~w~Fight");
	  			}
		  		else
		  		{
			  	    TextDrawSetString(PlayerSpecInfo[i][6], "~b~~h~WPS: ~w~Fight");
		  		}

				if (RoundFightType == FIGHTSIZE_ALLVSALL)
			    {
			        SetSpawnInfo(i, i, GetPlayerSkinEx(i), fFights_Spawns[id][i][0], fFights_Spawns[id][i][1], fFights_Spawns[id][i][2], 0.0, 0, 0, 0, 0, 0, 0);
			    }
			    else // 1 - 1
			    {
					Iter_Add(ovoPlayers, i);
			    }

//				SetSpawnInfo(i, i, GetPlayerSkinEx(i), Scenario_MultipleSpawns[i][0], Scenario_MultipleSpawns[i][1], Scenario_MultipleSpawns[i][2], Scenario_MultipleSpawns[i][3], 0, 0, 0, 0, 0, 0);
			}
			else if(Gaming == GAMETYPE_FALLOUT)
			{
				if (Player[i][Team] == TEAM_A)
  				{
  					TextDrawSetString(PlayerSpecInfo[i][6], "_");
	  			}
		  		else
		  		{
			  	    TextDrawSetString(PlayerSpecInfo[i][6], "_");
		  		}

			    SendClientMessage(i, COLOR_GREY, TXT_FALLOUT);
				SetSpawnInfo(i, i, GetPlayerSkinEx(i), 2482.1921 - random(39), -1660.4783 + random(47), 161.0000, random(360), 0, 0, 0, 0, 0, 0);
			}
			else if(Gaming == GAMETYPE_LASTBULLET)
			{
				if (Player[i][Team] == TEAM_A)
  				{
  					TextDrawSetString(PlayerSpecInfo[i][6], "~b~~h~WPS: ~w~Deagle");
	  			}
		  		else
		  		{
			  	    TextDrawSetString(PlayerSpecInfo[i][6], "~b~~h~WPS: ~w~Deagle");
		  		}

			    SendClientMessage(i, COLOR_GREY, TXT_LASTBULLET);
				SetSpawnInfo(i, i, GetPlayerSkinEx(i), lBullet_Spawns[id][i][0], lBullet_Spawns[id][i][1], lBullet_Spawns[id][i][2], random(360), 0, 0, 0, 0, 0, 0);

				LifesLeft = CreatePlayerTextDraw(i, 578.000000, 57.000000, "_");
				PlayerTextDrawAlignment(i, LifesLeft, 2);
				PlayerTextDrawBackgroundColor(i, LifesLeft, 51);
				PlayerTextDrawFont(i, LifesLeft, 2);
				PlayerTextDrawLetterSize(i, LifesLeft, 0.210000, 1.100000);
				PlayerTextDrawColor(i, LifesLeft, -1);
				PlayerTextDrawSetOutline(i, LifesLeft, 1);
				PlayerTextDrawSetProportional(i, LifesLeft, 1);
			}
		}

		if( pteam == TEAM_A )
		{
		   	TextDrawSetString(PlayerSpecInfo[i][1], "~"#GT_TEAMA"~~h~Damage ~w~0");
		   	TextDrawSetString(PlayerSpecInfo[i][2], "~"#GT_TEAMA"~~h~Kills ~w~0");

	    	TextDrawSetString(PlayerSpecInfo[i][8], sprintf ("~b~~h~T.Dmg ~w~%d", Player[i][Damage]));
		    Team1_StartHP += gConfig[GameMode] == GAMEMODE_NOCBUG ? 100 : 200;
		}
		else if( pteam == TEAM_B )
		{
		   	TextDrawSetString(PlayerSpecInfo[i][1], "~"#GT_TEAMB"~~h~Damage ~w~0");
		   	TextDrawSetString(PlayerSpecInfo[i][2], "~"#GT_TEAMB"~~h~Kills ~w~0");

	    	TextDrawSetString(PlayerSpecInfo[i][8], sprintf ("~g~~h~T.Dmg ~w~%d", Player[i][Damage]));
			Team2_StartHP += gConfig[GameMode] == GAMEMODE_NOCBUG ? 100 : 200;
		}

		if( Player[i][InDm] != -1 )
		{
		    MySQLStatus[TotalQuerys] ++; mysql_tquery(g_MySQLConnection, sprintf("UPDATE bestdmplayer SET damage = '%d', kills = '%d' WHERE nickname = '%s' AND dmid = '%d'", Player[i][DDamage], Player[i][DKills], Player[i][Nickname], Player[i][InDm]), "", "");
		    Player[i][InDm] = -1;
		}

		if (gConfig[UseHealthBars])
		{
			SetPlayerScore(i, 0);
		}
		else
		{
		    SetPlayerScore(i, gConfig[GameMode] == GAMEMODE_NOCBUG ? 100 : 200);
		}

		TeamPlayers[pteam] ++;
		SetPlayerColor(i, iTeam[pteam][InGameColor]);
		SetPlayerVirtualWorld(i, GAME_WORLD);

		if( GamePaused )
		{
		    TogglePlayerControllable( i , false );
		  //  TextDrawShowForPlayer( i , RoundPaused);
		}

		if(Gaming == GAMETYPE_BASE)
		{
			DisablePlayerCheckpoint(i);
			if(!Interior_Base)
				SetPlayerCheckpointEx(i, eScenario[Checkpoint][0], eScenario[Checkpoint][1], eScenario[Checkpoint][2]+1.5, 2.0);
		}

		// all great things are simple, and many can be expressed in single words: freedom, justice, honor, duty, mercy, hope.

		TextDrawHideForPlayer(i, TeamPlayers_TD);

		GangZoneShowForPlayer(i, ZonaAttornoCP, GANGZONE_COLORAZIONE);

		TogglePlayerSpectating (i, 1);

        // SetPlayerSpecialAction(i, SPECIAL_ACTION_DANCE2);

        PlayerPlaySound(i, 1187, 0.0, 0.0, 0.0);

        TogglePlayerControllable(playerid, false);

        SetPlayerInterior(i, eScenario[Interior]);

		SetPlayerPos( i, eScenario[SpawnDefenders][0] - 50 + random(50), eScenario[SpawnDefenders][1] - 50 + random(50), eScenario[SpawnDefenders][2] - 300.0 );

		stop PlayerKillTimer[ i ];
		PlayerTextDrawHide( i , PlayerKillTD );
//		PlayerTextDrawHide( i , PlayerKillTD[ 1 ] );

		PlayerTextDrawHide(i, TD_Player_Damages[0][0]);
		PlayerTextDrawHide(i, TD_Player_Damages[0][1]);
		PlayerTextDrawHide(i, TD_Player_Damages[0][2]);
		PlayerTextDrawHide(i, TD_Player_Damages[0][3]);
		PlayerTextDrawHide(i, TD_Player_Damages[0][4]);

		PlayerTextDrawHide(i, TD_Player_Damages[1][0]);
		PlayerTextDrawHide(i, TD_Player_Damages[1][1]);
		PlayerTextDrawHide(i, TD_Player_Damages[1][2]);
		PlayerTextDrawHide(i, TD_Player_Damages[1][3]);
		PlayerTextDrawHide(i, TD_Player_Damages[1][4]);

	//	stop Player[ i ][ Hide_Textdraw0 ];
	//	stop Player[ i ][ Hide_Textdraw1 ];
		Player [i][TD0_ID][0] = INVALID_PLAYER_ID;
		Player [i][TD0_WEAP][0] = 0;
		Player [i][TD0_DMG][0] = 0;
		Player [i][TD0_HEALTH][0] = 0;

		if (Player [i][TD0_TIMER][0] != Timer:-1)
			stop Player [i][TD0_TIMER][0];

		Player [i][TD0_TIMER][0] = Timer:-1;
		Player [i][TD1_ID][0] = INVALID_PLAYER_ID;
		Player [i][TD1_WEAP][0] = 0;
		Player [i][TD1_DMG][0] = 0;
		Player [i][TD1_HEALTH][0] = 0;

		if (Player [i][TD1_TIMER][0] != Timer:-1)
			stop Player [i][TD1_TIMER][0];
		Player [i][TD1_TIMER][0] = Timer:-1;
		Player [i][TD0_ID][1] = INVALID_PLAYER_ID;
		Player [i][TD0_WEAP][1] = 0;
		Player [i][TD0_DMG][1] = 0;
		Player [i][TD0_HEALTH][1] = 0;

		if (Player [i][TD0_TIMER][1] != Timer:-1)
			stop Player [i][TD0_TIMER][1];
		Player [i][TD0_TIMER][1] = Timer:-1;
		Player [i][TD1_ID][1] = INVALID_PLAYER_ID;
		Player [i][TD1_WEAP][1] = 0;
		Player [i][TD1_DMG][1] = 0;
		Player [i][TD1_HEALTH][1] = 0;

		if (Player [i][TD1_TIMER][1] != Timer:-1)
			stop Player [i][TD1_TIMER][1];
		Player [i][TD1_TIMER][1] = Timer:-1;
		Player [i][TD0_ID][2] = INVALID_PLAYER_ID;
		Player [i][TD0_WEAP][2] = 0;
		Player [i][TD0_DMG][2] = 0;
		Player [i][TD0_HEALTH][2] = 0;

		if (Player [i][TD0_TIMER][2] != Timer:-1)
			stop Player [i][TD0_TIMER][2];
		Player [i][TD0_TIMER][2] = Timer:-1;
		Player [i][TD1_ID][2] = INVALID_PLAYER_ID;
		Player [i][TD1_WEAP][2] = 0;
		Player [i][TD1_DMG][2] = 0;
		Player [i][TD1_HEALTH][2] = 0;

		if (Player [i][TD1_TIMER][2] != Timer:-1)
			stop Player [i][TD1_TIMER][2];
		Player [i][TD1_TIMER][2] = Timer:-1;
		Player [i][TD0_ID][3] = INVALID_PLAYER_ID;
		Player [i][TD0_WEAP][3] = 0;
		Player [i][TD0_DMG][3] = 0;
		Player [i][TD0_HEALTH][3] = 0;

		if (Player [i][TD0_TIMER][3] != Timer:-1)
			stop Player [i][TD0_TIMER][3];
		Player [i][TD0_TIMER][3] = Timer:-1;
		Player [i][TD1_ID][3] = INVALID_PLAYER_ID;
		Player [i][TD1_WEAP][3] = 0;
		Player [i][TD1_DMG][3] = 0;
		Player [i][TD1_HEALTH][3] = 0;

		if (Player [i][TD1_TIMER][3] != Timer:-1)
			stop Player [i][TD1_TIMER][3];
		Player [i][TD1_TIMER][3] = Timer:-1;
		Player [i][TD0_ID][4] = INVALID_PLAYER_ID;
		Player [i][TD0_WEAP][4] = 0;
		Player [i][TD0_DMG][4] = 0;
		Player [i][TD0_HEALTH][4] = 0;

		if (Player [i][TD0_TIMER][4] != Timer:-1)
			stop Player [i][TD0_TIMER][4];
		Player [i][TD0_TIMER][4] = Timer:-1;
		Player [i][TD1_ID][4] = INVALID_PLAYER_ID;
		Player [i][TD1_WEAP][4] = 0;
		Player [i][TD1_DMG][4] = 0;
		Player [i][TD1_HEALTH][4] = 0;

		if (Player [i][TD1_TIMER][4] != Timer:-1)
			stop Player [i][TD1_TIMER][4];
		Player [i][TD1_TIMER][4] = Timer:-1;

		PlayerTextDrawHide(i, PlayerInfo[0]);
		PlayerTextDrawHide(i, PlayerInfo[1]);
		PlayerTextDrawHide(i, PlayerInfo[2]);

		TextDrawHideForPlayer(i, GeneralTD[0]);
		TextDrawHideForPlayer(i, GeneralTD[1]);

		PlayerTextDrawSetString (i, PlayerInfo[1], sprintf ("DMG ~b~~h~0~n~~w~Tot. DMG ~b~~h~%d", Player[i][Damage]));

		PlayerLifesLeft[i] = 3;

		TextDrawShowForPlayer(i, RoundStart_TD1);
		TextDrawShowForPlayer(i, RoundStart_TD2);
		TextDrawShowForPlayer(i, RoundStart_TD3);

		SetPlayerCameraPos(i, floatadd(eScenario[Checkpoint][0], floatmul(60, floatsin(-30.0, degrees))), floatadd(eScenario[Checkpoint][1], floatmul(60, floatcos(-30.0, degrees))), eScenario[Checkpoint][2] + 20);
		SetPlayerCameraLookAt(i, eScenario[Checkpoint][0], eScenario[Checkpoint][1], eScenario[Checkpoint][2]);
	}

	//TextDrawShowForAll(RoundStats[0]);
	TextDrawShowForAll(RoundStats[1]);
	TextDrawShowForAll(RoundStats[2]);
	TextDrawShowForAll(RoundStats[3]);

	Start_X = eScenario[Checkpoint][0];
	Start_Y = eScenario[Checkpoint][1];
	Start_Z = eScenario[Checkpoint][2];

	RefreshTeamPlayers_TD();
	ScaloSecondiStart();

	CamMoving_Round = repeat CamStartUpdate();
	SyncTextdraw(1);

	SendClientMessageToAll(-1, "");
	SendClientMessageToAll(-1, "");
	SendClientMessageToAll(-1, "");
	SendClientMessageToAll(-1, "");
	SendClientMessageToAll(-1, "");
	SendClientMessageToAll(-1, "");
	SendClientMessageToAll(-1, "");
	SendClientMessageToAll(-1, "");
	SendClientMessageToAll(-1, "");
	SendClientMessageToAll(-1, "");
	SendClientMessageToAll(-1, "");
	SendClientMessageToAll(-1, "");
	SendClientMessageToAll(-1, "");

	TextDrawSetString(RoundStats[1], "_");
	TextDrawSetString(RoundStats[2], "_");
	TextDrawSetString(RoundStats[3], "_");

	// a variabile named "blockChat" can be better
	FinalCW = true;
	return true;
}

stock CleanSpecTDs(playerid)
{
	if( Player[playerid][Team] == TEAM_A )
	{
	   	TextDrawSetString(PlayerSpecInfo[playerid][1], sprintf ("~"#GT_TEAMA"~~h~Damage ~w~%d", Player[playerid][RDamage]));
	   	TextDrawSetString(PlayerSpecInfo[playerid][2], sprintf ("~"#GT_TEAMA"~~h~Kills ~w~%d", Player[playerid][RKills]));

    	TextDrawSetString(PlayerSpecInfo[playerid][8], sprintf ("~"#GT_TEAMA"~~h~T.Dmg ~w~%d", Player[playerid][Damage]));
	}
	else if( Player[playerid][Team] == TEAM_B )
	{
	   	TextDrawSetString(PlayerSpecInfo[playerid][1], sprintf ("~"#GT_TEAMB"~~h~Damage ~w~%d", Player[playerid][RDamage]));
	   	TextDrawSetString(PlayerSpecInfo[playerid][2], sprintf ("~"#GT_TEAMB"~~h~Kills ~w~%d", Player[playerid][RKills]));

    	TextDrawSetString(PlayerSpecInfo[playerid][8], sprintf ("~"#GT_TEAMB"~~h~T.Dmg ~w~%d", Player[playerid][Damage]));
	}
}

//forward CamStartUpdate();
timer CamStartUpdate[50]()
{
	new
	    Float: Xc, Float:Yc;

	foreach(new i:Player)
	{
	    if(!Player[i][InGame]) continue;

		Xc = floatadd(Start_X, floatmul(50+10, floatsin(-Player[i][AngoloFinal], degrees)));
		Yc = floatadd(Start_Y, floatmul(50+10, floatcos(-Player[i][AngoloFinal], degrees)));

		SetPlayerCameraPos(i, Xc, Yc, Start_Z+10);
		SetPlayerCameraLookAt(i, Start_X, Start_Y, floatadd(Start_Z, 1.0));

		Player[i][AngoloFinal] += 0.5;
		if(Player[i][AngoloFinal] >= 360.0)
			Player[i][AngoloFinal] = 0.0;
	}
}

//forward ScaloSecondiStart();
timer ScaloSecondiStart[1000]()
{
	switch (SecondiStart)
	{
	    case MAX_SECONDI_START: // Primo secondo (?) inizializzo un paio di cose
	    {
	    	TextDrawSetString(RoundStats[1], "_");
    		TextDrawSetString(RoundStats[2], "_");

	        foreach (new i:Player)
	        {
	            if (Player[i][InGame]) PlayerPlaySound(i, 1139, 0.0, 0.0, 0.0);
	        }

			TextDrawSetString(RoundStart_TD2, "The round will start in ~b~~h~"#MAX_SECONDI_START"~w~ seconds..");
		}
		#if MAX_SECONDI_START-1 == 4
	    case 4:
	    {
	        foreach (new i:Player)
	        {
	            if (Player[i][InGame]) PlayerPlaySound(i, 1139, 0.0, 0.0, 0.0);
	        }

			TextDrawSetString(RoundStart_TD2, "The round will start in ~b~~h~4~w~ seconds..");
	    }
		#else
	    case 4 .. MAX_SECONDI_START - 1:
	    {
	        foreach (new i:Player)
	        {
	            if (Player[i][InGame]) PlayerPlaySound(i, 1139, 0.0, 0.0, 0.0);
	        }

			TextDrawSetString(RoundStart_TD2, sprintf ("The round will start in ~b~~h~%d~w~ seconds..", SecondiStart));
	    }
	    #endif
	    /*case 6:
	    {
	    	TextDrawSetString(RoundStats[1], "_");
    		TextDrawSetString(RoundStats[2], "_");

	        foreach (new i:Player)
	        {
	            if (Player[i][InGame]) PlayerPlaySound(i, 1139, 0.0, 0.0, 0.0);
	        }

			TextDrawSetString(RoundStart_TD2, "~b~~h~The round will start in ~g~~h~6~b~~h~ seconds..");
			//TextDrawSetString(RoundStats[3], "~b~~h~Starting~w~..~g~~h~ 6");
	    }
	    case 5:
	    {
	        if (Gaming == GAMETYPE_BASE)
	        {
			    foreach(new i:Player)
			    {
			        if (Player[i][InGame])
			        {
		            	//MostraWeaponset(i);
		            	PlayerPlaySound(i, 1139, 0.0, 0.0, 0.0);
					}
				}
			}

			foreach (new i:Player)
	        {
	            if (Player[i][InGame]) PlayerPlaySound(i, 1139, 0.0, 0.0, 0.0);
	        }

	        TextDrawSetString(RoundStart_TD2, "~b~~h~The round will start in ~g~~h~5~b~~h~ seconds..");
			//TextDrawSetString(RoundStats[3], "~b~~h~Starting~w~..~g~~h~ 5");
	    }
	    case 4:
	    {
	        foreach (new i:Player)
	        {
	            if (Player[i][InGame]) PlayerPlaySound(i, 1139, 0.0, 0.0, 0.0);
	        }
	        TextDrawSetString(RoundStart_TD2, "~b~~h~The round will start in ~g~~h~4~b~~h~ seconds..");
			//TextDrawSetString(RoundStats[3], "~b~~h~Starting~w~..~g~~h~ 4");
		}*/
	    case 3:
	    {
	        foreach (new i:Player)
	        {
	            if (Player[i][InGame]) PlayerPlaySound(i, 7417, 0.0, 0.0, 0.0);
	        }
	        TextDrawSetString(RoundStart_TD2, "The round will start in ~b~~h~3~w~ seconds..");
			//TextDrawSetString(RoundStats[3], "~b~~h~Starting~w~..~g~~h~ 3");
	    }
	    case 2:
	    {
	        foreach (new i:Player)
	        {
	            if (Player[i][InGame]) PlayerPlaySound(i, 7418, 0.0, 0.0, 0.0);
	        }
	        TextDrawSetString(RoundStart_TD2, "The round will start in ~b~~h~2~w~ seconds..");
			//TextDrawSetString(RoundStats[3], "~b~~h~Starting~w~..~g~~h~ 2");
	    }
	    case 1:
	    {
	        foreach (new i:Player)
	        {
	            if (Player[i][InGame]) PlayerPlaySound(i, 7419, 0.0, 0.0, 0.0);
	        }
	        TextDrawSetString(RoundStart_TD2, "The round will start in ~b~~h~1~w~ seconds..");
			//TextDrawSetString(RoundStats[3], "~b~~h~Starting~w~..~g~~h~ 1");
 		}
 		case 0:
 		{
	        stop CamMoving_Round;
            FinalCW = false;
	        if (Gaming == GAMETYPE_FIGHT && RoundFightType == FIGHTSIZE_ONEVSONE)
	        {
	            if (Iter_Count(ovoPlayers) % 2 != 0)
	            {
					// CamMove = false;
	                // EndRound(NULL_TEAM);
					new id = 0;

			        do
			        {
			            id = random (MAX_FIGHTS);
			        } while (!fFights[id][fExists] || fFights[id][fSize] != FIGHTSIZE_ALLVSALL);

			        RoundFightType = FIGHTSIZE_ALLVSALL;

					eScenario[Interior] = fFights[id][fInterior];
					eScenario[Played]  	= fFights[id][fPlayed];

					eScenario[MinX] = fFights[id][fMinX];
					eScenario[MinY] = fFights[id][fMinY];

					eScenario[MaxX] = fFights[id][fMaxX];
					eScenario[MaxY] = fFights[id][fMaxY];

					eScenario[Checkpoint][0] = fFights_Spawns[id][0][0];
					eScenario[Checkpoint][1] = fFights_Spawns[id][0][1];
					eScenario[Checkpoint][2] = fFights_Spawns[id][0][2];

					fFights[id][fPlayed]++;

					strcpy_2(eScenario[BaseName], fFights[id][fName]);

					format( stringo , sizeof stringo , "mapname Fight: %d" , id );
					SendRconCommand(stringo);

					MySQLStatus[TotalQuerys] ++; mysql_tquery (g_MySQLConnection, sprintf("UPDATE fight SET played = played + 1 WHERE id = '%d'", fFights[id][fMySQLid]), "", "");

					RealRMins = 0;
					RealRSecs = 0;

					//ï¿½ï¿½ {"#COLOR_SYSTEM_FOCUS"}%s (%d){"#COLOR_SYSTEM_REST"} ï¿½ï¿½
			        //»» {"#COLOR_SYSTEM_FOCUS"}%s (%d){"#COLOR_SYSTEM_REST"} ««
	                format(stringo, sizeof stringo, "»» {"#COLOR_SYSTEM_FOCUS"}Fight (%d){"#COLOR_SYSTEM_REST"} ««", id);
					SendClientMessageToAll(COLOR_SYSTEM, stringo);

					SendClientMessageToAll(COLOR_SYSTEM, "All vs all fight was started instead of 1v1 one because the number of players was odd");

					//
					// stesso codice di sotto
					// da modificare insieme a quello

					foreach(new i:Player)
					{
						if(!Player[i][InGame]) continue;
						PlayerPlaySound(i, 1098, 0.0, 0.0, 0.0);
						SetCameraBehindPlayer(i);
			        	SetSpawnInfo(i, i, GetPlayerSkinEx(i), fFights_Spawns[eScenario[FileID]][i][0], fFights_Spawns[eScenario[FileID]][i][1], fFights_Spawns[eScenario[FileID]][i][2], 0.0, 0, 0, 0, 0, 0, 0);
						//SpawnPlayer(i);
						TogglePlayerSpectating(i, 0);
						//SetPlayerSpecialAction(i, 0);
						PlayerPlaySound(i, 3200, 0.0, 0.0, 0.0);
						if (AntiHits)
						{
	//					TextDrawShowForPlayer(i, TD_NotHits);
							TextDrawShowForPlayer(i, TD_NoHitsScritta);
						}
						PlayerTextDrawShow(i, PlayerInfo[0]);
						PlayerTextDrawShow(i, PlayerInfo[1]);
						PlayerTextDrawShow(i, PlayerInfo[2]);
						TextDrawShowForPlayer(i, GeneralTD[0]);
						TextDrawShowForPlayer(i, GeneralTD[1]);
					}
	            }
				else
				{
				// ovoPlayers
					new id = eScenario[FileID];

					while (Iter_Count(ovoPlayers) > 0)
					{
						new p1 = Iter_Random (ovoPlayers);

						while (!IsPlayerConnected(p1))
						{
							p1 = Iter_Random (ovoPlayers);
						}

	//					already_added [p1] = true;

						Iter_Remove (ovoPlayers, p1);

						new p2 = Iter_Random (ovoPlayers);

						while (!IsPlayerConnected(p2))
						{
							p2 = Iter_Random (ovoPlayers);
						}

	//					already_added [p2] = true;

						Iter_Remove (ovoPlayers, p2);

						SetPlayerVirtualWorld (p1, MIN_GM_WORLD + p1);
						SetPlayerVirtualWorld (p2, MIN_GM_WORLD + p1);

						PlayerPlaySound(p1, 1098, 0.0, 0.0, 0.0);
						PlayerPlaySound(p2, 1098, 0.0, 0.0, 0.0);

						SetSpawnInfo(p1, NO_TEAM, GetPlayerSkinEx(p1), fFights_Spawns[id][0][0], fFights_Spawns[id][0][1], fFights_Spawns[id][0][2], 0.0, 0, 0, 0, 0, 0, 0);
						SpawnPlayer(p1);

						SetSpawnInfo(p2, NO_TEAM, GetPlayerSkinEx(p2), fFights_Spawns[id][1][0], fFights_Spawns[id][1][1], fFights_Spawns[id][1][2], 0.0, 0, 0, 0, 0, 0, 0);
						SpawnPlayer(p2);

						ShowPlayerNameTagForPlayer(p1, p2, true);
						ShowPlayerNameTagForPlayer(p2, p1, true);

						PlayerPlaySound(p1, 3200, 0.0, 0.0, 0.0);
						SetCameraBehindPlayer(p1);
						PlayerTextDrawShow(p1, PlayerInfo[0]);
						PlayerTextDrawShow(p1, PlayerInfo[1]);
						PlayerTextDrawShow(p1, PlayerInfo[2]);
						TextDrawShowForPlayer(p1, GeneralTD[0]);
						TextDrawShowForPlayer(p1, GeneralTD[1]);
						SetCameraBehindPlayer(p1);
						TogglePlayerSpectating(p1, 0);

						PlayerPlaySound(p2, 3200, 0.0, 0.0, 0.0);
						SetCameraBehindPlayer(p2);
						PlayerTextDrawShow(p2, PlayerInfo[0]);
						PlayerTextDrawShow(p2, PlayerInfo[1]);
						PlayerTextDrawShow(p2, PlayerInfo[2]);
						TextDrawShowForPlayer(p2, GeneralTD[0]);
						TextDrawShowForPlayer(p2, GeneralTD[1]);
						SetCameraBehindPlayer(p2);
						TogglePlayerSpectating(p2, 0);

						Iter_Add (ovoInGame, p1);
						Iter_Add (ovoInGame, p2);

						PlayerAvversario [p1] = p2;
						PlayerAvversario [p2] = p1;
					}
				}
	        }
	        else
	        {
				foreach(new i:Player)
				{
					if(!Player[i][InGame]) continue;

					PlayerPlaySound(i, 1098, 0.0, 0.0, 0.0);
			        SetCameraBehindPlayer(i);
			        //SpawnPlayer(i);
			        TogglePlayerSpectating(i, 0);
			        //SetPlayerSpecialAction(i, 0);
			        PlayerPlaySound(i, 3200, 0.0, 0.0, 0.0);

			        if (AntiHits)
			        {
		//		  		TextDrawShowForPlayer(i, TD_NotHits);
				  		TextDrawShowForPlayer(i, TD_NoHitsScritta);
					}

					if (Gaming == GAMETYPE_LASTBULLET)
					{
						PlayerTextDrawSetString (i, LifesLeft, "3 lives left");
					}
					else if (Gaming == GAMETYPE_BASE) {
					    MostraWeaponset(i);
					}

			  		PlayerTextDrawShow(i, PlayerInfo[0]);
			  		PlayerTextDrawShow(i, PlayerInfo[1]);
			  		PlayerTextDrawShow(i, PlayerInfo[2]);

					TextDrawShowForPlayer(i, GeneralTD[0]);
					TextDrawShowForPlayer(i, GeneralTD[1]);
				}
			}

			defer SyncRound();

			//if (Gaming != GAMETYPE_GUNGAME && Gaming != GAMETYPE_FIGHT && Gaming != GAMETYPE_FALLOUT && Gaming != GAMETYPE_LASTBULLET)
			//    SetTimer("NameTagsUpdate", 1400, false);

            TextDrawShowForAll(RoundStats[0]);

		    CamMove = false;
		    RefreshIcons();

			SyncTextdraw(1);
			FixHealthBars();

			defer NameTagDrawDistance();

			if (Gaming == GAMETYPE_BASE)
  				TextDrawSetString( RoundStats[3] , sprintf( "%02d:%02d", RealRMins, RealRSecs ));
			else if (Gaming == GAMETYPE_ARENA || Gaming == GAMETYPE_TDM || Gaming == GAMETYPE_GUNGAME || Gaming == GAMETYPE_FIGHT || Gaming == GAMETYPE_FALLOUT || Gaming == GAMETYPE_LASTBULLET)
   				TextDrawSetString( RoundStats[3] , "00:00");

            TextDrawHideForAll(RoundStart_TD1);
			TextDrawHideForAll(RoundStart_TD2);
			TextDrawHideForAll(RoundStart_TD3);

			SendClientMessageToAll(COLOR_SYSTEM, buffer1);
            SendClientMessageToAll(COLOR_SYSTEM, buffer2);

			if (Round_PVPMode)
			{
		        SendClientMessageToAll(COLOR_SYSTEM, buffer3);
			}
			else if (Gaming == GAMETYPE_FIGHT)
			{
		        SendClientMessageToAll(COLOR_SYSTEM, buffer3);
			}

	        return true;
 		}
	}

	SecondiStart --;
	defer ScaloSecondiStart();
	//SetTimer("ScaloSecondiStart", 990, 0);
	return false;
//	SyncTextdraw(2); <-
// format(stringo, sizeof stringo, "~g~Round ~h~starting... ~h~%d" , SecondiStart );
}

/*
string = dini_Get(Arenafile(i),"Zmax");
ArenaZones[i][0] = floatstr(strtok(string,idx,','));
ArenaZones[i][1] = floatstr(strtok(string,idx,','));

string = dini_Get(Arenafile(i),"Zmin");
ArenaZones[i][2] = floatstr(strtok(string,idx,','));
ArenaZones[i][3] = floatstr(strtok(string,idx,','));

GangZoneCreate
(
	minx = ArenaZones[Current][2],
	miny = ArenaZones[Current][3],
	maxx = ArenaZones[Current][0],
	maxy = ArenaZones[Current][1]
);


minx	The X coordinate for the west side of the gangzone.
miny	The Y coordinate for the south side of the gangzone.
maxx	The X coordinate for the east side of the gangzone.
maxy	The Y coordinate for the north side of the gangzone.
*/
#define VALORE_SENTINELLA           200
stock EndRound(winner = NULL_TEAM, wintype = WINTYPE_ELIMINAZIONE)
{//http://sphotos-b.ak.fbcdn.net/hphotos-ak-snc7/s480x480/293630_445920995461977_206056201_n.jpg
	if (!RoundStarted) return false;

    RoundStarted = false;
    switch (gConfig[GameMode])
    {
        case GAMEMODE_ESL: SetGameModeText(#GAMEMODE_NAME" ESL");
        case GAMEMODE_NOCBUG: SetGameModeText(#GAMEMODE_NAME" NoCBug");
        case GAMEMODE_NORMAL: SetGameModeText(#GAMEMODE_NAME);
	}

	new
		in_checkpoint [ 128 ] = " ",
		process_finaltd = 0,

		td_teama_names[ (MAX_PLAYER_NAME * 19) + 6 ] = "",
		td_teamb_names[ (MAX_PLAYER_NAME * 19) + 6 ] = "",

		td_teama_kills[ 70 ] = "",
		td_teama_dmg  [ 70 ] = "",

		td_teamb_kills[ 70 ] = "",
		td_teamb_dmg  [ 70 ] = "",

		total_kills_teama = 0 ,
		total_dmg_teama = 0 ,

		total_kills_teamb = 0,
		total_dmg_teamb = 0;

	new
	    mScore1,
	    mScorer1 = INVALID_PLAYER_ID,

	    mScore2,
	    mScorer2 = INVALID_PLAYER_ID,

	    mScore3,
	    mScorer3 = INVALID_PLAYER_ID,

//		pScore,

		p = 0,
		winners [128];

	new la[MAX_SAVE_SLOTS][E_BINTREE_INPUT], j  = 0;
	new lb[MAX_SAVE_SLOTS][E_BINTREE_INPUT], j2 = 0;

	new Float:thp, Float:a, Float:h;

	new
	    bool:tcwcw = false;

	if (gConfig[Matchmode] == MATCHMODE_TCWCW)
	{
	    tcwcw = true;
	}
	else
	{
	    tcwcw = false;
	}//webMatch[g_Connection]

	foreach(new i:Player)
	{
//	    TextDrawShowForPlayer(i, HintTD);
	    if( Player[i][Team] == NULL_TEAM ) continue;

		PlayerPlaySound(i, 1098, 0.0, 0.0, 0.0);
		SetCameraBehindPlayer(i);

//        PlayerYVote[i] = false;
        PlayerAvversario[i] = INVALID_PLAYER_ID;

	    if (Gaming == GAMETYPE_FALLOUT)
	    {
	        if (winner != INVALID_PLAYER_ID)
	        {
		        format (winners, sizeof winners, "%s%s, ", winners, Player[i][Nickname]);
		        if (p < 3)
		        {
	      			switch (p)
	         		{
	           			case 0:
	              		{
	                		mScorer1 = i;
	                  		mScore1  = 1;
	                	}
	                	case 1:
	                	{
	                 		mScorer2 = i;
	                   		mScore2  = 1;
	                	}
		                case 2:
		                {
	                 		mScorer3 = i;
	                   		mScore3  = 1;
		                }
	           		}// switch(p)
	           		p ++;
				} // if (p < 3)
			} // if (winner != INVALID_PLAYER_ID)
		}

	    if (Player[ i ][Team] == TEAM_A)
	    {
			if (Gaming != GAMETYPE_FIGHT && Gaming != GAMETYPE_GUNGAME)
			{
				la[j][E_BINTREE_INPUT_POINTER] = i;
				la[j][E_BINTREE_INPUT_VALUE]   = Player[i][RDamage];
		    }
			else
			{
				la[j][E_BINTREE_INPUT_POINTER] = i;
				la[j][E_BINTREE_INPUT_VALUE]   = Player[i][RKills];
			}

			j ++;

		    total_kills_teama 	+= Player[i][RKills];
		    total_dmg_teama 	+= Player[i][RDamage];
		}
		else if (Player[ i ][Team] == TEAM_B)
		{
			if (Gaming != GAMETYPE_FIGHT && Gaming != GAMETYPE_GUNGAME)
			{
				lb[j2][E_BINTREE_INPUT_POINTER] = i;
				lb[j2][E_BINTREE_INPUT_VALUE]   = Player[i][RDamage];
		    }
			else
			{
				lb[j2][E_BINTREE_INPUT_POINTER] = i;
				lb[j2][E_BINTREE_INPUT_VALUE]   = Player[i][RKills];
			}
 		    j2++;

		    total_kills_teamb 	+= Player[i][RKills];
		    total_dmg_teamb 	+= Player[i][RDamage];
		}

		if(TeamRole[Player[i][Team]]==ATTACKERS) RemovePlayerMapIcon(i, MAPICON_ATTACKERSPAWN);
		/*if(gConfig[GameMode] == GAMEMODE_ESL)
		{
			SendClientMessage(i, COLOR_SYSTEM, "Use ~k~~CONVERSATION_YES~ to set yourself as ready, ~k~~CONVERSATION_NO~ to remove the ready status.");
		}*/

	    if( Gaming != GAMETYPE_GUNGAME && Gaming != GAMETYPE_FIGHT )
		{
		    if( Player[ i ][Team] == winner && Player[ i ][ InGame ] )
			{
		        GetPlayerHealth( i , h );
		        GetPlayerArmour( i , a );

		        thp += ( h + a );
		    }
		}

		if(IsPlayerInCheckpoint(i) && TeamRole[Player[i][Team]] != DEFENDERS && wintype == WINTYPE_CHECKPOINT)
		{
		    //ha catturando il checkpoint
		    RGivePlayerScore(i, 10, "Checkpoint!");
		    format(in_checkpoint, sizeof in_checkpoint, "%s%s, ",in_checkpoint,Player[i][Nickname]);
		}

		if (Player[i][InGame])
		{
	 		if (Gaming == GAMETYPE_LASTBULLET)
			{
	  			PlayerTextDrawDestroy (i, LifesLeft);
   				PlayerLifesLeft [i] = 3;
			}

			if(IsPlayerInAnyVehicle(i))
			{
			    DestroyVehicleEx(GetPlayerVehicleID(i));
			}

			SetSpawnInfo(i, i, GetPlayerSkinEx(i), Lobby[0] - MAX_RANDOM_SPAWN + random( MAX_RANDOM_SPAWN ), Lobby[1] - MAX_RANDOM_SPAWN + random( MAX_RANDOM_SPAWN ), Lobby[2], Lobby[3], 0, 0, 0, 0, 0, 0);

			if (!CamMove)
			{
				SpawnPlayer(i);
			}
			else
			{
			    TogglePlayerSpectating(i, 0);
			}
		}
		else // if (Player[i][InGame])
		{
			// il player non stava giocando
			// quindi controllo

			if(InSpec[i] != -1)
			{   // il player ï¿½ in spec, inutile controllare players che lo spectano
	            Spec_RemovePlayerFromSpec(i);
			}
			else
			{
			    // i players nel dm non possono spectare
			    // quindi controllo se il player ï¿½ fuori dal dm setto world e colore
			    // altrimenti faccio rimanere tutto com'ï¿½

			    if (Player[i][InDm] == -1)
			    {
					SetPlayerVirtualWorld(i, NORMAL_WORLD);
					SetPlayerColor(i, iTeam[Player[i][Team]][OutColor]);

					// ora cerco chi lo stava spectando
					foreach(new x:Player)
					{
					    //
					    if (InSpec[x] == i)
					    {
					        // ï¿½ in spec, setto una nuova posizione di spawn in modo da randomizzare anche questa
							SetSpawnInfo(i, i, GetPlayerSkinEx(i), Lobby[0] - MAX_RANDOM_SPAWN + random( MAX_RANDOM_SPAWN ), Lobby[1] - MAX_RANDOM_SPAWN + random( MAX_RANDOM_SPAWN ), Lobby[2], Lobby[3], 0, 0, 0, 0, 0, 0);
					        Spec_RemovePlayerFromSpec( i , .pos = false );
					    }

					    ShowPlayerNameTagForPlayer(i, x, true);
					}
				}
			}
		}// altrimenti no stava in game

	    DisablePlayerCheckpoint(i);
		Player[i][InGame] = 0;

		PlayerReady[i] = false;

		SetPlayerTeam(i, NO_TEAM);

		if (tcwcw)
		{
			Player[i][Kills]  += Player[i][RKills];
			Player[i][Deaths] += Player[i][RDeaths];
			Player[i][Damage] += Player[i][RDamage];

   			SetPlayerScore(i, Player[i][Damage]);

   			// send info to server
//   			if (winner != NULL_TEAM)
//   			{
//				mysql_function_query(webMatch[g_Connection], sprintf("INSERT INTO playerstats (tcwid, round, teamplayer, name, kills, deaths, damage) VALUES ('%d', '%d', '%d', '%s', '%d', '%d', '%d')", webMatch[MatchID], PlayingRound+1, Player[i][Team], Player[i][Nickname], Player[i][RKills], Player[i][RDeaths], Player[i][RDamage]), false, "", "");
//			}
		}
		else
		{
		    SetPlayerScore(i, Player[i][PlayerTotalPoints]);
		}

//		TextDrawHideForPlayer( i , RoundPaused );

		//TextDrawHideForPlayer(i, TD_NotHits);
		TextDrawHideForPlayer(i, TD_NoHitsScritta);

  		// forzo l'hide del td damage e del td kill se c'ï¿½

		stop PlayerKillTimer[ i ];
		PlayerTextDrawHide( i , PlayerKillTD );
//		PlayerTextDrawHide( i , PlayerKillTD[ 1 ] );

	//	stop Player[ i ][ Hide_Textdraw0 ] ;
	//	stop Player[ i ][ Hide_Textdraw1 ] ;

/*
		Player[ i ][ HitID ][0]  	= INVALID_PLAYER_ID ;
		Player[ i ][ Amount ][0]     = 0 ;

		Player[ i ][ tHitID ][0]		= INVALID_PLAYER_ID ;
		Player[ i ][ tAmount ][0]    = 0 ;

		Player[ i ][ HitID ][1]  	= INVALID_PLAYER_ID ;
		Player[ i ][ Amount ][1]     = 0 ;

		Player[ i ][ tHitID ][1]		= INVALID_PLAYER_ID ;
		Player[ i ][ tAmount ][1]    = 0 ;

		Player[ i ][ HitID ][2]  	= INVALID_PLAYER_ID ;
		Player[ i ][ Amount ][2]     = 0 ;

		Player[ i ][ tHitID ][2]		= INVALID_PLAYER_ID ;
		Player[ i ][ tAmount ][2]    = 0 ;

		Player[ i ][ HitID ][3]  	= INVALID_PLAYER_ID ;
		Player[ i ][ Amount ][3]     = 0 ;

		Player[ i ][ tHitID ][3]		= INVALID_PLAYER_ID ;
		Player[ i ][ tAmount ][3]    = 0 ;

		Player[ i ][ HitID ][4]  	= INVALID_PLAYER_ID ;
		Player[ i ][ Amount ][4]     = 0 ;

		Player[ i ][ tHitID ][4]		= INVALID_PLAYER_ID ;
		Player[ i ][ tAmount ][4]    = 0 ;
*/
		PlayerTextDrawHide(i, TD_Player_Damages[0][0]);
		PlayerTextDrawHide(i, TD_Player_Damages[0][1]);
		PlayerTextDrawHide(i, TD_Player_Damages[0][2]);
		PlayerTextDrawHide(i, TD_Player_Damages[0][3]);
		PlayerTextDrawHide(i, TD_Player_Damages[0][4]);

		PlayerTextDrawHide(i, TD_Player_Damages[1][0]);
		PlayerTextDrawHide(i, TD_Player_Damages[1][1]);
		PlayerTextDrawHide(i, TD_Player_Damages[1][2]);
		PlayerTextDrawHide(i, TD_Player_Damages[1][3]);
		PlayerTextDrawHide(i, TD_Player_Damages[1][4]);

		Player [i][TD0_ID][0] = INVALID_PLAYER_ID;
		Player [i][TD0_WEAP][0] = 0;
		Player [i][TD0_DMG][0] = 0;
		Player [i][TD0_HEALTH][0] = 0;

		if (Player [i][TD0_TIMER][0] != Timer:-1)
			stop Player [i][TD0_TIMER][0];
		Player [i][TD0_TIMER][0] = Timer:-1;
		Player [i][TD1_ID][0] = INVALID_PLAYER_ID;
		Player [i][TD1_WEAP][0] = 0;
		Player [i][TD1_DMG][0] = 0;
		Player [i][TD1_HEALTH][0] = 0;

		if (Player [i][TD1_TIMER][0] != Timer:-1)
			stop Player [i][TD1_TIMER][0];
		Player [i][TD1_TIMER][0] = Timer:-1;
		Player [i][TD0_ID][1] = INVALID_PLAYER_ID;
		Player [i][TD0_WEAP][1] = 0;
		Player [i][TD0_DMG][1] = 0;
		Player [i][TD0_HEALTH][1] = 0;

		if (Player [i][TD0_TIMER][1] != Timer:-1)
			stop Player [i][TD0_TIMER][1];
		Player [i][TD0_TIMER][1] = Timer:-1;
		Player [i][TD1_ID][1] = INVALID_PLAYER_ID;
		Player [i][TD1_WEAP][1] = 0;
		Player [i][TD1_DMG][1] = 0;
		Player [i][TD1_HEALTH][1] = 0;

		if (Player [i][TD1_TIMER][1] != Timer:-1)
			stop Player [i][TD1_TIMER][1];
		Player [i][TD1_TIMER][1] = Timer:-1;
		Player [i][TD0_ID][2] = INVALID_PLAYER_ID;
		Player [i][TD0_WEAP][2] = 0;
		Player [i][TD0_DMG][2] = 0;
		Player [i][TD0_HEALTH][2] = 0;

		if (Player [i][TD0_TIMER][2] != Timer:-1)
			stop Player [i][TD0_TIMER][2];
		Player [i][TD0_TIMER][2] = Timer:-1;
		Player [i][TD1_ID][2] = INVALID_PLAYER_ID;
		Player [i][TD1_WEAP][2] = 0;
		Player [i][TD1_DMG][2] = 0;
		Player [i][TD1_HEALTH][2] = 0;

		if (Player [i][TD1_TIMER][2] != Timer:-1)
			stop Player [i][TD1_TIMER][2];
		Player [i][TD1_TIMER][2] = Timer:-1;
		Player [i][TD0_ID][3] = INVALID_PLAYER_ID;
		Player [i][TD0_WEAP][3] = 0;
		Player [i][TD0_DMG][3] = 0;
		Player [i][TD0_HEALTH][3] = 0;

		if (Player [i][TD0_TIMER][3] != Timer:-1)
			stop Player [i][TD0_TIMER][3];
		Player [i][TD0_TIMER][3] = Timer:-1;
		Player [i][TD1_ID][3] = INVALID_PLAYER_ID;
		Player [i][TD1_WEAP][3] = 0;
		Player [i][TD1_DMG][3] = 0;
		Player [i][TD1_HEALTH][3] = 0;

		if (Player [i][TD1_TIMER][3] != Timer:-1)
		stop Player [i][TD1_TIMER][3];
		Player [i][TD1_TIMER][3] = Timer:-1;
		Player [i][TD0_ID][4] = INVALID_PLAYER_ID;
		Player [i][TD0_WEAP][4] = 0;
		Player [i][TD0_DMG][4] = 0;
		Player [i][TD0_HEALTH][4] = 0;

		if (Player [i][TD0_TIMER][4] != Timer:-1)
			stop Player [i][TD0_TIMER][4];
		Player [i][TD0_TIMER][4] = Timer:-1;
		Player [i][TD1_ID][4] = INVALID_PLAYER_ID;
		Player [i][TD1_WEAP][4] = 0;
		Player [i][TD1_DMG][4] = 0;
		Player [i][TD1_HEALTH][4] = 0;

		if (Player [i][TD1_TIMER][4] != Timer:-1)
			stop Player [i][TD1_TIMER][4];
		Player [i][TD1_TIMER][4] = Timer:-1;

		Player[ i ][ fInWaiting ] = false;
	}

	/// oook, a bit sad
	/// but for now ..

	for (new i = 0; i < MAX_SAVE_SLOTS; ++i)
	{
	    if (SavedPlayer[i][sAssigned] && SavedPlayer[i][sPlayed])
		{
			if (SavedPlayer[i][sTeam] == TEAM_A)
			{
				if (Gaming != GAMETYPE_FIGHT && Gaming != GAMETYPE_GUNGAME)
				{
					la[j][E_BINTREE_INPUT_POINTER] = VALORE_SENTINELLA + i;
					la[j][E_BINTREE_INPUT_VALUE]   = SavedPlayer[i][sRDamage];
			    }
				else
				{
					la[j][E_BINTREE_INPUT_POINTER] = VALORE_SENTINELLA + i;
					la[j][E_BINTREE_INPUT_VALUE]   = SavedPlayer[i][sRKills];
				}

				j ++;

			    total_kills_teama 	+= SavedPlayer[i][sRKills];
			    total_dmg_teama 	+= SavedPlayer[i][sRDamage];
			}
			else if (SavedPlayer[i][sTeam] == TEAM_B)
			{
				if (Gaming != GAMETYPE_FIGHT && Gaming != GAMETYPE_GUNGAME)
				{
					lb[j2][E_BINTREE_INPUT_POINTER] = VALORE_SENTINELLA + i;
					lb[j2][E_BINTREE_INPUT_VALUE]   = SavedPlayer[i][sRDamage];
			    }
				else
				{
					lb[j2][E_BINTREE_INPUT_POINTER] = VALORE_SENTINELLA + i;
					lb[j2][E_BINTREE_INPUT_VALUE]   = SavedPlayer[i][sRKills];
				}

	 		    j2++;

			    total_kills_teamb 	+= SavedPlayer[i][sRKills];
			    total_dmg_teamb 	+= SavedPlayer[i][sRDamage];
			}

			SavedPlayer[i][sPlayed] = false;
			SavedPlayer[i][sRDamage] = 0;
			SavedPlayer[i][sRKills] = 0;
			SavedPlayer[i][sRDeaths] = 0;
	    }
	}

	Bintree_Sort(la, j);
	Bintree_Sort(lb, j2);

	if (Gaming != GAMETYPE_FALLOUT)
	{
	    /*
		new top[3*2][E_BINTREE_INPUT];

		if((j-1)>=0)
		{
			top[0][E_BINTREE_INPUT_POINTER] = la[j-1][E_BINTREE_INPUT_POINTER];
			top[0][E_BINTREE_INPUT_VALUE] = la[j-1][E_BINTREE_INPUT_VALUE];
		}
		else
		{
			top[0][E_BINTREE_INPUT_POINTER] = INVALID_PLAYER_ID;
			top[0][E_BINTREE_INPUT_VALUE] = 0;
		}
		
		if ((j-2)>=0){
			top[1][E_BINTREE_INPUT_POINTER] = la[j-2][E_BINTREE_INPUT_POINTER];
			top[1][E_BINTREE_INPUT_VALUE] = la[j-2][E_BINTREE_INPUT_VALUE];
		}
		else
		{
			top[1][E_BINTREE_INPUT_POINTER] = INVALID_PLAYER_ID;
			top[1][E_BINTREE_INPUT_VALUE] = 0;
		}

		if ((j-3)>=0) {
			top[2][E_BINTREE_INPUT_POINTER] = la[j-3][E_BINTREE_INPUT_POINTER];
			top[2][E_BINTREE_INPUT_VALUE] = la[j-3][E_BINTREE_INPUT_VALUE];
		}
		else
		{
			top[2][E_BINTREE_INPUT_POINTER] = INVALID_PLAYER_ID;
			top[2][E_BINTREE_INPUT_VALUE] = 0;
		}

		if((j2-1)>=0)
		{
			top[3][E_BINTREE_INPUT_POINTER] = lb[j2-1][E_BINTREE_INPUT_POINTER];
			top[3][E_BINTREE_INPUT_VALUE] = lb[j2-1][E_BINTREE_INPUT_VALUE];
		}
		else
		{
			top[3][E_BINTREE_INPUT_POINTER] = INVALID_PLAYER_ID;
			top[3][E_BINTREE_INPUT_VALUE] = 0;
		}
		
		if ((j2-2)>=0)
		{
			top[4][E_BINTREE_INPUT_POINTER] = lb[j2-2][E_BINTREE_INPUT_POINTER];
			top[4][E_BINTREE_INPUT_VALUE] = lb[j2-2][E_BINTREE_INPUT_VALUE];
		}
		else
		{
			top[4][E_BINTREE_INPUT_POINTER] = INVALID_PLAYER_ID;
			top[4][E_BINTREE_INPUT_VALUE] = 0;
		}

		if ((j2-3)>=0)
		{
			top[5][E_BINTREE_INPUT_POINTER] = lb[j2-3][E_BINTREE_INPUT_POINTER];
			top[5][E_BINTREE_INPUT_VALUE] = lb[j2-3][E_BINTREE_INPUT_VALUE];
		}
		else
		{
			top[5][E_BINTREE_INPUT_POINTER] = INVALID_PLAYER_ID;
			top[5][E_BINTREE_INPUT_VALUE] = 0;
		}

		format(stringo, sizeof stringo, "0 = %d (%d) | 1 = %d (%d) | 2 = %d (%d)",
			top[0][E_BINTREE_INPUT_POINTER], top[0][E_BINTREE_INPUT_VALUE],
			top[1][E_BINTREE_INPUT_POINTER], top[1][E_BINTREE_INPUT_VALUE],
			top[2][E_BINTREE_INPUT_POINTER], top[2][E_BINTREE_INPUT_VALUE]);
		SendClientMessageToAll(-1, stringo);

		format(stringo, sizeof stringo, "3 = %d (%d) | 4 = %d (%d) | 5 = %d (%d)",
			top[3][E_BINTREE_INPUT_POINTER], top[3][E_BINTREE_INPUT_VALUE],
			top[4][E_BINTREE_INPUT_POINTER], top[4][E_BINTREE_INPUT_VALUE],
			top[5][E_BINTREE_INPUT_POINTER], top[5][E_BINTREE_INPUT_VALUE]);
		SendClientMessageToAll(-1, stringo);

		Bintree_Sort(top, 6);

		mScorer1 = top[5][E_BINTREE_INPUT_POINTER];
		mScore1 = top[5][E_BINTREE_INPUT_VALUE];

		format(stringo, sizeof stringo, "top[5]=%d,%d - mScorer1=%d - mScore1=%d",
			top[5][E_BINTREE_INPUT_POINTER], top[5][E_BINTREE_INPUT_VALUE],
			mScorer1, mScore1);
		SendClientMessageToAll(-1, stringo);
		
		mScorer2 = top[4][E_BINTREE_INPUT_POINTER];
		mScore2 = top[4][E_BINTREE_INPUT_VALUE];

		format(stringo, sizeof stringo, "top[4]=%d,%d - mScorer2=%d - mScore2=%d",
			top[4][E_BINTREE_INPUT_POINTER], top[4][E_BINTREE_INPUT_VALUE],
			mScorer2, mScore2);
		SendClientMessageToAll(-1, stringo);

		mScorer3 = top[3][E_BINTREE_INPUT_POINTER];
		mScore3 = top[3][E_BINTREE_INPUT_VALUE];

		format(stringo, sizeof stringo, "top[3]=%d,%d - mScorer3=%d - mScore3=%d",
			top[3][E_BINTREE_INPUT_POINTER], top[3][E_BINTREE_INPUT_VALUE],
			mScorer3, mScore3);
		SendClientMessageToAll(-1, stringo);
		*/
		
		new top[3*2][E_BINTREE_INPUT];

		top[0][E_BINTREE_INPUT_POINTER] = la[j-1][E_BINTREE_INPUT_POINTER];
		top[0][E_BINTREE_INPUT_VALUE] = la[j-1][E_BINTREE_INPUT_VALUE];

	    if ((j-2)>=0)
	    {
			top[1][E_BINTREE_INPUT_POINTER] = la[j-2][E_BINTREE_INPUT_POINTER];
			top[1][E_BINTREE_INPUT_VALUE] = la[j-2][E_BINTREE_INPUT_VALUE];
		}
		else
		{
			top[1][E_BINTREE_INPUT_POINTER] = INVALID_PLAYER_ID;
			top[1][E_BINTREE_INPUT_VALUE] = 0;
		}

		if ((j-3)>=0)
		{
			top[2][E_BINTREE_INPUT_POINTER] = la[j-3][E_BINTREE_INPUT_POINTER];
			top[2][E_BINTREE_INPUT_VALUE] = la[j-3][E_BINTREE_INPUT_VALUE];
		}
		else
		{
			top[2][E_BINTREE_INPUT_POINTER] = INVALID_PLAYER_ID;
			top[2][E_BINTREE_INPUT_VALUE] = 0;

		}

		top[3][E_BINTREE_INPUT_POINTER] = lb[j2-1][E_BINTREE_INPUT_POINTER];
		top[3][E_BINTREE_INPUT_VALUE] = lb[j2-1][E_BINTREE_INPUT_VALUE];

		if((j2-2)>=0)
		{
			top[4][E_BINTREE_INPUT_POINTER] = lb[j2-2][E_BINTREE_INPUT_POINTER];
			top[4][E_BINTREE_INPUT_VALUE] = lb[j2-2][E_BINTREE_INPUT_VALUE];
		}
		else
		{
			top[4][E_BINTREE_INPUT_POINTER] = INVALID_PLAYER_ID;
			top[4][E_BINTREE_INPUT_VALUE] = 0;
		}

		if((j2-3)>=0)
		{
			top[5][E_BINTREE_INPUT_POINTER] = lb[j2-3][E_BINTREE_INPUT_POINTER];
			top[5][E_BINTREE_INPUT_VALUE] = lb[j2-3][E_BINTREE_INPUT_VALUE];
		}
		else
		{
			top[5][E_BINTREE_INPUT_POINTER] = INVALID_PLAYER_ID;
			top[5][E_BINTREE_INPUT_VALUE] = 0;
		}

		Bintree_Sort(top, 6);
		
		mScorer1 = top[5][E_BINTREE_INPUT_POINTER];
		mScore1 = top[5][E_BINTREE_INPUT_VALUE];

		mScorer2 = top[4][E_BINTREE_INPUT_POINTER];
		mScore2 = top[4][E_BINTREE_INPUT_VALUE];

		mScorer3 = top[3][E_BINTREE_INPUT_POINTER];
		mScore3 = top[3][E_BINTREE_INPUT_VALUE];
	}

   	new bestid = INVALID_PLAYER_ID, score;
	for (new i = j - 1; i != -1; i--)
   	{
   	    new pid = la[i][E_BINTREE_INPUT_POINTER];

		if (pid >= VALORE_SENTINELLA) {
		    pid -= VALORE_SENTINELLA;
   	    	//if (Player[pid][Damage] > score)
	   	    if (Player[pid][Damage] > score)
	   	    {
	   	        score = Player[pid][Damage];
	   	        bestid = pid;
	   	    }//Stringa_TmpBest

		    strcat( td_teama_names , Player[ pid ][ Nickname ] );
		    strcat( td_teama_names , "~n~" );

			strcat( td_teama_kills , numstr( Player[ pid ][ RKills ] ) );
			strcat( td_teama_kills , "~n~" );

			strcat( td_teama_dmg   , numstr( Player[ pid ][ RDamage ] ) );
			strcat( td_teama_dmg   , "~n~" );
		}
		else
		{
	   	    //if (Player[pid][Damage] > score)
	   	    if (Player[pid][Damage] > score)
	   	    {
	   	        score = Player[pid][Damage];
	   	        bestid = pid;
	   	    }//Stringa_TmpBest

		    strcat( td_teama_names , Player[ pid ][ Nickname ] );
		    strcat( td_teama_names , "~n~" );

			strcat( td_teama_kills , numstr( Player[ pid ][ RKills ] ) );
			strcat( td_teama_kills , "~n~" );

			strcat( td_teama_dmg   , numstr( Player[ pid ][ RDamage ] ) );
			strcat( td_teama_dmg   , "~n~" );
		}
   	}

   	for (new i = j2 - 1; i != -1; i--)
   	{
   	    new pid = lb[i][E_BINTREE_INPUT_POINTER];
		if (pid >= VALORE_SENTINELLA)
		{
		    pid -= VALORE_SENTINELLA;
	   	    if (Player[pid][Damage] > score)
	   	    {
	   	        score = Player[pid][Damage];
	   	        bestid = pid;
	   	    }//Stringa_TmpBest

		    strcat( td_teamb_names , Player[ pid ][ Nickname ] );
		    strcat( td_teamb_names , "~n~" );

			strcat( td_teamb_kills , numstr( Player[ pid ][ RKills ] ) );
			strcat( td_teamb_kills , "~n~" );

			strcat( td_teamb_dmg   , numstr( Player[ pid ][ RDamage ] ) );
			strcat( td_teamb_dmg   , "~n~" );
		}
		else
		{
	 		if (Player[pid][Damage] > score)
	   	    {
	   	        score = Player[pid][Damage];
	   	        bestid = pid;
	   	    }//Stringa_TmpBest

		    strcat( td_teamb_names , Player[ pid ][ Nickname ] );
		    strcat( td_teamb_names , "~n~" );

			strcat( td_teamb_kills , numstr( Player[ pid ][ RKills ] ) );
			strcat( td_teamb_kills , "~n~" );

			strcat( td_teamb_dmg   , numstr( Player[ pid ][ RDamage ] ) );
			strcat( td_teamb_dmg   , "~n~" );
		}
   	}

	TextDrawHideForAll(RoundStats[0]);
	TextDrawHideForAll(RoundStats[1]);
	TextDrawHideForAll(RoundStats[2]);
	TextDrawHideForAll(RoundStats[3]);

	new hp = floatround (thp);

	strdel (in_checkpoint, strlen(in_checkpoint) - 2, strlen(in_checkpoint));

	FixHealthBars();

	SendClientMessageToAll(-1, " ");
	SendClientMessageToAll(-1, " ");
	SendClientMessageToAll(-1, " ");
	SendClientMessageToAll(-1, " ");
	SendClientMessageToAll(-1, " ");
	SendClientMessageToAll(-1, " ");
	SendClientMessageToAll(-1, " ");
	SendClientMessageToAll(-1, " ");
	SendClientMessageToAll(-1, " ");
	SendClientMessageToAll(-1, " ");
	SendClientMessageToAll(-1, " ");
	SendClientMessageToAll(-1, " ");
	SendClientMessageToAll(-1, " ");
    SendClientMessageToAll(-1, " ");
	SendClientMessageToAll(-1, " ");
	SendClientMessageToAll(-1, " ");

	new no_process = 0/*, txt = 0*/;
	if( Gaming != GAMETYPE_GUNGAME && Gaming != GAMETYPE_FIGHT && Gaming != GAMETYPE_FALLOUT && Gaming != GAMETYPE_LASTBULLET )
	{
		switch (winner)
		{
		    case TEAM_A: SendClientMessageToAll( HEX_TEAMA , "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~");
		    case TEAM_B: SendClientMessageToAll( HEX_TEAMB , "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~");
		    default: 	 SendClientMessageToAll( COLOR_GREY , "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~");
		}

		if( winner != NULL_TEAM )
		{
			iTeam[winner][RoundWins]++;
			/*
			if(TeamRole[TEAM_A] == ATTACKERS)
			{
			    TeamRole[TEAM_A] = DEFENDERS;
			    TeamRole[TEAM_B] = ATTACKERS;

				txt = 1;
			}
			else
			{
			    TeamRole[TEAM_A] = ATTACKERS;
			    TeamRole[TEAM_B] = DEFENDERS;

				txt = 2;
			}
			*/

			//if(gConfig[Matchmode] != MATCHMODE_NOSCORES)
			if(tcwcw)
			{
			    SetTimer("SwapTeams", 500, 0);

			    PlayingRound++;

//				mysql_function_query (webMatch[g_Connection], sprintf("INSERT INTO rounds (tcwid,round,type,twinner,tscore1,tscore2,bestdmg) VALUES ('%d', '%d', '%d', '%d', '%d', '%d', '%s')", webMatch[MatchID], PlayingRound, Gaming, winner, iTeam[TEAM_A][RoundWins], iTeam[TEAM_B][RoundWins], "-"), false, "", "");

				switch (winner)
				{
				    case TEAM_A:
					{
					    // [fixhere]  (fixed)
						format(stringo, sizeof stringo, "»» Team {e55757}%s{"#SC_TEAMA"} won for {e55757}%s{"#SC_TEAMA"} with {e55757}%d{"#SC_TEAMA"} HP remaining. (%d/%d)", iTeam[winner][Name], GetWinTypeString(wintype), hp, PlayingRound, TotalRounds);
                        SendClientMessageToAll(HEX_TEAMA, stringo);
					}
					case TEAM_B:
					{
					    // [fixhere]  (fixed)
						format(stringo, sizeof stringo, "»» Team {7b8ef7}%s{"#SC_TEAMB"} won for {7b8ef7}%s{"#SC_TEAMB"} with {7b8ef7}%d{"#SC_TEAMB"} HP remaining. (%d/%d)", iTeam[winner][Name], GetWinTypeString(wintype), hp, PlayingRound, TotalRounds);
                        SendClientMessageToAll(HEX_TEAMB, stringo);
					}
				}

		        if(PlayingRound>=TotalRounds)
				{
		            //SetTimer("Process_Final", 5000, 0);
		            defer Process_Final();

		            if (iTeam[TEAM_A][RoundWins]>iTeam[TEAM_B][RoundWins]) {
		            	SendClientMessageToAll(HEX_TEAMA, "All the rounds have been played! Wait while final results are being prepared...");
					}
					else if (iTeam[TEAM_A][RoundWins]<iTeam[TEAM_B][RoundWins]) {
					    SendClientMessageToAll(HEX_TEAMB, "All the rounds have been played! Wait while final results are being prepared...");
					}
					else if (iTeam[TEAM_A][RoundWins]==iTeam[TEAM_B][RoundWins]) {
					    SendClientMessageToAll(COLOR_GREY, "All the rounds have been played! Wait while final results are being prepared...");
					}
//					mysql_function_query (webMatch[g_Connection], sprintf ("UPDATE matchs SET incorso = '0', matchend = UNIX_TIMESTAMP() WHERE matchid = %d", webMatch[MatchID]), false, "", "");
		            process_finaltd = 1;
				}
				else process_finaltd = 0;

			    SendRconCommand(sprintf("mapname Lobby %s %d:%d %s", iTeam[TEAM_A][Name], iTeam[TEAM_A][RoundWins], iTeam[TEAM_B][RoundWins], iTeam[TEAM_B][Name]));
			}
			else
			{
				switch (winner)
				{
				    case TEAM_A://attack
					{
					    // [fixhere] (fixed)
						format(stringo, sizeof stringo, "»» Team {e55757}%s{"#SC_TEAMA"} won for {e55757}%s{"#SC_TEAMA"} with {e55757}%d{"#SC_TEAMA"} HP remaining.", iTeam[winner][Name], GetWinTypeString(wintype), hp);
                        SendClientMessageToAll(HEX_TEAMA, stringo);
					}
					case TEAM_B:
					{
					    // [fixhere] (fixed)
						format(stringo, sizeof stringo, "»» Team {7b8ef7}%s{"#SC_TEAMB"} won for {7b8ef7}%s{"#SC_TEAMB"} with {7b8ef7}%d{"#SC_TEAMB"} HP remaining.", iTeam[winner][Name], GetWinTypeString(wintype), hp);
                        SendClientMessageToAll(HEX_TEAMB, stringo);
					}
				}

	//			SendClientMessageToAll(0x89C738AA, "ï¿½ï¿½ Team {C6E0A3}%s{89C738} won for {C6E0A3}%s{89C738} with {C6E0A3}%d{89C738} HP remaining.", iTeam[winner][Name], GetWinTypeString(wintype), hp);
				MySQLStatus[TotalQuerys] ++; mysql_tquery(g_MySQLConnection, sprintf("UPDATE stats SET scores = '%d,%d' WHERE gid = %d", iTeam[TEAM_A][RoundWins], iTeam[TEAM_B][RoundWins], G_ID), "", "");

                SendRconCommand(sprintf("mapname Lobby %d:%d",  iTeam[TEAM_A][RoundWins], iTeam[TEAM_B][RoundWins]));
			}

			if( wintype == WINTYPE_CHECKPOINT )
			{
			    //in_checkpoint[ strlen (in_checkpoint) - 2 ] = EOS;
			    format(stringo, sizeof stringo, "Checkpoint holders: %s", in_checkpoint);
			    SendClientMessageToAll( 0xB0DD55AA , stringo);
			}
		}
		else
		{
		    //if( gConfig[Matchmode] != MATCHMODE_NOSCORES )
		    if(tcwcw)
			{
				format(stringo, sizeof stringo, "»» Not any team has won the round! (%d/%d)", PlayingRound, TotalRounds);
			    SendRconCommand(sprintf("mapname Lobby %s %d:%d %s", iTeam[TEAM_A][Name], iTeam[TEAM_A][RoundWins], iTeam[TEAM_B][RoundWins], iTeam[TEAM_B][Name]));
			}
			else
			{
				format(stringo, sizeof stringo, "»» Not any team has won the round!");
                SendRconCommand(sprintf("mapname Lobby %d:%d",  iTeam[TEAM_A][RoundWins], iTeam[TEAM_B][RoundWins]));
			}

			SendClientMessageToAll(COLOR_GREY, stringo);
			no_process = 1;
		}
	}
	else
	{
		SendClientMessageToAll( COLOR_GREY , "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~");

		switch (Gaming)
		{
			case GAMETYPE_GUNGAME:
			{
				if(winner != INVALID_PLAYER_ID)
				{
				    GetPlayerHealth( winner , h );
					GetPlayerArmour( winner , a );

					format(stringo, sizeof stringo, "»» Congratulations %s for winning with %d HP remaining!", Player[winner][Nickname], floatround( h+a ));
                    SendClientMessageToAll(COLOR_GREY, stringo);
				}
				else
				{
					SendClientMessageToAll(COLOR_GREY, "»» Noone won this Gungame round!");
				}

				SendRconCommand(sprintf("mapname Lobby %d:%d",  iTeam[TEAM_A][RoundWins], iTeam[TEAM_B][RoundWins]));
			}
		    case GAMETYPE_FIGHT:
			{
				if(winner != INVALID_PLAYER_ID)
				{
				    GetPlayerHealth( winner , h );
					GetPlayerArmour( winner , a );

					format(stringo, sizeof stringo, "»» Congratulations %s for winning with %d HP remaining!", Player[winner][Nickname], floatround( h+a ));
                    SendClientMessageToAll(COLOR_GREY, stringo);
					// creare il best fight qui
				}
				else
				{
					SendClientMessageToAll(COLOR_GREY, "»» Noone won this Fight round!");
				}

				SendRconCommand(sprintf("mapname Lobby %d:%d",  iTeam[TEAM_A][RoundWins], iTeam[TEAM_B][RoundWins]));
			}
			case GAMETYPE_FALLOUT:
			{
			    if (winner != INVALID_PLAYER_ID)
			    {
					format(stringo, sizeof stringo, "»» Congratulations to %s for winning Fallout!", winners);
					SendClientMessageToAll(COLOR_GREY, stringo);
				}
				else
				{
				    if (wintype == WINTYPE_EVERYONEFELL)
				    {
				        SendClientMessageToAll(COLOR_GREY, "»» Noone won, all players have fallen!");
				    }
				    else
				    {
				    	SendClientMessageToAll(COLOR_GREY, "»» Noone won this Fallout round!");
					}
				}

				DistruggiPiattaforma ();
				SendRconCommand(sprintf("mapname Lobby %d:%d",  iTeam[TEAM_A][RoundWins], iTeam[TEAM_B][RoundWins]));
			}
			case GAMETYPE_LASTBULLET:
			{
				if(winner != INVALID_PLAYER_ID)
				{
				    GetPlayerHealth( winner , h );
					GetPlayerArmour( winner , a );

					format(stringo, sizeof stringo, "»» Congratulations %s for winning with %d HP remaining!", Player[winner][Nickname], floatround( h+a ));
                    SendClientMessageToAll(COLOR_GREY, stringo);
				}
				else
				{
					SendClientMessageToAll(COLOR_GREY, "»» Noone won this Last Bullet round!");
				}

			    SendRconCommand(sprintf("mapname Lobby %d:%d",  iTeam[TEAM_A][RoundWins], iTeam[TEAM_B][RoundWins]));
			}
		}
		process_finaltd = 0;
	}

	if(!process_finaltd && no_process != 1)
	{
   		/*foreach(new i:Player)
		{
     		if (Player[i][FinalRound_Status] == FINALROUND_STATUS_HIDDEN)
     		{
     			Player[i][CurrentView] 			= PlayingRound;
     			Player[i][FinalRound_Status] 	= FINALROUND_STATUS_FORCED;
			}
       	}*/


		if (bestid != INVALID_PLAYER_ID)
		{
       		TextDrawSetString(FineRound_Dynamic[PlayingRound][Stringa_TmpBest], sprintf ("Actual Best Player~n~~w~%s~n~~y~(~w~%d~y~/~w~%d~y~)", Player[bestid][Nickname], score, Player[bestid][Kills]));
		}
		else
		{
		    TextDrawSetString(FineRound_Dynamic[PlayingRound][Stringa_TmpBest], "Actual Best Player~n~~w~NONE~n~~y~(~w~ND~y~/~w~ND~y~)");
		}

		if (Gaming != GAMETYPE_FALLOUT)
		{
		    // non era un fallout

			// premo i migliori due dei due teams
			// take

	//		format(stringo, sizeof stringo, "J: %d - J2: %d", j, j2);
	//		SendClientMessageToAll(-1, stringo);
/*
			foreach(new i:Player)
			{
			    if (Player[i][Team] != TEAM_A && Player[i][Team] != TEAM_B) continue;

				if (Gaming != GAMETYPE_FIGHT && Gaming != GAMETYPE_GUNGAME && Gaming != GAMETYPE_LASTBULLET)
					pScore = Player[i][RDamage];
				else pScore = Player[i][RKills];

			    if (pScore >= mScore1)
			    {
			        if (mScorer1 != INVALID_PLAYER_ID)
			        {
			            new
			                tmp2s = mScore2, tmp2p = mScorer2;

	                    mScorer2 = mScorer1;
	                    mScore2  = mScore1;

	                    mScore3  = tmp2s;
	                    mScorer3  = tmp2p;
			        }

					if (Gaming != GAMETYPE_FIGHT && Gaming != GAMETYPE_GUNGAME)
						mScore1  = Player[i][RDamage];
					else mScore1  = Player[i][RKills];

			        mScorer1 = i;
			    }
			    else if (pScore >= mScore2)
			    {
			        if (mScorer2 != INVALID_PLAYER_ID)
			        {
	                    mScorer3 = mScorer2;
	                    mScore3  = mScore2;
			        }

					if (Gaming != GAMETYPE_FIGHT && Gaming != GAMETYPE_GUNGAME && Gaming != GAMETYPE_LASTBULLET)
					{
						mScore2  = Player[i][RDamage];
					}
					else
					{
						mScore2  = Player[i][RKills];
					}

			        mScorer2 = i;
				}
			    else if (pScore >= mScore3)
			    {
					if (Gaming != GAMETYPE_FIGHT && Gaming != GAMETYPE_GUNGAME && Gaming != GAMETYPE_LASTBULLET)
					{
						mScore3  = Player[i][RDamage];
			        }
					else
					{
						mScore3  = Player[i][RKills];
					}

					mScorer3 = i;
			    }
			}
*/

			if (mScorer1 != INVALID_PLAYER_ID)
			{
			    if (mScorer1 >= VALORE_SENTINELLA)
				{
			        mScorer1 -= VALORE_SENTINELLA;

		            if (mScore1 == 0)
		            {
						TextDrawSetString( FineRound_Dynamic[PlayingRound][Top1_Nick] , "N/D" );
						TextDrawSetString( FineRound_Dynamic[PlayingRound][Top1_Stats] , "~y~Damage~w~ 0 ~y~Kills ~w~0" );

						SendClientMessageToAll(-1, "1st. {EDF400}N/D");
		            }
		            else
		            {
						TextDrawSetString( FineRound_Dynamic[PlayingRound][Top1_Nick] , SavedPlayer[mScorer1][sNickname_WOTag] );
						TextDrawSetString( FineRound_Dynamic[PlayingRound][Top1_Stats] , sprintf ("~y~Damage~w~ %d ~y~Kills ~w~%d", SavedPlayer[mScorer1][sRDamage], SavedPlayer[mScorer1][sRKills])  );

			  	      	format(stringo, sizeof stringo, "1st. {EDF400}%s{FFFFFF} (Kills: %d | Damage: %d)", SavedPlayer[mScorer1][sNickname], SavedPlayer[mScorer1][sRKills], SavedPlayer[mScorer1][sRDamage]);
	                    SendClientMessageToAll(-1, stringo);
					}

			    }
			    else
			    {
		            if (mScore1 == 0)
		            {
						TextDrawSetString( FineRound_Dynamic[PlayingRound][Top1_Nick] , "N/D" );
						TextDrawSetString( FineRound_Dynamic[PlayingRound][Top1_Stats] , "~y~Damage~w~ 0 ~y~Kills ~w~0" );

						SendClientMessageToAll(-1, "1st. {EDF400}N/D");
		            }
		            else
		            {
						TextDrawSetString( FineRound_Dynamic[PlayingRound][Top1_Nick] , Player[mScorer1][Nickname_WOTag] );
						TextDrawSetString( FineRound_Dynamic[PlayingRound][Top1_Stats] , sprintf ("~y~Damage~w~ %d ~y~Kills ~w~%d", Player[mScorer1][RDamage], Player[mScorer1][RKills])  );

			  	      	format(stringo, sizeof stringo, "1st. {EDF400}%s{FFFFFF} (Kills: %d | Damage: %d)", Player[mScorer1][Nickname], Player[mScorer1][RKills], Player[mScorer1][RDamage]);
	                    SendClientMessageToAll(-1, stringo);
					}
			    }
			}
			else
			{
				TextDrawSetString( FineRound_Dynamic[PlayingRound][Top1_Nick] , "N/D" );
				TextDrawSetString( FineRound_Dynamic[PlayingRound][Top1_Stats] , "~y~Damage~w~ 0 ~y~Kills ~w~0" );

				SendClientMessageToAll(-1, "1st. {EDF400}N/D");
			}


			if (mScorer2 != INVALID_PLAYER_ID)
			{
			    if (mScorer2 >= VALORE_SENTINELLA)
			    {
			    	mScorer2 -= VALORE_SENTINELLA;

				    if (mScore2 == 0)
				    {
				        SendClientMessageToAll(-1, "2nd. {C0C0C0}N/D");

						TextDrawSetString( FineRound_Dynamic[PlayingRound][Top2_Nick] , "N/D" );
						TextDrawSetString( FineRound_Dynamic[PlayingRound][Top2_Stats] , "~y~Damage~w~ 0 ~y~Kills ~w~0" );
				    }
				    else
				    {
						TextDrawSetString( FineRound_Dynamic[PlayingRound][Top2_Nick] , SavedPlayer[mScorer2][sNickname_WOTag] );
						TextDrawSetString( FineRound_Dynamic[PlayingRound][Top2_Stats] , sprintf ("~y~Damage~w~ %d ~y~Kills ~w~%d", SavedPlayer[mScorer2][sRDamage], SavedPlayer[mScorer2][sRKills])  );

			  	      	format(stringo, sizeof stringo, "2nd. {C0C0C0}%s{FFFFFF} (Kills: %d | Damage: %d)", SavedPlayer[mScorer2][sNickname], SavedPlayer[mScorer2][sRKills], SavedPlayer[mScorer2][sRDamage]);
	                    SendClientMessageToAll(-1, stringo);
					}
			    }
			    else
			    {
				    if (mScore2 == 0)
				    {
				        SendClientMessageToAll(-1, "2nd. {C0C0C0}N/D");

						TextDrawSetString( FineRound_Dynamic[PlayingRound][Top2_Nick] , "N/D" );
						TextDrawSetString( FineRound_Dynamic[PlayingRound][Top2_Stats] , "~y~Damage~w~ 0 ~y~Kills ~w~0" );
				    }
				    else
				    {
						TextDrawSetString( FineRound_Dynamic[PlayingRound][Top2_Nick] , Player[mScorer2][Nickname_WOTag] );
						TextDrawSetString( FineRound_Dynamic[PlayingRound][Top2_Stats] , sprintf ("~y~Damage~w~ %d ~y~Kills ~w~%d", Player[mScorer2][RDamage], Player[mScorer2][RKills])  );

			  	      	format(stringo, sizeof stringo, "2nd. {C0C0C0}%s{FFFFFF} (Kills: %d | Damage: %d)", Player[mScorer2][Nickname], Player[mScorer2][RKills], Player[mScorer2][RDamage]);
	                    SendClientMessageToAll(-1, stringo);
					}
			    }
			}
			else
			{
	  			SendClientMessageToAll(-1, "2nd. {C0C0C0}N/D");

				TextDrawSetString( FineRound_Dynamic[PlayingRound][Top2_Nick] , "N/D" );
				TextDrawSetString( FineRound_Dynamic[PlayingRound][Top2_Stats] , "~y~Damage~w~ 0 ~y~Kills ~w~0" );
			}

			if (mScorer3 != INVALID_PLAYER_ID)
			{
			    if (mScorer3 >= VALORE_SENTINELLA)
			    {
			        mScorer3 -= VALORE_SENTINELLA;

				    if (mScore3 == 0)
				    {
			 	       	SendClientMessageToAll(-1, "3rd. {CD7F32}N/D");

						TextDrawSetString( FineRound_Dynamic[PlayingRound][Top3_Nick] , "N/D" );
						TextDrawSetString( FineRound_Dynamic[PlayingRound][Top3_Stats] , "~y~Damage~w~ 0 ~y~Kills ~w~0" );
				    }
				    else
				    {
						TextDrawSetString( FineRound_Dynamic[PlayingRound][Top3_Nick] , SavedPlayer[mScorer3][sNickname_WOTag]);
						TextDrawSetString( FineRound_Dynamic[PlayingRound][Top3_Stats] , sprintf ("~y~Damage~w~ %d ~y~Kills ~w~%d", SavedPlayer[mScorer3][sRDamage], SavedPlayer[mScorer3][sRKills]) );

			 	       	format(stringo, sizeof stringo, "3rd. {CD7F32}%s{FFFFFF} (Kills: %d | Damage: %d)", SavedPlayer[mScorer3][sNickname], SavedPlayer[mScorer3][sRKills], SavedPlayer[mScorer3][sRDamage]);
	                    SendClientMessageToAll(-1, stringo);
					}
			    }
			    else
			    {
				    if (mScore3 == 0)
				    {
			 	       	SendClientMessageToAll(-1, "3rd. {CD7F32}N/D");

						TextDrawSetString( FineRound_Dynamic[PlayingRound][Top3_Nick] , "N/D" );
						TextDrawSetString( FineRound_Dynamic[PlayingRound][Top3_Stats] , "~y~Damage~w~ 0 ~y~Kills ~w~0" );
				    }
				    else
				    {
						TextDrawSetString( FineRound_Dynamic[PlayingRound][Top3_Nick] , Player[mScorer3][Nickname_WOTag]);
						TextDrawSetString( FineRound_Dynamic[PlayingRound][Top3_Stats] , sprintf ("~y~Damage~w~ %d ~y~Kills ~w~%d", Player[mScorer3][RDamage], Player[mScorer3][RKills]) );

			 	       	format(stringo, sizeof stringo, "3rd. {CD7F32}%s{FFFFFF} (Kills: %d | Damage: %d)", Player[mScorer3][Nickname], Player[mScorer3][RKills], Player[mScorer3][RDamage]);
	                    SendClientMessageToAll(-1, stringo);
					}
			    }
			}
			else
			{
				TextDrawSetString( FineRound_Dynamic[PlayingRound][Top3_Nick] , "N/D" );
				TextDrawSetString( FineRound_Dynamic[PlayingRound][Top3_Stats] , "~y~Damage~w~ 0 ~y~Kills ~w~0" );

	 	       	SendClientMessageToAll(-1, "3rd. {CD7F32}N/D");
			}
		}
		else
		{
			if (winner != INVALID_PLAYER_ID)
			{
		        if (mScorer1 != INVALID_PLAYER_ID)
		        {
					TextDrawSetString( FineRound_Dynamic[PlayingRound][Top1_Nick] , Player[mScorer1][Nickname_WOTag] );
					TextDrawSetString( FineRound_Dynamic[PlayingRound][Top1_Stats] , "_"  );

			  	   	format(stringo, sizeof stringo, "1st. {EDF400}%s{FFFFFF}", Player[mScorer1][Nickname]);
			  	   	SendClientMessageToAll(-1, stringo);
				}
				else
				{
					TextDrawSetString( FineRound_Dynamic[PlayingRound][Top1_Nick] , "N/D" );
					TextDrawSetString( FineRound_Dynamic[PlayingRound][Top1_Stats] , "_" );

					SendClientMessageToAll(-1, "1st. {EDF400}N/D");
				}

				if (mScorer2 != INVALID_PLAYER_ID)
				{
					TextDrawSetString( FineRound_Dynamic[PlayingRound][Top2_Nick] , Player[mScorer2][Nickname_WOTag] );
					TextDrawSetString( FineRound_Dynamic[PlayingRound][Top2_Stats] , "_"  );

			  	   	format(stringo, sizeof stringo, "2nd. {C0C0C0}%s{FFFFFF}", Player[mScorer2][Nickname]);
			  	   	SendClientMessageToAll(-1, stringo);
				}
				else
				{
		  			SendClientMessageToAll(-1, "2nd. {C0C0C0}N/D");

					TextDrawSetString( FineRound_Dynamic[PlayingRound][Top2_Nick] , "N/D" );
					TextDrawSetString( FineRound_Dynamic[PlayingRound][Top2_Stats] , "_" );
				}

				if (mScorer3 != INVALID_PLAYER_ID)
				{
					TextDrawSetString( FineRound_Dynamic[PlayingRound][Top3_Nick] , Player[mScorer3][Nickname_WOTag]);
					TextDrawSetString( FineRound_Dynamic[PlayingRound][Top3_Stats] , "_" );

			     	format(stringo, sizeof stringo, "3rd. {CD7F32}%s{FFFFFF}", Player[mScorer3][Nickname]);
			     	SendClientMessageToAll(-1, stringo);
		        }
				else
				{
					TextDrawSetString( FineRound_Dynamic[PlayingRound][Top3_Nick] , "N/D" );
					TextDrawSetString( FineRound_Dynamic[PlayingRound][Top3_Stats] , "_" );

		 	       	SendClientMessageToAll(-1, "3rd. {CD7F32}N/D");
				}
			}
		}

		if (gConfig[Matchmode] == MATCHMODE_TCWCW)
		{
/*
			"txt" values
			if(TeamRole[TEAM_A] == ATTACKERS)
			{
			    TeamRole[TEAM_A] = DEFENDERS;
			    TeamRole[TEAM_B] = ATTACKERS;

				txt = 1;
			}
			else
			{
			    TeamRole[TEAM_A] = ATTACKERS;
			    TeamRole[TEAM_B] = DEFENDERS;

				txt = 2;
			}
*/

/*
			if (txt == 2)
			{
				format(stringo, sizeof stringo, "»» Attackers: {0469FF}%s{"#COLOR_SYSTEM_REST"} «« Defenders: {43E41E}%s{"#COLOR_SYSTEM_REST"} - Use /showagain for the final TD ««", iTeam[TEAM_A][Name], iTeam[TEAM_B][Name]);
			}
			else
			{
				format(stringo, sizeof stringo, "»» Attackers: {43E41E}%s{"#COLOR_SYSTEM_REST"} «« Defenders: {0469FF}%s{"#COLOR_SYSTEM_REST"} - Use /showagain for the final TD ««", iTeam[TEAM_B][Name], iTeam[TEAM_A][Name]);
			}

			SendClientMessageToAll(COLOR_SYSTEM, stringo);
*/
			//SendClientMessageToAll(COLOR_SYSTEM, "Use /showagain to Hide or Show the final round textdraw, press \"Hide Textdraw\" to hide textdraw.");
            TextDrawSetString (FineRound_Dynamic[PlayingRound][RoundsInfo], sprintf ("Round ~y~~h~%d~w~/~y~%d", PlayingRound, TotalRounds));
        }
        else
        {
       		SendClientMessageToAll(COLOR_SYSTEM, "» Textdraw will be hidden in 5 seconds «");
            TextDrawSetString (FineRound_Dynamic[PlayingRound][RoundsInfo], "Round ~y~~h~-~w~/~y~-");

           	AutoHide_TD = defer AutoHideTD();
           	if (gConfig[AutoAD])
			{
			   	SendClientMessageToAll(COLOR_SYSTEM, "The next round will be started in 5 seconds..");
			}
		}

        TextDrawSetString(FineRound_Dynamic[PlayingRound][BluePlayers]	, td_teama_names);
        TextDrawSetString(FineRound_Dynamic[PlayingRound][GreenPlayers]	, td_teamb_names);

        TextDrawSetString(FineRound_Dynamic[PlayingRound][BlueKills]	, td_teama_kills);
        TextDrawSetString(FineRound_Dynamic[PlayingRound][GreenKills]	, td_teamb_kills);

        TextDrawSetString(FineRound_Dynamic[PlayingRound][BlueDamages]	, td_teama_dmg);
        TextDrawSetString(FineRound_Dynamic[PlayingRound][GreenDamage]	, td_teamb_dmg);

        TextDrawSetString(FineRound_Dynamic[PlayingRound][TotalKBlue]	, numstr (total_kills_teama));
        TextDrawSetString(FineRound_Dynamic[PlayingRound][TotalKGreen]	, numstr (total_kills_teamb));

        TextDrawSetString(FineRound_Dynamic[PlayingRound][TotalDBlue]	, numstr (total_dmg_teama));
        TextDrawSetString(FineRound_Dynamic[PlayingRound][TotalDGreen]	, numstr (total_dmg_teamb));

        new x [20];

        switch (Gaming)
        {
            case GAMETYPE_BASE: x = "Base";
            case GAMETYPE_PVP: x = "PVP";
            case GAMETYPE_ARENA: x = "Arena";
            case GAMETYPE_TDM: x = "TDM";
            case GAMETYPE_GUNGAME: x = "Gungame";
            case GAMETYPE_INTS: x = "Ints";
            case GAMETYPE_FIGHT: x = "Fight";
            case GAMETYPE_FALLOUT: x = "Fallout";
            case GAMETYPE_LASTBULLET: x = "Last Bullet";
        }

		if( Gaming != GAMETYPE_GUNGAME && Gaming != GAMETYPE_FIGHT && Gaming != GAMETYPE_FALLOUT && Gaming != GAMETYPE_LASTBULLET )
		{
			if( winner != NULL_TEAM )
			{
			    if (winner == TEAM_A)
			    {
			        TextDrawSetString (FineRound_Dynamic[PlayingRound][Stringa_TeamWin], sprintf ("~"#GT_TEAMA"~~h~[%s] ~w~team wins the round", iTeam[winner][ Name ]));
        			TextDrawSetString (FineRound_Dynamic[PlayingRound][Stringa_RoundInfo]   , sprintf ("%s ~"#GT_TEAMA"~~h~%d ~w~HP Remaining ~b~~h~%d", x, eScenario[FileID], hp ));
				}
				else
	 			{
			 		TextDrawSetString (FineRound_Dynamic[PlayingRound][Stringa_TeamWin], sprintf ("~"#GT_TEAMB"~~h~[%s] ~w~team wins the round", iTeam[winner][ Name ]));
        			TextDrawSetString (FineRound_Dynamic[PlayingRound][Stringa_RoundInfo]   , sprintf ("%s ~"#GT_TEAMB"~~h~%d ~w~HP Remaining ~r~~h~%d", x, eScenario[FileID], hp ));
				}

				if( TeamRole[ winner ] == DEFENDERS )// sono invertiti xk i teams swappano prima e quindi se ora il vincitore ï¿½ def prima era att
				{
					if (winner == TEAM_B)
					{
						TextDrawSetString (FineRound_Dynamic[PlayingRound][Stringa_Winner2] , "~"#GT_TEAMB"~~h~N~n~~"#GT_TEAMB"~~h~N~n~~"#GT_TEAMB"~~h~E~n~~"#GT_TEAMB"~~h~R~n~~"#GT_TEAMB"~~h~S");
                    	TextDrawSetString (FineRound_Dynamic[PlayingRound][Stringa_Winner1] , "~"#GT_TEAMB"~~h~W~n~~"#GT_TEAMB"~~h~ I~n~");
				    	TextDrawSetString ( FineRound_Dynamic[PlayingRound][AttDefWin] , "~"#GT_TEAMB"~~h~A~n~~"#GT_TEAMB"~~h~t~n~~"#GT_TEAMB"~~h~t~n~~"#GT_TEAMB"~~h~a~n~~"#GT_TEAMB"~~h~c~n~~"#GT_TEAMB"~~h~k ~n~~"#GT_TEAMB"~~h~e~n~~"#GT_TEAMB"~~h~r~n~~"#GT_TEAMB"~~h~s");

					}
					else
					{
						TextDrawSetString (FineRound_Dynamic[PlayingRound][Stringa_Winner2] , "~"#GT_TEAMA"~~h~N~n~~"#GT_TEAMA"~~h~N~n~~"#GT_TEAMA"~~h~E~n~~"#GT_TEAMA"~~h~R~n~~"#GT_TEAMA"~~h~S");
                    	TextDrawSetString (FineRound_Dynamic[PlayingRound][Stringa_Winner1] , "~"#GT_TEAMA"~~h~W~n~~"#GT_TEAMA"~~h~ I~n~");
					    TextDrawSetString ( FineRound_Dynamic[PlayingRound][AttDefWin] , "~"#GT_TEAMA"~~h~A~n~~"#GT_TEAMA"~~h~t~n~~"#GT_TEAMA"~~h~t~n~~"#GT_TEAMA"~~h~a~n~~"#GT_TEAMA"~~h~c~n~~"#GT_TEAMA"~~h~k ~n~~"#GT_TEAMA"~~h~e~n~~"#GT_TEAMA"~~h~r~n~~"#GT_TEAMA"~~h~s");
					}
				}
				else // leggi su
				{
					if (winner == TEAM_B)
					{
						TextDrawSetString (FineRound_Dynamic[PlayingRound][Stringa_Winner2] , "~"#GT_TEAMB"~~h~N~n~~"#GT_TEAMB"~~h~N~n~~"#GT_TEAMB"~~h~E~n~~"#GT_TEAMB"~~h~R~n~~"#GT_TEAMB"~~h~S");
                    	TextDrawSetString (FineRound_Dynamic[PlayingRound][Stringa_Winner1] , "~"#GT_TEAMB"~~h~W~n~~"#GT_TEAMB"~~h~ I~n~");
				    	TextDrawSetString ( FineRound_Dynamic[PlayingRound][AttDefWin] , "~"#GT_TEAMB"~~h~D~n~~"#GT_TEAMB"~~h~E~n~~"#GT_TEAMB"~~h~F~n~~"#GT_TEAMB"~~h~E~n~~"#GT_TEAMB"~~h~N~n~~"#GT_TEAMB"~~h~D~n~~"#GT_TEAMB"~~h~E~n~~"#GT_TEAMB"~~h~R~n~~"#GT_TEAMB"~~h~S");

					}
					else
					{
						TextDrawSetString (FineRound_Dynamic[PlayingRound][Stringa_Winner2] , "~"#GT_TEAMA"~~h~N~n~~"#GT_TEAMA"~~h~N~n~~"#GT_TEAMA"~~h~E~n~~"#GT_TEAMA"~~h~R~n~~"#GT_TEAMA"~~h~S");
	                    TextDrawSetString (FineRound_Dynamic[PlayingRound][Stringa_Winner1] , "~"#GT_TEAMA"~~h~W~n~~"#GT_TEAMA"~~h~ I~n~");
					    TextDrawSetString ( FineRound_Dynamic[PlayingRound][AttDefWin] , "~"#GT_TEAMA"~~h~D~n~~"#GT_TEAMA"~~h~E~n~~"#GT_TEAMA"~~h~F~n~~"#GT_TEAMA"~~h~E~n~~"#GT_TEAMA"~~h~N~n~~"#GT_TEAMA"~~h~D~n~~"#GT_TEAMA"~~h~E~n~~"#GT_TEAMA"~~h~R~n~~"#GT_TEAMA"~~h~S");
					}
				}
			}
			else
			{
				TextDrawSetString (FineRound_Dynamic[PlayingRound][Stringa_TeamWin], "N/D");
    			TextDrawSetString(FineRound_Dynamic[PlayingRound][Stringa_RoundInfo]   , sprintf ("%s ~y~~h~%d ~w~HP Remaining ~y~~h~%d", x, eScenario[FileID], hp ));
			}
		}
		else
		{
			if (Gaming == GAMETYPE_LASTBULLET)
			{
				TextDrawSetString (FineRound_Dynamic[PlayingRound][Stringa_TeamWin], "~y~~h~Last Bullet ~w~round");
			}
			else if (Gaming == GAMETYPE_FALLOUT)
			{
				TextDrawSetString (FineRound_Dynamic[PlayingRound][Stringa_TeamWin], "~y~~h~Fallout ~w~round");
			}
			else
			{
				if( winner != INVALID_PLAYER_ID )
				{
					TextDrawSetString (FineRound_Dynamic[PlayingRound][Stringa_TeamWin], sprintf ("~y~~h~%s ~w~wins the round", Player[winner][ Nickname ]));
				}
				else
				{
					TextDrawSetString (FineRound_Dynamic[PlayingRound][Stringa_TeamWin], "~y~~h~Noone ~w~wins the round");
				}
			}
		}

		foreach(new i:Player)
		{
			Player[i][RKills] = 0;
			Player[i][RDeaths] = 0;
			Player[i][RDamage] = 0;

		    // il player non stava vedendo nessun altro td
		    // se sta giï¿½ vedendo un td ignoralo
		    // oppure il lpayer potrebbe essere afk
		    if (Player[i][FinalRound_Status] == FINALROUND_STATUS_FORCED) continue;
		    // se il player non  è nel team a o nel team b non mostra il final round
		    if (Player[i][Team] != TEAM_A && Player[i][Team] != TEAM_B) continue;

			if (Player[i][FinalRound_Status] == FINALROUND_STATUS_HIDDEN)
			{
			    Player[i][CurrentView] 			= PlayingRound;
			    Player[i][FinalRound_Status] 	= FINALROUND_STATUS_FORCED;

				for (new i2 = 0; i2 < MAX_STATIC_TEXTDRAWS; i2++) TextDrawShowForPlayer(i, FineRound_Static[i2]);

				TextDrawShowForPlayer(i, FineRound_Dynamic[PlayingRound][BluePlayers]);
				TextDrawShowForPlayer(i, FineRound_Dynamic[PlayingRound][GreenPlayers]);
				TextDrawShowForPlayer(i, FineRound_Dynamic[PlayingRound][BlueKills]);
				TextDrawShowForPlayer(i, FineRound_Dynamic[PlayingRound][BlueDamages]);
				TextDrawShowForPlayer(i, FineRound_Dynamic[PlayingRound][GreenKills]);
				TextDrawShowForPlayer(i, FineRound_Dynamic[PlayingRound][GreenDamage]);
				TextDrawShowForPlayer(i, FineRound_Dynamic[PlayingRound][TotalKGreen]);
				TextDrawShowForPlayer(i, FineRound_Dynamic[PlayingRound][TotalDGreen]);
				TextDrawShowForPlayer(i, FineRound_Dynamic[PlayingRound][TotalKBlue]);
				TextDrawShowForPlayer(i, FineRound_Dynamic[PlayingRound][TotalDBlue]);
				TextDrawShowForPlayer(i, FineRound_Dynamic[PlayingRound][Top2_Nick]);
				TextDrawShowForPlayer(i, FineRound_Dynamic[PlayingRound][Top2_Stats]);
				TextDrawShowForPlayer(i, FineRound_Dynamic[PlayingRound][Top3_Stats]);
				TextDrawShowForPlayer(i, FineRound_Dynamic[PlayingRound][Top3_Nick]);
				TextDrawShowForPlayer(i, FineRound_Dynamic[PlayingRound][Top1_Stats]);
				TextDrawShowForPlayer(i, FineRound_Dynamic[PlayingRound][Top1_Nick]);
				TextDrawShowForPlayer(i, FineRound_Dynamic[PlayingRound][RoundsInfo]);
				TextDrawShowForPlayer(i, FineRound_Dynamic[PlayingRound][AttDefWin]);
		        TextDrawShowForPlayer(i, FineRound_Dynamic[PlayingRound][Stringa_Winner2]);
		        TextDrawShowForPlayer(i, FineRound_Dynamic[PlayingRound][Stringa_TeamWin]);
		        TextDrawShowForPlayer(i, FineRound_Dynamic[PlayingRound][Stringa_Winner1]);
				TextDrawShowForPlayer(i, FineRound_Dynamic[PlayingRound][Stringa_RoundInfo]);
		        TextDrawShowForPlayer(i, FineRound_Dynamic[PlayingRound][Stringa_TmpBest]);

		        if (gConfig[Matchmode] == MATCHMODE_TCWCW)
		        	SelectTextDraw (i, red);
			}
		}
	}

    if( Gaming != GAMETYPE_GUNGAME && Gaming != GAMETYPE_FIGHT && Gaming != GAMETYPE_FALLOUT && Gaming != GAMETYPE_LASTBULLET )
    {
		switch (winner)
		{
		    case TEAM_A: SendClientMessageToAll( HEX_TEAMA , "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~");
		    case TEAM_B: SendClientMessageToAll( HEX_TEAMB , "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~");
		    default: 	 SendClientMessageToAll( COLOR_GREY , "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~");
		}
	}
	else SendClientMessageToAll( COLOR_GREY , "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~");

	//hint_timer = SetTimer("Hint_ChangeFrase", 60000, true);

//	hint_timer = defer Hint_ChangeFrase();

	Weaponsets[0][TeamSelection][TEAM_A] = 0;
	Weaponsets[0][TeamSelection][TEAM_B] = 0;

	Weaponsets[1][TeamSelection][TEAM_A] = 0;
	Weaponsets[1][TeamSelection][TEAM_B] = 0;

	Weaponsets[2][TeamSelection][TEAM_A] = 0;
	Weaponsets[2][TeamSelection][TEAM_B] = 0;

	Weaponsets[3][TeamSelection][TEAM_A] = 0;
	Weaponsets[3][TeamSelection][TEAM_B] = 0;

	Weaponsets[4][TeamSelection][TEAM_A] = 0;
	Weaponsets[4][TeamSelection][TEAM_B] = 0;

	Weaponsets[5][TeamSelection][TEAM_A] = 0;
	Weaponsets[5][TeamSelection][TEAM_B] = 0;

	Weaponsets[6][TeamSelection][TEAM_A] = 0;
	Weaponsets[6][TeamSelection][TEAM_B] = 0;

	Weaponsets[7][TeamSelection][TEAM_A] = 0;
	Weaponsets[7][TeamSelection][TEAM_B] = 0;

	Weaponsets[8][TeamSelection][TEAM_A] = 0;
	Weaponsets[8][TeamSelection][TEAM_B] = 0;

	Weaponsets[9][TeamSelection][TEAM_A] = 0;
	Weaponsets[9][TeamSelection][TEAM_B] = 0;

	Weaponsets[10][TeamSelection][TEAM_A] = 0;
	Weaponsets[10][TeamSelection][TEAM_B] = 0;

	Weaponsets[11][TeamSelection][TEAM_A] = 0;
	Weaponsets[11][TeamSelection][TEAM_B] = 0;

//    LimitPauseUse[TEAM_A] = false;
//    LimitPauseUse[TEAM_B] = false;

	for(new i = 0; i < MAX_VEHICLES; i++)
	{
	    if(GetVehicleVirtualWorld(i) == GAME_WORLD)
		{
	        DestroyVehicleEx(i);
	    }
	}

    //TeamHitsTimer[TEAM_A]   = Timer:-1;
    //TeamHitsTimer[TEAM_B]   = Timer:-1;

//    stop TeamHitsTimer[TEAM_A];
//    stop TeamHitsTimer[TEAM_B];

    iTeam[TEAM_A][TDMKills] = 0;
    iTeam[TEAM_B][TDMKills] = 0;

    RoundFirstBlood         = false;
    Interior_Base           = false;

	Gaming 				= GAMETYPE_NOTHING;
    TeamPlayers[TEAM_A] = 0;
    TeamPlayers[TEAM_B] = 0;
	RealCPTime          = gConfig[TCp];
	GamePaused          = 0;

	Gungame_CurrentLeaderLVL = 0;
	Gungame_CurrentLeader = INVALID_PLAYER_ID;

//	GangZonePulseForAll(ZonaAttornoCP, COLOR_GANGZONE_CAPTURE, COLOR_GANGZONE_NOCAPTURE, 1000);
//	GangZoneStopPulseForAll(ZonaAttornoCP);
	GangZoneStopFlashForAll(ZonaAttornoCP);
	GangZoneDestroy(ZonaAttornoCP);
    KillTimer(Timer_SyncTD);

    esl_timeoutPlayers = 0; // resetto il numero di players crashati; tanto il round ï¿½ finito

	TextDrawSetString( SkinSelection_TDs , !"Welcome to ~r~Slaughterfield A/D");

    Round_PVPMode = 0;
	RefreshTeamPlayers_TD();

	Team1_StartHP = 0;
	Team2_StartHP = 0;

    TotalTeamDMG[ TEAM_A ] = 0;
    TotalTeamDMG[ TEAM_B ] = 0;

//    PausedBy = NULL_TEAM;

	TextDrawHideForAll( DamageTeamA );
	TextDrawHideForAll( DamageTeamB );

	TextDrawHideForAll(CPTimer);

	TextDrawShowForAll( TeamPlayers_TD );

	MySQLStatus[TotalQuerys] ++; mysql_tquery(g_MySQLConnection, sprintf ("DELETE FROM timeouts WHERE gid = %d", G_ID), "", "");

	RefreshTextGeneralTD();
	AntiHits = false;

	if (gConfig[GameMode] == GAMEMODE_ESL)
	{
	    // se non deve mostrare il final td
	    if(!process_finaltd)
	    {
	 		TextDrawShowForAll(ESLModeReady[0]);
	 		TextDrawShowForAll(ESLModeReady[1]);
	 		TextDrawShowForAll(ESLModeReady[2]);
	 		TextDrawShowForAll(ESLModeReady[3]);
	 		RefreshReadyTDs_Esl();
 		}
	}

/*	for (new i = 0; i < tottronchi; i++)
	{
		if (IsValidObject(tronchi_primiid[i]))
		{
			DestroyDynamicObject(tronchi_primiid[i]);
			DestroyDynamicObject(tronchi_primiid[i]+1);
			DestroyDynamicObject(tronchi_primiid[i]+2);
			DestroyDynamicObject(tronchi_primiid[i]+3);
			DestroyDynamicObject(tronchi_primiid[i]+4);
			DestroyDynamicObject(tronchi_primiid[i]+5);
		}

		tronchi_primiid[i] = -1;
	}

	tottronchi = 0;
*/
    consegutive = 0, lastKiller = INVALID_PLAYER_ID;

    // for now i didnt do ChangeSavedAttributeForEveryone cuz i dont think i need it
    /*
    for (new i = 0; i < MAX_SAVE_SLOTS; ++i) {
        if (SavedPlayer[i][sAssigned] && SavedPlayer[i][sPlayed]) {
            SavedPlayer[i][sPlayed] = false;
        }
    }
*/
 	//SetWorldTime(gConfig[GameTime]);
	return true;
}

//forward AutoHideTD();
timer AutoHideTD[5000]()
{
	new p = 0;
	foreach(new playerid:Player)
	{
	    if (Player[playerid][FinalRound_Status] == FINALROUND_STATUS_FORCED)
	    {
			new cv = Player[playerid][CurrentView];

			for (new i2 = 0; i2 < MAX_STATIC_TEXTDRAWS; i2++) TextDrawHideForPlayer(playerid, FineRound_Static[i2]);

			TextDrawHideForPlayer(playerid, FineRound_Dynamic[cv][BluePlayers]);
			TextDrawHideForPlayer(playerid, FineRound_Dynamic[cv][GreenPlayers]);
			TextDrawHideForPlayer(playerid, FineRound_Dynamic[cv][BlueKills]);
			TextDrawHideForPlayer(playerid, FineRound_Dynamic[cv][BlueDamages]);
			TextDrawHideForPlayer(playerid, FineRound_Dynamic[cv][GreenKills]);
			TextDrawHideForPlayer(playerid, FineRound_Dynamic[cv][GreenDamage]);
			TextDrawHideForPlayer(playerid, FineRound_Dynamic[cv][TotalKGreen]);
			TextDrawHideForPlayer(playerid, FineRound_Dynamic[cv][TotalDGreen]);
			TextDrawHideForPlayer(playerid, FineRound_Dynamic[cv][TotalKBlue]);
			TextDrawHideForPlayer(playerid, FineRound_Dynamic[cv][TotalDBlue]);
			TextDrawHideForPlayer(playerid, FineRound_Dynamic[cv][Top2_Nick]);
			TextDrawHideForPlayer(playerid, FineRound_Dynamic[cv][Top2_Stats]);
			TextDrawHideForPlayer(playerid, FineRound_Dynamic[cv][Top3_Stats]);
			TextDrawHideForPlayer(playerid, FineRound_Dynamic[cv][Top3_Nick]);
			TextDrawHideForPlayer(playerid, FineRound_Dynamic[cv][Top1_Stats]);
			TextDrawHideForPlayer(playerid, FineRound_Dynamic[cv][Top1_Nick]);
			TextDrawHideForPlayer(playerid, FineRound_Dynamic[cv][RoundsInfo]);
			TextDrawHideForPlayer(playerid, FineRound_Dynamic[cv][AttDefWin]);
		 	TextDrawHideForPlayer(playerid, FineRound_Dynamic[cv][Stringa_Winner2]);
		 	TextDrawHideForPlayer(playerid, FineRound_Dynamic[cv][Stringa_TeamWin]);
		  	TextDrawHideForPlayer(playerid, FineRound_Dynamic[cv][Stringa_Winner1]);
			TextDrawHideForPlayer(playerid, FineRound_Dynamic[cv][Stringa_RoundInfo]);
		 	TextDrawHideForPlayer(playerid, FineRound_Dynamic[cv][Stringa_TmpBest]);
		}

		if (Player[playerid][IsAfk]) continue;
		if (!Player[playerid][Spawned]) continue;
		if (Player[playerid][Team] == TEAM_A || Player[playerid][Team] == TEAM_B)
			p ++;
	}

	if (gConfig[AutoAD])
	{
    	AutoAD_Start (p);
	}
}

//forward AutoAD_Start(p);
timer AutoAD_Start[10000](p)
{
	if (p == -1)
	{
	    p = 0;

	    foreach (new i:Player)
	    {
	        if (!Player[i][Spawned] || Player[i][IsAfk]) continue;
			if (Player[i][Team] == TEAM_A || Player[i][Team] == TEAM_B)
			{
			    p ++;
			}
	    }
	}

	if (p < 2)
	{
	    SendClientMessageToAll (COLOR_SYSTEM, "* Auto start failed: Devono esserci almeno 2 giocatori!");
	}
	else
	{
	    if (p < 3)
	    {
	        SendClientMessageToAll(COLOR_SYSTEM, "* Round: Next round will be Player Vs Player.");
	        // start pvp

		    new pA = 0, pB = 0;

		    foreach(new i:Player)
			{
				if(Player[i][IsAfk]) continue;
				if(!Player[i][Spawned]) continue;

		        if(Player[i][Team] == TEAM_A) pA++;
		        if(Player[i][Team] == TEAM_B) pB++;
		    }

		    if( pA == 0 || pA > 1)
			{
				SendClientMessageToAll(red, "1 player only must be in the 1st team! Attendi altri 10 secondi!..");
				//SetTimerEx("AutoAD_Start", 10000, false, "i", -1);

				defer AutoAD_Start(-1);
				return 1;
			}

		    if( pB == 0 || pB > 1)
			{
				SendClientMessageToAll(red, "1 player only must be in the 2nd team! Attendi altri 10 secondi!..");
				//SetTimerEx("AutoAD_Start", 10000, false, "i", -1);

				defer AutoAD_Start(-1);
				return 1;
			}

			LastRoundType = GAMETYPE_PVP;
			Round_PVPMode = 1;

			new id;
			do
			{
			    id = random(MAX_ARENE);
			}
			while(!aArene[id][Exists] || !aArene[id][bForPVP]);

		    StartRound(id, GAMETYPE_ARENA);
	    }
	    else if(p >= 3 && p <= 4)
	    {
	        SendClientMessageToAll(COLOR_SYSTEM, "* Round: Next round will be Interior Base.");
	        // start ints
	        new id;

			do {
			    id = random(MAX_INTS);
			}
			while(!iBases[id][Exists]);

			Interior_Base = true;
			LastRoundType = GAMETYPE_INTS;
			StartRound(id, GAMETYPE_BASE, .xrandom = 1);
	    }
	    else if(p > 4)
	    {
	        // 4 basi, 1 arena
	        if (AutoAD_Cycle > 4)
	        {
	            SendClientMessageToAll(COLOR_SYSTEM, "* Round: Next round will be Arena.");

				new id;

	            // STart arena
				do {
				    id = random(MAX_ARENE);
				}
				while(!aArene[id][Exists]);

				StartRound(id, GAMETYPE_ARENA, .xrandom =  1);
				LastRoundType = GAMETYPE_ARENA;

	            AutoAD_Cycle = 0;
	        }
	        else
	        {
	            SendClientMessageToAll(COLOR_SYSTEM, "* Round: Next round will be Base.");
	            // Start base
	            new id;

				do
				{
				    id = random(basesPacks[CurrentGamepack][maxBases]);
				}
				while(!bBases[id][Exists]);

				LastRoundType = GAMETYPE_BASE;
				StartRound(id, GAMETYPE_BASE, .xrandom = 1);

	            AutoAD_Cycle ++;
	        }
	    }
	}

	return true;
}

public OnPlayerClickTextDraw(playerid, Text:clickedid)
{
	//format(stringo, sizeof stringo, "Player[playerid][SkinSelection] = %d", Player[playerid][SkinSelection]);
	//SendClientMessageToAll(-1, stringo);

    if(clickedid == FineRound_Static[26])
    {
		new cv = Player[playerid][CurrentView];

		for (new i2 = 0; i2 < MAX_STATIC_TEXTDRAWS; i2++) TextDrawHideForPlayer(playerid, FineRound_Static[i2]);

		TextDrawHideForPlayer(playerid, FineRound_Dynamic[cv][BluePlayers]);
		TextDrawHideForPlayer(playerid, FineRound_Dynamic[cv][GreenPlayers]);
		TextDrawHideForPlayer(playerid, FineRound_Dynamic[cv][BlueKills]);
		TextDrawHideForPlayer(playerid, FineRound_Dynamic[cv][BlueDamages]);
		TextDrawHideForPlayer(playerid, FineRound_Dynamic[cv][GreenKills]);
		TextDrawHideForPlayer(playerid, FineRound_Dynamic[cv][GreenDamage]);
		TextDrawHideForPlayer(playerid, FineRound_Dynamic[cv][TotalKGreen]);
		TextDrawHideForPlayer(playerid, FineRound_Dynamic[cv][TotalDGreen]);
		TextDrawHideForPlayer(playerid, FineRound_Dynamic[cv][TotalKBlue]);
		TextDrawHideForPlayer(playerid, FineRound_Dynamic[cv][TotalDBlue]);
		TextDrawHideForPlayer(playerid, FineRound_Dynamic[cv][Top2_Nick]);
		TextDrawHideForPlayer(playerid, FineRound_Dynamic[cv][Top2_Stats]);
		TextDrawHideForPlayer(playerid, FineRound_Dynamic[cv][Top3_Stats]);
		TextDrawHideForPlayer(playerid, FineRound_Dynamic[cv][Top3_Nick]);
		TextDrawHideForPlayer(playerid, FineRound_Dynamic[cv][Top1_Stats]);
		TextDrawHideForPlayer(playerid, FineRound_Dynamic[cv][Top1_Nick]);
		TextDrawHideForPlayer(playerid, FineRound_Dynamic[cv][RoundsInfo]);
		TextDrawHideForPlayer(playerid, FineRound_Dynamic[cv][AttDefWin]);
	 	TextDrawHideForPlayer(playerid, FineRound_Dynamic[cv][Stringa_Winner2]);
	 	TextDrawHideForPlayer(playerid, FineRound_Dynamic[cv][Stringa_TeamWin]);
	  	TextDrawHideForPlayer(playerid, FineRound_Dynamic[cv][Stringa_Winner1]);
		TextDrawHideForPlayer(playerid, FineRound_Dynamic[cv][Stringa_RoundInfo]);
		TextDrawHideForPlayer(playerid, FineRound_Dynamic[cv][Stringa_TmpBest]);

		Player[playerid][FinalRound_Status] = FINALROUND_STATUS_HIDDEN;
		if (gConfig[Matchmode] == MATCHMODE_TCWCW)
			CancelSelectTextDraw(playerid);
    }
    else if(clickedid == FineRound_Static[29])
    {
		if (Player[playerid][CurrentView] == PlayingRound && PlayingRound == 1)
		    return true;

		new cv = Player[playerid][CurrentView];

		TextDrawHideForPlayer(playerid, FineRound_Dynamic[cv][BluePlayers]);
		TextDrawHideForPlayer(playerid, FineRound_Dynamic[cv][GreenPlayers]);
		TextDrawHideForPlayer(playerid, FineRound_Dynamic[cv][BlueKills]);
		TextDrawHideForPlayer(playerid, FineRound_Dynamic[cv][BlueDamages]);
		TextDrawHideForPlayer(playerid, FineRound_Dynamic[cv][GreenKills]);
		TextDrawHideForPlayer(playerid, FineRound_Dynamic[cv][GreenDamage]);
		TextDrawHideForPlayer(playerid, FineRound_Dynamic[cv][TotalKGreen]);
		TextDrawHideForPlayer(playerid, FineRound_Dynamic[cv][TotalDGreen]);
		TextDrawHideForPlayer(playerid, FineRound_Dynamic[cv][TotalKBlue]);
		TextDrawHideForPlayer(playerid, FineRound_Dynamic[cv][TotalDBlue]);
		TextDrawHideForPlayer(playerid, FineRound_Dynamic[cv][Top2_Nick]);
		TextDrawHideForPlayer(playerid, FineRound_Dynamic[cv][Top2_Stats]);
		TextDrawHideForPlayer(playerid, FineRound_Dynamic[cv][Top3_Stats]);
		TextDrawHideForPlayer(playerid, FineRound_Dynamic[cv][Top3_Nick]);
		TextDrawHideForPlayer(playerid, FineRound_Dynamic[cv][Top1_Stats]);
		TextDrawHideForPlayer(playerid, FineRound_Dynamic[cv][Top1_Nick]);
		TextDrawHideForPlayer(playerid, FineRound_Dynamic[cv][RoundsInfo]);
		TextDrawHideForPlayer(playerid, FineRound_Dynamic[cv][AttDefWin]);
	 	TextDrawHideForPlayer(playerid, FineRound_Dynamic[cv][Stringa_Winner2]);
	 	TextDrawHideForPlayer(playerid, FineRound_Dynamic[cv][Stringa_TeamWin]);
	  	TextDrawHideForPlayer(playerid, FineRound_Dynamic[cv][Stringa_Winner1]);
		TextDrawHideForPlayer(playerid, FineRound_Dynamic[cv][Stringa_RoundInfo]);
		TextDrawHideForPlayer(playerid, FineRound_Dynamic[cv][Stringa_TmpBest]);

        Player[playerid][CurrentView] ++;
        if (Player[playerid][CurrentView] > PlayingRound)
        {
			Player[playerid][CurrentView] = 1;
        }

		cv = Player[playerid][CurrentView];
/*
		TextDrawShowForPlayer(playerid, FineRound_Dynamic[Player[playerid][CurrentView]][BluePlayers]);
		TextDrawShowForPlayer(playerid, FineRound_Dynamic[Player[playerid][CurrentView]][GreenPlayers]);
		TextDrawShowForPlayer(playerid, FineRound_Dynamic[Player[playerid][CurrentView]][BlueKills]);
		TextDrawShowForPlayer(playerid, FineRound_Dynamic[Player[playerid][CurrentView]][BlueDamages]);
		TextDrawShowForPlayer(playerid, FineRound_Dynamic[Player[playerid][CurrentView]][GreenKills]);
		TextDrawShowForPlayer(playerid, FineRound_Dynamic[Player[playerid][CurrentView]][GreenDamage]);
		TextDrawShowForPlayer(playerid, FineRound_Dynamic[Player[playerid][CurrentView]][TotalKGreen]);
		TextDrawShowForPlayer(playerid, FineRound_Dynamic[Player[playerid][CurrentView]][TotalDGreen]);
		TextDrawShowForPlayer(playerid, FineRound_Dynamic[Player[playerid][CurrentView]][TotalKBlue]);
		TextDrawShowForPlayer(playerid, FineRound_Dynamic[Player[playerid][CurrentView]][TotalDBlue]);
		TextDrawShowForPlayer(playerid, FineRound_Dynamic[Player[playerid][CurrentView]][Top2_Nick]);
		TextDrawShowForPlayer(playerid, FineRound_Dynamic[Player[playerid][CurrentView]][Top2_Stats]);
		TextDrawShowForPlayer(playerid, FineRound_Dynamic[Player[playerid][CurrentView]][Top3_Stats]);
		TextDrawShowForPlayer(playerid, FineRound_Dynamic[Player[playerid][CurrentView]][Top3_Nick]);
		TextDrawShowForPlayer(playerid, FineRound_Dynamic[Player[playerid][CurrentView]][Top1_Stats]);
		TextDrawShowForPlayer(playerid, FineRound_Dynamic[Player[playerid][CurrentView]][Top1_Nick]);
		TextDrawShowForPlayer(playerid, FineRound_Dynamic[Player[playerid][CurrentView]][RoundsInfo]);
		TextDrawShowForPlayer(playerid, FineRound_Dynamic[Player[playerid][CurrentView]][AttDefWin]);
        TextDrawShowForPlayer(playerid, FineRound_Dynamic[Player[playerid][CurrentView]][Stringa_Winner2]);
        TextDrawShowForPlayer(playerid, FineRound_Dynamic[Player[playerid][CurrentView]][Stringa_TeamWin]);
        TextDrawShowForPlayer(playerid, FineRound_Dynamic[Player[playerid][CurrentView]][Stringa_Winner1]);
		TextDrawShowForPlayer(playerid, FineRound_Dynamic[Player[playerid][CurrentView]][Stringa_RoundInfo]);
        TextDrawShowForPlayer(playerid, FineRound_Dynamic[Player[playerid][CurrentView]][Stringa_TmpBest]);
*/
		TextDrawShowForPlayer(playerid, FineRound_Dynamic[cv][BluePlayers]);
		TextDrawShowForPlayer(playerid, FineRound_Dynamic[cv][GreenPlayers]);
		TextDrawShowForPlayer(playerid, FineRound_Dynamic[cv][BlueKills]);
		TextDrawShowForPlayer(playerid, FineRound_Dynamic[cv][BlueDamages]);
		TextDrawShowForPlayer(playerid, FineRound_Dynamic[cv][GreenKills]);
		TextDrawShowForPlayer(playerid, FineRound_Dynamic[cv][GreenDamage]);
		TextDrawShowForPlayer(playerid, FineRound_Dynamic[cv][TotalKGreen]);
		TextDrawShowForPlayer(playerid, FineRound_Dynamic[cv][TotalDGreen]);
		TextDrawShowForPlayer(playerid, FineRound_Dynamic[cv][TotalKBlue]);
		TextDrawShowForPlayer(playerid, FineRound_Dynamic[cv][TotalDBlue]);
		TextDrawShowForPlayer(playerid, FineRound_Dynamic[cv][Top2_Nick]);
		TextDrawShowForPlayer(playerid, FineRound_Dynamic[cv][Top2_Stats]);
		TextDrawShowForPlayer(playerid, FineRound_Dynamic[cv][Top3_Stats]);
		TextDrawShowForPlayer(playerid, FineRound_Dynamic[cv][Top3_Nick]);
		TextDrawShowForPlayer(playerid, FineRound_Dynamic[cv][Top1_Stats]);
		TextDrawShowForPlayer(playerid, FineRound_Dynamic[cv][Top1_Nick]);
		TextDrawShowForPlayer(playerid, FineRound_Dynamic[cv][RoundsInfo]);
		TextDrawShowForPlayer(playerid, FineRound_Dynamic[cv][AttDefWin]);
	 	TextDrawShowForPlayer(playerid, FineRound_Dynamic[cv][Stringa_Winner2]);
	 	TextDrawShowForPlayer(playerid, FineRound_Dynamic[cv][Stringa_TeamWin]);
	  	TextDrawShowForPlayer(playerid, FineRound_Dynamic[cv][Stringa_Winner1]);
		TextDrawShowForPlayer(playerid, FineRound_Dynamic[cv][Stringa_RoundInfo]);
		TextDrawShowForPlayer(playerid, FineRound_Dynamic[cv][Stringa_TmpBest]);

	}
    else if(clickedid == FineRound_Static[34])
    {
		if (Player[playerid][CurrentView] == 1)
		    return true;

		new cv = Player[playerid][CurrentView];

		TextDrawHideForPlayer(playerid, FineRound_Dynamic[cv][BluePlayers]);
		TextDrawHideForPlayer(playerid, FineRound_Dynamic[cv][GreenPlayers]);
		TextDrawHideForPlayer(playerid, FineRound_Dynamic[cv][BlueKills]);
		TextDrawHideForPlayer(playerid, FineRound_Dynamic[cv][BlueDamages]);
		TextDrawHideForPlayer(playerid, FineRound_Dynamic[cv][GreenKills]);
		TextDrawHideForPlayer(playerid, FineRound_Dynamic[cv][GreenDamage]);
		TextDrawHideForPlayer(playerid, FineRound_Dynamic[cv][TotalKGreen]);
		TextDrawHideForPlayer(playerid, FineRound_Dynamic[cv][TotalDGreen]);
		TextDrawHideForPlayer(playerid, FineRound_Dynamic[cv][TotalKBlue]);
		TextDrawHideForPlayer(playerid, FineRound_Dynamic[cv][TotalDBlue]);
		TextDrawHideForPlayer(playerid, FineRound_Dynamic[cv][Top2_Nick]);
		TextDrawHideForPlayer(playerid, FineRound_Dynamic[cv][Top2_Stats]);
		TextDrawHideForPlayer(playerid, FineRound_Dynamic[cv][Top3_Stats]);
		TextDrawHideForPlayer(playerid, FineRound_Dynamic[cv][Top3_Nick]);
		TextDrawHideForPlayer(playerid, FineRound_Dynamic[cv][Top1_Stats]);
		TextDrawHideForPlayer(playerid, FineRound_Dynamic[cv][Top1_Nick]);
		TextDrawHideForPlayer(playerid, FineRound_Dynamic[cv][RoundsInfo]);
		TextDrawHideForPlayer(playerid, FineRound_Dynamic[cv][AttDefWin]);
	 	TextDrawHideForPlayer(playerid, FineRound_Dynamic[cv][Stringa_Winner2]);
	 	TextDrawHideForPlayer(playerid, FineRound_Dynamic[cv][Stringa_TeamWin]);
	  	TextDrawHideForPlayer(playerid, FineRound_Dynamic[cv][Stringa_Winner1]);
		TextDrawHideForPlayer(playerid, FineRound_Dynamic[cv][Stringa_RoundInfo]);
		TextDrawHideForPlayer(playerid, FineRound_Dynamic[cv][Stringa_TmpBest]);

        Player[playerid][CurrentView] --;
        if (Player[playerid][CurrentView] < 1)
        {
			Player[playerid][CurrentView] = 1;
        }

		/*
		TextDrawShowForPlayer(playerid, FineRound_Dynamic[Player[playerid][CurrentView]][BluePlayers]);
		TextDrawShowForPlayer(playerid, FineRound_Dynamic[Player[playerid][CurrentView]][GreenPlayers]);
		TextDrawShowForPlayer(playerid, FineRound_Dynamic[Player[playerid][CurrentView]][BlueKills]);
		TextDrawShowForPlayer(playerid, FineRound_Dynamic[Player[playerid][CurrentView]][BlueDamages]);
		TextDrawShowForPlayer(playerid, FineRound_Dynamic[Player[playerid][CurrentView]][GreenKills]);
		TextDrawShowForPlayer(playerid, FineRound_Dynamic[Player[playerid][CurrentView]][GreenDamage]);
		TextDrawShowForPlayer(playerid, FineRound_Dynamic[Player[playerid][CurrentView]][TotalKGreen]);
		TextDrawShowForPlayer(playerid, FineRound_Dynamic[Player[playerid][CurrentView]][TotalDGreen]);
		TextDrawShowForPlayer(playerid, FineRound_Dynamic[Player[playerid][CurrentView]][TotalKBlue]);
		TextDrawShowForPlayer(playerid, FineRound_Dynamic[Player[playerid][CurrentView]][TotalDBlue]);
		TextDrawShowForPlayer(playerid, FineRound_Dynamic[Player[playerid][CurrentView]][Top2_Nick]);
		TextDrawShowForPlayer(playerid, FineRound_Dynamic[Player[playerid][CurrentView]][Top2_Stats]);
		TextDrawShowForPlayer(playerid, FineRound_Dynamic[Player[playerid][CurrentView]][Top3_Stats]);
		TextDrawShowForPlayer(playerid, FineRound_Dynamic[Player[playerid][CurrentView]][Top3_Nick]);
		TextDrawShowForPlayer(playerid, FineRound_Dynamic[Player[playerid][CurrentView]][Top1_Stats]);
		TextDrawShowForPlayer(playerid, FineRound_Dynamic[Player[playerid][CurrentView]][Top1_Nick]);
		TextDrawShowForPlayer(playerid, FineRound_Dynamic[Player[playerid][CurrentView]][RoundsInfo]);
		TextDrawShowForPlayer(playerid, FineRound_Dynamic[Player[playerid][CurrentView]][AttDefWin]);
        TextDrawShowForPlayer(playerid, FineRound_Dynamic[Player[playerid][CurrentView]][Stringa_Winner2]);
        TextDrawShowForPlayer(playerid, FineRound_Dynamic[Player[playerid][CurrentView]][Stringa_TeamWin]);
        TextDrawShowForPlayer(playerid, FineRound_Dynamic[Player[playerid][CurrentView]][Stringa_Winner1]);
		TextDrawShowForPlayer(playerid, FineRound_Dynamic[Player[playerid][CurrentView]][Stringa_RoundInfo]);
        TextDrawShowForPlayer(playerid, FineRound_Dynamic[Player[playerid][CurrentView]][Stringa_TmpBest]);*/

		cv = Player[playerid][CurrentView];

		TextDrawShowForPlayer(playerid, FineRound_Dynamic[cv][BluePlayers]);
		TextDrawShowForPlayer(playerid, FineRound_Dynamic[cv][GreenPlayers]);
		TextDrawShowForPlayer(playerid, FineRound_Dynamic[cv][BlueKills]);
		TextDrawShowForPlayer(playerid, FineRound_Dynamic[cv][BlueDamages]);
		TextDrawShowForPlayer(playerid, FineRound_Dynamic[cv][GreenKills]);
		TextDrawShowForPlayer(playerid, FineRound_Dynamic[cv][GreenDamage]);
		TextDrawShowForPlayer(playerid, FineRound_Dynamic[cv][TotalKGreen]);
		TextDrawShowForPlayer(playerid, FineRound_Dynamic[cv][TotalDGreen]);
		TextDrawShowForPlayer(playerid, FineRound_Dynamic[cv][TotalKBlue]);
		TextDrawShowForPlayer(playerid, FineRound_Dynamic[cv][TotalDBlue]);
		TextDrawShowForPlayer(playerid, FineRound_Dynamic[cv][Top2_Nick]);
		TextDrawShowForPlayer(playerid, FineRound_Dynamic[cv][Top2_Stats]);
		TextDrawShowForPlayer(playerid, FineRound_Dynamic[cv][Top3_Stats]);
		TextDrawShowForPlayer(playerid, FineRound_Dynamic[cv][Top3_Nick]);
		TextDrawShowForPlayer(playerid, FineRound_Dynamic[cv][Top1_Stats]);
		TextDrawShowForPlayer(playerid, FineRound_Dynamic[cv][Top1_Nick]);
		TextDrawShowForPlayer(playerid, FineRound_Dynamic[cv][RoundsInfo]);
		TextDrawShowForPlayer(playerid, FineRound_Dynamic[cv][AttDefWin]);
	 	TextDrawShowForPlayer(playerid, FineRound_Dynamic[cv][Stringa_Winner2]);
	 	TextDrawShowForPlayer(playerid, FineRound_Dynamic[cv][Stringa_TeamWin]);
	  	TextDrawShowForPlayer(playerid, FineRound_Dynamic[cv][Stringa_Winner1]);
		TextDrawShowForPlayer(playerid, FineRound_Dynamic[cv][Stringa_RoundInfo]);
		TextDrawShowForPlayer(playerid, FineRound_Dynamic[cv][Stringa_TmpBest]);
	}
    else if(clickedid == Text:0xFFFF)//Text:INVALID_TEXT_DRAW
    {
        //SendClientMessageToAll(-1," 0xFFFF -> esc");
		if (Player[playerid][FinalRound_Status] == FINALROUND_STATUS_SHOW || Player[playerid][FinalRound_Status] == FINALROUND_STATUS_FORCED)
		{
			new cv = Player[playerid][CurrentView];

			for (new i2 = 0; i2 < MAX_STATIC_TEXTDRAWS; i2++) TextDrawHideForPlayer(playerid, FineRound_Static[i2]);

			/*TextDrawHideForPlayer(playerid, FineRound_Dynamic[Player[playerid][CurrentView]][BluePlayers]);
			TextDrawHideForPlayer(playerid, FineRound_Dynamic[Player[playerid][CurrentView]][GreenPlayers]);
			TextDrawHideForPlayer(playerid, FineRound_Dynamic[Player[playerid][CurrentView]][BlueKills]);
			TextDrawHideForPlayer(playerid, FineRound_Dynamic[Player[playerid][CurrentView]][BlueDamages]);
			TextDrawHideForPlayer(playerid, FineRound_Dynamic[Player[playerid][CurrentView]][GreenKills]);
			TextDrawHideForPlayer(playerid, FineRound_Dynamic[Player[playerid][CurrentView]][GreenDamage]);
			TextDrawHideForPlayer(playerid, FineRound_Dynamic[Player[playerid][CurrentView]][TotalKGreen]);
			TextDrawHideForPlayer(playerid, FineRound_Dynamic[Player[playerid][CurrentView]][TotalDGreen]);
			TextDrawHideForPlayer(playerid, FineRound_Dynamic[Player[playerid][CurrentView]][TotalKBlue]);
			TextDrawHideForPlayer(playerid, FineRound_Dynamic[Player[playerid][CurrentView]][TotalDBlue]);
			TextDrawHideForPlayer(playerid, FineRound_Dynamic[Player[playerid][CurrentView]][Top2_Nick]);
			TextDrawHideForPlayer(playerid, FineRound_Dynamic[Player[playerid][CurrentView]][Top2_Stats]);
			TextDrawHideForPlayer(playerid, FineRound_Dynamic[Player[playerid][CurrentView]][Top3_Stats]);
			TextDrawHideForPlayer(playerid, FineRound_Dynamic[Player[playerid][CurrentView]][Top3_Nick]);
			TextDrawHideForPlayer(playerid, FineRound_Dynamic[Player[playerid][CurrentView]][Top1_Stats]);
			TextDrawHideForPlayer(playerid, FineRound_Dynamic[Player[playerid][CurrentView]][Top1_Nick]);
			TextDrawHideForPlayer(playerid, FineRound_Dynamic[Player[playerid][CurrentView]][RoundsInfo]);
			TextDrawHideForPlayer(playerid, FineRound_Dynamic[Player[playerid][CurrentView]][AttDefWin]);
	        TextDrawHideForPlayer(playerid, FineRound_Dynamic[Player[playerid][CurrentView]][Stringa_Winner2]);
	        TextDrawHideForPlayer(playerid, FineRound_Dynamic[Player[playerid][CurrentView]][Stringa_TeamWin]);
	        TextDrawHideForPlayer(playerid, FineRound_Dynamic[Player[playerid][CurrentView]][Stringa_Winner1]);
			TextDrawHideForPlayer(playerid, FineRound_Dynamic[Player[playerid][CurrentView]][Stringa_RoundInfo]);
	        TextDrawHideForPlayer(playerid, FineRound_Dynamic[Player[playerid][CurrentView]][Stringa_TmpBest]);*/

			TextDrawHideForPlayer(playerid, FineRound_Dynamic[cv][BluePlayers]);
			TextDrawHideForPlayer(playerid, FineRound_Dynamic[cv][GreenPlayers]);
			TextDrawHideForPlayer(playerid, FineRound_Dynamic[cv][BlueKills]);
			TextDrawHideForPlayer(playerid, FineRound_Dynamic[cv][BlueDamages]);
			TextDrawHideForPlayer(playerid, FineRound_Dynamic[cv][GreenKills]);
			TextDrawHideForPlayer(playerid, FineRound_Dynamic[cv][GreenDamage]);
			TextDrawHideForPlayer(playerid, FineRound_Dynamic[cv][TotalKGreen]);
			TextDrawHideForPlayer(playerid, FineRound_Dynamic[cv][TotalDGreen]);
			TextDrawHideForPlayer(playerid, FineRound_Dynamic[cv][TotalKBlue]);
			TextDrawHideForPlayer(playerid, FineRound_Dynamic[cv][TotalDBlue]);
			TextDrawHideForPlayer(playerid, FineRound_Dynamic[cv][Top2_Nick]);
			TextDrawHideForPlayer(playerid, FineRound_Dynamic[cv][Top2_Stats]);
			TextDrawHideForPlayer(playerid, FineRound_Dynamic[cv][Top3_Stats]);
			TextDrawHideForPlayer(playerid, FineRound_Dynamic[cv][Top3_Nick]);
			TextDrawHideForPlayer(playerid, FineRound_Dynamic[cv][Top1_Stats]);
			TextDrawHideForPlayer(playerid, FineRound_Dynamic[cv][Top1_Nick]);
			TextDrawHideForPlayer(playerid, FineRound_Dynamic[cv][RoundsInfo]);
			TextDrawHideForPlayer(playerid, FineRound_Dynamic[cv][AttDefWin]);
			TextDrawHideForPlayer(playerid, FineRound_Dynamic[cv][Stringa_Winner2]);
			TextDrawHideForPlayer(playerid, FineRound_Dynamic[cv][Stringa_TeamWin]);
			TextDrawHideForPlayer(playerid, FineRound_Dynamic[cv][Stringa_Winner1]);
			TextDrawHideForPlayer(playerid, FineRound_Dynamic[cv][Stringa_RoundInfo]);
			TextDrawHideForPlayer(playerid, FineRound_Dynamic[cv][Stringa_TmpBest]);

			Player[playerid][FinalRound_Status] = FINALROUND_STATUS_HIDDEN;
		}
		else if (Player[playerid][SkinSelection] && !Player[playerid][fake_selection])
		{
		    // auto-assign
	        //SendClientMessageToAll(-1, "autoassign");
			//Spawn as attacker
			SpawnPlayerSelection(playerid, -1);
		}
    }
    // att
    else if (clickedid == Classtd_SpawnTN[0] || clickedid == Classtd_SpawnTN[4] || clickedid == Classtd_SpawnTN[7])
    {
        //Spawn as att
        //SendClientMessageToAll(-1, "clicked att");
		SpawnPlayerSelection(playerid, TEAM_A);
    }
    // def
    else if (clickedid == Classtd_SpawnTN[1] || clickedid == Classtd_SpawnTN[3] || clickedid == Classtd_SpawnTN[6])
    {
        //SendClientMessageToAll(-1, "clicked def");
		//Spawn as def
		SpawnPlayerSelection(playerid, TEAM_B);
    }
    // 29(avanti) / 34(indietro) (hide: 26)
    //SendClientMessageToAll(-1, "end ended - no cases?");
    return 1;
}

/*
forward HideFinalTD();
public  HideFinalTD()
{
	foreach(new x:Player)
	{
	    if(Player[x][FinalRound_Status] == FINALROUND_STATUS_FORCED)
		{
		    for (new i = 0; i < MAX_STATIC_TEXTDRAWS; i++) TextDrawHideForPlayer(x, FineRound_Static[i]);

			TextDrawHideForPlayer(x, FineRound_Dynamic[Player[x][CurrentView]][BluePlayers]);
			TextDrawHideForPlayer(x, FineRound_Dynamic[Player[x][CurrentView]][GreenPlayers]);
			TextDrawHideForPlayer(x, FineRound_Dynamic[Player[x][CurrentView]][BlueKills]);
			TextDrawHideForPlayer(x, FineRound_Dynamic[Player[x][CurrentView]][BlueDamages]);
			TextDrawHideForPlayer(x, FineRound_Dynamic[Player[x][CurrentView]][GreenKills]);
			TextDrawHideForPlayer(x, FineRound_Dynamic[Player[x][CurrentView]][GreenDamage]);
			TextDrawHideForPlayer(x, FineRound_Dynamic[Player[x][CurrentView]][TotalKGreen]);
			TextDrawHideForPlayer(x, FineRound_Dynamic[Player[x][CurrentView]][TotalDGreen]);
			TextDrawHideForPlayer(x, FineRound_Dynamic[Player[x][CurrentView]][TotalKBlue]);
			TextDrawHideForPlayer(x, FineRound_Dynamic[Player[x][CurrentView]][TotalDBlue]);
			TextDrawHideForPlayer(x, FineRound_Dynamic[Player[x][CurrentView]][Top2_Nick]);
			TextDrawHideForPlayer(x, FineRound_Dynamic[Player[x][CurrentView]][Top2_Stats]);
			TextDrawHideForPlayer(x, FineRound_Dynamic[Player[x][CurrentView]][Top3_Stats]);
			TextDrawHideForPlayer(x, FineRound_Dynamic[Player[x][CurrentView]][Top3_Nick]);
			TextDrawHideForPlayer(x, FineRound_Dynamic[Player[x][CurrentView]][Top1_Stats]);
			TextDrawHideForPlayer(x, FineRound_Dynamic[Player[x][CurrentView]][Top1_Nick]);
			TextDrawHideForPlayer(x, FineRound_Dynamic[Player[x][CurrentView]][RoundsInfo]);
			TextDrawHideForPlayer(x, FineRound_Dynamic[Player[x][CurrentView]][AttDefWin]);
	        TextDrawHideForPlayer(x, FineRound_Dynamic[Player[x][CurrentView]][Stringa_Winner2]);
	        TextDrawHideForPlayer(x, FineRound_Dynamic[Player[x][CurrentView]][Stringa_TeamWin]);
	        TextDrawHideForPlayer(x, FineRound_Dynamic[Player[x][CurrentView]][Stringa_Winner1]);
			TextDrawHideForPlayer(x, FineRound_Dynamic[Player[x][CurrentView]][Stringa_RoundInfo]);
	        TextDrawHideForPlayer(x, FineRound_Dynamic[Player[x][CurrentView]][Stringa_TmpBest]);

	        Player[x][FinalRound_Status] = FINALROUND_STATUS_HIDDEN;
	    }
	}
	return true;
}*/

stock BalancePlayers(playerid = INVALID_PLAYER_ID)
{
	new
	    Float:x,
	    Float:y,
	    Float:z,
	    Float:a,
		lt = TEAM_A;

	foreach(new i:Player)
	{
	    if(!Player[i][Spawned]) continue;
	    if (Player[i][IsAfk]) continue;

		if (Player[i][Team] == TEAM_A || Player[i][Team] == TEAM_B)
	    {
	        iTeam[Player[i][Team]][tPlayers] --;

		    GetPlayerPos(i, x, y, z);
		    GetPlayerFacingAngle(i, a);

         	if (lt == TEAM_A)
          	{
           		Player[ i ][ Team ] = TEAM_A;
           		iTeam[TEAM_A][tPlayers] ++;
           		SetSpawnInfo(i, TEAM_A, GetPlayerSkinEx(i), x, y, z - 0.5, a, 0, 0, 0, 0, 0, 0);
				lt = TEAM_B;
       		}
      		else
        	{
         		Player[ i ][ Team ] = TEAM_B;
         		iTeam[TEAM_B][tPlayers] ++;
         		SetSpawnInfo(i, TEAM_B, GetPlayerSkinEx(i), x, y, z - 0.5, a, 0, 0, 0, 0, 0, 0);
         		lt = TEAM_A;
         	}

			Sync_InCorso[i] = 1;

			GetPlayerWeaponData(i, 0, Sync_Weapons_ID[i][0], Sync_Weapons_AMMO[i][0]);
			GetPlayerWeaponData(i, 1, Sync_Weapons_ID[i][1], Sync_Weapons_AMMO[i][1]);
			GetPlayerWeaponData(i, 2, Sync_Weapons_ID[i][2], Sync_Weapons_AMMO[i][2]);
			GetPlayerWeaponData(i, 3, Sync_Weapons_ID[i][3], Sync_Weapons_AMMO[i][3]);
			GetPlayerWeaponData(i, 4, Sync_Weapons_ID[i][4], Sync_Weapons_AMMO[i][4]);
			GetPlayerWeaponData(i, 5, Sync_Weapons_ID[i][5], Sync_Weapons_AMMO[i][5]);
			GetPlayerWeaponData(i, 6, Sync_Weapons_ID[i][6], Sync_Weapons_AMMO[i][6]);
			GetPlayerWeaponData(i, 7, Sync_Weapons_ID[i][7], Sync_Weapons_AMMO[i][7]);
			GetPlayerWeaponData(i, 8, Sync_Weapons_ID[i][8], Sync_Weapons_AMMO[i][8]);
			GetPlayerWeaponData(i, 9, Sync_Weapons_ID[i][9], Sync_Weapons_AMMO[i][9]);
			GetPlayerWeaponData(i, 10, Sync_Weapons_ID[i][10], Sync_Weapons_AMMO[i][10]);
			GetPlayerWeaponData(i, 11, Sync_Weapons_ID[i][11], Sync_Weapons_AMMO[i][11]);
			GetPlayerWeaponData(i, 12, Sync_Weapons_ID[i][12], Sync_Weapons_AMMO[i][12]);

		    GetPlayerHealth(i, Sync_Health[i]);
		    GetPlayerArmour(i, Sync_Armour[i]);

		    SpawnPlayer(i);

			new veh, seat;
			if ((veh = GetPlayerVehicleID(i)) != 0 && (seat = GetPlayerVehicleSeat(i)) != 128) { PutPlayerInVehicle(i, veh, seat);  }
	    }
	}

	RefreshTeamPlayers_TD();
	RefreshReadyTDs_Esl();
	if (playerid == INVALID_PLAYER_ID)
	{
		SendClientMessageToAll(COLOR_SYSTEM, "Teams balanced.");
	}
	else
	{
	    format( stringo , sizeof stringo , "%s has balanced the teams.", Player[playerid][Nickname]);
	    SendClientMessageToAll(COLOR_SYSTEM, stringo );
	}
	return true;
}

//forward Process_Final();
timer Process_Final[5000]()
{
	Process_FineCW();
}

stock Process_FineCW()
{
	#define DIFF_FINAL_Y   1.3
	FinalCW = true;

	new
		str[ 128 ],

		teama_players	[ 400 ],
		teama_kills 	[ 128 ],
		teama_deaths 	[ 128 ],
		teama_dmg 		[ 128 ],

		teamb_players	[ 400 ],
		teamb_kills 	[ 128 ],
		teamb_deaths 	[ 128 ],
		teamb_dmg 		[ 128 ],

		total_kills_a,
		total_kills_b,

		total_deaths_a,
		total_deaths_b,

		total_damage_a,
		total_damage_b,

		Float:Final_YPos = -651.1580,

		la[ MAX_SAVE_SLOTS ][E_BINTREE_INPUT],
		lb[ MAX_SAVE_SLOTS ][E_BINTREE_INPUT],

		j,
		j2
	;

	mysql_tquery(g_MySQLConnection, sprintf(
	    "UPDATE matchdata SET teama = '%s', teamb = '%s', scorea = '%d', scoreb = '%d', totalrounds = '%d', playedrounds = '%d', time = NOW(), incorso = 0 WHERE id = '%d'",
			iTeam[TEAM_A][Name],
			iTeam[TEAM_B][Name],

			iTeam[TEAM_A][RoundWins],
			iTeam[TEAM_B][RoundWins],

			TotalRounds,
			PlayingRound,

			CurrentMatchID
	), "", "");

    foreach(new i:Player)
	{
        //if(Player[i][Team] == TEAM_REF||Player[i][Team] == NULL_TEAM) continue;

	    if (Player[ i ][Team] == TEAM_A)
	    {
	 		la[j][E_BINTREE_INPUT_POINTER] = i;
	   		la[j][E_BINTREE_INPUT_VALUE]   = Player[i][Damage];

		    j ++;

			mysql_tquery(g_MySQLConnection,
				sprintf
				(
					"INSERT INTO matchplayers (matchid, playername, damage, kills, deaths, team) VALUES (%d, '%s', %d, %d, %d, %d)",

				    CurrentMatchID,
				    Player[i][Nickname],
				    Player[i][Damage],
				    Player[i][Kills],
				    Player[i][Deaths],
				    TEAM_A//well.. since i already know what is the team, why read the variabile?
				)
				, "", ""
			);
		}
		else if (Player[ i ][Team] == TEAM_B)
		{
	 		lb[j2][E_BINTREE_INPUT_POINTER] = i;
 			lb[j2][E_BINTREE_INPUT_VALUE]   = Player[i][Damage];

		    j2++;

			// same code as above, keep it the same of above
			mysql_tquery(g_MySQLConnection,
				sprintf
				(
					"INSERT INTO matchplayers (matchid, playername, damage, kills, deaths, team) VALUES (%d, '%s', %d, %d, %d, %d)",

				    CurrentMatchID,
				    Player[i][Nickname],
				    Player[i][Damage],
				    Player[i][Kills],
				    Player[i][Deaths],
				    TEAM_B
				)
				, "", ""
			);
		}

		if (!Player[i][IsAfk])
		{
//		    TextDrawHideForPlayer(i, HintTD);

		    SetPlayerPos(i, 1327.4109, Final_YPos, 108.2632);
		    SetPlayerFacingAngle(i, 198.6254);

			SetPlayerCameraPos(i, 1327.4109,-651.1580,108.2632);
			SetPlayerCameraLookAt(i, 1327.4109,-651.1580,108.2632);

	  	    Final_YPos -= -0.418;

	  	    PlayAudioStreamForPlayer( i , "http://slfd.revonline.comuf.com/final_cw_song.mp3" );

			SendClientMessage(i, red, "");
			SendClientMessage(i, red, "");
			SendClientMessage(i, red, "");
			SendClientMessage(i, red, "");
			SendClientMessage(i, red, "");
			SendClientMessage(i, red, "");
			SendClientMessage(i, red, "");
			SendClientMessage(i, red, "");
			SendClientMessage(i, red, "");
			SendClientMessage(i, red, "");
			SendClientMessage(i, red, "");
			SendClientMessage(i, red, "");
			SendClientMessage(i, red, "");
			SendClientMessage(i, red, "");
			SendClientMessage(i, red, "");

			TogglePlayerControllable(i, false);
			SetPlayerSpecialAction(i, SPECIAL_ACTION_DANCE4);

			PlayerTextDrawHide(i, PlayerInfo[0]);
			PlayerTextDrawHide(i, PlayerInfo[1]);
			PlayerTextDrawHide(i, PlayerInfo[2]);
		}

		SetPlayerScore(i, 0);
    }

	for (new i = 0; i < MAX_SAVE_SLOTS; ++i)
	{
	    if (SavedPlayer[i][sAssigned] && SavedPlayer[i][sPlayed])
		{
			if (SavedPlayer[i][sTeam] == TEAM_A)
			{
				if (Gaming != GAMETYPE_FIGHT && Gaming != GAMETYPE_GUNGAME)
				{
					la[j][E_BINTREE_INPUT_POINTER] = VALORE_SENTINELLA + i;
					la[j][E_BINTREE_INPUT_VALUE]   = SavedPlayer[i][sDamage];
			    }
				else
				{
					la[j][E_BINTREE_INPUT_POINTER] = VALORE_SENTINELLA + i;
					la[j][E_BINTREE_INPUT_VALUE]   = SavedPlayer[i][sKills];
				}

				j ++;
			}
			else if (SavedPlayer[i][sTeam] == TEAM_B)
			{
				if (Gaming != GAMETYPE_FIGHT && Gaming != GAMETYPE_GUNGAME)
				{
					lb[j2][E_BINTREE_INPUT_POINTER] = VALORE_SENTINELLA + i;
					lb[j2][E_BINTREE_INPUT_VALUE]   = SavedPlayer[i][sDamage];
			    }
				else
				{
					lb[j2][E_BINTREE_INPUT_POINTER] = VALORE_SENTINELLA + i;
					lb[j2][E_BINTREE_INPUT_VALUE]   = SavedPlayer[i][sKills];
				}

	 		    j2++;
			}

			SavedPlayer[i][sPlayed] = false;
			SavedPlayer [i][sAssigned] = false;//the TCW/CW is finished.. so clear all
	    }
	}

    Bintree_Sort(la, j);
	Bintree_Sort(lb, j2);

    for (new i = j - 1; i != -1; i --)
    {
        new pid = la[i][E_BINTREE_INPUT_POINTER];

        if (pid >= VALORE_SENTINELLA) {
            pid -= VALORE_SENTINELLA;

			strcat( teama_players , SavedPlayer[ pid ][ sNickname ] );
		  	strcat( teama_players , "~n~" );

		    strcat( teama_kills , numstr( SavedPlayer[ pid ][ sKills ] ) );
		    strcat( teama_kills , "~n~" );

		    strcat( teama_deaths , numstr( SavedPlayer[ pid ][ sDeaths ] ) );
		    strcat( teama_deaths , "~n~" );

		    strcat( teama_dmg , numstr( SavedPlayer[ pid ][ sDamage ] ) );
		    strcat( teama_dmg , "~n~" );

			total_kills_a  += SavedPlayer[pid][sKills];
			total_deaths_a += SavedPlayer[pid][sDeaths];
			total_damage_a += SavedPlayer[pid][sDamage];
        }
		else
		{
			strcat( teama_players , Player[ pid ][ Nickname ] );
		  	strcat( teama_players , "~n~" );

		    strcat( teama_kills , numstr( Player[ pid ][ Kills ] ) );
		    strcat( teama_kills , "~n~" );

		    strcat( teama_deaths , numstr( Player[ pid ][ Deaths ] ) );
		    strcat( teama_deaths , "~n~" );

		    strcat( teama_dmg , numstr( Player[ pid ][ Damage ] ) );
		    strcat( teama_dmg , "~n~" );

			total_kills_a  += Player[pid][Kills];
			total_deaths_a += Player[pid][Deaths];
			total_damage_a += Player[pid][Damage];
		}
    }

    for (new i = j2 - 1; i != -1; i --)
    {
        new pid = lb[i][E_BINTREE_INPUT_POINTER];
        if (pid >= VALORE_SENTINELLA) {
            pid -= VALORE_SENTINELLA;

		   	strcat( teamb_players , SavedPlayer[ pid ][ sNickname ] );
		   	strcat( teamb_players , "~n~" );

		    strcat( teamb_kills , numstr( SavedPlayer[ pid ][ sKills ] ) );
		    strcat( teamb_kills , "~n~" );

		    strcat( teamb_deaths , numstr( SavedPlayer[ pid ][ sDeaths ] ) );
		    strcat( teamb_deaths , "~n~" );

		    strcat( teamb_dmg , numstr( SavedPlayer[ pid ][ sDamage ] ) );
		    strcat( teamb_dmg , "~n~" );

			total_kills_b  += SavedPlayer[pid][sKills];
			total_deaths_b += SavedPlayer[pid][sDeaths];
			total_damage_b += SavedPlayer[pid][sDamage];
        }
        else
        {

		   	strcat( teamb_players , Player[ pid ][ Nickname ] );
		   	strcat( teamb_players , "~n~" );

		    strcat( teamb_kills , numstr( Player[ pid ][ Kills ] ) );
		    strcat( teamb_kills , "~n~" );

		    strcat( teamb_deaths , numstr( Player[ pid ][ Deaths ] ) );
		    strcat( teamb_deaths , "~n~" );

		    strcat( teamb_dmg , numstr( Player[ pid ][ Damage ] ) );
		    strcat( teamb_dmg , "~n~" );

			total_kills_b  += Player[pid][Kills];
			total_deaths_b += Player[pid][Deaths];
			total_damage_b += Player[pid][Damage];

		}
    }

	SetWorldTime( 22 );
	SetWeather( 16 );

    TextDrawSetString(FinalTCWScreen[24], teama_players);
    TextDrawSetString(FinalTCWScreen[25], teama_kills);
    TextDrawSetString(FinalTCWScreen[26], teama_deaths);
    TextDrawSetString(FinalTCWScreen[27], teama_dmg);

    TextDrawSetString(FinalTCWScreen[28], teamb_players);
    TextDrawSetString(FinalTCWScreen[29], teamb_kills);
    TextDrawSetString(FinalTCWScreen[30], teamb_deaths);
    TextDrawSetString(FinalTCWScreen[31], teamb_dmg);

	new
		mScore1,
  		mScorer1 = INVALID_PLAYER_ID,

		mScore2,
  		mScorer2 = INVALID_PLAYER_ID,

	    mScore3,
	    mScorer3 = INVALID_PLAYER_ID;

	new top[3*2][E_BINTREE_INPUT];

	if((j-1)>=0)
	{
		top[0][E_BINTREE_INPUT_POINTER] = la[j-1][E_BINTREE_INPUT_POINTER];
		top[0][E_BINTREE_INPUT_VALUE] = la[j-1][E_BINTREE_INPUT_VALUE];
	}
	else
	{
		top[0][E_BINTREE_INPUT_POINTER] = INVALID_PLAYER_ID;
		top[0][E_BINTREE_INPUT_VALUE] = 0;
	}
	
	if ((j-2)>=0)
	{
		top[1][E_BINTREE_INPUT_POINTER] = la[j-2][E_BINTREE_INPUT_POINTER];
		top[1][E_BINTREE_INPUT_VALUE] = la[j-2][E_BINTREE_INPUT_VALUE];
	}
	else
	{
		top[1][E_BINTREE_INPUT_POINTER] = INVALID_PLAYER_ID;
		top[1][E_BINTREE_INPUT_VALUE] = 0;
	}
	
	if ((j-3)>=0)
	{
		top[2][E_BINTREE_INPUT_POINTER] = la[j-3][E_BINTREE_INPUT_POINTER];
		top[2][E_BINTREE_INPUT_VALUE] = la[j-3][E_BINTREE_INPUT_VALUE];
	}
	else
	{
		top[2][E_BINTREE_INPUT_POINTER] = INVALID_PLAYER_ID;
		top[2][E_BINTREE_INPUT_VALUE] = 0;
	}
	
	if((j2-1)>=0)
	{
		top[3][E_BINTREE_INPUT_POINTER] = lb[j2-1][E_BINTREE_INPUT_POINTER];
		top[3][E_BINTREE_INPUT_VALUE] = lb[j2-1][E_BINTREE_INPUT_VALUE];
	}
	else
	{
		top[3][E_BINTREE_INPUT_POINTER] = INVALID_PLAYER_ID;
		top[3][E_BINTREE_INPUT_VALUE] = 0;
	}
	
	if ((j2-2)>=0)
	{
		top[4][E_BINTREE_INPUT_POINTER] = lb[j2-2][E_BINTREE_INPUT_POINTER];
		top[4][E_BINTREE_INPUT_VALUE] = lb[j2-2][E_BINTREE_INPUT_VALUE];
	}
	else
	{
		top[4][E_BINTREE_INPUT_POINTER] = INVALID_PLAYER_ID;
		top[4][E_BINTREE_INPUT_VALUE] = 0;
	}
	
	if((j2-3)>=0)
	{
		top[5][E_BINTREE_INPUT_POINTER] = lb[j2-3][E_BINTREE_INPUT_POINTER];
		top[5][E_BINTREE_INPUT_VALUE] = lb[j2-3][E_BINTREE_INPUT_VALUE];
	}
	else
	{
		top[5][E_BINTREE_INPUT_POINTER] = INVALID_PLAYER_ID;
		top[5][E_BINTREE_INPUT_VALUE] = 0;
	}
	
	Bintree_Sort(top, 6);

	mScorer1 = top[5][E_BINTREE_INPUT_POINTER];
	mScore1 = top[5][E_BINTREE_INPUT_VALUE];

	mScorer2 = top[4][E_BINTREE_INPUT_POINTER];
	mScore2 = top[4][E_BINTREE_INPUT_VALUE];

	mScorer3 = top[3][E_BINTREE_INPUT_POINTER];
	mScore3 = top[3][E_BINTREE_INPUT_VALUE];

	TextDrawSetString( FinalTCWScreen[ 18 ] , "1st. N/D" );
	TextDrawSetString( FinalTCWScreen[ 19 ] , "2nd. N/D" );
	TextDrawSetString( FinalTCWScreen[ 20 ] , "3rd. N/D" );

	/*
	foreach(new i:Player)
	{
	    if (Player[i][Team] != TEAM_A && Player[i][Team] != TEAM_B) continue;
 		#if DEBUG == true
   	//	SendClientMessageToAll(-1,"Hey, sto controllando l'id %d..", i);
    	#endif

	    if (Player[i][Damage] >= mScore1)
	    {
      		if (mScorer1 != INVALID_PLAYER_ID)
			{
				new
    				tmp2s = mScore2, tmp2p = mScorer2;

				mScorer2 = mScorer1;
    			mScore2  = mScore1;

				mScore3  = tmp2s;
    			mScorer3  = tmp2p;

				#if DEBUG == true
    			SendClientMessageToAll(-1, "sposto di una posizione tutti i players");
       			#endif
       		}

			mScore1  = Player[i][Damage];
			mScorer1 = i;

	        #if DEBUG == true
	        SendClientMessageToAll(-1,"il best dmg score1 ï¿½ suo!");
	        #endif
	    }
	    else if (Player[i][Damage] >= mScore2)
	    {
     		if (mScorer2 != INVALID_PLAYER_ID)
	        {
				mScorer3 = mScorer2;
                mScore3  = mScore2;

				#if DEBUG == true
    			SendClientMessageToAll(-1, "sposto di una posizione tutti i players");
       			#endif
       		}

	        mScore2  = Player[i][Damage];
	        mScorer2 = i;

	        #if DEBUG == true
	        SendClientMessageToAll(-1,"il best dmg score2 ï¿½ suo!");
	        #endif
		}
	    else if (Player[i][Damage] >= mScore3)
	    {
	        mScore3  = Player[i][Damage];
	        mScorer3 = i;

	        #if DEBUG == true
	        SendClientMessageToAll(-1,"il best dmg score3 ï¿½ suo!");
	        #endif
	    }

		#if DEBUG == true
	//    SendClientMessageToAll(-1,"nulla?disp. score1:%d | score2:%d | score3: %d / ids: scorer1: %d | scorer2: %d | scorer3: %d", mScore1, mScore2, mScore3, mScorer1, mScorer2, mScorer3);
		#endif
	}*/
	//SavedPlayer
	if (mScorer1 != INVALID_PLAYER_ID)
	{
	    if (mScorer1 >= VALORE_SENTINELLA)
	    {
            mScorer1 -= VALORE_SENTINELLA;
            TextDrawSetString( FinalTCWScreen[ 18 ] , sprintf( "1st. %s (%d)" , SavedPlayer[mScorer1][sNickname] , mScore1 ) );
	    }
	    else
	    {
	        TextDrawSetString( FinalTCWScreen[ 18 ] , sprintf( "1st. %s (%d)" , Player[mScorer1][Nickname] , mScore1 ) );
	    }
	}
	else
	{
		TextDrawSetString( FinalTCWScreen[ 18 ] , "1st. N/D" );
	}

	if (mScorer2 != INVALID_PLAYER_ID)
	{
		if (mScorer2 >= VALORE_SENTINELLA)
		{
		    mScorer2 -= VALORE_SENTINELLA;
		    TextDrawSetString( FinalTCWScreen[ 19 ] , sprintf( "2nd. %s (%d)" , SavedPlayer[mScorer2][sNickname] , mScore2 ) );
		}
		else
		{
		    TextDrawSetString( FinalTCWScreen[ 19 ] , sprintf( "2nd. %s (%d)" , Player[mScorer2][Nickname] , mScore2 ) );
		}
	}
	else
	{
	    TextDrawSetString( FinalTCWScreen[ 19 ] , "2nd. N/D" );
	}

	if (mScorer3 != INVALID_PLAYER_ID)
	{
	    if (mScorer3 >= VALORE_SENTINELLA)
	    {
	        mScorer3 -= VALORE_SENTINELLA;
	        TextDrawSetString( FinalTCWScreen[ 20 ] , sprintf( "3rd. %s (%d)" , SavedPlayer[mScorer3][sNickname] , mScore3 ) );
	    }
	    else
	    {
	        TextDrawSetString( FinalTCWScreen[ 20 ] , sprintf( "3rd. %s (%d)" , Player[mScorer3][Nickname] , mScore3 ) );
	    }
	}
	else
	{
	    TextDrawSetString( FinalTCWScreen[ 20 ] , "3rd. N/D" );
	}

	// kkills

	TextDrawSetString( FinalTCWScreen[ 21 ] , "1st. N/D" );
	TextDrawSetString( FinalTCWScreen[ 22 ] , "2nd. N/D" );
	TextDrawSetString( FinalTCWScreen[ 23 ] , "3rd. N/D" );

	mScore1 = 0, mScorer1 = INVALID_PLAYER_ID;
	mScore2 = 0, mScorer2 = INVALID_PLAYER_ID;
 	mScore3 = 0, mScorer3 = INVALID_PLAYER_ID;

	foreach(new i:Player)
	{
	    if (Player[i][Kills] >= mScore1)
	    {
      		if (mScorer1 != INVALID_PLAYER_ID)
			{
				new
    				tmp2s = mScore2, tmp2p = mScorer2;

				mScorer2 = mScorer1;
    			mScore2  = mScore1;

				mScore3  = tmp2s;
    			mScorer3  = tmp2p;

       		}

			mScore1  = Player[i][Kills];
			mScorer1 = i;

	    }
	    else if (Player[i][Kills] >= mScore2)
	    {
     		if (mScorer2 != INVALID_PLAYER_ID)
	        {
				mScorer3 = mScorer2;
                mScore3  = mScore2;

       		}

	        mScore2  = Player[i][Kills];
	        mScorer2 = i;

		}
	    else if (Player[i][Kills] >= mScore3)
	    {
	        mScore3  = Player[i][Kills];
	        mScorer3 = i;
	    }
	}

	for(new i = 0; i < MAX_SAVE_SLOTS; ++i)
	{
	    if (!SavedPlayer[i][sAssigned]) continue;

	    if (SavedPlayer[i][sKills] >= mScore1)
	    {
      		if (mScorer1 != INVALID_PLAYER_ID)
			{
				new
    				tmp2s = mScore2, tmp2p = mScorer2;

				mScorer2 = mScorer1;
    			mScore2  = mScore1;

				mScore3  = tmp2s;
    			mScorer3  = tmp2p;

       		}

			mScore1  = SavedPlayer[i][sKills];
			mScorer1 = VALORE_SENTINELLA + i;

	    }
	    else if (SavedPlayer[i][sKills] >= mScore2)
	    {
     		if (mScorer2 != INVALID_PLAYER_ID)
	        {
				mScorer3 = mScorer2;
                mScore3  = mScore2;

       		}

	        mScore2  = SavedPlayer[i][sKills];
	        mScorer2 = VALORE_SENTINELLA + i;

		}
	    else if (SavedPlayer[i][sKills] >= mScore3)
	    {
	        mScore3  = SavedPlayer[i][sKills];
	        mScorer3 = VALORE_SENTINELLA + i;
	    }
	}

	if (mScorer1 != INVALID_PLAYER_ID)
  	{
  	    if (mScorer1 >= VALORE_SENTINELLA)
  	    {
  	        mScorer1 -= VALORE_SENTINELLA;
  	        TextDrawSetString( FinalTCWScreen[ 21 ] , sprintf( "1st. %s (%d)" , SavedPlayer[mScorer1][sNickname] , mScore1 ) );
  	    }
  	    else
  	    {
  	    	TextDrawSetString( FinalTCWScreen[ 21 ] , sprintf( "1st. %s (%d)" , Player[mScorer1][Nickname] , mScore1 ) );
		}
	}
	else
	{
	    TextDrawSetString( FinalTCWScreen[ 21 ] , "1st. N/D" );
	}

	if (mScorer2 != INVALID_PLAYER_ID)
	{
	    if (mScorer2 >= VALORE_SENTINELLA)
	    {
	        mScorer2 -= VALORE_SENTINELLA;
	        TextDrawSetString( FinalTCWScreen[ 22 ] , sprintf( "2nd. %s (%d)" , SavedPlayer[mScorer2][sNickname] , mScore2 ) );
	    }
	    else
	    {
			TextDrawSetString( FinalTCWScreen[ 22 ] , sprintf( "2nd. %s (%d)" , Player[mScorer2][Nickname] , mScore2 ) );
		}
	}
	else
	{
		TextDrawSetString( FinalTCWScreen[ 22 ] , "2nd. N/D" );
	}

	if (mScorer3 != INVALID_PLAYER_ID)
	{
	    if (mScorer3 >= VALORE_SENTINELLA)
	    {
	        mScorer3 -= VALORE_SENTINELLA;
	        TextDrawSetString( FinalTCWScreen[ 23 ] , sprintf( "3rd. %s (%d)" , SavedPlayer[mScorer3][sNickname] , mScore3 ) );
	    }
	    else
	    {
			TextDrawSetString( FinalTCWScreen[ 23 ] , sprintf( "3rd. %s (%d)" , Player[mScorer3][Nickname] , mScore3 ) );
		}
	}
	else
	{
	    TextDrawSetString( FinalTCWScreen[ 23 ] , "3rd. N/D" );
	}

	format( str , sizeof str , "Total kills: %d   Total Deaths: %d   Total damage: %d" , total_kills_a, total_deaths_a, total_damage_a);
    TextDrawSetString( FinalTCWScreen[ 16 ] , str ) ;

	format( str , sizeof str , "Total kills: %d   Total Deaths: %d   Total damage: %d" , total_kills_b, total_deaths_b, total_damage_b);
	TextDrawSetString( FinalTCWScreen[ 17 ] , str ) ;

	// final scores

	format( str , sizeof str , "~"#GT_TEAMA"~%s %d~w~ - ~"#GT_TEAMB"~%d %s", iTeam[TEAM_A][Name] , iTeam[TEAM_A][RoundWins] , iTeam[TEAM_B][RoundWins] , iTeam[TEAM_B][Name] );
    TextDrawSetString( FinalTCWScreen[ 1 ] , str ) ;

//	iTeam[TEAM_A][RoundWins] = 0;
//	iTeam[TEAM_B][RoundWins] = 0;

	TextDrawHideForAll(GeneralTD[0]);
	TextDrawHideForAll(GeneralTD[1]);

	TextDrawHideForAll(TeamPlayers_TD);

	ClearDeathMessages();

	foreach(new i:Player)
	{
	    if( !Player[i][Spawned] ) continue;
	    if( Player[i][IsAfk] ) continue;

		for(new x = 0; x < sizeof(FinalTCWScreen); x++)
		{
		    TextDrawShowForPlayer( i , FinalTCWScreen[x] );
		}
	}
/*
	for (new i = 0; i < MAX_PLAYERS; i++)
	{
		Player[i][Kills] = 0;
		Player[i][Damage] = 0;
		Player[i][Deaths] = 0;
	}
*/
    ResetScores ();
	FinalReady = true;

	CammUpdate = repeat CamUpdate();
	defer FINAL_DestroyFinal();
    //SetTimer("FINAL_DestroyFinal", 15000, 0);
    return true;
}

// well...
stock ClearSavedInfo() {
	for(new i = 0; i < MAX_SAVE_SLOTS; ++i) {
	    SavedPlayer [i][sAssigned] = false;
	}
}

//
timer CamUpdate[25]()
{
	new
	    Float: Xc, Float:Yc;

	foreach(new i:Player)
	{
		Xc = floatadd(1333.4302, floatmul(50+10, floatsin(-Player[i][AngoloFinal], degrees)));
		Yc = floatadd(-652.1138, floatmul(50+10, floatcos(-Player[i][AngoloFinal], degrees)));

		SetPlayerCameraPos(i, Xc, Yc, 108.2632+10);
		SetPlayerCameraLookAt(i, 1333.4302, -652.1138, floatadd(108.2632, 1.0));

		Player[i][AngoloFinal] += 0.5;
		if(Player[i][AngoloFinal] >= 360.0)
			Player[i][AngoloFinal] = 0.0;
	}
	return true;
}

//forward FINAL_DestroyFinal();
timer FINAL_DestroyFinal[15000]()
{
	stop CammUpdate ;

	for(new x = 0; x < sizeof(FinalTCWScreen); x++)
	{
  		TextDrawHideForAll(FinalTCWScreen[x]);
	}

	foreach(new i:Player)
	{
		if(!Player[i][Spawned]) continue;
		if(Player[i][IsAfk]) continue;
		TogglePlayerControllable(i, 1);
		if(Player[i][InDm] != -1)
		{
		    MySQLStatus[TotalQuerys] ++; mysql_tquery(g_MySQLConnection, sprintf("UPDATE bestdmplayer SET damage = '%d', kills = '%d' WHERE nickname = '%s' AND dmid = '%d'", Player[i][DDamage], Player[i][DKills], Player[i][Nickname], Player[i][InDm]), "", "");
			Player[i][InDm] = -1;
		}
		SetSpawnInfo(i, i, GetPlayerSkinEx(i), Lobby[0] - MAX_RANDOM_SPAWN + random( MAX_RANDOM_SPAWN ), Lobby[1] - MAX_RANDOM_SPAWN + random( MAX_RANDOM_SPAWN ), Lobby[2], Lobby[3], 0, 0, 0, 0, 0, 0);
		SpawnPlayer(i);
		SetCameraBehindPlayer(i);
	//	CreatePlayerInfoTD(i);
		PlayerPlaySound(i, 1098, 0.0, 0.0, 0.0);
		StopAudioStreamForPlayer(i);
		PlayerTextDrawShow(i, PlayerInfo[0]);
		PlayerTextDrawShow(i, PlayerInfo[1]);
		PlayerTextDrawShow(i, PlayerInfo[2]);
		Player[i][RadioStream] = false;
		SetPlayerSpecialAction(i, 0);
		FinalShow[ i ] = false;
//		TextDrawShowForPlayer(i, HintTD);
	}

	FinalCW = false;
	SendClientMessageToAll( COLOR_SYSTEM , "Use /final to show/hide again the final TD." );

	if (AC_State == STATE_ENABLED)
	{
		SendClientMessageToAll( COLOR_SYSTEM , "The anticheat has been disabled.");

	    AC_Toggle(false);
	    AC_State = STATE_DISABLED;
	    SendRconCommand ( sprintf ("hostname %s", g_stored_original_name) );
    }

	if (gConfig[Matchmode] != MATCHMODE_NOSCORES)
	{
		iTeam[TEAM_A][RoundWins] = 0;
		iTeam[TEAM_B][RoundWins] = 0;
	}

	if (gConfig[GameMode] == GAMEMODE_ESL) {
		TextDrawShowForAll(ESLModeReady[0]);
		TextDrawShowForAll(ESLModeReady[1]);
		TextDrawShowForAll(ESLModeReady[2]);
		TextDrawShowForAll(ESLModeReady[3]);
		RefreshReadyTDs_Esl();
	}

	PlayingRound = 0;
	TotalRounds  = 9;
	TextDrawShowForAll(GeneralTD[0]);
	TextDrawShowForAll(GeneralTD[1]);
	TextDrawShowForAll(TeamPlayers_TD);
	RefreshTextGeneralTD();

	SetWorldTime(gConfig[GameTime]);
	SetWeather(gConfig[GameWeather]);
	return true;
}

stock GetWinTypeString(wintype)
{
	new str[ 69 ];
	switch(wintype)
	{
	    case WINTYPE_ELIMINAZIONE: 	str = "Elimination";
	    case WINTYPE_CHECKPOINT: 	str = "Checkpoint";
	    case WINTYPE_TIME: 			str = "Time expired";
	    case WINTYPE_ENDING: 		str = "Ended";
	    case WINTYPE_HEALTH: 		str = "Health";
	}
	return str;
}

stock RemoveClan(name[])
{
	new
	    fixName[ MAX_PLAYER_NAME ],
	    founded,
	    start,
	    end;

	strcpy(fixName, name);
	for(new i = 0, j = strlen(name); i < j ; i++)
	{
		if(name[i] == '[' && !founded)
		{
		    start = i;
		    founded = 1;
		}
		if(name[i] == ']' && founded)
		{
		    end = i;
			break;
		}
	}

	if(start==0&&end==0) return fixName;
	if((start+end)<strlen(name))strdel(fixName, start, end+1);
	return fixName;
}

stock RefreshIcons()
{
	if (!RoundStarted) return false;
	if (Gaming == GAMETYPE_FIGHT || Gaming == GAMETYPE_GUNGAME || Gaming == GAMETYPE_FALLOUT) return false;

	new it;
	foreach(new i:Player)
	{
		it = Player[i][Team];
		foreach(new p:Player)
		{
		    if(HelperLocked[p])    continue;
		    if(!Player[p][InGame]) continue;

			if (Gaming == GAMETYPE_LASTBULLET)
			{
			    SetPlayerMarkerForPlayer( i, p, ( GetPlayerColor( p ) & 0xFFFFFF00 ) );
			}
			else
			{
				if(Player[p][Team] == it)
				{
				    SetPlayerMarkerForPlayer( i, p, iTeam[it][InGameColor] );
				}
				else
				{
				    SetPlayerMarkerForPlayer( i, p, ( GetPlayerColor( p ) & 0xFFFFFF00 ) );
				}
			}
		}
	}
	return true;
}

#define NAMETAG_DRAWDISTANCE        2000
timer NameTagDrawDistance[NAMETAG_DRAWDISTANCE]() {
	if (!RoundStarted) return false;

	new
	    t,
		Float:fX,
		Float:fY,
		Float:fZ;

	foreach (new i:Player) {
		t = Player[i][Team];
		GetPlayerPos (i, fX, fY, fZ);

	    foreach (new x:Player) {
	        if (t != Player[x][Team]) {
	            if (GetPlayerDistanceFromPoint(x, fX, fY, fZ) > 9.0) {
	                ShowPlayerNameTagForPlayer (i, x, 0);
	            }
	            else {
	                ShowPlayerNameTagForPlayer (i, x, 1);
	            }
	 		}
	    }
	}

	defer NameTagDrawDistance();
	return 1;
}

//forward SyncRound();
timer SyncRound[1000]()
{
	if (!RoundStarted || GamePaused) return true;
	if (Gaming == GAMETYPE_BASE)
	{
	    // should be improved.
		new bool:ended = false;

		RealRSecs--;

		if (RealRMins == 1 && RealRSecs == 0)
		{
		    foreach(new i : Player)
			{
		        if(!Player[i][InGame]) continue;
				PlayerPlaySound(i, 1058, 0.0, 0.0, 0.0);
		    }
		}
		else if (RealRMins == 0 && RealRSecs < 1)
		{
		    ended = true;
		}

		if (RealRSecs < 0)
		{
		    RealRSecs = 59;
		    RealRMins --;

		    if(ended)
			{
			    if (!Interior_Base)
				{
 	  				EndRound(( TeamRole[TEAM_A] == DEFENDERS ? TEAM_A : TEAM_B ), WINTYPE_TIME);
				}
				else
				{
				    new
				        hpA,
				        hpB,
						Float:a,
						Float:h;

					foreach(new i:Player)
					{
					    if (Player[i][InGame])
					    {
							GetPlayerHealth(i, h);
							GetPlayerArmour(i, a);

					        if (Player[i][Team] == TEAM_A)
					        {
					            hpA += floatround( h + a );
					        }
					        else
					        {
					            hpB += floatround( h + a );
					        }
					    }
					}

					if (hpA > hpB)
					{
					    EndRound(TEAM_A, WINTYPE_HEALTH);
					}
					else if (hpA < hpB)
					{
					    EndRound(TEAM_B, WINTYPE_HEALTH);
					}
					else
					{
					    EndRound(NULL_TEAM, WINTYPE_HEALTH);
					}
				}
			}
		}

		if (gConfig[UCp])
		{
			new rem_sec = 0/*, def = 0*/;

			foreach(new i:Player)
			{
				if(!Player[i][InGame]) continue;
				if(IsPlayerInAnyVehicle(i)) continue;
			    if(!IsPlayerInCheckpoint(i)) continue;
			    if(TeamRole[Player[i][Team]] == ATTACKERS/* && !def */) rem_sec = 1;
				else if(TeamRole[Player[i][Team]] == DEFENDERS)
				{
					rem_sec = 0;
					//def=1;
					break;
				}
			}

			if (rem_sec > 0)
			{
				if (RealCPTime == gConfig[TCp]) {
				    GangZoneFlashForAll(ZonaAttornoCP, (TeamRole[TEAM_A] == ATTACKERS ? iTeam[TEAM_A][InGameColor] : iTeam[TEAM_B][InGameColor]));
				}

			   	//GangZonePulseForAll(ZonaAttornoCP, (TeamRole[TEAM_A] == DEFENDERS ? iTeam[TEAM_A][InGameColor] : iTeam[TEAM_B][InGameColor]), (TeamRole[TEAM_A] == ATTACKERS ? iTeam[TEAM_A][InGameColor] : iTeam[TEAM_B][InGameColor]), 1000);
			    RealCPTime --;
			    AllPlaySound(1056);

	            TextDrawSetString(CPTimer, sprintf("~"#GT_TEAMB"~~h~Checkpoint: ~w~~h~%d", RealCPTime));
	            TextDrawShowForAll(CPTimer);
			}
			else
			{
			    /*
			    if(RealCPTime != gConfig[TCp])
				{
			    	GangZonePulseForAll(ZonaAttornoCP, (TeamRole[TEAM_A] == ATTACKERS ? iTeam[TEAM_A][InGameColor] : iTeam[TEAM_B][InGameColor]), (TeamRole[TEAM_A] == DEFENDERS ? iTeam[TEAM_A][InGameColor] : iTeam[TEAM_B][InGameColor]), 1000);
				}
				else
				{
				    //GangZonePulseForAll(ZonaAttornoCP, COLOR_GANGZONE_CAPTURE, COLOR_GANGZONE_NOCAPTURE, 1000);
				    //GangZoneStopPulseForAll(ZonaAttornoCP);
					GangZoneStopFlashForAll(ZonaAttornoCP);
				}*/
				GangZoneStopFlashForAll(ZonaAttornoCP);
			    RealCPTime   = gConfig[TCp];
	  //          TextDrawSetString(CPTimer, sprintf("~b~~h~Checkpoint: ~w~~h~%d", RealCPTime));
	            TextDrawHideForAll(CPTimer);
			}

			if(RealCPTime < 1)
			{
			    EndRound(( TeamRole[TEAM_A] == ATTACKERS ? TEAM_A : TEAM_B ), WINTYPE_CHECKPOINT);
			}
		}
	}
	else
	{
	    // Arene TDM Fight Gungame
	    // e tanto altro

        RealRSecs ++;
        if (RealRSecs > 59)
        {
            RealRSecs = 0;
            RealRMins ++;
        }

		if (Gaming == GAMETYPE_FALLOUT)
        {
	        if (fallout_alive_objs < 3)
	        {
	        	SendClientMessageToAll(red, "Round ended.");
				EndRound ();
				return true;
	        }

	        if (fallout_timers_startati < 99)
	        {
			    new
			        obj;

			    do {
			        obj = random (100);
			    } while (fallout_obj_timerstart[obj] == true);

				//fallout_object_timer [obj] = SetTimerEx ("ShakeObject", 100, true, "i", obj);
				fallout_object_timer[obj] = repeat ShakeObject(obj);
    			fallout_obj_timerstart [obj] = true;
    			fallout_timers_startati ++;
			}

			new Float:x, Float:y, Float:z;

			foreach (new i:Player)
			{
			    if (Player[i][InGame])
			    {
			        GetPlayerPos (i, x, y, z);

			        if (z <= 158)
					{
						foreach(new o:Player)
						{
						    if (InSpec[o] == i)
						        Spec_SwitchSpec(o, 1);
						}

/*						TextDrawHideForPlayer(i, RoundStats[0]);
						TextDrawHideForPlayer(i, RoundStats[1]);
						TextDrawHideForPlayer(i, RoundStats[2]);
						TextDrawHideForPlayer(i, RoundStats[3]);
*/
					    DisablePlayerCheckpoint(i);

						Player[i][InGame] = 0;
						SetPlayerVirtualWorld(i, NORMAL_WORLD);
						SetPlayerColor(i, iTeam[Player[i][Team]][OutColor]);
						TeamPlayers[Player[i][Team]] --;

						SyncTextdraw (1);

						TextDrawShowForPlayer(i, TeamPlayers_TD);
						SetSpawnInfo(i, i, GetPlayerSkinEx(i), Lobby[0] - MAX_RANDOM_SPAWN + random( MAX_RANDOM_SPAWN ), Lobby[1] - MAX_RANDOM_SPAWN + random( MAX_RANDOM_SPAWN ), Lobby[2], Lobby[3], 0, 0, 0, 0, 0, 0);

					   	GangZoneHideForPlayer(i, ZonaAttornoCP);

						SpawnPlayer(i);

						format(stringo, sizeof stringo, "»» {"#COLOR_SYSTEM_FOCUS"}%s{"#COLOR_SYSTEM_REST"} fell from the platform!", Player[i][Nickname]);
                        SendClientMessageToAll (COLOR_SYSTEM, stringo);

						if (TeamPlayers[TEAM_A] == 0 && TeamPlayers[TEAM_B] == 0)
						{
						    EndRound (INVALID_PLAYER_ID, WINTYPE_EVERYONEFELL);
						}
						else if ((TeamPlayers[TEAM_A] + TeamPlayers[TEAM_B]) == 1)
						{
						    EndRound (GetLastAlivePlayer(), WINTYPE_EVERYONEFELL);
						}
					}
			    }
			}
		}
		else
		{
		    foreach(new i:Player)
			{
		        if (Player[i][InGame])
				{
		            if (!IsPlayerInArea(i, eScenario[MinX], eScenario[MaxX], eScenario[MinY], eScenario[MaxY]))
					{
		                Player_outArena[i] = true;
		                Player_outSecs[i]  --;
		                format(stringo, sizeof stringo, "~r~Come back in the arena within ~g~%d ~r~seconds!", Player_outSecs[i]);
		                GameTextForPlayer(i, stringo, 1000, 3);

						if(Player_outSecs[i] < 1)
						{
							new pt = Player[i][Team];

						    format(stringo, sizeof stringo, "{FF0000}%s{BC0909} has been removed from the round for being too much time out from the Arena!", Player[i][Nickname]);
                            SendClientMessageToAll(0xBC0909AA, stringo);

							Player_outSecs[i] = 10;

/*							TextDrawHideForPlayer(i, RoundStats[0]);
							TextDrawHideForPlayer(i, RoundStats[1]);
							TextDrawHideForPlayer(i, RoundStats[2]);
							TextDrawHideForPlayer(i, RoundStats[3]);
*/
						    DisablePlayerCheckpoint(i);

							Player[i][InGame] = 0;
							SetPlayerVirtualWorld(i, NORMAL_WORLD);
							SetPlayerColor(i, iTeam[pt][OutColor]);

							if (!CamMove)
							{
								FixHealthBars();
							}

							RemovePlayerMapIcon(i, MAPICON_ATTACKERSPAWN);

							if( pt == TEAM_A )
							{
							    Team1_StartHP -= gConfig[GameMode] == GAMEMODE_NOCBUG ? 100 : 200;

								if (Team1_StartHP == 0)
			   	 					Team1_StartHP = 1;
							}
							else if( pt == TEAM_B )
							{
								Team2_StartHP -= gConfig[GameMode] == GAMEMODE_NOCBUG ? 100 : 200;

								if (Team2_StartHP == 0)
								    Team2_StartHP = 1;
							}
							TeamPlayers[pt] --;
							SyncTextdraw(1);

							if (Gaming == GAMETYPE_BASE)
							{
								if(Player[i][Weaponset] != INVALID_WEAPON_SET)
								{
									Weaponsets[Player[i][Weaponset]][TeamSelection][pt] --;
								}

								Player[i][Weaponset] = INVALID_WEAPON_SET;
							}

							TextDrawShowForPlayer(i, TeamPlayers_TD);
							SetSpawnInfo(i, i, GetPlayerSkinEx(i), Lobby[0] - MAX_RANDOM_SPAWN + random( MAX_RANDOM_SPAWN ), Lobby[1] - MAX_RANDOM_SPAWN + random( MAX_RANDOM_SPAWN ), Lobby[2], Lobby[3], 0, 0, 0, 0, 0, 0);

						   	GangZoneHideForPlayer(i, ZonaAttornoCP);

							SpawnPlayer(i);

							if (AntiHits)
							{
		//					    TextDrawHideForPlayer(i, TD_NotHits);
							    TextDrawHideForPlayer(i, TD_NoHitsScritta);
							}

							RefreshTeamPlayers_TD();

							if (Gaming == GAMETYPE_FIGHT && RoundFightType == FIGHTSIZE_ONEVSONE)
							{
							    Iter_Remove(ovoInGame, i);

							    if (!Player[i][fInWaiting]) // il player aveva un avversario (non aspettava nessun player che finiva il suo duel)
								{
							        new killerid = PlayerAvversario[i]; // laaazzzy scripter
							        PlayerAvversario[i] = INVALID_PLAYER_ID;

								    new avversario = INVALID_PLAYER_ID;

									if (Iter_Count(ovoInGame) > 1)
									{
									    foreach(new x:ovoInGame)
									    {
									        if (Player[x][fInWaiting])
									        {
									            Player[x][fInWaiting] = false;
									            avversario = x;
									            break;
									        }
									    }

									    if (avversario == INVALID_PLAYER_ID)
									    {
									    	Player[killerid][fInWaiting] = true;
									    	PlayerAvversario[killerid] = INVALID_PLAYER_ID;

									    	SendClientMessage (killerid, COLOR_SYSTEM, "Wait for the next opponent.");

									    	new szString[ 123 ] = "Current fights: ";// szString

									    	new bool:written[MAX_PLAYERS] = {false, ...};

									    	foreach(new x:ovoInGame)
									    	{
									    	    if (written[x]) continue;

									    	    if (!Player[x][fInWaiting])
									    	    {
									    	        format (szString, sizeof szString, "%s%s vs %s ", szString, Player[x][Nickname], Player[PlayerAvversario[x]][Nickname]);

													if (strlen(szString) > 120)
													{
													    SendClientMessage (killerid, COLOR_SYSTEM, szString);
													    szString = "";
													}

													written[PlayerAvversario[x]] = true;
									    	    }
									    	}

									    	SendClientMessage (killerid, COLOR_SYSTEM, szString);
										}
										else
										{

										    SetPlayerHealth (killerid, 100.0);
										    GivePlayerWeapon (killerid, RoundFightWeapon, 500);

							//				SetPlayerVirtualWorld (killerid, MIN_GM_WORLD + killerid);
											SetPlayerVirtualWorld (avversario, GetPlayerVirtualWorld (killerid));

		                                    PlayerAvversario [avversario] = killerid;
		                                    PlayerAvversario [killerid]   = avversario;

											new id = eScenario[FileID];

										    ShowPlayerNameTagForPlayer(killerid, avversario, true);
										    ShowPlayerNameTagForPlayer(avversario, killerid, true);

											SetPlayerPos(avversario, fFights_Spawns[id][1][0], fFights_Spawns[id][1][1], fFights_Spawns[id][1][2]);
										}

									}
									else
									{
										EndRound (killerid);
									}
								}
							}
							else
							    defer CheckPlayers();
						    	//SetTimer("CheckPlayers", DELAY_CHECKPLAYERS, 0);
						}
		            }
		            else
					{
	                	Player_outSecs[i]  = 10;
	                	Player_outArena[i] = false;
		            }
		        }
			}

	        if (RealRSecs > 59)
	        {
	            RealRMins ++;
	            RealRSecs = 0;
	        }
	    }
	}

	SyncTextdraw(2);
 	defer SyncRound();
 	return 1;
}

// Si suppone che venga utilizzato solo quando ci sta un solo player con InGame su true
stock GetLastAlivePlayer()
{
	foreach(new i:Player) {
	    if (Player[i][InGame]) return i;
	}

	return INVALID_PLAYER_ID;
}

//forward ShakeObject(obj);
timer ShakeObject[100](obj)
{
	if (!RoundStarted)
	{
	    stop fallout_object_timer[obj];
	    return true;
	}

	//SendClientMessageToAll(red, "Timer-Object: %d, alive: %d, obj status: %d", obj, fallout_alive_objs, fallout_obj_status [obj]);

    fallout_obj_status [obj] ++;

	switch (fallout_obj_status[obj])
	{
 		case 0, 5:
   		{
       		SetDynamicObjectRot(obj, 31.8, 2, 0);
     	}
        case 1, 6:
        {
        	SetDynamicObjectRot(obj, 33.8, 0, 0);
        }
        case 2, 7:
        {
        	SetDynamicObjectRot(obj, 31.8, -2, 0);
        }
        case 3, 8:
        {
        	SetDynamicObjectRot(obj, 29.8, 0, 0);
        }
        case 4, 9:
        {
        	SetDynamicObjectRot(obj, 31.8, 0, 0);
        }
        case 10:
        {
        	new Float:X, Float:Y, Float:Z;
        	GetDynamicObjectPos(obj, X, Y, Z);
        	MoveDynamicObject(obj, X, Y, Z - 100, 4);
        }
        case 11..99:
        {
        	SetDynamicObjectRot(obj, 31.8 - ((fallout_obj_status[obj] * 2) - 20), 0, 0);
        }
        case 100:
        {
	       	DestroyDynamicObject(obj);

			stop fallout_object_timer[obj];

	        fallout_alive_objs --;

	        fallout_obj_status [obj] = -1;

	        if (fallout_alive_objs < 3)
	        {
	        	SendClientMessageToAll(red, "Round ended.");
				EndRound ();
				return true;
	        }
  		}
	}

	/*
	if (fallout_obj_status[obj] > 100 || fallout_obj_status[obj] == -1)
	{
 		DestroyDynamicObject(obj);

		KillTimer(fallout_object_timer[obj]);

        fallout_alive_objs --;

        fallout_obj_status [obj] = -1;

		if (fallout_alive_objs < 3)
  		{
    		SendClientMessageToAll(red, "Round ended (Alive objs: %d).", fallout_alive_objs);
			EndRound ();
			return true;
   		}
	}*/
	return true;
}


IsPlayerInArea(playerid, Float:minx, Float:maxx, Float:miny, Float:maxy)
{
    new Float:x, Float:y, Float:z;
    GetPlayerPos(playerid, x, y, z);
    if (x > minx && x < maxx && y > miny && y < maxy) return true;
    return 0;
}

stock AllPlaySound(id)
{
	foreach(new i:Player)
	{
	    PlayerPlaySound(i, id, 0.0, 0.0, 0.0);
	}
}

// score system
stock RGivePlayerScore(playerid, score, text[], resettime = 5)//resettime = in secondi
{
	stop Player_ScorerTimer[playerid]; //"uccide" il timer precedente
	Player[playerid][PlayerScorer_Score] += score;
	Player[playerid][PlayerTotalPoints] += score;

	PlayerTextDrawShow (playerid, PlayerScorer_TD0);
	PlayerTextDrawShow (playerid, PlayerScorer_TD1);

	PlayerTextDrawSetString (playerid, PlayerScorer_TD0, sprintf("+%d", Player[playerid][PlayerScorer_Score]));
	PlayerTextDrawSetString (playerid, PlayerScorer_TD1, text);

//	Player_ScorerTimer[playerid] = SetTimerEx("Player_ResetScores", (resettime*1000), false, "i", playerid);
	Player_ScorerTimer[playerid] = defer Player_ResetScores[resettime*1000](playerid);
	return true;
}

//forward Player_ResetScores(playerid);
timer Player_ResetScores[5000](playerid) {
	Player[playerid][PlayerScorer_Score] = 0;

	PlayerTextDrawHide (playerid, PlayerScorer_TD0);
	PlayerTextDrawHide (playerid, PlayerScorer_TD1);
}

/*
//Scenari
forward LoadArena(tag[], identifier[], text[]);
public LoadArena(tag[], identifier[], text[])
{
	new Float:x, Float:y, Float:z, Float:a;
	sscanf(text, "p<,>ffff", x, y, z, a);

	if(!strcmp(identifier, "T0")||!strcmp(identifier, "T1_0")||!strcmp(identifier, "a_0"))
	{ //att
	    eScenario[SpawnAttackers][0] = x;
	    eScenario[SpawnAttackers][1] = y;
	    eScenario[SpawnAttackers][2] = z;
	}
	else if(!strcmp(identifier, "T1")||!strcmp(identifier, "T2_0")||!strcmp(identifier, "d_0"))
	{ // def
	    eScenario[SpawnDefenders][0] = x;
	    eScenario[SpawnDefenders][1] = y;
	    eScenario[SpawnDefenders][2] = z;
	}
	else if(!strcmp(identifier, "Zmin"))
	{
	    eScenario[MinX] = x;
	    eScenario[MinY] = y;
	}
	else if(!strcmp(identifier, "Zmax"))
	{
	    eScenario[MaxX] = x;
	    eScenario[MaxY] = y;
	}
	else if(!strcmp(identifier, "Interior", true)) eScenario[Interior] = strval(text);
	else if(!strcmp(identifier, "Name", true)) strcpy(eScenario[BaseName], text);
	else if(!strcmp(identifier, "home"))
	{
		eScenario[Checkpoint][0] = x;
  		eScenario[Checkpoint][1] = y;
    	eScenario[Checkpoint][2] = z;
	}
}

forward LoadGunGame(tag[], identifier[], text[]);
public LoadGunGame(tag[], identifier[], text[])
{
	new Float:x, Float:y, Float:z, Float:a;
	sscanf(text, "p<,>ffff", x, y, z, a);

	for(new i = 0; i < MAX_MULTIPLE_SPAWNS; i++)
	{
		if(!strcmp(identifier, numstr(i), true))
		 {
			Scenario_MultipleSpawns[i][0] = x;
			Scenario_MultipleSpawns[i][1] = y;
			Scenario_MultipleSpawns[i][2] = z;
			Scenario_MultipleSpawns[i][3] = a;
		}
	}

	if (!strcmp(identifier, "Interior", true))
	{
	    eScenario[Interior] = strval( text );
	}
	else if (!strcmp(identifier, "zone", true))
	{
	    eScenario[MaxX] = x;
	    eScenario[MaxY] = y;
	    eScenario[MinX] = z;
	    eScenario[MinY] = a;
	}
}

forward LoadMassacre(tag[], identifier[], text[]);
public LoadMassacre(tag[], identifier[], text[])
{
	new Float:x, Float:y, Float:z, Float:a;
	sscanf(text, "p<,>ffff", x, y, z, a);

	for(new i = 0; i < MAX_MULTIPLE_SPAWNS; i++)
	{
		if(!strcmp(identifier, numstr(i), true))
		 {
			Scenario_MultipleSpawns[i][0] = x;
			Scenario_MultipleSpawns[i][1] = y;
			Scenario_MultipleSpawns[i][2] = z;
			Scenario_MultipleSpawns[i][3] = a;
		}
	}

	if (!strcmp(identifier, "Interior", true))
	{
	    eScenario[Interior] = strval( text );
	}
	else if (!strcmp(identifier, "zone", true))
	{
	    eScenario[MaxX] = x;
	    eScenario[MaxY] = y;
	    eScenario[MinX] = z;
	    eScenario[MinY] = a;
	}
}

// Scenario_MultipleSpawns
// MAX_MULTIPLE_SPAWNS

forward LoadScenario(tag[], identifier[], text[]);
public LoadScenario(tag[], identifier[], text[])
{
	new Float:x, Float:y, Float:z, Float:a;
	sscanf(text, "p<,>ffff", x, y, z, a);

	if(!strcmp(identifier, "T1_0") || !strcmp(identifier, "a_0"))
	{ //att
	    eScenario[SpawnAttackers][0] = x;
	    eScenario[SpawnAttackers][1] = y;
	    eScenario[SpawnAttackers][2] = z;
	}
 	else if(!strcmp(identifier, "T2_0") || !strcmp(identifier, "d_0"))
 	{ // def
	    eScenario[SpawnDefenders][0] = x;
	    eScenario[SpawnDefenders][1] = y;
	    eScenario[SpawnDefenders][2] = z;
	}
	else if(!strcmp(identifier, "Interior", true)) eScenario[Interior] = strval(text);
	else if(!strcmp(identifier, "Name", true)) strcpy(eScenario[BaseName], text);
	else if(!strcmp(identifier, "home"))
	{
		eScenario[Checkpoint][0] = x;
  		eScenario[Checkpoint][1] = y;
    	eScenario[Checkpoint][2] = z;
	}
}*/

//forward CheckPlayers();
timer CheckPlayers[DELAY_CHECKPLAYERS]()
{
	switch (Gaming)
	{
	    case GAMETYPE_FIGHT:
	    {
		    if (RoundFightType == FIGHTSIZE_ALLVSALL)
		    {
				new p = 0, x = -1;

			    foreach(new i:Player)
			    {
			        if (Player[i][InGame])
			        {
			            p ++;
			            x = i;
					}
			    }

			    if (p == 1)
			    {
			        if (x == -1) return false;
			        EndRound (x);
			    }
				else if (p == 0)
				{
					EndRound (INVALID_PLAYER_ID, WINTYPE_ELIMINAZIONE);
				}
			}
	    }
	    case GAMETYPE_LASTBULLET:
	    {
			new p = 0, x = -1;

		    foreach(new i:Player)
		    {
		        if (Player[i][InGame])
		        {
          			p ++;
          			x = i;
				}
    		}

		    if (p == 1)
		    {
		        if (x == -1) return false;
			    EndRound (x);
			}
			else if (p == 0)
			{
				EndRound (INVALID_PLAYER_ID, WINTYPE_ELIMINAZIONE);
			}
	    }
	    case GAMETYPE_GUNGAME:
	    {
			new p = 0, x = -1;

		    foreach(new i:Player)
		    {
		        if (Player[i][InGame])
		        {
		            p ++;
		            x = i;
				}
		    }

		    if (p == 1)
		    {
		        if (x == -1) return false;
		        EndRound (x);
		    }
			else if (p == 0)
			{
				EndRound (INVALID_PLAYER_ID, WINTYPE_ELIMINAZIONE);
			}
	    }
	    case GAMETYPE_FALLOUT:
	    {
			if (TeamPlayers[TEAM_A] == 0 && TeamPlayers[TEAM_B] == 0)
			{
			    EndRound (INVALID_PLAYER_ID, WINTYPE_EVERYONEFELL);
			}
		}
	    default:
	    {
			if(TeamPlayers[TEAM_A] < 1 && TeamPlayers[TEAM_B] > 0)
			{
		 		EndRound(TEAM_B);
			}
			else if(TeamPlayers[TEAM_B] == 0 && TeamPlayers[TEAM_A] > 0)
			{
			    EndRound(TEAM_A);
			}
			else if(TeamPlayers[TEAM_A] < 1 && TeamPlayers[TEAM_B] < 1)
			{
			    EndRound(NULL_TEAM);
			}
	    }
	}
	return true;
}

////////////////////////////////////////////////////////////////////////////////
//==============================================================================
////////////////////////////////////////////////////////////////////////////////
//funzioni / etc

ClearDeathMessages()
{
    SendDeathMessage(500, 500, 500);
	SendDeathMessage(500, 500, 500);
	SendDeathMessage(500, 500, 500);
	SendDeathMessage(500, 500, 500);
	SendDeathMessage(500, 500, 500);

	lastKiller = INVALID_PLAYER_ID;
	consegutive = 0;
    return true;
}

stock SendDeathMessageEx(killerid, playerid, reason) {
	if (lastKiller == killerid) {
	    consegutive ++;

	    if (consegutive == 5) {
	        consegutive = 0;
			RGivePlayerScore(killerid, 10, "Kill list!");
	    }
	}
	else {
	    lastKiller  = killerid;
	    consegutive = 1;
	}

	return SendDeathMessage(killerid, playerid, reason);
}

stock GetVehicleModelIDFromName(vname[])
{
	for(new i = 0; i < 211; i++)
	{
		if ( strfind(aVehicleNames[i], vname, true) != -1 )
			return i + MIN_VEHI_ID;
	}
	return -1;
}

stock GetWeaponModelIDFromName(wname[])
{
    for(new i = 0; i < 48; i++) {
        if (i == 19 || i == 20 || i == 21) continue;
		if (strfind(aWeaponNames[i], wname, true) != -1) {
			return i;
		}
	}
	return -1;
}

stock GetWeaponSlot(weaponid)
{
	switch (weaponid)
	{
		case 0, 1: return 0; // Unarmed
		case 2 .. 9: return true; // Melee
		case 22 .. 24: return 2; // Pistol
		case 25 .. 27: return 3; // Shotgun
		case 28, 29, 32: return 4; // SMG
		case 30, 31: return 5; // Machinegun
		case 33, 34: return 6; // Rifle
		case 35 .. 38: return 7; // Heavy
		case 16, 18, 39: return 8; // Projectile
		case 42, 43: return 9; // Special
		case 14 : return 10; // Gifts
		case 44 .. 46: return 11; // Special
		case 40 : return 12; // Detonator
	}
	return 0;
}

strtok(const string[], &index)
{
	new length = strlen(string);
	while ((index < length) && (string[index] <= ' '))
	{
		index++;
	}

	new offset = index;
	new xresult[20];
	while ((index < length) && (string[index] > ' ') && ((index - offset) < (sizeof(xresult) - 1)))
	{
		xresult[index - offset] = string[index];
		index++;
	}
	xresult[index - offset] = EOS;
	return xresult;
}

stock SyncTextdraw(place)//1
{
//	#error Finire nuovo sistema round stats
	if (!RoundStarted) 	return false;
	if (CamMove) 		return false;

	switch (place)
	{
		case 1:
		{
		    if (Gaming == GAMETYPE_LASTBULLET)
		    {
      			TextDrawSetString(RoundStats[1], sprintf ("~b~~h~Players:~w~ %d", TeamPlayers[TEAM_A] + TeamPlayers[TEAM_B]));

			    TextDrawSetString(RoundStats[2], "_");
		    }
			else if (Gaming == GAMETYPE_FIGHT)
			{
			    if (RoundFightType == FIGHTSIZE_ONEVSONE)
			    {
			    	TextDrawSetString(RoundStats[1], sprintf ("~b~~h~Players:~w~ %d", Iter_Count(ovoInGame)));
			    }
			    else
			    {
			        TextDrawSetString(RoundStats[1], sprintf ("~b~~h~Players:~w~ %d", TeamPlayers[TEAM_A] + TeamPlayers[TEAM_B]));
			    }

			    TextDrawSetString(RoundStats[2], "_");
			}
			else if (Gaming == GAMETYPE_GUNGAME)
			{
				if (Gungame_CurrentLeader != INVALID_PLAYER_ID)
				{
					TextDrawSetString(RoundStats[1], sprintf ("~b~~h~Leader:~w~ %s (%d kills)", Player[Gungame_CurrentLeader][Nickname], Gungame_CurrentLeaderLVL));
				}
				else
				{
					TextDrawSetString(RoundStats[1], "~b~~h~Leader:~w~ -");
				}

				TextDrawSetString(RoundStats[2], sprintf ("~g~~h~Players:~w~ %d", TeamPlayers[TEAM_A] + TeamPlayers[TEAM_B]));
			}
			else if (Gaming == GAMETYPE_FALLOUT)
			{
			    TextDrawSetString(RoundStats[1], sprintf ("~b~~h~Players:~w~ %d", TeamPlayers[TEAM_A] + TeamPlayers[TEAM_B]));
			    TextDrawSetString(RoundStats[2], "_");
			}
			else
			{
			    new pHA = 0, pHB = 0, Float:a, Float:h;

				foreach (new i:Player)
				{
				    if (!Player[i][InGame]) continue;

				    GetPlayerHealth(i, h);
				    GetPlayerArmour(i, a);

					if (Player[i][Team] == TEAM_A)
					{
					    pHA += floatround(h + a);
					}
					else
					{
					    pHB += floatround(h + a);
					}
				}

				if (gConfig[Matchmode] != MATCHMODE_NOSCORES)
				{
					SetGameModeText( sprintf( "%s - %d (%d) | %s - %d (%d)" , iTeam[ TEAM_A ][ Name ] , iTeam[ TEAM_A ][ RoundWins ] , pHA , iTeam[ TEAM_B ][ Name ] , iTeam[ TEAM_B ][ RoundWins ] , pHB ) );
				}
/**
Textdraw3 = TextDrawCreate(169.000000, 433.000000, "~r~~h~s7 ~r~4  ~w~(~r~~h~~h~1000~w~)");
TextDrawAlignment(Textdraw3, 2);
TextDrawBackgroundColor(Textdraw3, 48);
TextDrawFont(Textdraw3, 1);
TextDrawLetterSize(Textdraw3, 0.239999, 1.299999);
TextDrawColor(Textdraw3, -1);
TextDrawSetOutline(Textdraw3, 1);
TextDrawSetProportional(Textdraw3, 1);

Textdraw4 = TextDrawCreate(465.000000, 433.000000, "~b~~h~s7 ~b~4  ~w~(~b~~h~~h~1000~w~)");
TextDrawAlignment(Textdraw4, 2);
TextDrawBackgroundColor(Textdraw4, 48);
TextDrawFont(Textdraw4, 1);
TextDrawLetterSize(Textdraw4, 0.239999, 1.299999);
TextDrawColor(Textdraw4, -1);
TextDrawSetOutline(Textdraw4, 1);
TextDrawSetProportional(Textdraw4, 1);
**/
			//	new pA = (pHA * 100) / Team1_StartHP;
			//	new pB = (pHB * 100) / Team2_StartHP;
			//	new x[ 12 ];

				if (Gaming == GAMETYPE_TDM)
				{
					/*if( pA >= 60 ) x = "~g~~h~~h~";
					else if(pA <= 20 ) x = "~r~~h~~h~";
					else x = "~y~h~";

					//( pA >= 60 ? ( "~g~~h~~h~" ) : ( pA <= 20 ? ( "~r~~h~~h~" ) : ( "~y~h~" ) )

					format(stringo, sizeof stringo, "~b~~h~%s~w~ (%s%d~w~ // %d/%d)", iTeam[TEAM_A][Name], x, pHA, iTeam[TEAM_A][TDMKills], gConfig[TDMKills]);
					TextDrawSetString(RoundStats[1], stringo);

					if( pB >= 60 ) x = "~g~~h~~h~";
					else if(pB <= 20 ) x = "~r~~h~~h~";
					else x = "~y~~h~";

					format(stringo, sizeof stringo,  "~g~~h~%s~w~ (%s%d~w~ // %d/%d)", iTeam[TEAM_B][Name], x, pHB, iTeam[TEAM_B][TDMKills], gConfig[TDMKills]);
					TextDrawSetString(RoundStats[2], stringo);*/
					/*
					if( pA >= 60 ) x = "~g~~h~~h~";
					else if(pA <= 20 ) x = "~r~~h~~h~";
					else x = "~y~~h~";

					format(stringo, sizeof stringo, "~"#GT_TEAMA"~~h~%s ~"#GT_TEAMA"~%d  ~w~(%s%d~w~ - %d/%d)", iTeam[TEAM_A][Name], TeamPlayers[TEAM_A], x, pHA, iTeam[TEAM_A][TDMKills], gConfig[TDMKills]);
					TextDrawSetString(RoundStats[1], stringo);*/

					//~r~~h~s7 ~r~4  ~w~(~r~~h~~h~1000~w~)
					format(stringo, sizeof stringo, "~"#GT_TEAMA"~~h~%s ~"#GT_TEAMA"~%d  ~w~(~"#GT_TEAMA"~~h~~h~%d~w~) ~w~(~"#GT_TEAMA"~~h~~h~%d/%d~w~)", iTeam[TEAM_A][Name], TeamPlayers[TEAM_A], pHA, iTeam[TEAM_A][TDMKills], gConfig[TDMKills]);
                    TextDrawSetString(RoundStats[1], stringo);
					/*
					if( pB >= 60 ) x = "~g~~h~~h~";
					else if(pB <= 20 ) x = "~r~~h~~h~";
					else x = "~y~~h~";

					format(stringo, sizeof stringo,  "~"#GT_TEAMB"~~h~%s ~"#GT_TEAMB"~%d  ~w~ (%s%d~w~ - %d/%d)", iTeam[TEAM_B][Name], TeamPlayers[TEAM_B], x, pHB, iTeam[TEAM_B][TDMKills], gConfig[TDMKills]);
					*/
					// ~b~~h~s7 ~b~4  ~w~(~b~~h~~h~1000~w~)

					format (stringo, sizeof stringo, "~"#GT_TEAMB"~~h~%s ~"#GT_TEAMB"~%d  ~w~(~"#GT_TEAMB"~~h~~h~%d~w~) ~w~(~"#GT_TEAMB"~~h~~h~%d/%d~w~)", iTeam[TEAM_B][Name], TeamPlayers[TEAM_B], pHB, iTeam[TEAM_B][TDMKills], gConfig[TDMKills]);
					TextDrawSetString(RoundStats[2], stringo);
				}
				else
				{
				    /*
					if( pA >= 60 ) x = "~g~~h~~h~";
					else if(pA <= 20 ) x = "~r~~h~~h~";
					else x = "~y~~h~";
					*/
					//~b~~h~%s~w~ (%s%d~w~)
					//~b~~h~s7 ~b~5  ~w~(~g~~h~~h~1200~w~)
					//~b~~h~%s ~b~%d  ~w~(%s%d~w~)

					//format(stringo, sizeof stringo, "~"#GT_TEAMA"~~h~%s ~"#GT_TEAMA"~%d  ~w~(%s%d~w~)", iTeam[TEAM_A][Name], TeamPlayers[TEAM_A], x, pHA);

					format(stringo, sizeof stringo, "~"#GT_TEAMA"~~h~%s ~"#GT_TEAMA"~%d  ~w~(~"#GT_TEAMA"~~h~~h~%d~w~)", iTeam[TEAM_A][Name], TeamPlayers[TEAM_A], pHA);
					TextDrawSetString(RoundStats[1], stringo);

					/*
					if( pB >= 60 ) x = "~g~~h~~h~";
					else if(pB <= 20 ) x = "~r~~h~~h~";
					else x = "~y~~h~";
					*/
					// ~g~~h~s7 ~g~5  ~w~(~g~~h~~h~1200~w~)
					// ~g~~h~%s~w~ (%s%d~w~)
		//			format(stringo, sizeof stringo,  "~"#GT_TEAMB"~~h~%s ~"#GT_TEAMB"~%d  ~w~(%s%d~w~)", iTeam[TEAM_B][Name], TeamPlayers[TEAM_B], x, pHB);

					// ~g~~h~%s ~g~%d  ~w~(%s%d~w~)

					format (stringo, sizeof stringo, "~"#GT_TEAMB"~~h~%s ~"#GT_TEAMB"~%d  ~w~(~"#GT_TEAMB"~~h~~h~%d~w~)", iTeam[TEAM_B][Name], TeamPlayers[TEAM_B], pHB);
					TextDrawSetString(RoundStats[2], stringo);
				}

				// aggiornamento barre
				// rStats_ABar
				// rStats_BBar
				/* ** 	    case TEAM_A:
	    {
//          65.0 <- x (Max) 4.0 (min (?)) (3, 25)
//          hp * 0.325

            TextDrawTextSize(HealthBars[playerid][hb_progress], (value * 0.325) , 95.0);
	    }
	    case TEAM_B:
	    {
//          634 (x) (max) - 570 (min (?))
//          hp * 0.32

			TextDrawTextSize(HealthBars[playerid][hb_progress], 570 + (value * 0.32) , 95.0);
		}

	new Text:t = RoundStats[rStats_ABar] = TextDrawCreate(-3.000000, 435.000000, "_");
	TextDrawBackgroundColor(t, 255);
	TextDrawFont(t, 1);
	TextDrawLetterSize(t, 0.600000, 2.300000);
	TextDrawColor(t, -1);
	TextDrawSetOutline(t, 0);
	TextDrawSetProportional(t, 1);
	TextDrawSetShadow(t, 1);
	TextDrawUseBox(t, 1);
	TextDrawBoxColor(t, 3394640);
	TextDrawTextSize(t, 318.000000, 340.000000);

	t = RoundStats[rStats_BBar] = TextDrawCreate(643.000000, 435.000000, "_");
	TextDrawBackgroundColor(t, 255);
	TextDrawFont(t, 1);
	TextDrawLetterSize(t, 0.500000, 1.200000);
	TextDrawColor(t, -1);
	TextDrawSetOutline(t, 0);
	TextDrawSetProportional(t, 1);
	TextDrawSetShadow(t, 1);
	TextDrawUseBox(t, 1);
	TextDrawBoxColor(t, 10040144);
	TextDrawTextSize(t, 320.000000, 323.000000);
	TextDrawBackgroundColor(t, 255);
	TextDrawFont(t, 1);
	TextDrawLetterSize(t, 0.500000, 1.200000);
	TextDrawColor(t, -1);
	TextDrawSetOutline(t, 0);
	TextDrawSetProportional(t, 1);
	TextDrawSetShadow(t, 1);
	TextDrawUseBox(t, 1);
	TextDrawBoxColor(t, 10040144);
	TextDrawTextSize(t, 320.000000, 323.000000);

	TextDrawTextSize(t, 320.000000, 323.000000);
 */


		//		TextDrawTextSize (RoundStats[rStats_ABar], 320 + (pHA * Team1_TotalHP) , 340.0);
			}
		}
		case 2:
		{
		    /*
		    if (Gaming == GAMETYPE_ARENA || Gaming == GAMETYPE_TDM || Gaming == GAMETYPE_FIGHT || Gaming == GAMETYPE_GUNGAME || Gaming == GAMETYPE_FALLOUT || Gaming == GAMETYPE_LASTBULLET)
			{
				format(stringo, sizeof stringo, "~g~~h~%02d:%02d", RealRMins, RealRSecs );
			}
			else
		    {
				if(RealRMins < 2)
				{
					format(stringo, sizeof stringo, "~r~~h~%02d:%02d", RealRMins, RealRSecs );
				}
				else if(RealRMins > 5)
				{
					format(stringo, sizeof stringo, "~g~~h~%02d:%02d", RealRMins, RealRSecs );
				}
				else
				{
					format(stringo, sizeof stringo, "~y~~h~%02d:%02d", RealRMins, RealRSecs );
				}
			}
			*/

			TextDrawSetString( RoundStats[3] , sprintf( "%02d:%02d", RealRMins, RealRSecs ));
		//	TextDrawSetString(RoundStats[rStats_Time], stringo);
		}
	}
	return true;
}

stock FixHealthBars()
{
	if (!gConfig[ UseHealthBars ] || Gaming == GAMETYPE_GUNGAME || Gaming == GAMETYPE_FIGHT || Gaming == GAMETYPE_FALLOUT || Gaming == GAMETYPE_LASTBULLET) return false;

	#define DIFF_Y          13

	for (new i = 0; i < MAX_PLAYERS; i++)
	{
	    DestroyHealthBar(i);
	}

	if (RoundStarted)
	{
		new
		    Float:LastY_A = 214.0,
			Float:LastY_B = 214.0,
			Float:h,
			Float:a;

		foreach(new i:Player)
		{
		    if( ! Player[i][InGame] ) continue;

			GetPlayerHealth(i, h);
			GetPlayerArmour(i, a);

		  	//format( szString , sizeof szString , "%s (%d)", RemoveClan(Player[i][Nickname]) , floatround( h + a ) );

			switch(Player[i][Team])
			{
			    case TEAM_A:
				{   // 4
					CreateHealthBar(i, LastY_A);
					UpdateHealthBar(i, h+a);
					ShowHealthBarForAll(i);

					LastY_A += DIFF_Y;
				}
				case TEAM_B:
				{   //573

					CreateHealthBar(i, LastY_B);
					UpdateHealthBar(i, h+a);
					ShowHealthBarForAll(i);

					LastY_B += DIFF_Y;
				}
			}
		}
	}
	return true;
}

/*stock IsPlayerAdminEx(playerid, cmd[ ])
{
	for (new i = 0; i < sizeof(aCommands); i++)
	{
	    if (!strcmp(aCommands[i][aCommand], cmd, true))
	    {
	        if (aCommands[i][aTempPower] == true && Player[ playerid ][ TmpAdmin ])
	            return true;

			if (Player[playerid][aLevel] >= aCommands[i][aLevel])
			    return true;

	        SendClientMessage( playerid , red , "You must be a level %d+ admin to use this command.", aCommands[ i ][ aLevel ] );
	        PlayerPlaySound(playerid, SOUND_WRONGCOMMAND, 0.0, 0.0, 0.0);
	        return false;
	    }
	}
	if (Player[playerid][aLevel] <= 2)
	{
 		SendClientMessage( playerid , red , "You must be a level 2+ admin to use this command.");
   		PlayerPlaySound(playerid, SOUND_WRONGCOMMAND, 0.0, 0.0, 0.0);
   		return false;
	}
	return true;
}*/

stock IsSubPlayer(playerid)
{
	if(Player[playerid][Team] == TEAM_A_SUB||Player[playerid][Team]==TEAM_B_SUB)
	{
	    return true;
	}
	return 0;
}

stock GetPlayerSkinEx(playerid)
{
	new
	    skin;

 	if(RoundStarted && Player[playerid][InGame])
 	{
 		skin = iTeam[Player[playerid][Team]][Skin];
	}
	else
	{
	    if( Player[playerid][Skin] > 0 )
		{
		   	skin = Player[playerid][Skin];
		}
		else
		{
		    skin = iTeam[Player[playerid][Team]][Skin];
		}
	}
	return skin;
}

////////////////////////////////////////////////////////////////////////////////
//==============================================================================
////////////////////////////////////////////////////////////////////////////////
//anticheat - writing / reporting functions
/*#if AC_ENABLED == true
enum AC
{
	Vehicles
}

//invia un messaggio agli admins + salva il cheat rilevato sul file ac.txt
stock AC_Message( AC:type , playerid )
{
	new str[ 128 ];
	new h, m, s , y , M , d;

	gettime( h , m , s );
	getdate( y , M , d );

	switch (AC:type)
	{
	    case Vehicles: { format( str , sizeof str, "[%d/%d/%d %d:%d:%d] AC: %s is driving a vehicle not registered on the server. (%d)", d , M , y , h , m , s , Player[ playerid ][ Nickname ] , GetPlayerVehicleID( playerid ) ); }
	}

	AC_WriteLog( str );
	SendAdminMessage( str );
	return true;
}
//invia il report agli admins
stock SendAdminMessage( const message[ ] )
{
	foreach(new i:Player)
	{
	    if (Player[i][aLevel] > 0 || IsPlayerAdmin(i))
		{
	        SendClientMessage( i , red , message );
	    }
	}
	return true;
}
//scrive sul file ac.txt il cheat rilevato + player + ora
stock AC_WriteLog( message[ 128 ] )
{
	new
	    File:f = fopen( "FeuerFrei/logs/ac.txt" , io_append )
	;

	strcat( message , "\r\n" );

	fwrite( f , message );

	fclose( f );
	return true;
}
////////////////////////////////////////////////////////////////////////////////
//==============================================================================
////////////////////////////////////////////////////////////////////////////////
//anticheat - checking / more functions
//rileva se il veicolo in uso ï¿½ registrato dalla gamemode
stock AC_VehicleCheck( vehicle , playerid )
{
	if (GetVehicleModel( vehicle ) == 570) return false;
	if ( iVeh[ vehicle ][Created] == false )
	{
	    DestroyVehicle( vehicle );
	    AC_Message( AC:Vehicles , playerid );
	    return true;
	}
	return false;
}*/
////////////////////////////////////////////////////////////////////////////////
//==============================================================================
////////////////////////////////////////////////////////////////////////////////
//cars
#define CARLABEL_DISTANCE       25.0

stock CreateVehicleEx(modelid, Float:x, Float:y, Float:z, Float:angle, color1, color2, respawn_delay, world = 0)
{
	new veh = CreateVehicle(modelid, x, y, z, angle, color1, color2, respawn_delay);
	LinkVehicleToInterior(veh, world);
	new szScritta[ 60 ];

//	strcat(szScritta, aVehicleNames[modelid-400]);
//	strcat(szScritta, "stringo = "\n{FF0000}- ¤¤¤¤¤¤¤¤¤¤ -";");

    szScritta = "{"#HEX_OTHER_COLOR"}- {"#HEX_HEALTH_COLOR_VEH"}¤¤¤¤¤¤¤¤¤¤{"#HEX_OTHER_COLOR"} -\n";
    strcat(szScritta, aVehicleNames[modelid-400]);

	VehLabel[veh] = Create3DTextLabel(szScritta, 0xA61100AA, 0.0, 0.0, 0.0, CARLABEL_DISTANCE, world);
	Attach3DTextLabelToVehicle(VehLabel[veh], veh, 0.0, 0.0, 0.5);

	iVeh[veh][Color1] = color1;
	iVeh[veh][Color2] = color2;
	Iter_Add(iVehicles, veh);
	iVeh[veh][Created] = true;
	return veh;
}

stock Label_AddStaticVehicle(modelid, Float:x, Float:y, Float:z, Float:angle, color1, color2, world = 0)
{
	new veh = AddStaticVehicle(modelid, x, y, z, angle, color1, color2);
	LinkVehicleToInterior(veh, world);
	new szScritta[ 60 ];
    szScritta = "{"#HEX_OTHER_COLOR"}- {"#HEX_HEALTH_COLOR_VEH"}¤¤¤¤¤¤¤¤¤¤{"#HEX_OTHER_COLOR"} -\n";
    strcat(szScritta, aVehicleNames[modelid-400]);
	VehLabel[veh] = Create3DTextLabel(szScritta, 0xA61100AA, 0.0, 0.0, 0.0, CARLABEL_DISTANCE, world);
	Attach3DTextLabelToVehicle(VehLabel[veh], veh, 0.0, 0.0, 0.5);
	iVeh[veh][Color1] = color1;
	iVeh[veh][Color2] = color2;
	Iter_Add(iVehicles, veh);
	iVeh[veh][Created] = true;
	return veh;
}

stock Label_AddStaticVehicleEx(modelid, Float:x, Float:y, Float:z, Float:angle, color1, color2, world)
{
	new veh = AddStaticVehicleEx(modelid, x, y, z, angle, color1, color2, 0);

	new szScritta[ 60 ];
    szScritta = "{"#HEX_OTHER_COLOR"}- {"#HEX_HEALTH_COLOR_VEH"}¤¤¤¤¤¤¤¤¤¤{"#HEX_OTHER_COLOR"} -\n";
    strcat(szScritta, aVehicleNames[modelid-400]);
	VehLabel[veh] = Create3DTextLabel(szScritta, 0xA61100AA, 0.0, 0.0, 0.0, CARLABEL_DISTANCE, world);
	Attach3DTextLabelToVehicle(VehLabel[veh], veh, 0.0, 0.0, 0.5);
	iVeh[veh][Color1] = color1;
	iVeh[veh][Color2] = color2;
	Iter_Add(iVehicles, veh);
	iVeh[veh][Created] = true;
	return veh;
}

stock ChangeVehiclePaintjobEx(veh, paint)
{
    iVeh[veh][Paint] = paint;
	return ChangeVehiclePaintjob(veh, paint);
}

/*stock AddVehicleComponentEx(vehicleid, component)
{
	return AddVehicleComponent(vehicleid, component);
}*/

stock DestroyVehicleEx(vehid)
{
	// To avoid bugs.
	if (iVeh[vehid][Created] == false) return false;

	DestroyVehicle(vehid);
	Iter_Remove(iVehicles, vehid);
	iVeh[vehid][Created] = false;
	Delete3DTextLabel(VehLabel[vehid]);
	return true;
}

////////////////////////////////////////////////////////////////////////////////
//==============================================================================
////////////////////////////////////////////////////////////////////////////////
//alcune cose

// swap teams
//stock SwapTeams()
forward SwapTeams();
public SwapTeams()
{
	new
	    xname [MAX_TEAM_NAME];

	// switch main teams
	// xname = iTeam[TEAM_A][Name];
	strcat(xname, iTeam[TEAM_A][Name], MAX_TEAM_NAME);

	strdel(iTeam[TEAM_A][Name], 0, MAX_TEAM_NAME);
	strcat(iTeam[TEAM_A][Name], iTeam[TEAM_B][Name], MAX_TEAM_NAME);
	//iTeam[TEAM_A][Name] = iTeam[TEAM_B][Name];

	strdel(iTeam[TEAM_B][Name], 0, MAX_TEAM_NAME);
	strcat(iTeam[TEAM_B][Name], xname, MAX_TEAM_NAME);
	iTeam[TEAM_B][Name] = xname;

	// switch sub name

	// xname = iTeam[TEAM_A][Name];
	strdel(xname, 0, MAX_PLAYER_NAME);
	strcat(xname, iTeam[TEAM_A_SUB][Name], MAX_TEAM_NAME);

	strdel(iTeam[TEAM_A_SUB][Name], 0, MAX_TEAM_NAME);
	strcat(iTeam[TEAM_A_SUB][Name], iTeam[TEAM_B_SUB][Name], MAX_TEAM_NAME);

	strdel(iTeam[TEAM_B_SUB][Name], 0, MAX_TEAM_NAME);
	strcat(iTeam[TEAM_B_SUB][Name], xname, MAX_TEAM_NAME);
	iTeam[TEAM_B_SUB][Name] = xname;

    TextDrawSetString(Classtd_SpawnTN[6], sprintf("~r~~h~~h~%s", iTeam[TEAM_A][Name]));
    TextDrawSetString(Classtd_SpawnTN[7], sprintf("~b~~h~~h~%s", iTeam[TEAM_B][Name]));

	new
	    tmp_int;

	tmp_int = iTeam[TEAM_A][RoundWins];

	iTeam[TEAM_A][RoundWins] = iTeam[TEAM_B][RoundWins];
	iTeam[TEAM_B][RoundWins] = tmp_int;

	tmp_int = iTeam[TEAM_A][tPlayers];
	iTeam[TEAM_A][tPlayers] = iTeam[TEAM_B][tPlayers];
	iTeam[TEAM_B][tPlayers] = tmp_int;

	foreach(new playerid:Player)
	{
		switch (Player[playerid][Team])
		{
		    case TEAM_A:
		        Player[playerid][Team] = TEAM_B;
		    case TEAM_B:
		        Player[playerid][Team] = TEAM_A;
		    case TEAM_A_SUB:
		        Player[playerid][Team] = TEAM_B_SUB;
		    case TEAM_B_SUB:
                Player[playerid][Team] = TEAM_A_SUB;
		}

	    new
			Float:x, Float:y, Float:z, Float:a;

	    GetPlayerPos(playerid, x, y, z);
	    GetPlayerFacingAngle(playerid, a);

		Sync_InCorso[playerid] = 1;

		GetPlayerWeaponData(playerid, 0, Sync_Weapons_ID[playerid][0], Sync_Weapons_AMMO[playerid][0]);
		GetPlayerWeaponData(playerid, 1, Sync_Weapons_ID[playerid][1], Sync_Weapons_AMMO[playerid][1]);
		GetPlayerWeaponData(playerid, 2, Sync_Weapons_ID[playerid][2], Sync_Weapons_AMMO[playerid][2]);
		GetPlayerWeaponData(playerid, 3, Sync_Weapons_ID[playerid][3], Sync_Weapons_AMMO[playerid][3]);
		GetPlayerWeaponData(playerid, 4, Sync_Weapons_ID[playerid][4], Sync_Weapons_AMMO[playerid][4]);
		GetPlayerWeaponData(playerid, 5, Sync_Weapons_ID[playerid][5], Sync_Weapons_AMMO[playerid][5]);
		GetPlayerWeaponData(playerid, 6, Sync_Weapons_ID[playerid][6], Sync_Weapons_AMMO[playerid][6]);
		GetPlayerWeaponData(playerid, 7, Sync_Weapons_ID[playerid][7], Sync_Weapons_AMMO[playerid][7]);
		GetPlayerWeaponData(playerid, 8, Sync_Weapons_ID[playerid][8], Sync_Weapons_AMMO[playerid][8]);
		GetPlayerWeaponData(playerid, 9, Sync_Weapons_ID[playerid][9], Sync_Weapons_AMMO[playerid][9]);
		GetPlayerWeaponData(playerid, 10, Sync_Weapons_ID[playerid][10], Sync_Weapons_AMMO[playerid][10]);
		GetPlayerWeaponData(playerid, 11, Sync_Weapons_ID[playerid][11], Sync_Weapons_AMMO[playerid][11]);
		GetPlayerWeaponData(playerid, 12, Sync_Weapons_ID[playerid][12], Sync_Weapons_AMMO[playerid][12]);

		if (Player[playerid][InGame])
		{
			foreach(new i:Player)
			{
				SetPlayerMarkerForPlayer( i, playerid, ( GetPlayerColor( playerid ) & 0xFFFFFF00 ) );
			}
		}

	    SetSpawnInfo(playerid, Player[playerid][Team], GetPlayerSkinEx(playerid), x, y, z - 0.5, a, 0, 0, 0, 0, 0, 0);

	    GetPlayerHealth(playerid, Sync_Health[playerid]);
	    GetPlayerArmour(playerid, Sync_Armour[playerid]);

	    SpawnPlayer(playerid);
	}

	RefreshTeamPlayers_TD();
	RefreshTextGeneralTD();

	if (gConfig[Matchmode] == MATCHMODE_NOSCORES)
	    SendRconCommand(sprintf("mapname Lobby %d:%d",  iTeam[TEAM_A][RoundWins], iTeam[TEAM_B][RoundWins]));
	else
		SendRconCommand(sprintf("mapname Lobby %s %d:%d %s", iTeam[TEAM_A][Name], iTeam[TEAM_A][RoundWins], iTeam[TEAM_B][RoundWins], iTeam[TEAM_B][Name]));

	// Now swap saved teams
	for (new i = 0; i < MAX_SAVE_SLOTS; ++i) {
	    if (!SavedPlayer[i][sAssigned]) continue;
		switch (SavedPlayer[i][sTeam]) {
		    case TEAM_A: {
		        SavedPlayer[i][sTeam] = TEAM_B;
		    }
		    case TEAM_B: {
		        SavedPlayer[i][sTeam] = TEAM_A;
		    }
		    case TEAM_A_SUB: {
		        SavedPlayer[i][sTeam] = TEAM_B_SUB;
		    }
		    case TEAM_B_SUB: {
		        SavedPlayer[i][sTeam] = TEAM_A_SUB;
		    }
		}
	}
	return 1;
}

/*stock GetPlayerSpeed(playerid)
{
    new Float:ST[4];
    if(IsPlayerInAnyVehicle(playerid))
    GetVehicleVelocity(GetPlayerVehicleID(playerid),ST[0],ST[1],ST[2]);
    else GetPlayerVelocity(playerid,ST[0],ST[1],ST[2]);
    ST[3] = floatsqroot(floatpower(floatabs(ST[0]), 2.0) + floatpower(floatabs(ST[1]), 2.0) + floatpower(floatabs(ST[2]), 2.0)) * 179.28625;
    return floatround(ST[3]);
}*/

stock IsNosCompatible(vehicle)
{
	switch(vehicle)
	{
		case 417,425,430,435,441,446,447,448,449,450,452,453,454,460,461,462,463,464,465,468,469,472,473,476,481,484,487,488,493,497,501,509,510,511,512,513,519,520,521,522,523,537,538,539,548,553,563,564,569,570,577,581,584,586,590,591,592,593,594,595,606,607,608,610,611: return false;
	}
	return true;
}

stock GetPlayerFromIp(ip[]) {
	new xip[24];
	foreach(new i:Player) {
	    GetPlayerIp(i, xip, 24);
	    if(!strcmp(xip, ip)) return i;
	}
	return -1;
}

stock GetWeaponModel(weaponid)
{
    new model;

    switch(weaponid)
    {
        case 1: model=331; case 2: model=333; case 3: model=334;
        case 4: model=335; case 5: model=336; case 6: model=337;
        case 7: model=338; case 8: model=339; case 9: model=341;
        case 10: model=321; case 11: model=322; case 12: model=323;
        case 13: model=324; case 14: model=325; case 15: model=326;
        case 16: model=342; case 17: model=343; case 18: model=344;
        case 22: model=346; case 23: model=347; case 24: model=348;
        case 25: model=349; case 26: model=350; case 27: model=351;
        case 28: model=352; case 29: model=353; case 30: model=355;
        case 31: model=356; case 32: model=372; case 33: model=357;
        case 34: model=358; case 35: model=359; case 36: model=360;
        case 37: model=361; case 38: model=362; case 39: model=363;
        case 41: model=365; case 42: model=366; case 46: model=371;
    }

    return model;
}

stock IsPlayerPaused(playerid)
{
	if( (gettime() - 2000) >= ( Player[playerid][Last_Tick]) ) {
	    return true;
	}
	return 0;
}

////////////////////////////////////////////////////////////////////////////////
//==============================================================================
////////////////////////////////////////////////////////////////////////////////
//checker+afk
/*forward LimitsChecker();
public LimitsChecker() {
	foreach(new i:Player){

	    if(! Player[i][Spawned] ) continue;
	    if( Player[i][IsAfk] ) continue;

	    if( gConfig[EPLLimit] )
		{
	        if( GetPlayerPacketloss(i) > gConfig[PlLimit] )
			{
			    SendClientMessageToAll(COLOR_SYSTEM, "%s has been automatically kicked from the server. (Reason: Packetloss) (Packetloss: %f - Limit: %f)", Player[i][Nickname], GetPlayerPacketloss(i), gConfig[PlLimit] );
			    Kick(i, "Too High Packetloss");
			}
	    }

	    if( gConfig[EFpsLimit] )
		{
	        if( pFPS[i] < gConfig[FpsLimit] )
			{
			    SendClientMessageToAll(COLOR_SYSTEM, "%s has been automatically kicked from the server. (Reason: Low FPS) (FPS: %d - Limit: %d)", Player[i][Nickname], pFPS[i], gConfig[FpsLimit]);
			    Kick(i, "Too Low FPS");
			}
	    }

	    if( gConfig[EPingLimit] )
		{
	        if( GetPlayerPing(i) > gConfig[PingLimit] )
			{
			    SendClientMessageToAll(COLOR_SYSTEM, "%s has been automatically kicked from the server. (Reason: Too High Ping) (Ping: %d - Limit: %d)", Player[i][Nickname], GetPlayerPing(i), gConfig[PingLimit]);
			    Kick(i, "Too High Ping");
			}
	    }

	    if(GetPlayerState(i) == PLAYER_STATE_SPECTATING) continue;

	    if( IsPlayerPaused( i ) )
		{
	        if(Player[i][IsAfk]) continue;

	        PlayerAfk_Seconds[i]++;

	        if( Player[i][AfkLabelCreated] == false )
			{
				Player[ i ][ AfkLabel ] = Create3DTextLabel("I'm AFK", COLOR_RED, 0.0, 0.0, 0.0, 30.0, -1, 0);
				Attach3DTextLabelToPlayer(Player[ i ][ AfkLabel ], i, 0.0, 0.0, 0.0);
				Player[i][AfkLabelCreated] = true;
			}

			if( Player[i][InGame] )
			{
			    if( PlayerAfk_Seconds[i] > 3 && !GamePaused && CamMove == false )
				{
				    SendClientMessageToAll(COLOR_SYSTEM, "%s has been auto-removed from the round for being AFK.", Player[i][Nickname]);
				    Player_outSecs[i] = 10;

					TextDrawHideForPlayer(i, RoundStats[0]);
					TextDrawHideForPlayer(i, RoundStats[1]);
					TextDrawHideForPlayer(i, RoundStats[2]);
					TextDrawHideForPlayer(i, RoundStats[3]);

				    DisablePlayerCheckpoint(i);

					Player[i][InGame] = 0;
					SetPlayerVirtualWorld(i, NORMAL_WORLD);
					SetPlayerColor(i, iTeam[Player[i][Team]][OutColor]);

					if (!CamMove)
					{
						FixHealthBars();
					}

					SyncTextdraw(1);

					RemovePlayerMapIcon(i, MAPICON_ATTACKERSPAWN);

					if( Player[i][Team] == TEAM_A )
					{
					    Team1_StartHP -= gConfig[GameMode] == GAMEMODE_NOCBUG ? 100 : 200;

						if (Team1_StartHP == 0)
						    Team1_StartHP = 1;
					}
					else if( Player[i][Team] == TEAM_B )
					{
						Team2_StartHP -= gConfig[GameMode] == GAMEMODE_NOCBUG ? 100 : 200;

						if (Team2_StartHP == 0)
						    Team2_StartHP = 1;
					}

				    TeamPlayers[Player[i][Team]] --;

					if (Gaming == GAMETYPE_BASE)
					{
						if(Player[i][Weaponset] != INVALID_WEAPON_SET)
						{
							Weaponsets[Player[i][Weaponset]][TeamSelection][Player[i][Team]] --;
						}

						Player[i][Weaponset] = INVALID_WEAPON_SET;
					}

					TextDrawShowForPlayer(i, TeamPlayers_TD);
					SetSpawnInfo(i, i, GetPlayerSkinEx(i), Lobby[0] - MAX_RANDOM_SPAWN + random( MAX_RANDOM_SPAWN ), Lobby[1] - MAX_RANDOM_SPAWN + random( MAX_RANDOM_SPAWN ), Lobby[2], Lobby[3], 0, 0, 0, 0, 0, 0);

					if( GamePaused )
					{
						TogglePlayerControllable(i, true);
					 	TextDrawHideForPlayer(i, RoundPaused[ 0 ] );
					  	TextDrawHideForPlayer(i, RoundPaused[ 1 ] );
					}

				   	GangZoneHideForPlayer(i, ZonaAttornoCP);

					SpawnPlayer(i);

					if (AntiHits)
					{
					    TextDrawHideForPlayer(i, TD_NotHits[0]);
					    TextDrawHideForPlayer(i, TD_NotHits[1]);
					}

					RefreshTeamPlayers_TD();

					if(!GamePaused)
					{
						if(Gaming != GAMETYPE_GUNGAME)
						{
						    SetTimer("CheckPlayers", DELAY_CHECKPLAYERS, 0);
						}
						else
						{
						    new p = 0, la = INVALID_PLAYER_ID;
						    foreach(new a:Player)
							{
						        if(Player[a][InGame])
								{
									p++;
									la=a;
								}
						    }
						    if(p == 1)
							{
						        EndRound(la);
						    }
						    else if(p == 0)
							{
						        EndRound(INVALID_PLAYER_ID);
						    }
						}
					}
			    }
			}
			else
			{
			    if (gConfig[AutoAFK])
			    {
				    if( PlayerAfk_Seconds[i] > 12 )
					{
						cmd_afk(i, "");
				    }
				}
			}
		}
	}
}
*/
////////////////////////////////////////////////////////////////////////////////
//==============================================================================
////////////////////////////////////////////////////////////////////////////////
enum hb_bars
{
	Text:hb_bg,
	Text:hb_progress,
	Text:hb_name,
	bool:hb_created,
	Float:hb_y,
}


new HealthBars[MAX_PLAYERS][hb_bars];

stock CreateHealthBar(playerid, Float:y)
{
	if (HealthBars[playerid][hb_created])
	    return false;

	switch (Player[playerid][Team])
	{
	    case TEAM_A:
	    {
			/*new Text:td = HealthBars[playerid][hb_bg] = TextDrawCreate(35.000000, y, "_");
			TextDrawAlignment(td, 2);
			TextDrawBackgroundColor(td, 112);
			TextDrawFont(td, 1);
			TextDrawLetterSize(td, 0.500000, 0.799996);
			TextDrawColor(td, -1);
			TextDrawSetOutline(td, 0);
			TextDrawSetProportional(td, 1);
			TextDrawSetShadow(td, 1);
			TextDrawUseBox(td, 1);
			TextDrawBoxColor(td, 112);
			TextDrawTextSize(td, 0.000000, 62.000000);*/

			new Text:td = HealthBars[playerid][hb_bg] = TextDrawCreate(37.000000, y, "_");
			TextDrawAlignment(td, 2);
			TextDrawBackgroundColor(td, 255);
			TextDrawFont(td, 1);
			TextDrawLetterSize(td, 0.500000, 0.799998);
			TextDrawColor(td, -1);
			TextDrawSetOutline(td, 0);
			TextDrawSetProportional(td, 1);
			TextDrawSetShadow(td, 1);
			TextDrawUseBox(td, 1);
			TextDrawBoxColor(td, 48);
			TextDrawTextSize(td, 0.000000, 66.000000);

			/*
			td = HealthBars[playerid][hb_progress] = TextDrawCreate(5.000000, y + 1, "_");
			TextDrawBackgroundColor(td, 255);
			TextDrawFont(td, 1);
			TextDrawLetterSize(td, 0.519999, 0.599996);
			TextDrawColor(td, -1);
			TextDrawSetOutline(td, 0);
			TextDrawSetProportional(td, 1);
			TextDrawSetShadow(td, 1);
			TextDrawUseBox(td, 1);
			TextDrawBoxColor(td, 3394640);//003399
			TextDrawTextSize(td, 65.000000, 49.00000);
			*/

			//td = HealthBars[playerid][hb_progress] = TextDrawCreate(37.000000, y + 1, "_");
			/*TextDrawAlignment(td, 2);
			TextDrawBackgroundColor(td, 255);
			TextDrawFont(td, 1);
			TextDrawLetterSize(td, 0.500000, 0.599997);
			TextDrawColor(td, -1);
			TextDrawSetOutline(td, 0);
			TextDrawSetProportional(td, 1);
			TextDrawSetShadow(td, 1);
			TextDrawUseBox(td, 1);
			TextDrawBoxColor(td, 424381232);
			TextDrawTextSize(td, 0.000000, 64.000000);*/

			td = HealthBars[playerid][hb_progress] = TextDrawCreate(5.000000, y + 1, "_");
			TextDrawBackgroundColor(td, 255);
			TextDrawFont(td, 1);
			TextDrawLetterSize(td, 0.500000, 0.599997);
			TextDrawColor(td, -1);
			TextDrawSetOutline(td, 0);
			TextDrawSetProportional(td, 1);
			TextDrawSetShadow(td, 1);
			TextDrawUseBox(td, 1);
			//TextDrawBoxColor(td, 424381232); 0xff0505AA  424381232
			TextDrawBoxColor(td, 0xff050520);

			TextDrawTextSize(td, 51.000000, 64.000000);

			/*td = HealthBars[playerid][hb_name] = TextDrawCreate(33.000000, y - 2, "x");
			TextDrawAlignment(td, 2);
			TextDrawBackgroundColor(td, 255);
			TextDrawFont(td, 1);
			TextDrawLetterSize(td, 0.119998, 1.100000);
			TextDrawColor(td, -1714618369);
			TextDrawSetOutline(td, 0);
			TextDrawSetProportional(td, 1);
			TextDrawSetShadow(td, 1);*/

			td = HealthBars[playerid][hb_name] = TextDrawCreate(37.000000, y - 1, "Nickname");
			TextDrawAlignment(td, 2);
			TextDrawBackgroundColor(td, 48);
			TextDrawFont(td, 1);
			TextDrawLetterSize(td, 0.169999, 0.799996);
			TextDrawColor(td, -1);
			TextDrawSetOutline(td, 1);
			TextDrawSetProportional(td, 1);
		}
		case TEAM_B:
		{
			/*new Text:td = HealthBars[playerid][hb_bg] = TextDrawCreate(604.000000, y, "_");
			TextDrawAlignment(td, 2);
			TextDrawBackgroundColor(td, 112);
			TextDrawFont(td, 1);
			TextDrawLetterSize(td, 0.500000, 0.799996);
			TextDrawColor(td, -1);
			TextDrawSetOutline(td, 0);
			TextDrawSetProportional(td, 1);
			TextDrawSetShadow(td, 1);
			TextDrawUseBox(td, 1);
			TextDrawBoxColor(td, 112);
			TextDrawTextSize(td, 0.000000, 62.000000);*/

			new Text:td = HealthBars[playerid][hb_bg] = TextDrawCreate(602.000000, y, "_");
			TextDrawAlignment(td, 2);
			TextDrawBackgroundColor(td, 255);
			TextDrawFont(td, 1);
			TextDrawLetterSize(td, 0.500000, 0.799997);
			TextDrawColor(td, -1);
			TextDrawSetOutline(td, 0);
			TextDrawSetProportional(td, 1);
			TextDrawSetShadow(td, 1);
			TextDrawUseBox(td, 1);
			TextDrawBoxColor(td, 48);
			TextDrawTextSize(td, 0.000000, 66.000000);

			/*td = HealthBars[playerid][hb_progress] = TextDrawCreate(574.000000, y + 1, "_");
			TextDrawBackgroundColor(td, 255);
			TextDrawFont(td, 1);
			TextDrawLetterSize(td, 0.539999, 0.599997);
			TextDrawColor(td, -1);
			TextDrawSetOutline(td, 0);
			TextDrawSetProportional(td, 1);
			TextDrawSetShadow(td, 1);
			TextDrawUseBox(td, 1);
			TextDrawBoxColor(td, 10040144);
			TextDrawTextSize(td, 634.000000, 99.000000);

			td = HealthBars[playerid][hb_progress] = TextDrawCreate(602.000000, y + 1, "_");
			TextDrawAlignment(td, 2);
			TextDrawBackgroundColor(td, 255);
			TextDrawFont(td, 1);
			TextDrawLetterSize(td, 0.500000, 0.599997);
			TextDrawColor(td, -1);
			TextDrawSetOutline(td, 0);
			TextDrawSetProportional(td, 1);
			TextDrawSetShadow(td, 1);
			TextDrawUseBox(td, 1);
			TextDrawBoxColor(td, 997861680);
			TextDrawTextSize(td, 0.000000, 64.000000);*/

			td = HealthBars[playerid][hb_progress] = TextDrawCreate(570.000000, y + 1, "_");
			TextDrawBackgroundColor(td, 255);
			TextDrawFont(td, 1);
			TextDrawLetterSize(td, 0.500000, 0.599997);
			TextDrawColor(td, -1);
			TextDrawSetOutline(td, 0);
			TextDrawSetProportional(td, 1);
			TextDrawSetShadow(td, 1);
			TextDrawUseBox(td, 1);
			TextDrawBoxColor(td, 424381232);
			TextDrawTextSize(td, 606.000000, 64.000000);

			/*td = HealthBars[playerid][hb_name] = TextDrawCreate(603.000000, y - 2, "x");
			TextDrawAlignment(td, 2);
			TextDrawBackgroundColor(td, 255);
			TextDrawFont(td, 1);
			TextDrawLetterSize(td, 0.119998, 1.100000);
			TextDrawColor(td, -1714644481);
			TextDrawSetOutline(td, 0);
			TextDrawSetProportional(td, 1);
			TextDrawSetShadow(td, 1);*/

			td = HealthBars[playerid][hb_name] = TextDrawCreate(602.000000, y - 1, "Morgengreen: 200");
			TextDrawAlignment(td, 2);
			TextDrawBackgroundColor(td, 48);
			TextDrawFont(td, 1);
			TextDrawLetterSize(td, 0.169999, 0.799997);
			TextDrawColor(td, -1);
			TextDrawSetOutline(td, 1);
			TextDrawSetProportional(td, 1);
		}
	}

	HealthBars[playerid][hb_y] = y;
	HealthBars[playerid][hb_created] = true;
	return 1;
}

stock UpdateHealthBar(playerid, Float:value)
{
	if(!HealthBars[playerid][hb_created])
	    return false;

	switch (Player[playerid][Team])
	{
	    case TEAM_A:
	    {
////vecchie          65.0 <- x (Max) 4.0 (min (?)) (3, 25)
//          69 max - 1 min
////vecchie          hp * 0.325

            TextDrawTextSize(HealthBars[playerid][hb_progress], (value * 0.345) , 95.0);
	    }
	    case TEAM_B:
	    {
////vecchie          634 (x) (max) - 570 (min (?))
//          634 max - 566 min 320 + (pHA * Team1_TotalHP)
////vecchie          hp * 0.32

			TextDrawTextSize(HealthBars[playerid][hb_progress], 566 + (value * 0.345) - 1, 95.0);
		}
	}

	TextDrawSetString(HealthBars[playerid][hb_name], sprintf ("%s: %d",  Player[playerid][Nickname_WOTag], floatround(value)));
	return 1;
}

stock DestroyHealthBar(playerid)
{
	if(!HealthBars[playerid][hb_created])
	    return false;

    HealthBars[playerid][hb_created] = false;

    TextDrawDestroy(HealthBars[playerid][hb_bg]);
    TextDrawDestroy(HealthBars[playerid][hb_progress]);
    TextDrawDestroy(HealthBars[playerid][hb_name]);
	return 1;
}

stock ShowHealthBarForAll(playerid)
{
	if(!HealthBars[playerid][hb_created])
	    return false;

	foreach(new i:Player)
	{
	    if (Player[i][InGame] || InSpec[i] != -1)
		{
//		    TextDrawHideForPlayer(i, HealthBars[playerid][hb_bg]);
//		    TextDrawHideForPlayer(i, HealthBars[playerid][hb_progress]);
//		    TextDrawHideForPlayer(i, HealthBars[playerid][hb_name]);

		    TextDrawShowForPlayer(i, HealthBars[playerid][hb_bg]);
		    TextDrawShowForPlayer(i, HealthBars[playerid][hb_progress]);
		    TextDrawShowForPlayer(i, HealthBars[playerid][hb_name]);
		}
	}
	return true;
}

////////////////////////////////////////////////////////////////////////////////
//==============================================================================
////////////////////////////////////////////////////////////////////////////////
//sscanf
//cmd_alvl

SSCANF:weaps(string[])
{
    // This function is VERY basic, needs VASTLY improving to detect variations.
    if ('0' <= string[0] <= '9')
    {
        new
            ret = strval(string);
        if (0 <= ret <= 48)
        {
            return ret;
        }
    }
	else
	{
		for(new i = 0; i < 48; i++)
		{
	 		if (i == 19 || i == 20 || i == 21) continue;
			if (strfind(aWeaponNames[i], string, true) != -1) {
				return i;
			}
		}
	}
    return -1;
}

SSCANF:demothing(string[])
{
    if ('0' <= string[0] <= '9')
    {
        new
            ret = strval(string);
        if (0 <= ret <= 3)
        {
            return ret;
        }
    }
	else
	{
	    if (!strcmp(string, "base", true)) return 0;
	    else if (!strcmp(string, "arena", true)) return 1;
	    else if (!strcmp(string, "gungame", true)) return 2;
        else if (!strcmp(string, "massacre", true)) return 3;
	}
    return -1;

}

SSCANF:cmd_alvl(string[])
{
   	if (!strcmp(string, "Remove", true)) return 0;
    else if (!strcmp(string, "Mod", true)) return 1;
    else if (!strcmp(string, "newbieadmin", true)) return 2;
    else if (!strcmp(string, "Admin", true)) return 3;
    return -1;
}

SSCANF:vehiclex(string[])
{
    // This function is VERY basic, needs VASTLY improving to detect variations.
    if ('0' <= string[0] <= '9')
    {
        new
            ret = strval(string);
        if (400 <= ret <= 611)
        {
            return ret;
        }
    }
	else
	{
		for(new i = 0; i < 211; i++)
		{
			if ( strfind(aVehicleNames[i], string, true) != -1 )
				return i + MIN_VEHI_ID;
		}
	}
/*    else if (strfind(string, "Landstalker", true) != -1) return 400;
    else if (strfind(string, "Bravura", true) != -1) return 401;
    else if (strfind(string, "Buffalo", true) != -1)return 402;
    else if (strfind(string, "Linerunner", true) != -1) return 403;
    else if (strfind(string, "Perenniel", true) != -1) return 404;
    else if (strfind(string, "Sentinel", true) != -1) return 405;
    else if (strfind(string, "Dumper", true) != -1) return 406;
    else if (strfind(string, "Firetruck", true) != -1) return 407;
    else if (strfind(string, "Trashmaster", true) != -1) return 408;
    else if (strfind(string, "Stretch", true) != -1) return 409;
    else if (strfind(string, "Manana", true) != -1) return 410;
    else if (strfind(string, "Infernus", true) != -1) return 411;
    else if (strfind(string, "Voodoo", true) != -1) return 412;
    else if (strfind(string, "Pony", true) != -1) return 413;
    else if (strfind(string, "Mule", true) != -1) return 414;
    else if (strfind(string, "Cheetah", true) != -1) return 415;
    else if (strfind(string, "Ambulance", true) != -1) return 416;
    else if (strfind(string, "Leviathan", true) != -1) return 417;
    else if (strfind(string, "Moonbeam", true) != -1) return 418;
    else if (strfind(string, "Esperanto", true) != -1) return 419;
    else if (strfind(string, "Taxi", true) != -1) return 420;
    else if (strfind(string, "Washington", true) != -1) return 421;
    else if (strfind(string, "Bobcat", true) != -1) return 422;
    else if (strfind(string, "Mr Whoopee", true) != -1) return 423;
    else if (strfind(string, "BF Injection", true) != -1) return 424;
    else if (strfind(string, "Hunter", true) != -1) return 425;
    else if (strfind(string, "Premier", true) != -1) return 426;
    else if (strfind(string, "Enforcer", true) != -1) return 427;
    else if (strfind(string, "Securicar", true) != -1) return 428;
    else if (strfind(string, "Banshee", true) != -1) return 429;
    else if (strfind(string, "Predator", true) != -1) return 430;
    else if (strfind(string, "Bus", true) != -1) return 431;
    else if (strfind(string, "Rhino", true) != -1) return 432;
    else if (strfind(string, "Barracks", true) != -1) return 433;
    else if (strfind(string, "Hotknife", true) != -1) return 434;
    else if (strfind(string, "Article Trailer", true) != -1) return 435;
    else if (strfind(string, "Previon", true) != -1) return 436;
    else if (strfind(string, "Coach", true) != -1) return 437;
    else if (strfind(string, "Cabbie", true) != -1) return 438;
    else if (strfind(string, "Stallion", true) != -1) return 439;
    else if (strfind(string, "Rumpo", true) != -1) return 440;
    else if (strfind(string, "RC Bandit", true) != -1) return 441;
    else if (strfind(string, "Romero", true) != -1) return 442;
    else if (strfind(string, "Packer", true) != -1) return 443;
    else if (strfind(string, "Monster", true) != -1) return 444;
    else if (strfind(string, "Admiral", true) != -1) return 445;
    else if (strfind(string, "Squallo", true) != -1) return 446;
    else if (strfind(string, "Seasparrow", true) != -1) return 447;
    else if (strfind(string, "Pizzaboy", true) != -1) return 448;
    else if (strfind(string, "Tram", true) != -1) return 449;
    else if (strfind(string, "Article Trailer 2", true) != -1) return 450;
    else if (strfind(string, "Turismo", true) != -1) return 451;
    else if (strfind(string, "Speeder", true) != -1) return 452;
    else if (strfind(string, "Reefer", true) != -1) return 453;
    else if (strfind(string, "Tropic", true) != -1) return 454;
    else if (strfind(string, "Flatbed", true) != -1) return 455;
    else if (strfind(string, "Yankee", true) != -1) return 456;
    else if (strfind(string, "Caddy", true) != -1) return 457;
    else if (strfind(string, "Solair", true) != -1) return 458;
    else if (strfind(string, "Berkley's RC Van", true) != -1) return 459;
    else if (strfind(string, "Skimmer", true) != -1) return 460;
    else if (strfind(string, "PCJ-600", true) != -1) return 461;
    else if (strfind(string, "Faggio", true) != -1) return 462;
    else if (strfind(string, "Freeway", true) != -1) return 463;
    else if (strfind(string, "RC Baron", true) != -1) return 464;
    else if (strfind(string, "RC Raider", true) != -1) return 465;
    else if (strfind(string, "Glendale", true) != -1) return 466;
    else if (strfind(string, "Oceanic", true) != -1) return 467;
    else if (strfind(string, "Sanchez", true) != -1) return 468;
    else if (strfind(string, "Sparrow", true) != -1) return 469;
    else if (strfind(string, "Patriot", true) != -1) return 470;
    else if (strfind(string, "Quad", true) != -1) return 471;
    else if (strfind(string, "Coastguard", true) != -1) return 472;
    else if (strfind(string, "Dinghy", true) != -1) return 473;
    else if (strfind(string, "Hermes", true) != -1) return 474;
    else if (strfind(string, "Sabre", true) != -1) return 475;
    else if (strfind(string, "Rustler", true) != -1) return 476;
    else if (strfind(string, "ZR-350", true) != -1) return 477;
    else if (strfind(string, "Walton", true) != -1) return 478;
    else if (strfind(string, "Regina", true) != -1) return 479;
    else if (strfind(string, "Comet", true) != -1) return 480;
    else if (strfind(string, "BMX", true) != -1) return 481;
    else if (strfind(string, "Burrito", true) != -1) return 482;
    else if (strfind(string, "Camper", true) != -1) return 483;
    else if (strfind(string, "Marquis", true) != -1) return 484;
    else if (strfind(string, "Baggage", true) != -1) return 485;
    else if (strfind(string, "Dozer", true) != -1) return 486;
    else if (strfind(string, "Maverick", true) != -1) return 487;
    else if (strfind(string, "SAN News Maverick", true) != -1) return 488;
    else if (strfind(string, "Rancher", true) != -1) return 489;
    else if (strfind(string, "FBI Rancher", true) != -1) return 490;
    else if (strfind(string, "Virgo", true) != -1) return 491;
    else if (strfind(string, "Greenwood", true) != -1) return 492;
    else if (strfind(string, "Jetmax", true) != -1) return 493;
    else if (strfind(string, "Hotring Racer", true) != -1) return 494;
    else if (strfind(string, "Sandking", true) != -1) return 495;
    else if (strfind(string, "Blista Compact", true) != -1) return 496;
    else if (strfind(string, "Police Maverick", true) != -1) return 497;
    else if (strfind(string, "Boxville", true) != -1) return 498;
    else if (strfind(string, "Benson", true) != -1) return 499;
    else if (strfind(string, "Mesa", true) != -1) return 500;
    else if (strfind(string, "RC Goblin", true) != -1) return 501;
    else if (strfind(string, "Hotring Racer", true) != -1) return 502;
    else if (strfind(string, "Hotring Racer", true) != -1) return 503;
    else if (strfind(string, "Bloodring Banger", true) != -1) return 504;
    else if (strfind(string, "Rancher", true) != -1) return 505;
    else if (strfind(string, "Super GT", true) != -1) return 506;
    else if (strfind(string, "Elegant", true) != -1) return 507;
    else if (strfind(string, "Journey", true) != -1) return 508;
    else if (strfind(string, "Bike", true) != -1) return 509;
    else if (strfind(string, "Mountain Bike", true) != -1) return 510;
    else if (strfind(string, "Beagle", true) != -1) return 511;
    else if (strfind(string, "Cropduster", true) != -1) return 512;
    else if (strfind(string, "Stuntplane", true) != -1) return 513;
    else if (strfind(string, "Tanker", true) != -1) return 514;
    else if (strfind(string, "Roadtrain", true) != -1) return 515;
    else if (strfind(string, "Nebula", true) != -1) return 516;
    else if (strfind(string, "Majestic", true) != -1) return 517;
    else if (strfind(string, "Buccaneer", true) != -1) return 518;
    else if (strfind(string, "Shamal", true) != -1) return 519;
    else if (strfind(string, "Hydra", true) != -1) return 520;
    else if (strfind(string, "FCR-900", true) != -1) return 521;
    else if (strfind(string, "NRG-500", true) != -1) return 522;
    else if (strfind(string, "HPV1000", true) != -1) return 523;
    else if (strfind(string, "Cement Truck", true) != -1) return 524;
    else if (strfind(string, "Towtruck", true) != -1) return 525;
    else if (strfind(string, "Fortune", true) != -1) return 526;
    else if (strfind(string, "Cadrona", true) != -1) return 527;
    else if (strfind(string, "FBI Truck", true) != -1) return 528;
    else if (strfind(string, "Willard", true) != -1) return 529;
    else if (strfind(string, "Forklift", true) != -1) return 530;
    else if (strfind(string, "Tractor", true) != -1) return 531;
    else if (strfind(string, "Combine Harvester", true) != -1) return 532;
    else if (strfind(string, "Feltzer", true) != -1) return 533;
    else if (strfind(string, "Remington", true) != -1) return 534;
    else if (strfind(string, "Slamvan", true) != -1) return 535;
    else if (strfind(string, "Blade", true) != -1) return 536;
    else if (strfind(string, "Freight (Train)", true) != -1) return 537;
    else if (strfind(string, "Brownstreak (Train)", true) != -1) return 538;
    else if (strfind(string, "Vortex", true) != -1) return 539;
    else if (strfind(string, "Vincent", true) != -1) return 540;
    else if (strfind(string, "Bullet", true) != -1) return 541;
    else if (strfind(string, "Clover", true) != -1) return 542;
    else if (strfind(string, "Sadler", true) != -1) return 543;
    else if (strfind(string, "Firetruck LA", true) != -1) return 544;
    else if (strfind(string, "Hustler", true) != -1) return 545;
    else if (strfind(string, "Intruder", true) != -1) return 546;
    else if (strfind(string, "Primo", true) != -1) return 547;
    else if (strfind(string, "Cargobob", true) != -1) return 548;
    else if (strfind(string, "Tampa", true) != -1) return 549;
    else if (strfind(string, "Sunrise", true) != -1) return 550;
    else if (strfind(string, "Merit", true) != -1) return 551;
    else if (strfind(string, "Utility Van", true) != -1) return 552;
    else if (strfind(string, "Nevada", true) != -1) return 553;
    else if (strfind(string, "Yosemite", true) != -1) return 554;
    else if (strfind(string, "Windsor", true) != -1) return 555;
    else if (strfind(string, "Monster \"A\"", true) != -1) return 556;
    else if (strfind(string, "Monster \"B\"", true) != -1) return 557;
    else if (strfind(string, "Uranus", true) != -1) return 558;
    else if (strfind(string, "Jester", true) != -1) return 559;
    else if (strfind(string, "Sultan", true) != -1) return 560;
    else if (strfind(string, "Stratum", true) != -1) return 561;
    else if (strfind(string, "Elegy", true) != -1) return 562;
    else if (strfind(string, "Raindance", true) != -1) return 563;
    else if (strfind(string, "RC Tiger", true) != -1) return 564;
    else if (strfind(string, "Flash", true) != -1) return 565;
    else if (strfind(string, "Tahoma", true) != -1) return 566;
    else if (strfind(string, "Savanna", true) != -1) return 567;
    else if (strfind(string, "Bandito", true) != -1) return 568;
    else if (strfind(string, "Freight Flat Trailer (Train)", true) != -1) return 569;
    else if (strfind(string, "Streak Trailer (Train)", true) != -1) return 570;
    else if (strfind(string, "Kart", true) != -1) return 571;
    else if (strfind(string, "Mower", true) != -1) return 572;
    else if (strfind(string, "Dune", true) != -1) return 573;
    else if (strfind(string, "Sweeper", true) != -1) return 574;
    else if (strfind(string, "Broadway", true) != -1) return 575;
    else if (strfind(string, "Tornado", true) != -1) return 576;
    else if (strfind(string, "AT400", true) != -1) return 577;
    else if (strfind(string, "DFT-30", true) != -1) return 578;
    else if (strfind(string, "Huntley", true) != -1) return 579;
    else if (strfind(string, "Stafford", true) != -1) return 580;
    else if (strfind(string, "BF-400", true) != -1) return 581;
    else if (strfind(string, "Newsvan", true) != -1) return 582;
    else if (strfind(string, "Tug", true) != -1) return 583;
    else if (strfind(string, "Petrol Trailer", true) != -1) return 584;
    else if (strfind(string, "Emperor", true) != -1) return 585;
    else if (strfind(string, "Wayfarer", true) != -1) return 586;
    else if (strfind(string, "Euros", true) != -1) return 587;
    else if (strfind(string, "Hotdog", true) != -1) return 588;
    else if (strfind(string, "Club", true) != -1) return 589;
    else if (strfind(string, "Freight Box Trailer (Train)", true) != -1) return 590;
    else if (strfind(string, "Article Trailer 3", true) != -1) return 591;
    else if (strfind(string, "Andromada", true) != -1) return 592;
    else if (strfind(string, "Dodo", true) != -1) return 593;
    else if (strfind(string, "RC Cam", true) != -1) return 594;
    else if (strfind(string, "Launch", true) != -1) return 595;
    else if (strfind(string, "Police Car (LSPD)", true) != -1) return 596;
    else if (strfind(string, "Police Car (SFPD)", true) != -1) return 597;
    else if (strfind(string, "Police Car (LVPD)", true) != -1) return 598;
    else if (strfind(string, "Police Ranger", true) != -1) return 599;
    else if (strfind(string, "Picador", true) != -1) return 600;
    else if (strfind(string, "S.W.A.T.", true) != -1) return 601;
    else if (strfind(string, "Alpha", true) != -1) return 602;
    else if (strfind(string, "Phoenix", true) != -1) return 603;
    else if (strfind(string, "Glendale Shit", true) != -1) return 604;
    else if (strfind(string, "Sadler Shit", true) != -1) return 605;
    else if (strfind(string, "Baggage Trailer \"A\"", true) != -1) return 606;
    else if (strfind(string, "Baggage Trailer \"B\"", true) != -1) return 607;
    else if (strfind(string, "Tug Stairs Trailer", true) != -1) return 608;
    else if (strfind(string, "Boxville", true) != -1) return 609;
    else if (strfind(string, "Farm Trailer", true) != -1) return 610;
    else if (strfind(string, "Utility Trailer", true) != -1) return 611;*/
    return -1;
}

/*SSCANF:player_name(string[]) {
    new foundplayer = INVALID_PLAYER_ID, name[MAX_PLAYER_NAME];
    new bool:numeric = true;

    for (new i = 0, c; (c = string[i]); i++) {
        if (c < '0' || c > '9') {
            numeric = false;

            break;
        }
    }

    if (numeric) {
        foundplayer = strval(string);

        if (IsPlayerConnected(foundplayer))
            return foundplayer;
        else
            foundplayer = INVALID_PLAYER_ID;
    }

    foreach(new playerid : Player) {
        GetPlayerName(playerid, name, sizeof(name));

        if (strfind(name, string, true) != -1) {
            if (foundplayer != INVALID_PLAYER_ID)
                return INVALID_PLAYER_ID; // Multiple matches
            else
                foundplayer = playerid;
        }
    }

    return foundplayer;
}

SSCANF:player(string[])
{
	new
	    	 fplayer = INVALID_PLAYER_ID,
		bool:numeric = true;

    for (new i = 0, c; (c = string[i]); i++)
	{
        if (c < '0' || c > '9')
		{
            numeric = false;

            break;
        }
    }

    if (numeric)
    {
        fplayer = strval (string);

        if (!IsPlayerConnected (fplayer))
            return -1;
    }

    foreach (new i:Player)
    {
        if (strfind(Player[i][Nickname], string, true) != -1)
        {
            if (fplayer != INVALID_PLAYER_ID) return INVALID_PLAYER_ID;
            fplayer = i;
        }
    }

	return fplayer;
}
*/

SSCANF:teamname(string[])
{
    if ('1' <= string[0] <= '3')
    {
        new
            ret = strval(string);
        if (TEAM_A <= ret <= TEAM_B_SUB)
        {
            return ret;
        }
    }
    else if (!strcmp(string, iTeam[TEAM_A][Name], true)) return TEAM_A;
    else if (!strcmp(string, iTeam[TEAM_B][Name], true)) return TEAM_B;
    else if (!strcmp(string, iTeam[TEAM_REF][Name], true)) return TEAM_REF;
    else if (!strcmp(string, iTeam[TEAM_A_SUB][Name], true)) return TEAM_A_SUB;
    else if (!strcmp(string, iTeam[TEAM_B_SUB][Name], true)) return TEAM_B_SUB;
	return -1;
}

SSCANF:gametypes(string[])
{
    if ('0' <= string[0] <= '9')
    {
        new
            ret = strval(string);
        if (GAMETYPE_BASE <= ret <= GAMETYPE_PVP)
        {
            return ret;
        }
    }
    else if (!strcmp(string, "Base", true)) return GAMETYPE_BASE;
    else if (!strcmp(string, "Arena", true)) return GAMETYPE_ARENA;
    else if (!strcmp(string, "TDM", true)) return GAMETYPE_TDM;
    else if (!strcmp(string, "Ints", true)) return GAMETYPE_INTS;
    else if (!strcmp(string, "PVP", true)) return GAMETYPE_PVP;
    return -1;
}

////////////////////////////////////////////////////////////////////////////////
//==============================================================================
////////////////////////////////////////////////////////////////////////////////
//new spec code

//ogni volta che un player va in spec DEVE passare per questa funzione:
stock Spec_PutPlayerInSpec( playerid , whospec )
{
	// controlli non necessario se si eseguono prima ( meglio perchï¿½ assecondati da msg?) ma x il momento
	// ï¿½ meglio tenerli
	if (!IsPlayerConnected(whospec))
	    return false;

	if(Player[playerid][InDm] != -1) {
	    // update dm stats
		MySQLStatus[TotalQuerys] ++; mysql_tquery(g_MySQLConnection, sprintf("UPDATE bestdmplayer SET damage = '%d', kills = '%d' WHERE nickname = '%s' AND dmid = '%d'", Player[playerid][DDamage], Player[playerid][DKills], Player[playerid][Nickname], Player[playerid][InDm]), "", "");
		Player[playerid][InDm] = -1;
	}

	// mette il player nello spec

	SendClientMessage(playerid, COLOR_SYSTEM, "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~");
	SendClientMessage(playerid, COLOR_SYSTEM, "* Use {"#COLOR_SYSTEM_FOCUS"}~k~~PED_FIREWEAPON~{"#COLOR_SYSTEM_REST"} to move between the players in your team");
	SendClientMessage(playerid, COLOR_SYSTEM, "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~");

    TogglePlayerSpectating( playerid , true );
    if (!IsPlayerInAnyVehicle( whospec ))
    {
        PlayerSpectatePlayer( playerid , whospec );
    }
    else
    {
        PlayerSpectateVehicle( playerid , GetPlayerVehicleID( whospec ) );
    }

/*	PlayerTextDrawShow(playerid, SpecPlayerInfo[0]);
	PlayerTextDrawShow(playerid, SpecPlayerInfo[1]);
	PlayerTextDrawShow(playerid, SpecPlayerInfo[2]);
	PlayerTextDrawShow(playerid, SpecPlayerInfo[3]);
	PlayerTextDrawShow(playerid, SpecPlayerInfo[4]);
	PlayerTextDrawShow(playerid, SpecPlayerInfo[5]);
	PlayerTextDrawShow(playerid, SpecPlayerInfo[6]);
	PlayerTextDrawShow(playerid, SpecPlayerInfo[7]);
	PlayerTextDrawShow(playerid, SpecPlayerInfo[8]);
*/

//PlayerSpecInfo

	TextDrawShowForPlayer(playerid, PlayerSpecInfo[whospec][0]);
	TextDrawShowForPlayer(playerid, PlayerSpecInfo[whospec][1]);
	TextDrawShowForPlayer(playerid, PlayerSpecInfo[whospec][2]);
	TextDrawShowForPlayer(playerid, PlayerSpecInfo[whospec][3]);
	TextDrawShowForPlayer(playerid, PlayerSpecInfo[whospec][4]);
	TextDrawShowForPlayer(playerid, PlayerSpecInfo[whospec][5]);
	TextDrawShowForPlayer(playerid, PlayerSpecInfo[whospec][6]);
	TextDrawShowForPlayer(playerid, PlayerSpecInfo[whospec][7]);
	TextDrawShowForPlayer(playerid, PlayerSpecInfo[whospec][8]);

    PlayerTextDrawHide(playerid, PlayerInfo[0]);
    PlayerTextDrawHide(playerid, PlayerInfo[1]);
    PlayerTextDrawHide(playerid, PlayerInfo[2]);

	stop PlayerKillTimer[ playerid ];
	PlayerTextDrawHide( playerid , PlayerKillTD );
//	PlayerTextDrawHide( playerid , PlayerKillTD[ 1 ] );

	Player [playerid][TD0_ID][0] = INVALID_PLAYER_ID;
	Player [playerid][TD0_WEAP][0] = 0;
	Player [playerid][TD0_DMG][0] = 0;
	Player [playerid][TD0_HEALTH][0] = 0;

	if (Player [playerid][TD0_TIMER][0] != Timer:-1)
		stop Player [playerid][TD0_TIMER][0];

	Player [playerid][TD0_TIMER][0] = Timer:-1;
	Player [playerid][TD1_ID][0] = INVALID_PLAYER_ID;
	Player [playerid][TD1_WEAP][0] = 0;
	Player [playerid][TD1_DMG][0] = 0;
	Player [playerid][TD1_HEALTH][0] = 0;

	if (Player [playerid][TD1_TIMER][0] != Timer:-1)
		stop Player [playerid][TD1_TIMER][0];
	Player [playerid][TD1_TIMER][0] = Timer:-1;
	Player [playerid][TD0_ID][1] = INVALID_PLAYER_ID;
	Player [playerid][TD0_WEAP][1] = 0;
	Player [playerid][TD0_DMG][1] = 0;
	Player [playerid][TD0_HEALTH][1] = 0;

	if (Player [playerid][TD0_TIMER][1] != Timer:-1)
		stop Player [playerid][TD0_TIMER][1];

	Player [playerid][TD0_TIMER][1] = Timer:-1;
	Player [playerid][TD1_ID][1] = INVALID_PLAYER_ID;
	Player [playerid][TD1_WEAP][1] = 0;
	Player [playerid][TD1_DMG][1] = 0;
	Player [playerid][TD1_HEALTH][1] = 0;


	if (Player [playerid][TD1_TIMER][1] != Timer:-1)
		stop Player [playerid][TD1_TIMER][1];
	Player [playerid][TD1_TIMER][1] = Timer:-1;

	Player [playerid][TD0_ID][2] = INVALID_PLAYER_ID;
	Player [playerid][TD0_WEAP][2] = 0;
	Player [playerid][TD0_DMG][2] = 0;
	Player [playerid][TD0_HEALTH][2] = 0;

	if (Player [playerid][TD0_TIMER][2] != Timer:-1)
		stop Player [playerid][TD0_TIMER][2];

	Player [playerid][TD0_TIMER][2] = Timer:-1;

	Player [playerid][TD1_ID][2] = INVALID_PLAYER_ID;
	Player [playerid][TD1_WEAP][2] = 0;
	Player [playerid][TD1_DMG][2] = 0;
	Player [playerid][TD1_HEALTH][2] = 0;


	if (Player [playerid][TD1_TIMER][2] != Timer:-1)
		stop Player [playerid][TD1_TIMER][2];

	Player [playerid][TD1_TIMER][2] = Timer:-1;
	Player [playerid][TD0_ID][3] = INVALID_PLAYER_ID;
	Player [playerid][TD0_WEAP][3] = 0;
	Player [playerid][TD0_DMG][3] = 0;
	Player [playerid][TD0_HEALTH][3] = 0;

	if (Player [playerid][TD0_TIMER][3] != Timer:-1)
		stop Player [playerid][TD0_TIMER][3];

	Player [playerid][TD0_TIMER][3] = Timer:-1;

	Player [playerid][TD1_ID][3] = INVALID_PLAYER_ID;
	Player [playerid][TD1_WEAP][3] = 0;
	Player [playerid][TD1_DMG][3] = 0;
	Player [playerid][TD1_HEALTH][3] = 0;


	if (Player [playerid][TD1_TIMER][3] != Timer:-1)
		stop Player [playerid][TD1_TIMER][3];

	Player [playerid][TD1_TIMER][3] = Timer:-1;

	Player [playerid][TD0_ID][4] = INVALID_PLAYER_ID;
	Player [playerid][TD0_WEAP][4] = 0;
	Player [playerid][TD0_DMG][4] = 0;
	Player [playerid][TD0_HEALTH][4] = 0;

	if (Player [playerid][TD0_TIMER][4] != Timer:-1)
		stop Player [playerid][TD0_TIMER][4];

	Player [playerid][TD0_TIMER][4] = Timer:-1;

	Player [playerid][TD1_ID][4] = INVALID_PLAYER_ID;
	Player [playerid][TD1_WEAP][4] = 0;
	Player [playerid][TD1_DMG][4] = 0;
	Player [playerid][TD1_HEALTH][4] = 0;


	if (Player [playerid][TD1_TIMER][4] != Timer:-1)
		stop Player [playerid][TD1_TIMER][4];

	Player [playerid][TD1_TIMER][4] = Timer:-1;

    InSpec[ playerid ] = whospec;
	defer spec_fix(playerid, whospec);

	if (gConfig[ UseHealthBars ])
	{
 		foreach(new i:Player)
	    {
     		if (!Player[i][InGame]) continue;

	 		TextDrawShowForPlayer(playerid, HealthBars[i][hb_bg]);
	 		TextDrawShowForPlayer(playerid, HealthBars[i][hb_progress]);
	 		TextDrawShowForPlayer(playerid, HealthBars[i][hb_name]);
		}
	}

//    fSpecTimer[ playerid ] = SetTimerEx( "RefreshSpecInfo"  , 1000 , true  , "i" , playerid );
//	SetTimerEx( "RefreshSpecsList" , 5    , false , "i" , whospec  );
	RefreshSpecsList (whospec);

	// aggiorno SpecPlayerInfo[6] qui


/*	  		new t = Player[playerid][Team];
	  		foreach(new i:Player)// il player ha deciso di cambiare arma - cerco i players che lo spectato e aggiorno le armi
	  		{// so giï¿½ che siamo in base (altrimenti non stava qua) quindi non controllo il gaming type
	  		    if (InSpec[i] == playerid)
	  		    {
	  		        if (t==TEAM_A)
	  		            PlayerTextDrawSetString(i, SpecPlayerInfo[6], sprintf("~r~~h~WPS: ~w~%s", Weaponsets[id][SetName]));
	  		        else
	  		    		PlayerTextDrawSetString(i, SpecPlayerInfo[6], sprintf("~b~~h~WPS: ~w~%s", Weaponsets[id][SetName]));
	  		    }
	  		}*/

	//controllo se il gioco ï¿½ startato e mostro il round stats
//	if (RoundStarted)// non dovrebbe essere piï¿½ necessario dato che i controlli avvengono prima
//	{
		//round effettivamente in corso, mostro i roundstats
//  Riattivare in caso di bug, il player dovrebbe giï¿½ vederli (stesso caso nell'add)
//	TextDrawShowForPlayer(playerid, RoundStats[0]);
//	TextDrawShowForPlayer(playerid, RoundStats[1]);
//	TextDrawShowForPlayer(playerid, RoundStats[2]);
//	TextDrawShowForPlayer(playerid, RoundStats[3]);

	// sfrutto lo switch di sopra
	if (Gaming == GAMETYPE_BASE && !Interior_Base)
		SetPlayerCheckpointEx(playerid, eScenario[Checkpoint][0], eScenario[Checkpoint][1], eScenario[Checkpoint][2], 2.0);
//	}

    SetPlayerInterior( playerid , GetPlayerInterior( whospec ));
    SetPlayerVirtualWorld( playerid , GetPlayerVirtualWorld( whospec ));
	return true;
}

//forward spec_fix(playerid);
timer spec_fix[100](playerid, whospec)
{
    TogglePlayerSpectating( playerid , true );
    if (!IsPlayerInAnyVehicle( whospec ))
    {
        PlayerSpectatePlayer( playerid , whospec );
    }
    else
    {
        PlayerSpectateVehicle( playerid , GetPlayerVehicleID( whospec ) );
    }
}

//il player ï¿½ giï¿½ in spec ma ha deciso di cambiare "target"
//potrebbe essere usato anche x aggiornare lo spec?
stock Spec_ChangeSpecTarget( playerid , target )
{
	if (InSpec[playerid] == -1) // questo codice ï¿½ solo x chi giï¿½ sta osservando
		return false;

	new old_spec = InSpec[playerid];

	TextDrawHideForPlayer(playerid, PlayerSpecInfo[old_spec][0]);
	TextDrawHideForPlayer(playerid, PlayerSpecInfo[old_spec][1]);
	TextDrawHideForPlayer(playerid, PlayerSpecInfo[old_spec][2]);
	TextDrawHideForPlayer(playerid, PlayerSpecInfo[old_spec][3]);
	TextDrawHideForPlayer(playerid, PlayerSpecInfo[old_spec][4]);
	TextDrawHideForPlayer(playerid, PlayerSpecInfo[old_spec][5]);
	TextDrawHideForPlayer(playerid, PlayerSpecInfo[old_spec][6]);
	TextDrawHideForPlayer(playerid, PlayerSpecInfo[old_spec][7]);
	TextDrawHideForPlayer(playerid, PlayerSpecInfo[old_spec][8]);

	InSpec[playerid] = target;

	TextDrawShowForPlayer(playerid, PlayerSpecInfo[target][0]);
	TextDrawShowForPlayer(playerid, PlayerSpecInfo[target][1]);
	TextDrawShowForPlayer(playerid, PlayerSpecInfo[target][2]);
	TextDrawShowForPlayer(playerid, PlayerSpecInfo[target][3]);
	TextDrawShowForPlayer(playerid, PlayerSpecInfo[target][4]);
	TextDrawShowForPlayer(playerid, PlayerSpecInfo[target][5]);
	TextDrawShowForPlayer(playerid, PlayerSpecInfo[target][6]);
	TextDrawShowForPlayer(playerid, PlayerSpecInfo[target][7]);
	TextDrawShowForPlayer(playerid, PlayerSpecInfo[target][8]);

	RefreshSpecsList(old_spec);
	RefreshSpecsList(target);

    TogglePlayerSpectating( playerid , true );
    if (!IsPlayerInAnyVehicle( target ))
    {
        PlayerSpectatePlayer( playerid , target );
    }
    else
    {
        PlayerSpectateVehicle( playerid , GetPlayerVehicleID( target ) );
    }

    SetPlayerInterior( playerid , GetPlayerInterior( target ));
    SetPlayerVirtualWorld( playerid , GetPlayerVirtualWorld( target ));
	return true;
}

//quando lo spec viene chiuso DEVE passare per questa funzione
//quando la funzione TogglePlayerSpectating viene chiamata ONplayerspawn sarï¿½ richiamato a sua volta
stock Spec_RemovePlayerFromSpec( playerid , pos = true )
{
	//resetta la variabile e rimuove effettivamente il player dallo spec
	if (InSpec[playerid] == -1)
	    return false;

	new t = InSpec[playerid];
	InSpec[playerid] = -1;
	RefreshSpecsList(t);

	if (pos) SetSpawnInfo(playerid, playerid, GetPlayerSkinEx(playerid), Lobby[0] - MAX_RANDOM_SPAWN + random( MAX_RANDOM_SPAWN ), Lobby[1] - MAX_RANDOM_SPAWN + random( MAX_RANDOM_SPAWN ), Lobby[2], Lobby[3], 0, 0, 0, 0, 0, 0);
    TogglePlayerSpectating( playerid , false );

//    KillTimer( SpecTimer[ playerid ] );

	TextDrawHideForPlayer(playerid, PlayerSpecInfo[t][0]);
	TextDrawHideForPlayer(playerid, PlayerSpecInfo[t][1]);
	TextDrawHideForPlayer(playerid, PlayerSpecInfo[t][2]);
	TextDrawHideForPlayer(playerid, PlayerSpecInfo[t][3]);
	TextDrawHideForPlayer(playerid, PlayerSpecInfo[t][4]);
	TextDrawHideForPlayer(playerid, PlayerSpecInfo[t][5]);
	TextDrawHideForPlayer(playerid, PlayerSpecInfo[t][6]);
	TextDrawHideForPlayer(playerid, PlayerSpecInfo[t][7]);
	TextDrawHideForPlayer(playerid, PlayerSpecInfo[t][8]);

	PlayerTextDrawShow(playerid, PlayerInfo[0]);
	PlayerTextDrawShow(playerid, PlayerInfo[1]);
	PlayerTextDrawShow(playerid, PlayerInfo[2]);

	if (gConfig[ UseHealthBars ])
	{
 		foreach(new i:Player)
	    {
     		if (!Player[i][InGame]) continue;

	 		TextDrawHideForPlayer(playerid, HealthBars[i][hb_bg]);
	 		TextDrawHideForPlayer(playerid, HealthBars[i][hb_progress]);
	 		TextDrawHideForPlayer(playerid, HealthBars[i][hb_name]);
		}
	}

  //  if (RoundStarted)//stessa cosa quando viene aggiunto allo spec, solo che toglie
  //  {//si puï¿½ spectare solo se il round ï¿½ in corso

/*	TextDrawHideForPlayer(playerid, RoundStats[0]);
	TextDrawHideForPlayer(playerid, RoundStats[1]);
	TextDrawHideForPlayer(playerid, RoundStats[2]);
	TextDrawHideForPlayer(playerid, RoundStats[3]);
*/
	DisablePlayerCheckpoint( playerid );
   // }
    return true;
}

// A chi piï¿½ amiamo, meno dire sappiamo

//quando il player preme uno dei due tasti del mouse lo spec deve cambiare
//tasto sinistro -> va avanti (KEY_FIRE) (SPEC_VERSE_UP)
//tasto destro -> va indietro ( SPEC_VERSE_DOWN )

stock Spec_SwitchSpec( playerid , force = 0 )
{
	new
	    bool: found = false,
		t = Player[playerid][Team];

	foreach(new i:Player)
	{
	    if (i <= InSpec[playerid])   	continue;
	    if (i == playerid)   			continue;
	    if (InSpec[i] != -1)    		continue;
	    if (!Player[i][InGame]) 		continue;
	    if (Gaming != GAMETYPE_FALLOUT && Gaming != GAMETYPE_FIGHT && Gaming != GAMETYPE_GUNGAME && Gaming != GAMETYPE_LASTBULLET)
	 		if (t != TEAM_REF)
	   			if (Player[i][Team] != t && t != GetHisSubTeam(i))
	      			continue;

		Spec_ChangeSpecTarget( playerid , i );
  		found = true;
  		break;
	}

	if (!found)
	{
		foreach(new i:Player)
		{
		    if (i == playerid)   	continue;
			if (InSpec[i] == i)		continue;
		    if (InSpec[i] != -1) 	continue;
		    if (!Player[i][InGame]) continue;
		    if (Gaming != GAMETYPE_FALLOUT && Gaming != GAMETYPE_FIGHT && Gaming != GAMETYPE_GUNGAME && Gaming != GAMETYPE_LASTBULLET)
		 		if (t != TEAM_REF)
		   			if (Player[i][Team] != t && t != GetHisSubTeam(i))
		      			continue;

			Spec_ChangeSpecTarget( playerid , i );
	  		found = true;
	  		break;
		}

	    if (!found && force) Spec_RemovePlayerFromSpec( playerid );
	    else if (!found && !force) SendClientMessage( playerid , red , "There are no players to spectate for you.");
	}
	return true;
}
//maintenance

forward RefreshSpecsList( player );
public RefreshSpecsList( player )
{
	new
	    szString[ 128 ],
	    count = 0;

	szString = "~b~~h~Spectators";

	foreach(new i:Player)
	{
	    if (InSpec[i] == player)
	    {
	        format( szString , sizeof szString , "%s~n~~w~%s" , szString , Player[ i ][ Nickname ]);
			count ++;
	    }
	}

	PlayerTextDrawSetString( player , PlayerSpecList , szString );
	if (count > 0)
	{
	    PlayerTextDrawShow(player, PlayerSpecList);
	}
	else
	{
	    PlayerTextDrawHide(player, PlayerSpecList);
	}
	return true;
}
////////////////////////////////////////////////////////////////////////////////
//==============================================================================
////////////////////////////////////////////////////////////////////////////////
//create all tds

stock CreateGameTextdraws()
{
	GeneralTextdraw();
    Textdraw_GeneralCreate();
  //  SigmaTD();
    CreateRoundStats();
    //CreaRoundStats();
    CreateFinalRoundTD();
    Process_FinalCWTDs();

	CPTimer = TextDrawCreate(274.000000, 396.000000, "~b~~h~Checkpoint: ~w~~h~25");
	TextDrawBackgroundColor(CPTimer, 80);
	TextDrawFont(CPTimer, 2);
	TextDrawLetterSize(CPTimer, 0.289999, 1.500000);
	TextDrawColor(CPTimer, -1);
	TextDrawSetOutline(CPTimer, 1);
	TextDrawSetProportional(CPTimer, 1);

	BlackScreen = TextDrawCreate(650.000000, 0.000000, "_");
	TextDrawBackgroundColor(BlackScreen, 255);
	TextDrawFont(BlackScreen, 1);
	TextDrawLetterSize(BlackScreen, 0.500000, 50.000000);
	TextDrawColor(BlackScreen, -1);
	TextDrawSetOutline(BlackScreen, 0);
	TextDrawSetProportional(BlackScreen, 1);
	TextDrawSetShadow(BlackScreen, 1);
	TextDrawUseBox(BlackScreen, 1);
	TextDrawBoxColor(BlackScreen, 102);
	TextDrawTextSize(BlackScreen, -10.000000, 20.000000);
	/**
	DamageTeamA = TextDrawCreate(35.000000, 433.000000, "350");
	TextDrawAlignment(DamageTeamA, 2);
	TextDrawBackgroundColor(DamageTeamA, 255);
	TextDrawFont(DamageTeamA, 1);
	TextDrawLetterSize(DamageTeamA, 0.370000, 1.400000);
	TextDrawColor(DamageTeamA, 1721368575);
	TextDrawSetOutline(DamageTeamA, 0);
	TextDrawSetProportional(DamageTeamA, 1);
	TextDrawSetShadow(DamageTeamA, 1);

	DamageTeamB = TextDrawCreate(601.000000, 433.000000, "355");
	TextDrawAlignment(DamageTeamB, 2);
	TextDrawBackgroundColor(DamageTeamB, 255);
	TextDrawFont(DamageTeamB, 1);
	TextDrawLetterSize(DamageTeamB, 0.370000, 1.400000);
	TextDrawColor(DamageTeamB, -1711302145);
	TextDrawSetOutline(DamageTeamB, 0);
	TextDrawSetProportional(DamageTeamB, 1);
	TextDrawSetShadow(DamageTeamB, 1);
	**/
	TeamPlayers_TD = TextDrawCreate(577.000000, 24.000000, "Teams ~b~~h~5~w~/~g~~h~5");
	TextDrawAlignment(TeamPlayers_TD, 2);
	TextDrawBackgroundColor(TeamPlayers_TD, 80);
	TextDrawFont(TeamPlayers_TD, 1);
	TextDrawLetterSize(TeamPlayers_TD, 0.310000, 1.600000);
	TextDrawColor(TeamPlayers_TD, -1);
	TextDrawSetOutline(TeamPlayers_TD, 1);
	TextDrawSetProportional(TeamPlayers_TD, 1);

	// skin selection
	SkinSelection_TDs = TextDrawCreate(549.000000, 387.000000, "Welcome to ~r~Slaughterfield A/D~w~~n~");
	TextDrawAlignment(SkinSelection_TDs, 2);
	TextDrawBackgroundColor(SkinSelection_TDs, 255);
	TextDrawFont(SkinSelection_TDs, 1);
	TextDrawLetterSize(SkinSelection_TDs, 0.350000, 2.300000);
	TextDrawColor(SkinSelection_TDs, -1);
	TextDrawSetOutline(SkinSelection_TDs, 0);
	TextDrawSetProportional(SkinSelection_TDs, 1);
	TextDrawSetShadow(SkinSelection_TDs, 1);

	// esl mode textdraw
	ESLModeReady[0] = TextDrawCreate(21.000000, 125.000000, "~b~~h~Home (4 players ready)");
	TextDrawBackgroundColor(ESLModeReady[0], 255);
	TextDrawFont(ESLModeReady[0], 1);
	TextDrawLetterSize(ESLModeReady[0], 0.310000, 1.500000);
	TextDrawColor(ESLModeReady[0], -1);
	TextDrawSetOutline(ESLModeReady[0], 0);
	TextDrawSetProportional(ESLModeReady[0], 1);
	TextDrawSetShadow(ESLModeReady[0], 1);

	ESLModeReady[1] = TextDrawCreate(606.000000, 125.000000, "~g~~h~Away (3 players ready)");
	TextDrawAlignment(ESLModeReady[1], 3);
	TextDrawBackgroundColor(ESLModeReady[1], 255);
	TextDrawFont(ESLModeReady[1], 1);
	TextDrawLetterSize(ESLModeReady[1], 0.310000, 1.500000);
	TextDrawColor(ESLModeReady[1], -1);
	TextDrawSetOutline(ESLModeReady[1], 0);
	TextDrawSetProportional(ESLModeReady[1], 1);
	TextDrawSetShadow(ESLModeReady[1], 1);

	ESLModeReady[2] = TextDrawCreate(606.000000, 141.000000, "_");
	TextDrawAlignment(ESLModeReady[2], 3);
	TextDrawBackgroundColor(ESLModeReady[2], 255);
	TextDrawFont(ESLModeReady[2], 1);
	TextDrawLetterSize(ESLModeReady[2], 0.230000, 1.500000);
	TextDrawColor(ESLModeReady[2], -1);
	TextDrawSetOutline(ESLModeReady[2], 0);
	TextDrawSetProportional(ESLModeReady[2], 1);
	TextDrawSetShadow(ESLModeReady[2], 1);

	ESLModeReady[3] = TextDrawCreate(21.000000, 141.000000, "_");
	TextDrawBackgroundColor(ESLModeReady[3], 255);
	TextDrawFont(ESLModeReady[3], 1);
	TextDrawLetterSize(ESLModeReady[3], 0.230000, 1.500000);
	TextDrawColor(ESLModeReady[3], -1);
	TextDrawSetOutline(ESLModeReady[3], 0);
	TextDrawSetProportional(ESLModeReady[3], 1);
	TextDrawSetShadow(ESLModeReady[3], 1);
	/*
	TD_NotHits = TextDrawCreate(550.000000, 69.000000, "_");
	TextDrawBackgroundColor(TD_NotHits, 255);
	TextDrawFont(TD_NotHits, 1);
	TextDrawLetterSize(TD_NotHits, 0.129999, 0.400000);
	TextDrawColor(TD_NotHits, -1);
	TextDrawSetOutline(TD_NotHits, 0);
	TextDrawSetProportional(TD_NotHits, 1);
	TextDrawSetShadow(TD_NotHits, 1);
	TextDrawUseBox(TD_NotHits, 1);
	TextDrawBoxColor(TD_NotHits, 255);
	TextDrawTextSize(TD_NotHits, 605.000000, 1.000000);
	*/
	TD_NoHitsScritta = TextDrawCreate(560.000000, 67.000000, "Fall prot.");
	TextDrawBackgroundColor(TD_NoHitsScritta, 255);
	TextDrawFont(TD_NoHitsScritta, 2);
	TextDrawLetterSize(TD_NoHitsScritta, 0.150000, 0.699998);
	TextDrawColor(TD_NoHitsScritta, -1);
	TextDrawSetOutline(TD_NoHitsScritta, 0);
	TextDrawSetProportional(TD_NoHitsScritta, 1);
	TextDrawSetShadow(TD_NoHitsScritta, 1);

	// hint textdraw
/*	HintTD = TextDrawCreate(638.000000, 436.000000, hintFrasi[random(sizeof hintFrasi)]);
	TextDrawAlignment(HintTD, 3);
	TextDrawBackgroundColor(HintTD, 112);
	TextDrawFont(HintTD, 2);
	TextDrawLetterSize(HintTD, 0.139999, 1.199998);
	TextDrawColor(HintTD, -1);
	TextDrawSetOutline(HintTD, 1);
	TextDrawSetProportional(HintTD, 1);*/

	RoundStart_TD1 = TextDrawCreate(10.000000, 20.000000, "Campo da tennis - Random base");
	TextDrawBackgroundColor(RoundStart_TD1, 255);
	TextDrawFont(RoundStart_TD1, 0);
	TextDrawLetterSize(RoundStart_TD1, 0.600000, 2.000000);
	TextDrawColor(RoundStart_TD1, -1);
	TextDrawSetOutline(RoundStart_TD1, 1);
	TextDrawSetProportional(RoundStart_TD1, 1);

	RoundStart_TD2 = TextDrawCreate(43.000000, 391.000000, "The round will start in 5 seconds...");
	TextDrawBackgroundColor(RoundStart_TD2, 48);
	TextDrawFont(RoundStart_TD2, 2);
	TextDrawLetterSize(RoundStart_TD2, 0.200000, 1.000000);
	TextDrawColor(RoundStart_TD2, -1);
	TextDrawSetOutline(RoundStart_TD2, 1);
	TextDrawSetProportional(RoundStart_TD2, 1);

	RoundStart_TD3 = TextDrawCreate(0.000000, 346.000000, "-");
	TextDrawBackgroundColor(RoundStart_TD3, 255);
	TextDrawFont(RoundStart_TD3, 1);
	TextDrawLetterSize(RoundStart_TD3, 17.750043, 8.700002);
	TextDrawColor(RoundStart_TD3, 32);
	TextDrawSetOutline(RoundStart_TD3, 0);
	TextDrawSetProportional(RoundStart_TD3, 1);
	TextDrawSetShadow(RoundStart_TD3, 0);

	/**
	 * Class spawn tds
	 */
	new Text:t = Classtd_SpawnTN[0] = TextDrawCreate(208.000000, 113.000000, "\\");
	TextDrawBackgroundColor( t, 255);
	TextDrawFont( t, 1);
	TextDrawLetterSize( t,  0.980000, 13.700001);
	TextDrawColor( t,  96);
	TextDrawSetOutline( t,  0);
	TextDrawSetProportional( t,  1);
	TextDrawSetShadow(t, 0);

	t = Classtd_SpawnTN[1] = TextDrawCreate(404.000000, 113.000000, "/");
	TextDrawBackgroundColor( t, 255);
	TextDrawFont( t, 1);
	TextDrawLetterSize( t,  0.980000, 13.700001);
	TextDrawColor( t,  96);
	TextDrawSetOutline( t,  0);
	TextDrawSetProportional( t,  1);
	TextDrawSetShadow(t, 0);

	t = Classtd_SpawnTN[2] = TextDrawCreate(217.000000, 136.000000, "Welcome to ~b~~h~~h~s7 ~w~Server");
	TextDrawBackgroundColor( t, 48);
	TextDrawFont( t, 1);
	TextDrawLetterSize( t,  0.500000, 2.000000);
	TextDrawColor( t,  -1);
	TextDrawSetOutline( t,  1);
	TextDrawSetProportional( t,  1);

	t = Classtd_SpawnTN[3] = TextDrawCreate(412.000000, 142.000000, "ld_otb2:ric1");
	TextDrawBackgroundColor( t, 255);
	TextDrawFont( t, 4);
	TextDrawLetterSize( t,  0.200000, -2.000000);
	TextDrawColor( t,  -1);
	TextDrawSetOutline( t,  0);
	TextDrawSetProportional( t,  1);
	TextDrawSetShadow(t, 1);
	TextDrawUseBox(t, 1);
	TextDrawBoxColor(t, 255);
	TextDrawTextSize(t, 61.000000, 90.000000);
    TextDrawSetSelectable(t, 1);

	t = Classtd_SpawnTN[4] = TextDrawCreate(155.000000, 142.000000, "ld_otb2:ric2");
	TextDrawBackgroundColor( t, 255);
	TextDrawFont( t, 4);
	TextDrawLetterSize( t,  0.200000, -2.000000);
	TextDrawColor( t,  -1);
	TextDrawSetOutline( t,  0);
	TextDrawSetProportional( t,  1);
	TextDrawSetShadow(t, 1);
	TextDrawUseBox(t, 1);
	TextDrawBoxColor(t, 255);
	TextDrawTextSize(t, 61.000000, 90.000000);
	TextDrawSetSelectable(t, 1);

	t = Classtd_SpawnTN[5] = TextDrawCreate(311.000000, 163.000000, "Welcome to ~r~~h~~h~SlaughterField A~w~/~r~~h~~h~D~n~~w~for more info about Sigma seveN Clan~n~visit the website");
	TextDrawAlignment(t, 2);
	TextDrawBackgroundColor( t, 48);
	TextDrawFont( t, 1);
	TextDrawLetterSize( t,  0.250000, 1.999999);
	TextDrawColor( t,  -1);
	TextDrawSetOutline( t,  1);
	TextDrawSetProportional( t,  1);

	t = Classtd_SpawnTN[6] = TextDrawCreate(185.000000, 217.000000, "~r~~h~~h~Attackers");
	TextDrawAlignment(t, 2);
	TextDrawBackgroundColor( t, 48);
	TextDrawFont( t, 1);
	TextDrawLetterSize( t,  0.349999, 1.399999);
	TextDrawColor( t,  -1);
	TextDrawSetOutline( t,  1);
	TextDrawSetProportional( t,  1);//TextDrawTextSize

	t = Classtd_SpawnTN[7] = TextDrawCreate(444.000000, 217.000000, "~b~~h~~h~Defenders");
	TextDrawAlignment(t, 2);
	TextDrawBackgroundColor( t, 48);
	TextDrawFont( t, 1);
	TextDrawLetterSize( t,  0.349999, 1.399999);
	TextDrawColor( t,  -1);
	TextDrawSetOutline( t,  1);
	TextDrawSetProportional( t,  1);//TextDrawTextSize

	t = Classtd_SpawnTN[8] = TextDrawCreate(313.000000, 217.000000, "www.~r~~h~~h~sigmaseven~w~.forumfree.it");
	TextDrawAlignment(t, 2);
	TextDrawBackgroundColor( t, 48);
	TextDrawFont( t, 1);
	TextDrawLetterSize( t,  0.250000, 1.999999);
	TextDrawColor( t,  -1);
	TextDrawSetOutline( t,  1);
	TextDrawSetProportional( t,  1);
}

////////////////////////////////////////////////////////////////////////////////
//==============================================================================
////////////////////////////////////////////////////////////////////////////////
//textdraw misc

stock GeneralTextdraw()
{
	GeneralTD[0] = TextDrawCreate(606.000000, 98.000000, "~"#GT_TEAMB"~~h~s7~w~ 5 - 4 ~g~~h~sB");
	TextDrawAlignment(GeneralTD[0], 3);
	TextDrawBackgroundColor(GeneralTD[0], 80);
	TextDrawFont(GeneralTD[0], 1);
	TextDrawLetterSize(GeneralTD[0], 0.310000, 1.600000);
	TextDrawColor(GeneralTD[0], -1);
	TextDrawSetOutline(GeneralTD[0], 1);
	TextDrawSetProportional(GeneralTD[0], 1);

	GeneralTD[1] = TextDrawCreate(605.000000, 112.000000, "Rounds ~r~~h~5~w~/~r~9");
	TextDrawAlignment(GeneralTD[1], 3);
	TextDrawBackgroundColor(GeneralTD[1], 80);
	TextDrawFont(GeneralTD[1], 1);
	TextDrawLetterSize(GeneralTD[1], 0.289999, 1.500000);
	TextDrawColor(GeneralTD[1], -1);
	TextDrawSetOutline(GeneralTD[1], 1);
	TextDrawSetProportional(GeneralTD[1], 1);
}

stock RefreshTextGeneralTD()
{
	if (gConfig[Matchmode] == MATCHMODE_NOSCORES)
	{
		format( stringo , sizeof stringo , "Scores ~"#GT_TEAMA"~~h~%d ~w~- ~"#GT_TEAMB"~~h~%d", iTeam[TEAM_A][RoundWins] , iTeam[TEAM_B][RoundWins] );
		TextDrawSetString( GeneralTD[ 0 ] , stringo );
		TextDrawSetString( GeneralTD[ 1 ] , "_");
	}
	else
	{
	    format( stringo , sizeof stringo , "~"#GT_TEAMA"~~h~%s~w~ %d - %d ~"#GT_TEAMB"~~h~%s", iTeam[TEAM_A][Name] , iTeam[TEAM_A][RoundWins] , iTeam[TEAM_B][RoundWins] , iTeam[TEAM_B][Name] );
		TextDrawSetString( GeneralTD[ 0 ] , stringo );
	    format( stringo , sizeof stringo , "Rounds ~r~~h~%d~w~/~r~%d", PlayingRound , TotalRounds );
		TextDrawSetString( GeneralTD[ 1 ] , stringo);
	}
	return true;
}

stock DestroyGeneralTD()
{
	TextDrawDestroy(GeneralTD[0]);
	TextDrawDestroy(GeneralTD[1]);
}

stock Textdraw_GeneralCreate()
{
	/*RoundPaused[0] = TextDrawCreate(259.000000, 158.000000, "~b~Round ~g~paused");
	TextDrawBackgroundColor(RoundPaused[0], 255);
	TextDrawFont(RoundPaused[0], 2);
	TextDrawLetterSize(RoundPaused[0], 0.400000, 2.099998);
	TextDrawColor(RoundPaused[0], -1);
	TextDrawSetOutline(RoundPaused[0], 0);
	TextDrawSetProportional(RoundPaused[0], 1);
	TextDrawSetShadow(RoundPaused[0], 1);

	RoundPaused[1] = TextDrawCreate(320.000000, 155.000000, "_");
	TextDrawAlignment(RoundPaused[1], 2);
	TextDrawBackgroundColor(RoundPaused[1], 255);
	TextDrawFont(RoundPaused[1], 2);
	TextDrawLetterSize(RoundPaused[1], 0.800000, 3.000000);
	TextDrawColor(RoundPaused[1], -1);
	TextDrawSetOutline(RoundPaused[1], 0);
	TextDrawSetProportional(RoundPaused[1], 1);
	TextDrawSetShadow(RoundPaused[1], 1);
	TextDrawUseBox(RoundPaused[1], 1);
	TextDrawBoxColor(RoundPaused[1], 16);
	TextDrawTextSize(RoundPaused[1], 20.000000, -136.000000);

	RoundPaused = TextDrawCreate(87.000000, 325.000000, "Unpausing ~r~~h~3~r~ 2 1");
	TextDrawAlignment(RoundPaused, 2);
	TextDrawBackgroundColor(RoundPaused, 96);
	TextDrawFont(RoundPaused, 1);
	TextDrawLetterSize(RoundPaused, 0.330000, 1.299998);
	TextDrawColor(RoundPaused, -1);
	TextDrawSetOutline(RoundPaused, 1);
	TextDrawSetProportional(RoundPaused, 1);*/
}
/*
stock Td_Pause_Destroy()
{
	TextDrawDestroy( RoundPaused );
}
*/
/*stock SigmaTD()
{
	SigmaTextdraw = TextDrawCreate(495.000000, 1.000000, "www.~b~~h~sigmaseven~w~.~g~~h~forumfree~w~.it");
	TextDrawBackgroundColor(SigmaTextdraw, 255);
	TextDrawFont(SigmaTextdraw, 1);
	TextDrawLetterSize(SigmaTextdraw, 0.239999, 1.399999);
	TextDrawColor(SigmaTextdraw, -1);
	TextDrawSetOutline(SigmaTextdraw, 0);
	TextDrawSetProportional(SigmaTextdraw, 1);
	TextDrawSetShadow(SigmaTextdraw, 1);
}
*/
/*stock Process_FinalRoundTD()
{
	//new td
	FinalTD[0] = TextDrawCreate(320.000000, 100.000000, "_");
	TextDrawAlignment(FinalTD[0], 2);
	TextDrawBackgroundColor(FinalTD[0], 255);
	TextDrawFont(FinalTD[0], 1);
	TextDrawLetterSize(FinalTD[0], 0.500000, 2.000000);
	TextDrawColor(FinalTD[0], -1);
	TextDrawSetOutline(FinalTD[0], 0);
	TextDrawSetProportional(FinalTD[0], 1);
	TextDrawSetShadow(FinalTD[0], 1);
	TextDrawUseBox(FinalTD[0], 1);
	TextDrawBoxColor(FinalTD[0], 101);
	TextDrawTextSize(FinalTD[0], 32.000000, 134.000000);

	FinalTD[1] = TextDrawCreate(271.000000, 97.000000, "Atta~h~ckers~h~ win");
	TextDrawBackgroundColor(FinalTD[1], 255);
	TextDrawFont(FinalTD[1], 0);
	TextDrawLetterSize(FinalTD[1], 0.600000, 2.000000);
	TextDrawColor(FinalTD[1], 852308735);
	TextDrawSetOutline(FinalTD[1], 0);
	TextDrawSetProportional(FinalTD[1], 1);
	TextDrawSetShadow(FinalTD[1], 1);

	FinalTD[2] = TextDrawCreate(320.000000, 121.000000, "_");
	TextDrawAlignment(FinalTD[2], 2);
	TextDrawBackgroundColor(FinalTD[2], 255);
	TextDrawFont(FinalTD[2], 1);
	TextDrawLetterSize(FinalTD[2], 0.500000, 8.000000);
	TextDrawColor(FinalTD[2], 101);
	TextDrawSetOutline(FinalTD[2], 0);
	TextDrawSetProportional(FinalTD[2], 1);
	TextDrawSetShadow(FinalTD[2], 1);
	TextDrawUseBox(FinalTD[2], 1);
	TextDrawBoxColor(FinalTD[2], 101);
	TextDrawTextSize(FinalTD[2], 60.000000, 286.000000);

	FinalTD[3] = TextDrawCreate(349.000000, 140.000000, "wins the round!");
	TextDrawAlignment(FinalTD[3], 2);
	TextDrawBackgroundColor(FinalTD[3], 255);
	TextDrawFont(FinalTD[3], 1);
	TextDrawLetterSize(FinalTD[3], 0.479999, 1.799998);
	TextDrawColor(FinalTD[3], -1);
	TextDrawSetOutline(FinalTD[3], 0);
	TextDrawSetProportional(FinalTD[3], 1);
	TextDrawSetShadow(FinalTD[3], 2);

	FinalTD[4] = TextDrawCreate(320.000000, 179.000000, "_");
	TextDrawAlignment(FinalTD[4], 2);
	TextDrawBackgroundColor(FinalTD[4], 255);
	TextDrawFont(FinalTD[4], 1);
	TextDrawLetterSize(FinalTD[4], 0.500000, 1.500000);
	TextDrawColor(FinalTD[4], -1);
	TextDrawSetOutline(FinalTD[4], 0);
	TextDrawSetProportional(FinalTD[4], 1);
	TextDrawSetShadow(FinalTD[4], 1);
	TextDrawUseBox(FinalTD[4], 1);
	TextDrawBoxColor(FinalTD[4], 255);
	TextDrawTextSize(FinalTD[4], 0.000000, -293.000000);

	FinalTD[5] = TextDrawCreate(261.000000, 140.000000, "[BFS]");
	TextDrawAlignment(FinalTD[5], 2);
	TextDrawBackgroundColor(FinalTD[5], 255);
	TextDrawFont(FinalTD[5], 1);
	TextDrawLetterSize(FinalTD[5], 0.479999, 1.799998);
	TextDrawColor(FinalTD[5], 852308735);
	TextDrawSetOutline(FinalTD[5], 0);
	TextDrawSetProportional(FinalTD[5], 1);
	TextDrawSetShadow(FinalTD[5], 2);

	FinalTD[6] = TextDrawCreate(178.000000, 180.000000, "Top damage");
	TextDrawBackgroundColor(FinalTD[6], 255);
	TextDrawFont(FinalTD[6], 1);
	TextDrawLetterSize(FinalTD[6], 0.239999, 1.200000);
	TextDrawColor(FinalTD[6], -16776961);
	TextDrawSetOutline(FinalTD[6], 0);
	TextDrawSetProportional(FinalTD[6], 1);
	TextDrawSetShadow(FinalTD[6], 1);

	FinalTD[7] = TextDrawCreate(230.000000, 180.000000, "1st. [s7]Morgenstern");
	TextDrawBackgroundColor(FinalTD[7], 255);
	TextDrawFont(FinalTD[7], 1);
	TextDrawLetterSize(FinalTD[7], 0.170000, 1.200000);
	TextDrawColor(FinalTD[7], -2686721);
	TextDrawSetOutline(FinalTD[7], 0);
	TextDrawSetProportional(FinalTD[7], 1);
	TextDrawSetShadow(FinalTD[7], 1);

	FinalTD[8] = TextDrawCreate(312.000000, 180.000000, "2nd. [s7]Morgenstern");
	TextDrawBackgroundColor(FinalTD[8], 255);
	TextDrawFont(FinalTD[8], 1);
	TextDrawLetterSize(FinalTD[8], 0.170000, 1.200000);
	TextDrawColor(FinalTD[8], -1061109505);
	TextDrawSetOutline(FinalTD[8], 0);
	TextDrawSetProportional(FinalTD[8], 1);
	TextDrawSetShadow(FinalTD[8], 1);

	FinalTD[9] = TextDrawCreate(425.000000, 180.000000, "3rd. [s7]Morgenstern");
	TextDrawAlignment(FinalTD[9], 2);
	TextDrawBackgroundColor(FinalTD[9], 255);
	TextDrawFont(FinalTD[9], 1);
	TextDrawLetterSize(FinalTD[9], 0.170000, 1.200000);
	TextDrawColor(FinalTD[9], -626712321);
	TextDrawSetOutline(FinalTD[9], 0);
	TextDrawSetProportional(FinalTD[9], 1);
	TextDrawSetShadow(FinalTD[9], 1);

	FinalTD[10] = TextDrawCreate(248.000000, 201.000000, "_");
	TextDrawAlignment(FinalTD[10], 2);
	TextDrawBackgroundColor(FinalTD[10], 255);
	TextDrawFont(FinalTD[10], 1);
	TextDrawLetterSize(FinalTD[10], 0.500000, 20.000000);
	TextDrawColor(FinalTD[10], -1);
	TextDrawSetOutline(FinalTD[10], 0);
	TextDrawSetProportional(FinalTD[10], 1);
	TextDrawSetShadow(FinalTD[10], 1);
	TextDrawUseBox(FinalTD[10], 1);
	TextDrawBoxColor(FinalTD[10], 52581);
	TextDrawTextSize(FinalTD[10], 0.000000, -148.000000);

	FinalTD[11] = TextDrawCreate(392.000000, 201.000000, "_");
	TextDrawAlignment(FinalTD[11], 2);
	TextDrawBackgroundColor(FinalTD[11], 255);
	TextDrawFont(FinalTD[11], 1);
	TextDrawLetterSize(FinalTD[11], 0.500000, 20.000000);
	TextDrawColor(FinalTD[11], -1);
	TextDrawSetOutline(FinalTD[11], 0);
	TextDrawSetProportional(FinalTD[11], 1);
	TextDrawSetShadow(FinalTD[11], 1);
	TextDrawUseBox(FinalTD[11], 1);
	TextDrawBoxColor(FinalTD[11], 852308581);
	TextDrawTextSize(FinalTD[11], 0.000000, -148.000000);

	FinalTD[12] = TextDrawCreate(320.000000, 201.000000, "_");
	TextDrawAlignment(FinalTD[12], 2);
	TextDrawBackgroundColor(FinalTD[12], 255);
	TextDrawFont(FinalTD[12], 1);
	TextDrawLetterSize(FinalTD[12], 0.500000, 1.500000);
	TextDrawColor(FinalTD[12], -1);
	TextDrawSetOutline(FinalTD[12], 0);
	TextDrawSetProportional(FinalTD[12], 1);
	TextDrawSetShadow(FinalTD[12], 1);
	TextDrawUseBox(FinalTD[12], 1);
	TextDrawBoxColor(FinalTD[12], 255);
	TextDrawTextSize(FinalTD[12], 0.000000, -292.000000);

	FinalTD[13] = TextDrawCreate(320.000000, 378.000000, "_");
	TextDrawAlignment(FinalTD[13], 2);
	TextDrawBackgroundColor(FinalTD[13], 255);
	TextDrawFont(FinalTD[13], 1);
	TextDrawLetterSize(FinalTD[13], 0.500000, 1.500000);
	TextDrawColor(FinalTD[13], -1);
	TextDrawSetOutline(FinalTD[13], 0);
	TextDrawSetProportional(FinalTD[13], 1);
	TextDrawSetShadow(FinalTD[13], 1);
	TextDrawUseBox(FinalTD[13], 1);
	TextDrawBoxColor(FinalTD[13], 255);
	TextDrawTextSize(FinalTD[13], 0.000000, -292.000000);

	FinalTD[14] = TextDrawCreate(178.000000, 201.000000, "Nickname         Kills      Damage");
	TextDrawBackgroundColor(FinalTD[14], 255);
	TextDrawFont(FinalTD[14], 1);
	TextDrawLetterSize(FinalTD[14], 0.239998, 1.200000);
	TextDrawColor(FinalTD[14], -2016478465);
	TextDrawSetOutline(FinalTD[14], 0);
	TextDrawSetProportional(FinalTD[14], 1);
	TextDrawSetShadow(FinalTD[14], 1);

	FinalTD[15] = TextDrawCreate(323.000000, 201.000000, "Nickname         Kills      Damage");
	TextDrawBackgroundColor(FinalTD[15], 255);
	TextDrawFont(FinalTD[15], 1);
	TextDrawLetterSize(FinalTD[15], 0.239997, 1.200000);
	TextDrawColor(FinalTD[15], 852308735);
	TextDrawSetOutline(FinalTD[15], 0);
	TextDrawSetProportional(FinalTD[15], 1);
	TextDrawSetShadow(FinalTD[15], 1);

	FinalTD[16] = TextDrawCreate(178.000000, 218.000000, "[s7]Morgenstern");
	TextDrawBackgroundColor(FinalTD[16], 255);
	TextDrawFont(FinalTD[16], 1);
	TextDrawLetterSize(FinalTD[16], 0.169999, 1.299999);
	TextDrawColor(FinalTD[16], -2016478465);
	TextDrawSetOutline(FinalTD[16], 0);
	TextDrawSetProportional(FinalTD[16], 1);
	TextDrawSetShadow(FinalTD[16], 1);

	FinalTD[17] = TextDrawCreate(254.000000, 220.000000, "KB");
	TextDrawAlignment(FinalTD[17], 2);
	TextDrawBackgroundColor(FinalTD[17], 255);
	TextDrawFont(FinalTD[17], 1);
	TextDrawLetterSize(FinalTD[17], 0.239996, 1.200000);
	TextDrawColor(FinalTD[17], -2016478465);
	TextDrawSetOutline(FinalTD[17], 0);
	TextDrawSetProportional(FinalTD[17], 1);
	TextDrawSetShadow(FinalTD[17], 1);

	FinalTD[18] = TextDrawCreate(298.000000, 220.000000, "DB");
	TextDrawAlignment(FinalTD[18], 2);
	TextDrawBackgroundColor(FinalTD[18], 255);
	TextDrawFont(FinalTD[18], 1);
	TextDrawLetterSize(FinalTD[18], 0.239997, 1.200000);
	TextDrawColor(FinalTD[18], -2016478465);
	TextDrawSetOutline(FinalTD[18], 0);
	TextDrawSetProportional(FinalTD[18], 1);
	TextDrawSetShadow(FinalTD[18], 1);

	FinalTD[19] = TextDrawCreate(399.000000, 220.000000, "KG");
	TextDrawAlignment(FinalTD[19], 2);
	TextDrawBackgroundColor(FinalTD[19], 255);
	TextDrawFont(FinalTD[19], 1);
	TextDrawLetterSize(FinalTD[19], 0.239996, 1.200000);
	TextDrawColor(FinalTD[19], -1863413505);
	TextDrawSetOutline(FinalTD[19], 0);
	TextDrawSetProportional(FinalTD[19], 1);
	TextDrawSetShadow(FinalTD[19], 1);

	FinalTD[20] = TextDrawCreate(320.000000, 218.000000, "[s7]Morgenstern");
//	TextDrawAlignment(FinalTD[20], 2);
	TextDrawBackgroundColor(FinalTD[20], 255);
	TextDrawFont(FinalTD[20], 1);
	TextDrawLetterSize(FinalTD[20], 0.169999, 1.299999);
	TextDrawColor(FinalTD[20], -1863413505);
	TextDrawSetOutline(FinalTD[20], 0);
	TextDrawSetProportional(FinalTD[20], 1);
	TextDrawSetShadow(FinalTD[20], 1);

	FinalTD[21] = TextDrawCreate(443.000000, 220.000000, "DG");
	TextDrawAlignment(FinalTD[21], 2);
	TextDrawBackgroundColor(FinalTD[21], 255);
	TextDrawFont(FinalTD[21], 1);
	TextDrawLetterSize(FinalTD[21], 0.239997, 1.200000);
	TextDrawColor(FinalTD[21], -1863413505);
	TextDrawSetOutline(FinalTD[21], 0);
	TextDrawSetProportional(FinalTD[21], 1);
	TextDrawSetShadow(FinalTD[21], 1);

	FinalTD[22] = TextDrawCreate(248.000000, 378.000000, "Total kills: 99  Total damage: 9999");
	TextDrawAlignment(FinalTD[22], 2);
	TextDrawBackgroundColor(FinalTD[22], 255);
	TextDrawFont(FinalTD[22], 1);
	TextDrawLetterSize(FinalTD[22], 0.239997, 1.200000);
	TextDrawColor(FinalTD[22], -2016478465);
	TextDrawSetOutline(FinalTD[22], 0);
	TextDrawSetProportional(FinalTD[22], 1);
	TextDrawSetShadow(FinalTD[22], 1);

	FinalTD[23] = TextDrawCreate(392.000000, 378.000000, "Total kills: 99  Total damage: 9999");
	TextDrawAlignment(FinalTD[23], 2);
	TextDrawBackgroundColor(FinalTD[23], 255);
	TextDrawFont(FinalTD[23], 1);
	TextDrawLetterSize(FinalTD[23], 0.239997, 1.200000);
	TextDrawColor(FinalTD[23], -1863413505);
	TextDrawSetOutline(FinalTD[23], 0);
	TextDrawSetProportional(FinalTD[23], 1);
	TextDrawSetShadow(FinalTD[23], 1);
}*/

stock CreateRoundStats()
{
	/*
	RoundStats[0] = TextDrawCreate(320.000000, 434.000000, "_");
	TextDrawAlignment(RoundStats[0], 2);
	TextDrawBackgroundColor(RoundStats[0], 255);
	TextDrawFont(RoundStats[0], 1);
	TextDrawLetterSize(RoundStats[0], 0.500000, 1.300000);
	TextDrawColor(RoundStats[0], 101);
	TextDrawSetOutline(RoundStats[0], 0);
	TextDrawSetProportional(RoundStats[0], 1);
	TextDrawSetShadow(RoundStats[0], 1);
	TextDrawUseBox(RoundStats[0], 1);
	//TextDrawBoxColor(RoundStats[0], 101);
	TextDrawBoxColor(RoundStats[0], 0x00000045);
	TextDrawTextSize(RoundStats[0], -1.000000, -644.000000);

	RoundStats[1] = TextDrawCreate(120.000000, 432.000000, "~b~~h~s7 ~b~5  ~w~(~g~~h~~h~1200~w~)");
	TextDrawAlignment(RoundStats[1], 2);
	TextDrawBackgroundColor(RoundStats[1], 80);
	TextDrawFont(RoundStats[1], 1);
	TextDrawLetterSize(RoundStats[1], 0.349999, 1.600000);
	TextDrawColor(RoundStats[1], 16711935);
	TextDrawSetOutline(RoundStats[1], 1);
	TextDrawSetProportional(RoundStats[1], 1);

	RoundStats[3] = TextDrawCreate(320.000000, 435.000000, "~g~~h~~h~12:57");
	TextDrawAlignment(RoundStats[3], 2);
	TextDrawBackgroundColor(RoundStats[3], 80);
	TextDrawFont(RoundStats[3], 1);
	TextDrawLetterSize(RoundStats[3], 0.370000, 1.100000);
	TextDrawColor(RoundStats[3], 16711935);
	TextDrawSetOutline(RoundStats[3], 1);
	TextDrawSetProportional(RoundStats[3], 1);

	RoundStats[2] = TextDrawCreate(516.000000, 432.000000, "~g~~h~s7 ~g~5  ~w~(~g~~h~~h~1200~w~)");
	TextDrawAlignment(RoundStats[2], 2);
	TextDrawBackgroundColor(RoundStats[2], 80);
	TextDrawFont(RoundStats[2], 1);
	TextDrawLetterSize(RoundStats[2], 0.349999, 1.600000);
	TextDrawColor(RoundStats[2], -1);
	TextDrawSetOutline(RoundStats[2], 1);
	TextDrawSetProportional(RoundStats[2], 1);
	*/

	new Text:t = RoundStats[0] = TextDrawCreate(0.000000, 328.000000, "-");
	TextDrawBackgroundColor(t, 255);
	TextDrawFont(t, 1);
	TextDrawLetterSize(t, 44.149940, 20.300001);
	TextDrawColor(t, 64);
	TextDrawSetOutline(t, 0);
	TextDrawSetProportional(t, 1);
	TextDrawSetShadow(t, 0);

	t = RoundStats[1] = TextDrawCreate(169.000000, 433.000000, "~r~~h~s7 ~r~4  ~w~(~r~~h~~h~1000~w~)");
	TextDrawAlignment(t, 2);
	TextDrawBackgroundColor(t, 48);
	TextDrawFont(t, 1);
	TextDrawLetterSize(t, 0.239999, 1.299999);
	TextDrawColor(t, -1);
	TextDrawSetOutline(t, 1);
	TextDrawSetProportional(t, 1);

	t = RoundStats[2] = TextDrawCreate(465.000000, 433.000000, "~b~~h~s7 ~b~4  ~w~(~b~~h~~h~1000~w~)");
	TextDrawAlignment(t, 2);
	TextDrawBackgroundColor(t, 48);
	TextDrawFont(t, 1);
	TextDrawLetterSize(t, 0.239999, 1.299999);
	TextDrawColor(t, -1);
	TextDrawSetOutline(t, 1);
	TextDrawSetProportional(t, 1);

	t = RoundStats[3] = TextDrawCreate(315.000000, 433.000000, "07:59");
	TextDrawAlignment(t, 2);
	TextDrawBackgroundColor(t, 48);
	TextDrawFont(t, 1);
	TextDrawLetterSize(t, 0.239999, 1.299999);
	TextDrawColor(t, -1);
	TextDrawSetOutline(t, 1);
	TextDrawSetProportional(t, 1);

	DamageTeamB = TextDrawCreate(520.000000, 433.000000, "~w~-~b~~h~182");
	TextDrawAlignment(DamageTeamB, 2);
	TextDrawBackgroundColor(DamageTeamB, 48);
	TextDrawFont(DamageTeamB, 2);
	TextDrawLetterSize(DamageTeamB, 0.239999, 1.299999);
	TextDrawColor(DamageTeamB, -1);
	TextDrawSetOutline(DamageTeamB, 1);
	TextDrawSetProportional(DamageTeamB, 1);

	DamageTeamA = TextDrawCreate(110.000000, 433.000000, "~w~-~r~~h~182");
	TextDrawAlignment(DamageTeamA, 2);
	TextDrawBackgroundColor(DamageTeamA, 48);
	TextDrawFont(DamageTeamA, 2);
	TextDrawLetterSize(DamageTeamA, 0.240000, 1.300000);
	TextDrawColor(DamageTeamA, -1);
	TextDrawSetOutline(DamageTeamA, 1);
	TextDrawSetProportional(DamageTeamA, 1);
}
/*
stock DestroyPlayerInfo(playerid)
	return PlayerTextDrawDestroy(playerid, PlayerInfo);*/

stock Process_FinalCWTDs()
{
	// nuovo textdraw
	FinalTCWScreen[0] = TextDrawCreate(325.000000, 69.000000, "_");
	TextDrawAlignment(FinalTCWScreen[0], 2);
	TextDrawBackgroundColor(FinalTCWScreen[0], 255);
	TextDrawFont(FinalTCWScreen[0], 1);
	TextDrawLetterSize(FinalTCWScreen[0], 0.460000, 8.000000);
	TextDrawColor(FinalTCWScreen[0], -1);
	TextDrawSetOutline(FinalTCWScreen[0], 0);
	TextDrawSetProportional(FinalTCWScreen[0], 1);
	TextDrawSetShadow(FinalTCWScreen[0], 1);
	TextDrawUseBox(FinalTCWScreen[0], 1);
	TextDrawBoxColor(FinalTCWScreen[0], 101);
	TextDrawTextSize(FinalTCWScreen[0], 412.000000, 470.000000);

	FinalTCWScreen[1] = TextDrawCreate(324.000000, 76.000000, "~b~s7 7~w~ - ~g~2 H2K");
	TextDrawAlignment(FinalTCWScreen[1], 2);
	TextDrawBackgroundColor(FinalTCWScreen[1], -1);
	TextDrawFont(FinalTCWScreen[1], 1);
	TextDrawLetterSize(FinalTCWScreen[1], 0.899999, 6.000000);
	TextDrawColor(FinalTCWScreen[1], -1);
	TextDrawSetOutline(FinalTCWScreen[1], 1);
	TextDrawSetProportional(FinalTCWScreen[1], 1);

	FinalTCWScreen[2] = TextDrawCreate(325.000000, 146.000000, "_");
	TextDrawAlignment(FinalTCWScreen[2], 2);
	TextDrawBackgroundColor(FinalTCWScreen[2], 255);
	TextDrawFont(FinalTCWScreen[2], 1);
	TextDrawLetterSize(FinalTCWScreen[2], 0.500000, 1.000000);
	TextDrawColor(FinalTCWScreen[2], 101);
	TextDrawSetOutline(FinalTCWScreen[2], 0);
	TextDrawSetProportional(FinalTCWScreen[2], 1);
	TextDrawSetShadow(FinalTCWScreen[2], 1);
	TextDrawUseBox(FinalTCWScreen[2], 1);
	TextDrawBoxColor(FinalTCWScreen[2], 153);
	TextDrawTextSize(FinalTCWScreen[2], 30.000000, 470.000000);

	FinalTCWScreen[3] = TextDrawCreate(90.000000, 145.000000, "Top damage");
	TextDrawBackgroundColor(FinalTCWScreen[3], 255);
	TextDrawFont(FinalTCWScreen[3], 1);
	TextDrawLetterSize(FinalTCWScreen[3], 0.300000, 1.000000);
	TextDrawColor(FinalTCWScreen[3], -16776961);
	TextDrawSetOutline(FinalTCWScreen[3], 0);
	TextDrawSetProportional(FinalTCWScreen[3], 1);
	TextDrawSetShadow(FinalTCWScreen[3], 1);

	FinalTCWScreen[4] = TextDrawCreate(325.000000, 160.000000, "_");
	TextDrawAlignment(FinalTCWScreen[4], 2);
	TextDrawBackgroundColor(FinalTCWScreen[4], 255);
	TextDrawFont(FinalTCWScreen[4], 1);
	TextDrawLetterSize(FinalTCWScreen[4], 0.500000, 1.000000);
	TextDrawColor(FinalTCWScreen[4], 101);
	TextDrawSetOutline(FinalTCWScreen[4], 0);
	TextDrawSetProportional(FinalTCWScreen[4], 1);
	TextDrawSetShadow(FinalTCWScreen[4], 1);
	TextDrawUseBox(FinalTCWScreen[4], 1);
	TextDrawBoxColor(FinalTCWScreen[4], 153);
	TextDrawTextSize(FinalTCWScreen[4], 30.000000, 470.000000);

	FinalTCWScreen[5] = TextDrawCreate(90.000000, 159.000000, "Top kills");
	TextDrawBackgroundColor(FinalTCWScreen[5], 255);
	TextDrawFont(FinalTCWScreen[5], 1);
	TextDrawLetterSize(FinalTCWScreen[5], 0.300000, 1.000000);
	TextDrawColor(FinalTCWScreen[5], -16776961);
	TextDrawSetOutline(FinalTCWScreen[5], 0);
	TextDrawSetProportional(FinalTCWScreen[5], 1);
	TextDrawSetShadow(FinalTCWScreen[5], 1);

	FinalTCWScreen[6] = TextDrawCreate(85.000000, 80.000000, "L");
	TextDrawBackgroundColor(FinalTCWScreen[6], 255);
	TextDrawFont(FinalTCWScreen[6], 2);
	TextDrawLetterSize(FinalTCWScreen[6], 1.899999, 8.100000);
	TextDrawColor(FinalTCWScreen[6], -1);
	TextDrawSetOutline(FinalTCWScreen[6], 0);
	TextDrawSetProportional(FinalTCWScreen[6], 1);
	TextDrawSetShadow(FinalTCWScreen[6], 1);

	FinalTCWScreen[7] = TextDrawCreate(564.000000, 129.000000, "L");
	TextDrawBackgroundColor(FinalTCWScreen[7], 255);
	TextDrawFont(FinalTCWScreen[7], 2);
	TextDrawLetterSize(FinalTCWScreen[7], -1.899999, -8.099999);
	TextDrawColor(FinalTCWScreen[7], -1);
	TextDrawSetOutline(FinalTCWScreen[7], 0);
	TextDrawSetProportional(FinalTCWScreen[7], 1);
	TextDrawSetShadow(FinalTCWScreen[7], 1);

	// rosso
	FinalTCWScreen[8] = TextDrawCreate(205.000000, 178.000000, "_");
	TextDrawAlignment(FinalTCWScreen[8], 2);
	TextDrawBackgroundColor(FinalTCWScreen[8], 255);
	TextDrawFont(FinalTCWScreen[8], 1);
	TextDrawLetterSize(FinalTCWScreen[8], 0.810000, 22.000000);
	TextDrawColor(FinalTCWScreen[8], -1);
	TextDrawSetOutline(FinalTCWScreen[8], 0);
	TextDrawSetProportional(FinalTCWScreen[8], 1);
	TextDrawSetShadow(FinalTCWScreen[8], 1);
	TextDrawUseBox(FinalTCWScreen[8], 1);
	TextDrawBoxColor(FinalTCWScreen[8], 0xff000044);//52325
	TextDrawTextSize(FinalTCWScreen[8], 70.000000, -237.000000);

	// blu
	FinalTCWScreen[9] = TextDrawCreate(445.000000, 178.000000, "_");
	TextDrawAlignment(FinalTCWScreen[9], 2);
	TextDrawBackgroundColor(FinalTCWScreen[9], 255);
	TextDrawFont(FinalTCWScreen[9], 1);
	TextDrawLetterSize(FinalTCWScreen[9], 0.519999, 22.000000);
	TextDrawColor(FinalTCWScreen[9], -1);
	TextDrawSetOutline(FinalTCWScreen[9], 0);
	TextDrawSetProportional(FinalTCWScreen[9], 1);
	TextDrawSetShadow(FinalTCWScreen[9], 1);
	TextDrawUseBox(FinalTCWScreen[9], 1);
	TextDrawBoxColor(FinalTCWScreen[9], 52325);//852308581
	TextDrawTextSize(FinalTCWScreen[9], 45.000000, 230.000000);

	FinalTCWScreen[10] = TextDrawCreate(205.000000, 178.000000, "_");
	TextDrawAlignment(FinalTCWScreen[10], 2);
	TextDrawBackgroundColor(FinalTCWScreen[10], 255);
	TextDrawFont(FinalTCWScreen[10], 1);
	TextDrawLetterSize(FinalTCWScreen[10], 0.469999, 1.599998);
	TextDrawColor(FinalTCWScreen[10], -1);
	TextDrawSetOutline(FinalTCWScreen[10], 0);
	TextDrawSetProportional(FinalTCWScreen[10], 1);
	TextDrawSetShadow(FinalTCWScreen[10], 1);
	TextDrawUseBox(FinalTCWScreen[10], 1);
	TextDrawBoxColor(FinalTCWScreen[10], 255);
	TextDrawTextSize(FinalTCWScreen[10], 0.000000, 231.000000);

	FinalTCWScreen[11] = TextDrawCreate(205.000000, 379.000000, "_");
	TextDrawAlignment(FinalTCWScreen[11], 2);
	TextDrawBackgroundColor(FinalTCWScreen[11], 255);
	TextDrawFont(FinalTCWScreen[11], 1);
	TextDrawLetterSize(FinalTCWScreen[11], 0.469999, 1.599998);
	TextDrawColor(FinalTCWScreen[11], -1);
	TextDrawSetOutline(FinalTCWScreen[11], 0);
	TextDrawSetProportional(FinalTCWScreen[11], 1);
	TextDrawSetShadow(FinalTCWScreen[11], 1);
	TextDrawUseBox(FinalTCWScreen[11], 1);
	TextDrawBoxColor(FinalTCWScreen[11], 255);
	TextDrawTextSize(FinalTCWScreen[11], 0.000000, 230.000000);

	// rosso (ora è blu)
	FinalTCWScreen[12] = TextDrawCreate(93.000000, 181.000000, "Nickname               Kills        Deaths        Damage");
	TextDrawBackgroundColor(FinalTCWScreen[12], 255);
	TextDrawFont(FinalTCWScreen[12], 1);
	TextDrawLetterSize(FinalTCWScreen[12], 0.239999, 1.000000);
	TextDrawColor(FinalTCWScreen[12], 0xf47a7aAA);
	TextDrawSetOutline(FinalTCWScreen[12], 0);
	TextDrawSetProportional(FinalTCWScreen[12], 1);
	TextDrawSetShadow(FinalTCWScreen[12], 1);

	FinalTCWScreen[13] = TextDrawCreate(445.000000, 379.000000, "_");
	TextDrawAlignment(FinalTCWScreen[13], 2);
	TextDrawBackgroundColor(FinalTCWScreen[13], 255);
	TextDrawFont(FinalTCWScreen[13], 1);
	TextDrawLetterSize(FinalTCWScreen[13], 0.469998, 1.599997);
	TextDrawColor(FinalTCWScreen[13], -1);
	TextDrawSetOutline(FinalTCWScreen[13], 0);
	TextDrawSetProportional(FinalTCWScreen[13], 1);
	TextDrawSetShadow(FinalTCWScreen[13], 1);
	TextDrawUseBox(FinalTCWScreen[13], 1);
	TextDrawBoxColor(FinalTCWScreen[13], 255);
	TextDrawTextSize(FinalTCWScreen[13], 0.000000, 230.000000);

	FinalTCWScreen[14] = TextDrawCreate(445.000000, 178.000000, "_");
	TextDrawAlignment(FinalTCWScreen[14], 2);
	TextDrawBackgroundColor(FinalTCWScreen[14], 255);
	TextDrawFont(FinalTCWScreen[14], 1);
	TextDrawLetterSize(FinalTCWScreen[14], 0.469998, 1.599997);
	TextDrawColor(FinalTCWScreen[14], -1);
	TextDrawSetOutline(FinalTCWScreen[14], 0);
	TextDrawSetProportional(FinalTCWScreen[14], 1);
	TextDrawSetShadow(FinalTCWScreen[14], 1);
	TextDrawUseBox(FinalTCWScreen[14], 1);
	TextDrawBoxColor(FinalTCWScreen[14], 255);
	TextDrawTextSize(FinalTCWScreen[14], 0.000000, 230.000000);

	// blu (was green)
	FinalTCWScreen[15] = TextDrawCreate(334.000000, 181.000000, "Nickname               Kills        Deaths        Damage");
	TextDrawBackgroundColor(FinalTCWScreen[15], 255);
	TextDrawFont(FinalTCWScreen[15], 1);
	TextDrawLetterSize(FinalTCWScreen[15], 0.239998, 1.000000);
	TextDrawColor(FinalTCWScreen[15], 1687547391);
	TextDrawSetOutline(FinalTCWScreen[15], 0);
	TextDrawSetProportional(FinalTCWScreen[15], 1);
	TextDrawSetShadow(FinalTCWScreen[15], 1);

	// rosso
	FinalTCWScreen[16] = TextDrawCreate(94.000000, 381.000000, "Total kills: 99   Total Deaths: 99   Total damage: 9999");
	TextDrawBackgroundColor(FinalTCWScreen[16], 255);
	TextDrawFont(FinalTCWScreen[16], 1);
	TextDrawLetterSize(FinalTCWScreen[16], 0.239998, 1.000000);
	TextDrawColor(FinalTCWScreen[16], 0xf47a7aAA);
	TextDrawSetOutline(FinalTCWScreen[16], 0);
	TextDrawSetProportional(FinalTCWScreen[16], 1);
	TextDrawSetShadow(FinalTCWScreen[16], 1);

	// blu
	FinalTCWScreen[17] = TextDrawCreate(334.000000, 381.000000, "Total kills: 99   Total Deaths: 99   Total damage: 9999");
	TextDrawBackgroundColor(FinalTCWScreen[17], 255);
	TextDrawFont(FinalTCWScreen[17], 1);
	TextDrawLetterSize(FinalTCWScreen[17], 0.239998, 1.000000);
	TextDrawColor(FinalTCWScreen[17], 1687547391);
	TextDrawSetOutline(FinalTCWScreen[17], 0);
	TextDrawSetProportional(FinalTCWScreen[17], 1);
	TextDrawSetShadow(FinalTCWScreen[17], 1);

	FinalTCWScreen[18] = TextDrawCreate(158.000000, 146.000000, "1st. [s7]Morgenstern (9999)");
	TextDrawBackgroundColor(FinalTCWScreen[18], 255);
	TextDrawFont(FinalTCWScreen[18], 1);
	TextDrawLetterSize(FinalTCWScreen[18], 0.230000, 1.000000);
	TextDrawColor(FinalTCWScreen[18], -2686721);
	TextDrawSetOutline(FinalTCWScreen[18], 0);
	TextDrawSetProportional(FinalTCWScreen[18], 1);
	TextDrawSetShadow(FinalTCWScreen[18], 1);

	FinalTCWScreen[19] = TextDrawCreate(291.000000, 146.000000, "2nd. [s7]Morgenstern (9999)");
	TextDrawBackgroundColor(FinalTCWScreen[19], 255);
	TextDrawFont(FinalTCWScreen[19], 1);
	TextDrawLetterSize(FinalTCWScreen[19], 0.230000, 1.000000);
	TextDrawColor(FinalTCWScreen[19], -1061109505);
	TextDrawSetOutline(FinalTCWScreen[19], 0);
	TextDrawSetProportional(FinalTCWScreen[19], 1);
	TextDrawSetShadow(FinalTCWScreen[19], 1);

	FinalTCWScreen[20] = TextDrawCreate(428.000000, 146.000000, "3rd. [s7]Morgenstern (9999)");
	TextDrawBackgroundColor(FinalTCWScreen[20], 255);
	TextDrawFont(FinalTCWScreen[20], 1);
	TextDrawLetterSize(FinalTCWScreen[20], 0.230000, 1.000000);
	TextDrawColor(FinalTCWScreen[20], -626712321);
	TextDrawSetOutline(FinalTCWScreen[20], 0);
	TextDrawSetProportional(FinalTCWScreen[20], 1);
	TextDrawSetShadow(FinalTCWScreen[20], 1);

	FinalTCWScreen[21] = TextDrawCreate(158.000000, 159.000000, "1st. [s7]Morgenstern (99)");
	TextDrawBackgroundColor(FinalTCWScreen[21], 255);
	TextDrawFont(FinalTCWScreen[21], 1);
	TextDrawLetterSize(FinalTCWScreen[21], 0.230000, 1.000000);
	TextDrawColor(FinalTCWScreen[21], -2686721);
	TextDrawSetOutline(FinalTCWScreen[21], 0);
	TextDrawSetProportional(FinalTCWScreen[21], 1);
	TextDrawSetShadow(FinalTCWScreen[21], 1);

	FinalTCWScreen[22] = TextDrawCreate(292.000000, 159.000000, "2nd. [s7]Morgenstern (99)");
	TextDrawBackgroundColor(FinalTCWScreen[22], 255);
	TextDrawFont(FinalTCWScreen[22], 1);
	TextDrawLetterSize(FinalTCWScreen[22], 0.230000, 1.000000);
	TextDrawColor(FinalTCWScreen[22], -1061109505);
	TextDrawSetOutline(FinalTCWScreen[22], 0);
	TextDrawSetProportional(FinalTCWScreen[22], 1);
	TextDrawSetShadow(FinalTCWScreen[22], 1);

	FinalTCWScreen[23] = TextDrawCreate(428.000000, 159.000000, "3rd. [s7]Morgenstern (99)");
	TextDrawBackgroundColor(FinalTCWScreen[23], 255);
	TextDrawFont(FinalTCWScreen[23], 1);
	TextDrawLetterSize(FinalTCWScreen[23], 0.230000, 1.000000);
	TextDrawColor(FinalTCWScreen[23], -626712321);
	TextDrawSetOutline(FinalTCWScreen[23], 0);
	TextDrawSetProportional(FinalTCWScreen[23], 1);
	TextDrawSetShadow(FinalTCWScreen[23], 1);

	// rosso
	FinalTCWScreen[24] = TextDrawCreate(92.000000, 198.000000, "[s7]MorgensternBlue");
	TextDrawBackgroundColor(FinalTCWScreen[24], 255);
	TextDrawFont(FinalTCWScreen[24], 1);
	TextDrawLetterSize(FinalTCWScreen[24], 0.239998, 1.000000);
	TextDrawColor(FinalTCWScreen[24], 0xf47a7aAA);
	TextDrawSetOutline(FinalTCWScreen[24], 0);
	TextDrawSetProportional(FinalTCWScreen[24], 1);
	TextDrawSetShadow(FinalTCWScreen[24], 1);

	FinalTCWScreen[25] = TextDrawCreate(191.000000, 198.000000, "bK");
	TextDrawAlignment(FinalTCWScreen[25], 2);
	TextDrawBackgroundColor(FinalTCWScreen[25], 255);
	TextDrawFont(FinalTCWScreen[25], 1);
	TextDrawLetterSize(FinalTCWScreen[25], 0.239998, 1.000000);
	TextDrawColor(FinalTCWScreen[25], 0xf47a7aAA);
	TextDrawSetOutline(FinalTCWScreen[25], 0);
	TextDrawSetProportional(FinalTCWScreen[25], 1);
	TextDrawSetShadow(FinalTCWScreen[25], 1);

	FinalTCWScreen[26] = TextDrawCreate(241.000000, 198.000000, "bD");
	TextDrawAlignment(FinalTCWScreen[26], 2);
	TextDrawBackgroundColor(FinalTCWScreen[26], 255);
	TextDrawFont(FinalTCWScreen[26], 1);
	TextDrawLetterSize(FinalTCWScreen[26], 0.239998, 1.000000);
	TextDrawColor(FinalTCWScreen[26], 0xf47a7aAA);
	TextDrawSetOutline(FinalTCWScreen[26], 0);
	TextDrawSetProportional(FinalTCWScreen[26], 1);
	TextDrawSetShadow(FinalTCWScreen[26], 1);

	FinalTCWScreen[27] = TextDrawCreate(298.000000, 198.000000, "1996");
	TextDrawAlignment(FinalTCWScreen[27], 2);
	TextDrawBackgroundColor(FinalTCWScreen[27], 255);
	TextDrawFont(FinalTCWScreen[27], 1);
	TextDrawLetterSize(FinalTCWScreen[27], 0.239998, 1.000000);
	TextDrawColor(FinalTCWScreen[27], 0xf47a7aAA);
	TextDrawSetOutline(FinalTCWScreen[27], 0);
	TextDrawSetProportional(FinalTCWScreen[27], 1);
	TextDrawSetShadow(FinalTCWScreen[27], 1);

	FinalTCWScreen[28] = TextDrawCreate(332.000000, 198.000000, "[s7]MorgensternGreen");
	TextDrawBackgroundColor(FinalTCWScreen[28], 255);
	TextDrawFont(FinalTCWScreen[28], 1);
	TextDrawLetterSize(FinalTCWScreen[28], 0.239998, 1.000000);
	TextDrawColor(FinalTCWScreen[28], 1687547391);
	TextDrawSetOutline(FinalTCWScreen[28], 0);
	TextDrawSetProportional(FinalTCWScreen[28], 1);
	TextDrawSetShadow(FinalTCWScreen[28], 1);

	FinalTCWScreen[29] = TextDrawCreate(432.000000, 198.000000, "vK");
	TextDrawAlignment(FinalTCWScreen[29], 2);
	TextDrawBackgroundColor(FinalTCWScreen[29], 255);
	TextDrawFont(FinalTCWScreen[29], 1);
	TextDrawLetterSize(FinalTCWScreen[29], 0.239998, 1.000000);
	TextDrawColor(FinalTCWScreen[29], 1687547391);
	TextDrawSetOutline(FinalTCWScreen[29], 0);
	TextDrawSetProportional(FinalTCWScreen[29], 1);
	TextDrawSetShadow(FinalTCWScreen[29], 1);

	FinalTCWScreen[30] = TextDrawCreate(481.000000, 198.000000, "vD");
	TextDrawAlignment(FinalTCWScreen[30], 2);
	TextDrawBackgroundColor(FinalTCWScreen[30], 255);
	TextDrawFont(FinalTCWScreen[30], 1);
	TextDrawLetterSize(FinalTCWScreen[30], 0.239998, 1.000000);
	TextDrawColor(FinalTCWScreen[30], 1687547391);
	TextDrawSetOutline(FinalTCWScreen[30], 0);
	TextDrawSetProportional(FinalTCWScreen[30], 1);
	TextDrawSetShadow(FinalTCWScreen[30], 1);

	FinalTCWScreen[31] = TextDrawCreate(538.000000, 198.000000, "1990");
	TextDrawAlignment(FinalTCWScreen[31], 2);
	TextDrawBackgroundColor(FinalTCWScreen[31], 255);
	TextDrawFont(FinalTCWScreen[31], 1);
	TextDrawLetterSize(FinalTCWScreen[31], 0.239998, 1.000000);
	TextDrawColor(FinalTCWScreen[31], 1687547391);
	TextDrawSetOutline(FinalTCWScreen[31], 0);
	TextDrawSetProportional(FinalTCWScreen[31], 1);
	TextDrawSetShadow(FinalTCWScreen[31], 1);
}

stock HexToInt(string[])
{
    if (string[0] == 0)
    {
        return 0;
    }
    new i;
    new cur = 1;
    new res = 0;
    for (i = strlen(string); i > 0; i--)
    {
        if (string[i-1] < 58)
        {
            res = res + cur * (string[i - 1] - 48);
        }
        else
        {
            res = res + cur * (string[i-1] - 65 + 10);
            cur = cur * 16;
        }
    }
    return res;
}

stock GetReadyStartType()
{
	new str[ 18 ];
	switch (gConfig[ReadyType])
	{
	    case GAMETYPE_BASE: 						str = "AAD";
	    case GAMETYPE_ARENA: 						str = "Arena";
	    case GAMETYPE_TDM: 							str = "TDM";
	    case GAMETYPE_INTS: 						str = "Interiors";
	    case GAMETYPE_PVP: 							str = "Player Vs Player";
	    case GAMETYPE_GUNGAME: 						str = "GunGame";
	}
	return str;
}


// nuovo final td
stock CreateFinalRoundTD()
{
	FineRound_Static[0] = TextDrawCreate(321.000000, 120.000000, "_");
	TextDrawAlignment(FineRound_Static[0], 2);
	TextDrawBackgroundColor(FineRound_Static[0], 255);
	TextDrawFont(FineRound_Static[0], 1);
	TextDrawLetterSize(FineRound_Static[0], 0.500000, 7.799999);
	TextDrawColor(FineRound_Static[0], -1);
	TextDrawSetOutline(FineRound_Static[0], 0);
	TextDrawSetProportional(FineRound_Static[0], 1);
	TextDrawSetShadow(FineRound_Static[0], 1);
	TextDrawUseBox(FineRound_Static[0], 1);
	TextDrawBoxColor(FineRound_Static[0], 112);
	TextDrawTextSize(FineRound_Static[0], 0.000000, 290.000000);

	FineRound_Static[1] = TextDrawCreate(259.000000, 198.000000, "_"); // box rosso
	TextDrawAlignment(FineRound_Static[1], 2);
	TextDrawBackgroundColor(FineRound_Static[1], 255);
	TextDrawFont(FineRound_Static[1], 1);
	TextDrawLetterSize(FineRound_Static[1], 0.500000, 11.100004);
	TextDrawColor(FineRound_Static[1], -1);
	TextDrawSetOutline(FineRound_Static[1], 0);
	TextDrawSetProportional(FineRound_Static[1], 1);
	TextDrawSetShadow(FineRound_Static[1], 1);
	TextDrawUseBox(FineRound_Static[1], 1);
	TextDrawBoxColor(FineRound_Static[1], 0xff000044);// [fixhere] cambia qui
	TextDrawTextSize(FineRound_Static[1], 0.000000, 166.000000);

	FineRound_Static[2] = TextDrawCreate(259.000000, 305.000000, "_"); // box blu
	TextDrawAlignment(FineRound_Static[2], 2);
	TextDrawBackgroundColor(FineRound_Static[2], 255);
	TextDrawFont(FineRound_Static[2], 1);
	TextDrawLetterSize(FineRound_Static[2], 0.500000, 11.100004);
	TextDrawColor(FineRound_Static[2], -1);
	TextDrawSetOutline(FineRound_Static[2], 0);
	TextDrawSetProportional(FineRound_Static[2], 1);
	TextDrawSetShadow(FineRound_Static[2], 1);
	TextDrawUseBox(FineRound_Static[2], 1);
	TextDrawBoxColor(FineRound_Static[2], 3407728);// deve essere blu
	TextDrawTextSize(FineRound_Static[2], 0.000000, 166.000000);

	FineRound_Static[3] = TextDrawCreate(407.000000, 305.000000, "_");
	TextDrawAlignment(FineRound_Static[3], 2);
	TextDrawBackgroundColor(FineRound_Static[3], 255);
	TextDrawFont(FineRound_Static[3], 1);
	TextDrawLetterSize(FineRound_Static[3], 0.500000, 11.100004);
	TextDrawColor(FineRound_Static[3], -1);
	TextDrawSetOutline(FineRound_Static[3], 0);
	TextDrawSetProportional(FineRound_Static[3], 1);
	TextDrawSetShadow(FineRound_Static[3], 1);
	TextDrawUseBox(FineRound_Static[3], 1);
	TextDrawBoxColor(FineRound_Static[3], 112);
	TextDrawTextSize(FineRound_Static[3], 0.000000, 118.000000);

	FineRound_Static[4] = TextDrawCreate(259.000000, 198.000000, "_");
	TextDrawAlignment(FineRound_Static[4], 2);
	TextDrawBackgroundColor(FineRound_Static[4], 255);
	TextDrawFont(FineRound_Static[4], 1);
	TextDrawLetterSize(FineRound_Static[4], 0.500000, 0.700003);
	TextDrawColor(FineRound_Static[4], -1);
	TextDrawSetOutline(FineRound_Static[4], 0);
	TextDrawSetProportional(FineRound_Static[4], 1);
	TextDrawSetShadow(FineRound_Static[4], 1);
	TextDrawUseBox(FineRound_Static[4], 1);
	TextDrawBoxColor(FineRound_Static[4], 255);
	TextDrawTextSize(FineRound_Static[4], 0.000000, 166.000000);

	FineRound_Static[5] = TextDrawCreate(409.000000, 207.000000, "_");
	TextDrawAlignment(FineRound_Static[5], 2);
	TextDrawBackgroundColor(FineRound_Static[5], 96);
	TextDrawFont(FineRound_Static[5], 1);
	TextDrawLetterSize(FineRound_Static[5], 0.239998, 1.499997);
	TextDrawColor(FineRound_Static[5], -2686721);
	TextDrawSetOutline(FineRound_Static[5], 1);
	TextDrawSetProportional(FineRound_Static[5], 1);

	FineRound_Static[6] = TextDrawCreate(259.000000, 292.000000, "_");
	TextDrawAlignment(FineRound_Static[6], 2);
	TextDrawBackgroundColor(FineRound_Static[6], 255);
	TextDrawFont(FineRound_Static[6], 1);
	TextDrawLetterSize(FineRound_Static[6], 0.500000, 0.700003);
	TextDrawColor(FineRound_Static[6], -1);
	TextDrawSetOutline(FineRound_Static[6], 0);
	TextDrawSetProportional(FineRound_Static[6], 1);
	TextDrawSetShadow(FineRound_Static[6], 1);
	TextDrawUseBox(FineRound_Static[6], 1);
	TextDrawBoxColor(FineRound_Static[6], 255);
	TextDrawTextSize(FineRound_Static[6], 0.000000, 166.000000);

	FineRound_Static[7] = TextDrawCreate(259.000000, 305.000000, "_");
	TextDrawAlignment(FineRound_Static[7], 2);
	TextDrawBackgroundColor(FineRound_Static[7], 255);
	TextDrawFont(FineRound_Static[7], 1);
	TextDrawLetterSize(FineRound_Static[7], 0.500000, 0.700003);
	TextDrawColor(FineRound_Static[7], -1);
	TextDrawSetOutline(FineRound_Static[7], 0);
	TextDrawSetProportional(FineRound_Static[7], 1);
	TextDrawSetShadow(FineRound_Static[7], 1);
	TextDrawUseBox(FineRound_Static[7], 1);
	TextDrawBoxColor(FineRound_Static[7], 255);
	TextDrawTextSize(FineRound_Static[7], 0.000000, 166.000000);

	FineRound_Static[8] = TextDrawCreate(259.000000, 399.000000, "_");
	TextDrawAlignment(FineRound_Static[8], 2);
	TextDrawBackgroundColor(FineRound_Static[8], 255);
	TextDrawFont(FineRound_Static[8], 1);
	TextDrawLetterSize(FineRound_Static[8], 0.500000, 0.700003);
	TextDrawColor(FineRound_Static[8], -1);
	TextDrawSetOutline(FineRound_Static[8], 0);
	TextDrawSetProportional(FineRound_Static[8], 1);
	TextDrawSetShadow(FineRound_Static[8], 1);
	TextDrawUseBox(FineRound_Static[8], 1);
	TextDrawBoxColor(FineRound_Static[8], 255);
	TextDrawTextSize(FineRound_Static[8], 0.000000, 166.000000);

	// rosso (inizialmente era blu)
	FineRound_Static[9] = TextDrawCreate(175.000000, 197.000000, "Nickname");// 1724710911 = blu | -1711302145 = green
	TextDrawBackgroundColor(FineRound_Static[9], 96);
	TextDrawFont(FineRound_Static[9], 1);
	TextDrawLetterSize(FineRound_Static[9], 0.230000, 0.899999);
	TextDrawColor(FineRound_Static[9], 0xf47a7aAA);
	TextDrawSetOutline(FineRound_Static[9], 1);
	TextDrawSetProportional(FineRound_Static[9], 1);

	// blu (verde)
	FineRound_Static[10] = TextDrawCreate(175.000000, 304.000000, "Nickname");// 1724710911 = blu | -1711302145 = green
	TextDrawBackgroundColor(FineRound_Static[10], 96);
	TextDrawFont(FineRound_Static[10], 1);
	TextDrawLetterSize(FineRound_Static[10], 0.230000, 0.899999);
	TextDrawColor(FineRound_Static[10], 1724710911);
	TextDrawSetOutline(FineRound_Static[10], 1);
	TextDrawSetProportional(FineRound_Static[10], 1);

	//rosso
	FineRound_Static[11] = TextDrawCreate(282.000000, 197.000000, "Kills");// 1724710911 = blu | -1711302145 = green
	TextDrawBackgroundColor(FineRound_Static[11], 96);
	TextDrawFont(FineRound_Static[11], 1);
	TextDrawLetterSize(FineRound_Static[11], 0.230000, 0.899999);
	TextDrawColor(FineRound_Static[11], 0xf47a7aAA);
	TextDrawSetOutline(FineRound_Static[11], 1);
	TextDrawSetProportional(FineRound_Static[11], 1);

	//rosso
	FineRound_Static[12] = TextDrawCreate(311.000000, 197.000000, "Damage");// 1724710911 = blu | -1711302145 = green
	TextDrawBackgroundColor(FineRound_Static[12], 96);
	TextDrawFont(FineRound_Static[12], 1);
	TextDrawLetterSize(FineRound_Static[12], 0.230000, 0.899999);
	TextDrawColor(FineRound_Static[12], 0xf47a7aAA);
	TextDrawSetOutline(FineRound_Static[12], 1);
	TextDrawSetProportional(FineRound_Static[12], 1);

	// blu
	FineRound_Static[13] = TextDrawCreate(282.000000, 304.000000, "Kills");// 1724710911 = blu | -1711302145 = green
	TextDrawBackgroundColor(FineRound_Static[13], 96);
	TextDrawFont(FineRound_Static[13], 1);
	TextDrawLetterSize(FineRound_Static[13], 0.230000, 0.899999);
	TextDrawColor(FineRound_Static[13], 1724710911);
	TextDrawSetOutline(FineRound_Static[13], 1);
	TextDrawSetProportional(FineRound_Static[13], 1);

	// blu
	FineRound_Static[14] = TextDrawCreate(311.000000, 304.000000, "Damage");// 1724710911 = blu | -1711302145 = green
	TextDrawBackgroundColor(FineRound_Static[14], 96);
	TextDrawFont(FineRound_Static[14], 1);
	TextDrawLetterSize(FineRound_Static[14], 0.230000, 0.899999);
	TextDrawColor(FineRound_Static[14], 1724710911);
	TextDrawSetOutline(FineRound_Static[14], 1);
	TextDrawSetProportional(FineRound_Static[14], 1);

	// rosso
	FineRound_Static[15] = TextDrawCreate(175.000000, 291.000000, "Total");// 1724710911 = blu | -1711302145 = green
	TextDrawBackgroundColor(FineRound_Static[15], 96);
	TextDrawFont(FineRound_Static[15], 1);
	TextDrawLetterSize(FineRound_Static[15], 0.230000, 0.899999);
	TextDrawColor(FineRound_Static[15], 0xf47a7aAA);
	TextDrawSetOutline(FineRound_Static[15], 1);
	TextDrawSetProportional(FineRound_Static[15], 1);

	//blu
	FineRound_Static[16] = TextDrawCreate(175.000000, 398.000000, "Total");
	TextDrawBackgroundColor(FineRound_Static[16], 96);
	TextDrawFont(FineRound_Static[16], 1);
	TextDrawLetterSize(FineRound_Static[16], 0.230000, 0.899999);
	TextDrawColor(FineRound_Static[16], 1724710911);
	TextDrawSetOutline(FineRound_Static[16], 1);
	TextDrawSetProportional(FineRound_Static[16], 1);

	FineRound_Static[17] = TextDrawCreate(407.000000, 198.000000, "_");
	TextDrawAlignment(FineRound_Static[17], 2);
	TextDrawBackgroundColor(FineRound_Static[17], 255);
	TextDrawFont(FineRound_Static[17], 1);
	TextDrawLetterSize(FineRound_Static[17], 0.500000, 0.700003);
	TextDrawColor(FineRound_Static[17], -1);
	TextDrawSetOutline(FineRound_Static[17], 0);
	TextDrawSetProportional(FineRound_Static[17], 1);
	TextDrawSetShadow(FineRound_Static[17], 1);
	TextDrawUseBox(FineRound_Static[17], 1);
	TextDrawBoxColor(FineRound_Static[17], 255);
	TextDrawTextSize(FineRound_Static[17], 0.000000, 118.000000);

	FineRound_Static[18] = TextDrawCreate(407.000000, 209.000000, "_");
	TextDrawAlignment(FineRound_Static[18], 2);
	TextDrawBackgroundColor(FineRound_Static[18], 255);
	TextDrawFont(FineRound_Static[18], 1);
	TextDrawLetterSize(FineRound_Static[18], 0.500000, 2.700005);
	TextDrawColor(FineRound_Static[18], 0x5c6df2AA);
	TextDrawSetOutline(FineRound_Static[18], 0);
	TextDrawSetProportional(FineRound_Static[18], 1);
	TextDrawSetShadow(FineRound_Static[18], 1);
	TextDrawUseBox(FineRound_Static[18], 1);
	TextDrawBoxColor(FineRound_Static[18], -2686864);
	TextDrawTextSize(FineRound_Static[18], 0.000000, 118.000000);

	FineRound_Static[19] = TextDrawCreate(407.000000, 238.000000, "_");
	TextDrawAlignment(FineRound_Static[19], 2);
	TextDrawBackgroundColor(FineRound_Static[19], 255);
	TextDrawFont(FineRound_Static[19], 1);
	TextDrawLetterSize(FineRound_Static[19], 0.500000, 3.000004);
	TextDrawColor(FineRound_Static[19], -1);
	TextDrawSetOutline(FineRound_Static[19], 0);
	TextDrawSetProportional(FineRound_Static[19], 1);
	TextDrawSetShadow(FineRound_Static[19], 1);
	TextDrawUseBox(FineRound_Static[19], 1);
	TextDrawBoxColor(FineRound_Static[19], -1061109648);
	TextDrawTextSize(FineRound_Static[19], 0.000000, 118.000000);

	FineRound_Static[20] = TextDrawCreate(407.000000, 270.000000, "_");
	TextDrawAlignment(FineRound_Static[20], 2);
	TextDrawBackgroundColor(FineRound_Static[20], 255);
	TextDrawFont(FineRound_Static[20], 1);
	TextDrawLetterSize(FineRound_Static[20], 0.500000, 3.100003);
	TextDrawColor(FineRound_Static[20], -1);
	TextDrawSetOutline(FineRound_Static[20], 0);
	TextDrawSetProportional(FineRound_Static[20], 1);
	TextDrawSetShadow(FineRound_Static[20], 1);
	TextDrawUseBox(FineRound_Static[20], 1);
	TextDrawBoxColor(FineRound_Static[20], -626712464);
	TextDrawTextSize(FineRound_Static[20], 0.000000, 118.000000);

	FineRound_Static[21] = TextDrawCreate(407.000000, 198.000000, "_");
	TextDrawAlignment(FineRound_Static[21], 2);
	TextDrawBackgroundColor(FineRound_Static[21], 255);
	TextDrawFont(FineRound_Static[21], 1);
	TextDrawLetterSize(FineRound_Static[21], 0.500000, 11.100004);
	TextDrawColor(FineRound_Static[21], -1);
	TextDrawSetOutline(FineRound_Static[21], 0);
	TextDrawSetProportional(FineRound_Static[21], 1);
	TextDrawSetShadow(FineRound_Static[21], 1);
	TextDrawUseBox(FineRound_Static[21], 1);
	TextDrawBoxColor(FineRound_Static[21], 112);
	TextDrawTextSize(FineRound_Static[21], 0.000000, 118.000000);

	FineRound_Static[22] = TextDrawCreate(346.000000, 211.000000, "ld_drv:gold");
	TextDrawBackgroundColor(FineRound_Static[22], 255);
	TextDrawFont(FineRound_Static[22], 4);
	TextDrawLetterSize(FineRound_Static[22], -0.199999, -2.000000);
	TextDrawColor(FineRound_Static[22], -1);
	TextDrawSetOutline(FineRound_Static[22], 0);
	TextDrawSetProportional(FineRound_Static[22], 1);
	TextDrawSetShadow(FineRound_Static[22], 1);
	TextDrawUseBox(FineRound_Static[22], 1);
	TextDrawBoxColor(FineRound_Static[22], 255);
	TextDrawTextSize(FineRound_Static[22], 26.000000, 19.000000);

	FineRound_Static[23] = TextDrawCreate(346.000000, 241.000000, "ld_drv:silfly");
	TextDrawBackgroundColor(FineRound_Static[23], 255);
	TextDrawFont(FineRound_Static[23], 4);
	TextDrawLetterSize(FineRound_Static[23], -0.199999, -2.000000);
	TextDrawColor(FineRound_Static[23], -1);
	TextDrawSetOutline(FineRound_Static[23], 0);
	TextDrawSetProportional(FineRound_Static[23], 1);
	TextDrawSetShadow(FineRound_Static[23], 1);
	TextDrawUseBox(FineRound_Static[23], 1);
	TextDrawBoxColor(FineRound_Static[23], 255);
	TextDrawTextSize(FineRound_Static[23], 26.000000, 19.000000);

	FineRound_Static[24] = TextDrawCreate(346.000000, 274.000000, "ld_drv:brboat");
	TextDrawBackgroundColor(FineRound_Static[24], 255);
	TextDrawFont(FineRound_Static[24], 4);
	TextDrawLetterSize(FineRound_Static[24], -0.199999, -2.000000);
	TextDrawColor(FineRound_Static[24], -1);
	TextDrawSetOutline(FineRound_Static[24], 0);
	TextDrawSetProportional(FineRound_Static[24], 1);
	TextDrawSetShadow(FineRound_Static[24], 1);
	TextDrawUseBox(FineRound_Static[24], 1);
	TextDrawBoxColor(FineRound_Static[24], 255);
	TextDrawTextSize(FineRound_Static[24], 26.000000, 19.000000);

	FineRound_Static[25] = TextDrawCreate(405.000000, 197.000000, "Podium");
	TextDrawAlignment(FineRound_Static[25], 2);
	TextDrawBackgroundColor(FineRound_Static[25], 96);
	TextDrawFont(FineRound_Static[25], 1);
	TextDrawLetterSize(FineRound_Static[25], 0.230000, 0.899999);
	TextDrawColor(FineRound_Static[25], -1);
	TextDrawSetOutline(FineRound_Static[25], 1);
	TextDrawSetProportional(FineRound_Static[25], 1);

	FineRound_Static[26] = TextDrawCreate(349.000000, 390.000000, "Hide Textdraw");
	TextDrawBackgroundColor(FineRound_Static[26], 255);
	TextDrawFont(FineRound_Static[26], 2);
	TextDrawLetterSize(FineRound_Static[26], 0.360000, 1.200000);
	TextDrawColor(FineRound_Static[26], -1);
	TextDrawSetOutline(FineRound_Static[26], 0);
	TextDrawSetProportional(FineRound_Static[26], 1);
	TextDrawSetShadow(FineRound_Static[26], 1);
	TextDrawSetSelectable(FineRound_Static[26], 1);// 29(avanti) / 34(indietro) (hide: 26)

	FineRound_Static[27] = TextDrawCreate(407.000000, 387.000000, "_");
	TextDrawAlignment(FineRound_Static[27], 2);
	TextDrawBackgroundColor(FineRound_Static[27], 255);
	TextDrawFont(FineRound_Static[27], 1);
	TextDrawLetterSize(FineRound_Static[27], 0.500000, 2.000004);
	TextDrawColor(FineRound_Static[27], -1);
	TextDrawSetOutline(FineRound_Static[27], 0);
	TextDrawSetProportional(FineRound_Static[27], 1);
	TextDrawSetShadow(FineRound_Static[27], 1);
	TextDrawUseBox(FineRound_Static[27], 1);
	TextDrawBoxColor(FineRound_Static[27], 112);
	TextDrawTextSize(FineRound_Static[27], 0.000000, 118.000000);

	FineRound_Static[28] = TextDrawCreate(407.000000, 305.000000, "_");
	TextDrawAlignment(FineRound_Static[28], 2);
	TextDrawBackgroundColor(FineRound_Static[28], 255);
	TextDrawFont(FineRound_Static[28], 1);
	TextDrawLetterSize(FineRound_Static[28], 0.500000, 2.000004);
	TextDrawColor(FineRound_Static[28], -1);
	TextDrawSetOutline(FineRound_Static[28], 0);
	TextDrawSetProportional(FineRound_Static[28], 1);
	TextDrawSetShadow(FineRound_Static[28], 1);
	TextDrawUseBox(FineRound_Static[28], 1);
	TextDrawBoxColor(FineRound_Static[28], 112);
	TextDrawTextSize(FineRound_Static[28], 0.000000, 118.000000);

	FineRound_Static[29] = TextDrawCreate(424.000000, 358.000000, "ld_beat:right");
	TextDrawBackgroundColor(FineRound_Static[29], 255);
	TextDrawFont(FineRound_Static[29], 4);
	TextDrawLetterSize(FineRound_Static[29], 0.699999, 3.000000);
	TextDrawColor(FineRound_Static[29], -1);
	TextDrawSetOutline(FineRound_Static[29], 0);
	TextDrawSetProportional(FineRound_Static[29], 1);
	TextDrawSetShadow(FineRound_Static[29], 1);
	TextDrawUseBox(FineRound_Static[29], 1);
	TextDrawBoxColor(FineRound_Static[29], 255);
	TextDrawTextSize(FineRound_Static[29], 35.000000, 27.000000);
	TextDrawSetSelectable(FineRound_Static[29], 1);// 29 / 34 (hide: 26)

	FineRound_Static[30] = TextDrawCreate(174.000000, 117.000000, "ld_drv:tvcorn");
	TextDrawBackgroundColor(FineRound_Static[30], 255);
	TextDrawFont(FineRound_Static[30], 4);
	TextDrawLetterSize(FineRound_Static[30], 0.500000, 1.000000);
	TextDrawColor(FineRound_Static[30], -1);
	TextDrawSetOutline(FineRound_Static[30], 0);
	TextDrawSetProportional(FineRound_Static[30], 1);
	TextDrawSetShadow(FineRound_Static[30], 1);
	TextDrawUseBox(FineRound_Static[30], 1);
	TextDrawBoxColor(FineRound_Static[30], 255);
	TextDrawTextSize(FineRound_Static[30], 147.000000, 39.000000);

	FineRound_Static[31] = TextDrawCreate(174.000000, 193.000000, "ld_drv:tvcorn");
	TextDrawBackgroundColor(FineRound_Static[31], 255);
	TextDrawFont(FineRound_Static[31], 4);
	TextDrawLetterSize(FineRound_Static[31], 0.589999, -1.000000);
	TextDrawColor(FineRound_Static[31], -1);
	TextDrawSetOutline(FineRound_Static[31], 0);
	TextDrawSetProportional(FineRound_Static[31], 1);
	TextDrawSetShadow(FineRound_Static[31], 1);
	TextDrawUseBox(FineRound_Static[31], 1);
	TextDrawBoxColor(FineRound_Static[31], 255);
	TextDrawTextSize(FineRound_Static[31], 147.000000, -37.000000);

	FineRound_Static[32] = TextDrawCreate(468.000000, 193.000000, "ld_drv:tvcorn");
	TextDrawAlignment(FineRound_Static[32], 2);
	TextDrawBackgroundColor(FineRound_Static[32], 255);
	TextDrawFont(FineRound_Static[32], 4);
	TextDrawLetterSize(FineRound_Static[32], 0.589999, -1.000000);
	TextDrawColor(FineRound_Static[32], -1);
	TextDrawSetOutline(FineRound_Static[32], 0);
	TextDrawSetProportional(FineRound_Static[32], 1);
	TextDrawSetShadow(FineRound_Static[32], 1);
	TextDrawUseBox(FineRound_Static[32], 1);
	TextDrawBoxColor(FineRound_Static[32], 255);
	TextDrawTextSize(FineRound_Static[32], -147.000000, -37.000000);

	FineRound_Static[33] = TextDrawCreate(468.000000, 117.000000, "ld_drv:tvcorn");
	TextDrawAlignment(FineRound_Static[33], 2);
	TextDrawBackgroundColor(FineRound_Static[33], 255);
	TextDrawFont(FineRound_Static[33], 4);
	TextDrawLetterSize(FineRound_Static[33], 0.589999, -1.000000);
	TextDrawColor(FineRound_Static[33], -1);
	TextDrawSetOutline(FineRound_Static[33], 0);
	TextDrawSetProportional(FineRound_Static[33], 1);
	TextDrawSetShadow(FineRound_Static[33], 1);
	TextDrawUseBox(FineRound_Static[33], 1);
	TextDrawBoxColor(FineRound_Static[33], 255);
	TextDrawTextSize(FineRound_Static[33], -147.000000, 39.000000);

	FineRound_Static[34] = TextDrawCreate(357.000000, 358.000000, "ld_beat:left");
	TextDrawBackgroundColor(FineRound_Static[34], 255);
	TextDrawFont(FineRound_Static[34], 4);
	TextDrawLetterSize(FineRound_Static[34], 0.699998, 3.000000);
	TextDrawColor(FineRound_Static[34], -1);
	TextDrawSetOutline(FineRound_Static[34], 0);
	TextDrawSetProportional(FineRound_Static[34], 1);
	TextDrawSetShadow(FineRound_Static[34], 1);
	TextDrawUseBox(FineRound_Static[34], 1);
	TextDrawBoxColor(FineRound_Static[34], 255);
	TextDrawTextSize(FineRound_Static[34], 35.000000, 27.000000);
	TextDrawSetSelectable(FineRound_Static[34], 1);

	for (new i = 0; i < MAX_TCW_ROUNDS; i++)
	{
	    // Syntax:
	    //  FineRound_Dinamyc[ROUND_ID][TD_ID]
	    // FineRound_Dynamic [i][ 0 etc. ]

	 	new Text:t = FineRound_Dynamic[i][BluePlayers] = TextDrawCreate(175.000000, 207.000000, "Nothing!");
		TextDrawBackgroundColor(t, 96);
		TextDrawFont(t, 1);
		TextDrawLetterSize(t, 0.230000, 0.899999);
		TextDrawColor(t, 0xf47a7aAA); // 1724710911 = blu | -1711302145 = green
		TextDrawSetOutline(t, 1);
		TextDrawSetProportional(t, 1);

		t = FineRound_Dynamic[i][GreenPlayers] = TextDrawCreate(175.000000, 314.000000, "Nothing!");
		TextDrawBackgroundColor(t, 96);
		TextDrawFont(t, 1);
		TextDrawLetterSize(t, 0.230000, 0.899999);
		TextDrawColor(t, 1724710911);
		TextDrawSetOutline(t, 1);
		TextDrawSetProportional(t, 1);

		// blue stava sopra
		// green sotto

		// blue = red
		// green = blue
		t = FineRound_Dynamic[i][BlueKills] = TextDrawCreate(290.000000, 207.000000, "0");// 1724710911 = blu | -1711302145 = green
		TextDrawAlignment(t, 2);
		TextDrawBackgroundColor(t, 96);
		TextDrawFont(t, 1);
		TextDrawLetterSize(t, 0.230000, 0.899999);
		TextDrawColor(t, 0xf47a7aAA);
		TextDrawSetOutline(t, 1);
		TextDrawSetProportional(t, 1);

		t = FineRound_Dynamic[i][BlueDamages] = TextDrawCreate(326.000000, 207.000000, "0");// 1724710911 = blu | -1711302145 = green
		TextDrawAlignment(t, 2);
		TextDrawBackgroundColor(t, 96);
		TextDrawFont(t, 1);
		TextDrawLetterSize(t, 0.230000, 0.899999);
		TextDrawColor(t, 0xf47a7aAA);
		TextDrawSetOutline(t, 1);
		TextDrawSetProportional(t, 1);

		t = FineRound_Dynamic[i][GreenKills] = TextDrawCreate(290.000000, 314.000000, "0");// 1724710911 = blu | -1711302145 = green
		TextDrawAlignment(t, 2);
		TextDrawBackgroundColor(t, 96);
		TextDrawFont(t, 1);
		TextDrawLetterSize(t, 0.230000, 0.899999);
		TextDrawColor(t, 1724710911);
		TextDrawSetOutline(t, 1);
		TextDrawSetProportional(t, 1);

		t = FineRound_Dynamic[i][GreenDamage] = TextDrawCreate(326.000000, 314.000000, "0");// 1724710911 = blu | -1711302145 = green
		TextDrawAlignment(t, 2);
		TextDrawBackgroundColor(t, 96);
		TextDrawFont(t, 1);
		TextDrawLetterSize(t, 0.230000, 0.899999);
		TextDrawColor(t, 1724710911);
		TextDrawSetOutline(t, 1);
		TextDrawSetProportional(t, 1);
//totals
		t = FineRound_Dynamic[i][TotalKBlue] = TextDrawCreate(290.000000, 291.000000, "0");// 1724710911 = blu | -1711302145 = green
		TextDrawAlignment(t, 2);
		TextDrawBackgroundColor(t, 96);
		TextDrawFont(t, 1);
		TextDrawLetterSize(t, 0.230000, 0.899999);
		TextDrawColor(t, 0xf47a7aAA);
		TextDrawSetOutline(t, 1);
		TextDrawSetProportional(t, 1);

		t = FineRound_Dynamic[i][TotalDBlue] = TextDrawCreate(326.000000, 291.000000, "0");// 1724710911 = blu | -1711302145 = green
		TextDrawAlignment(t, 2);
		TextDrawBackgroundColor(t, 96);
		TextDrawFont(t, 1);
		TextDrawLetterSize(t, 0.230000, 0.899999);
		TextDrawColor(t, 0xf47a7aAA);
		TextDrawSetOutline(t, 1);
		TextDrawSetProportional(t, 1);

		t = FineRound_Dynamic[i][TotalKGreen] = TextDrawCreate(290.000000, 398.000000, "0");// 1724710911 = blu | -1711302145 = green
		TextDrawAlignment(t, 2);
		TextDrawBackgroundColor(t, 96);
		TextDrawFont(t, 1);
		TextDrawLetterSize(t, 0.230000, 0.899999);
		TextDrawColor(t, 1724710911);
		TextDrawSetOutline(t, 1);
		TextDrawSetProportional(t, 1);

		t = FineRound_Dynamic[i][TotalDGreen] = TextDrawCreate(326.000000, 398.000000, "0");// 1724710911 = blu | -1711302145 = green
		TextDrawAlignment(t, 2);
		TextDrawBackgroundColor(t, 96);
		TextDrawFont(t, 1);
		TextDrawLetterSize(t, 0.230000, 0.899999);
		TextDrawColor(t, 1724710911);
		TextDrawSetOutline(t, 1);
		TextDrawSetProportional(t, 1);
//podio
		t = FineRound_Dynamic[i][Top2_Nick] = TextDrawCreate(409.000000, 236.000000, "N/D");
		TextDrawAlignment(t, 2);
		TextDrawBackgroundColor(t, 96);
		TextDrawFont(t, 1);
		TextDrawLetterSize(t, 0.239998, 1.499997);
		TextDrawColor(t, -1061109505);
		TextDrawSetOutline(t, 1);
		TextDrawSetProportional(t, 1);

		t = FineRound_Dynamic[i][Top1_Stats] = TextDrawCreate(410.000000, 224.000000, "_");
		TextDrawAlignment(t, 2);
		TextDrawBackgroundColor(t, 96);
		TextDrawFont(t, 1);
		TextDrawLetterSize(t, 0.230000, 0.899999);
		TextDrawColor(t, -1);
		TextDrawSetOutline(t, 1);
		TextDrawSetProportional(t, 1);

		t = FineRound_Dynamic[i][Top3_Nick] = TextDrawCreate(409.000000, 268.000000, "N/D");
		TextDrawAlignment(t, 2);
		TextDrawBackgroundColor(t, 96);
		TextDrawFont(t, 1);
		TextDrawLetterSize(t, 0.239998, 1.499997);
		TextDrawColor(t, -626712321);
		TextDrawSetOutline(t, 1);
		TextDrawSetProportional(t, 1);

		t = FineRound_Dynamic[i][Top1_Nick] = TextDrawCreate(407.000000, 206.000000, "N/D");
		TextDrawAlignment(t, 2);
		TextDrawBackgroundColor(t, 96);
		TextDrawFont(t, 1);
		TextDrawLetterSize(t, 0.239998, 1.499997);
		TextDrawColor(t, -2686721);
		TextDrawSetOutline(t, 1);
		TextDrawSetProportional(t, 1);

		t = FineRound_Dynamic[i][Top2_Stats] = TextDrawCreate(410.000000, 255.000000, "_");
		TextDrawAlignment(t, 2);
		TextDrawBackgroundColor(t, 96);
		TextDrawFont(t, 1);
		TextDrawLetterSize(t, 0.230000, 0.899999);
		TextDrawColor(t, -1);
		TextDrawSetOutline(t, 1);
		TextDrawSetProportional(t, 1);

		t = FineRound_Dynamic[i][Top3_Stats] = TextDrawCreate(410.000000, 287.000000, "_");
		TextDrawAlignment(t, 2);
		TextDrawBackgroundColor(t, 96);
		TextDrawFont(t, 1);
		TextDrawLetterSize(t, 0.230000, 0.899999);
		TextDrawColor(t, -1);
		TextDrawSetOutline(t, 1);
		TextDrawSetProportional(t, 1);
// other
		t = FineRound_Dynamic[i][RoundsInfo] = TextDrawCreate(408.000000, 308.000000, "Round ~y~~h~0~w~/~y~0");
		TextDrawAlignment(t, 2);
		TextDrawBackgroundColor(t, 255);
		TextDrawFont(t, 2);
		TextDrawLetterSize(t, 0.360000, 1.200000);
		TextDrawColor(t, -1);
		TextDrawSetOutline(t, 0);
		TextDrawSetProportional(t, 1);
		TextDrawSetShadow(t, 1);

		t = FineRound_Dynamic[i][AttDefWin] = TextDrawCreate(175.000000, 118.000000, "~g~~h~A~n~~g~~h~t~n~~g~~h~t~n~~g~~h~a~n~~g~~h~c~n~~g~~h~k ~n~~g~~h~e~n~~g~~h~r~n~~g~~h~s");
		TextDrawBackgroundColor(t, 80);
		TextDrawFont(t, 2);
		TextDrawLetterSize(t, 0.310000, 0.899999);
		TextDrawColor(t, 16711935);
		TextDrawSetOutline(t, 1);
		TextDrawSetProportional(t, 1);

		t = FineRound_Dynamic[i][Stringa_Winner2] = TextDrawCreate(458.000000, 142.000000, "~g~~h~N~n~~g~~h~N~n~~g~~h~E~n~~g~~h~R~n~~g~~h~S");
		TextDrawBackgroundColor(t, 80);
		TextDrawFont(t, 2);
		TextDrawLetterSize(t, 0.310000, 0.899999);
		TextDrawColor(t, 16711935);
		TextDrawSetOutline(t, 1);
		TextDrawSetProportional(t, 1);

		t = FineRound_Dynamic[i][Stringa_TeamWin] = TextDrawCreate(320.000000, 138.000000, "_");
		TextDrawAlignment(t, 2);
		TextDrawBackgroundColor(t, 96);
		TextDrawFont(t, 1);
		TextDrawLetterSize(t, 0.409999, 3.000000);
		TextDrawColor(t, -1);
		TextDrawSetOutline(t, 1);
		TextDrawSetProportional(t, 1);

		t = FineRound_Dynamic[i][Stringa_Winner1] = TextDrawCreate(456.000000, 126.000000, "~g~~h~W~n~~g~~h~ I~n~");
		TextDrawBackgroundColor(t, 80);
		TextDrawFont(t, 2);
		TextDrawLetterSize(t, 0.310000, 0.899999);
		TextDrawColor(t, 16711935);
		TextDrawSetOutline(t, 1);
		TextDrawSetProportional(t, 1);

		t = FineRound_Dynamic[i][Stringa_RoundInfo] = TextDrawCreate(321.000000, 169.000000, "_");
		TextDrawAlignment(t, 2);
		TextDrawBackgroundColor(t, 32);
		TextDrawFont(t, 1);
		TextDrawLetterSize(t, 0.230000, 0.899999);
		TextDrawColor(t, -1);
		TextDrawSetOutline(t, 1);
		TextDrawSetProportional(t, 1);

		t = FineRound_Dynamic[i][Stringa_TmpBest] = TextDrawCreate(407.000000, 325.000000, "_");
		TextDrawAlignment(t, 2);
		TextDrawBackgroundColor(t, 96);
		TextDrawFont(t, 1);
		TextDrawLetterSize(t, 0.239997, 1.499997);
		TextDrawColor(t, -2686721);
		TextDrawSetOutline(t, 1);
		TextDrawSetProportional(t, 1);
	}
}

/**
stock CreaRoundStats()
{
	new Text:t = RoundStats[rStats_ABar] = TextDrawCreate(-3.000000, 435.000000, "_");
	TextDrawBackgroundColor(t, 255);
	TextDrawFont(t, 1);
	TextDrawLetterSize(t, 0.600000, 2.300000);
	TextDrawColor(t, -1);
	TextDrawSetOutline(t, 0);
	TextDrawSetProportional(t, 1);
	TextDrawSetShadow(t, 1);
	TextDrawUseBox(t, 1);
	TextDrawBoxColor(t, 3394640);
	TextDrawTextSize(t, 318.000000, 340.000000);

	t = RoundStats[rStats_BBar] = TextDrawCreate(643.000000, 435.000000, "_");
	TextDrawBackgroundColor(t, 255);
	TextDrawFont(t, 1);
	TextDrawLetterSize(t, 0.500000, 1.200000);
	TextDrawColor(t, -1);
	TextDrawSetOutline(t, 0);
	TextDrawSetProportional(t, 1);
	TextDrawSetShadow(t, 1);
	TextDrawUseBox(t, 1);
	TextDrawBoxColor(t, 10040144);
	TextDrawTextSize(t, 320.000000, 323.000000);


	t = RoundStats[rStats_BBar] = TextDrawCreate(325.000000, 435.000000, "_");
	TextDrawBackgroundColor(t, 255);
	TextDrawFont(t, 1);
	TextDrawLetterSize(t, 2.109997, 1.300000);
	TextDrawColor(t, -1);
	TextDrawSetOutline(t, 0);
	TextDrawSetProportional(t, 1);
	TextDrawSetShadow(t, 1);
	TextDrawUseBox(t, 1);
	TextDrawBoxColor(t, 10040144);
	TextDrawTextSize(t, 639.000000, 267.000000);

	t = RoundStats[rStats_Time] = TextDrawCreate(306.000000, 434.000000, "~g~~h~07~w~:~b~~h~59");
	TextDrawBackgroundColor(t, 96);
	TextDrawFont(t, 2);
	TextDrawLetterSize(t, 0.239999, 1.200000);
	TextDrawColor(t, -1);
	TextDrawSetOutline(t, 1);
	TextDrawSetProportional(t, 1);

	t = RoundStats[rStats_Background] = TextDrawCreate(319.000000, 434.000000, "_");
	TextDrawAlignment(t, 2);
	TextDrawBackgroundColor(t, 255);
	TextDrawFont(t, 1);
	TextDrawLetterSize(t, 0.500000, 2.699999);
	TextDrawColor(t, -1);
	TextDrawSetOutline(t, 0);
	TextDrawSetProportional(t, 1);
	TextDrawSetShadow(t, 1);
	TextDrawUseBox(t, 1);
	TextDrawBoxColor(t, 80);
	TextDrawTextSize(t, -5.000000, 640.000000);

	t = RoundStats[rStats_AStats] = TextDrawCreate(113.000000, 434.000000, "~b~~h~s7 ~b~2 ~w~(~g~~h~~h~800~w~)");
	TextDrawAlignment(t, 2);
	TextDrawBackgroundColor(t, 96);
	TextDrawFont(t, 2);
	TextDrawLetterSize(t, 0.239999, 1.200000);
	TextDrawColor(t, -1);
	TextDrawSetOutline(t, 1);
	TextDrawSetProportional(t, 1);

	t = RoundStats[rStats_BStats] = TextDrawCreate(526.000000, 434.000000, "~g~~h~s7 ~g~2 ~w~(~g~~h~~h~800~w~)");
	TextDrawAlignment(t, 2);
	TextDrawBackgroundColor(t, 96);
	TextDrawFont(t, 2);
	TextDrawLetterSize(t, 0.239999, 1.200000);
	TextDrawColor(t, -1);
	TextDrawSetOutline(t, 1);
	TextDrawSetProportional(t, 1);

	t = RoundStats[rStats_AHits] = TextDrawCreate(36.000000, 434.000000, "~b~~h~~h~135");
	TextDrawAlignment(t, 2);
	TextDrawBackgroundColor(t, 96);
	TextDrawFont(t, 2);
	TextDrawLetterSize(t, 0.239999, 1.200000);
	TextDrawColor(t, -1);
	TextDrawSetOutline(t, 1);
	TextDrawSetProportional(t, 1);

	t = RoundStats[rStats_BHits] = TextDrawCreate(600.000000, 434.000000, "~g~~h~~h~135");
	TextDrawAlignment(t, 2);
	TextDrawBackgroundColor(t, 96);
	TextDrawFont(t, 2);
	TextDrawLetterSize(t, 0.239999, 1.200000);
	TextDrawColor(t, -1);
	TextDrawSetOutline(t, 1);
	TextDrawSetProportional(t, 1);
}

//And this is the end of the best existing A/D GM. Stay hungry, stay foolish!
ff
*/

